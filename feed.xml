<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>蔡华的博客</title>
    <description>Be publicly useful and privately happy.</description>
    <link>https://caihua.tech/</link>
    <atom:link href="https://caihua.tech/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Wed, 25 Oct 2017 00:10:21 +0800</pubDate>
    <lastBuildDate>Wed, 25 Oct 2017 00:10:21 +0800</lastBuildDate>
    <generator>Jekyll v3.2.1</generator>
    
      <item>
        <title>Shader合并与Variant</title>
        <description>&lt;h4 id=&quot;section&quot;&gt;前言&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;写这个的起因是因为看了唐建伟大佬在UWA上发表的文章&lt;a href=&quot;https://blog.uwa4d.com/archives/USparkle_Shader.html&quot;&gt;合并Shader系列_如何合并渲染状态&lt;/a&gt;。看完后受益良多，但是也对文中这样合并shader会不会产生shader的变种（shader variant）有所担心，因此在UWA的问答上提出了问题，最后唐建伟也做出了&lt;a href=&quot;https://answer.uwa4d.com/question/59dd6f350461bc6f45206ad5/%E3%80%8A%E5%90%88%E5%B9%B6Shader%E7%B3%BB%E5%88%97-%7C-%E5%A6%82%E4%BD%95%E5%90%88%E5%B9%B6%E6%B8%B2%E6%9F%93%E7%8A%B6%E6%80%81%E3%80%8B%E8%BF%99%E7%AF%87%E6%96%87%E7%AB%A0%E5%BC%95%E5%8F%91%E7%9A%84shader-variant%E9%97%AE%E9%A2%98&quot;&gt;回答&lt;/a&gt;，经过大佬授权在这里根据回答进行一些总结，想看原文的可以直接点击链接。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;sahder-variant&quot;&gt;Sahder Variant的概念&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;其实一个variant可以理解为一个具体的在GPU上执行的小程序，而一个Shader通常会编译出非常多的variant来应对不同的情况，比如单说雾效就有如下：没有雾效、有线性雾、有指数雾1、有指数雾2这样的4个variant(ps:这里只考虑雾效，其他条件一致)。至于原因嘛，有很多，粗略归纳一下是因为GPU需要更多的并行处理、逻辑单元少，因此Shader里面要尽可能规避各种判断、循环语句等等，最后本来可以通过逻辑判断来处理的雾效就需要编译成不同的执行程序来对应不同的情况(ps：这是一种高级优化，背后的原理很多很多，建议自行查询相关资料，查明前因后果，我懂的也不多)。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;shader-variant&quot;&gt;问题1:这样通过多参数来设置渲染状态不会造成shader variant吗？&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;在这篇文章中，我们只合并了渲染状态，渲染状态的合并不会导致Unity编译出更多的shader variant。
口说无凭，那么我们就先拿一个示例Shader来做测试，我选用了文章中的“ShaderCombine/01.ShaderCombineSimpleZTest”来做测试，Unity版本为 5.5.4p3，使用Unity的Shader Variant Collection来算取Variant数量，不管是否加入合并的代码，Variant的数量都是259，如下图所示：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://uwa-public.oss-cn-beijing.aliyuncs.com/answer/image/public/101228/1507705049102.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;即便是使用“ShaderCombine/02.ShaderCombineCommonState”来测试，Variant的数量也是是259，如下图所示&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://uwa-public.oss-cn-beijing.aliyuncs.com/answer/image/public/101228/1507705061601.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;从上面的图片可以看出，不管是否有渲染状态的参数在里面，Variant的数量都不会改变。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;shader-variant-1&quot;&gt;问题2：什么情况下在才会造成shader variant呢？&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;宏定义(Keyword)，“#pragma multi_compile XXX YYY ZZZ”，“#pragma multi_compile_xxx”，SubShader，Pass，Fallback及一些特殊不常用命令等的增减会造成variant的数量变化。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;至于一个Shader到底会生成多少variant呢？精确的计算方法，Unity并没有给出，但是我的归纳总结一下就是几组不同的编译宏的组合了，比如雾效、光照图、光源、阴影等等。另外还可以通过Unity的工具Shader Variant Collection来查看一个Shader到底有多少个variant，也可以在里面来自己组合和预编译自己想要的variant。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;variant&quot;&gt;福利：为什么修改渲染状态不会产生variant？&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;刚刚我们说了造成variant数量增加主要是需要生成不同的variant来应对不同的情况，那么不同的渲染状态是不是不同的情况呢？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;其实不是。生成不同的variant主要是为了消灭Shader内部的逻辑判断（ps：Shader的真正逻辑是CGPROGRAM…ENDCG中间的东西）。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;继续用雾效举例，先只考虑有雾效和没雾效，按一般的游戏逻辑写法，我们通常会在逻辑里用一个if判断来搞定，但是由于GPU的特殊性，这样的做法非常低效、不可取，那么就会使用Keyword这样的编译宏在编译的时候就分别编译为有雾效和没雾效的2个执行程序，也就是2个variant。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;现在说会渲染状态，看任何的Shader，我们都不会在CGPROGRAM…ENDCG里面有关于渲染状态的处理代码，当然不需要为不同的渲染状态编译不同的variant，也就不会造成variant的增加。（这部分可以参看Unity的渲染流水线，渲染一个物体需要非常多的步骤，我们写的Shader编译成的variant只在流水线中的两个可编程部分执行，而渲染状态是设置其他步骤的，与variant是完全隔离开、互不干扰。也可以说CGPROGRAM…ENDCG内的逻辑决定了variant的数量，CGPROGRAM…ENDCG外的是给Unity配置状态用的，不会引起Shader的逻辑变化，因此没变化）。
另附上一张简化版渲染流程图：
&lt;img src=&quot;https://uwa-public.oss-cn-beijing.aliyuncs.com/answer/image/public/101228/1507705163873.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Wed, 25 Oct 2017 00:02:11 +0800</pubDate>
        <link>https://caihua.tech/2017/10/25/Shader%E5%90%88%E5%B9%B6%E4%B8%8EVariant/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/10/25/Shader%E5%90%88%E5%B9%B6%E4%B8%8EVariant/</guid>
        
        <category>UWA</category>
        
        
      </item>
    
      <item>
        <title>每天一点UWA：第十二周</title>
        <description>&lt;h2 id=&quot;ui&quot;&gt;UI&lt;/h2&gt;
&lt;h4 id=&quot;ugui&quot;&gt;对于UGUI文字花屏问题，有什么推荐的解决方法吗？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;对于UGUI字体花屏的现象， 很有可能是字体的UV不准确导致。&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/yaukey/p/unity_ugui_font_texture_uv_wrong.html&quot;&gt;关于UGUI字体花屏和乱码&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;UGUI研究院之Text字体花屏（二十二）：http://www.xuanyusong.com/archives/4259&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;工具&lt;/h2&gt;
&lt;h4 id=&quot;deep-profilercolor--colorselftotalprofilerbeginsample0deep-profiler&quot;&gt;最近用Deep Profiler发现项目里有一个直接调用Color != Color的接口耗时很高，而且百分比也很高（不管是Self还是Total）。但是如果用Profiler.BeginSample显示时，其耗时又很低，百分比也很低几乎等于0。这样的情况下是Deep Profiler出问题了吗？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;针对上图具体例子来看，Deep Profiler中RoleRender_ChangeColor.get_running的CPU开销虽然较高，但其参考意义不大。因为不开Deep Profiler模式，此处开销是不会这么高的。&lt;/li&gt;
  &lt;li&gt;这是因为，图中的开销实际上是操作了200次循环且获取时间戳的开销，也就是说，当循环或者操作大量次数时，Deep Profiler模式中本身统计耗时操作的时间占比很大，所以此处反馈的时间其实并不是研发团队想看到的真正代码耗时。这也是为何很多团队反馈Deep Profiler统计不算准确的原因。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;粒子&lt;/h2&gt;
&lt;h4 id=&quot;section-2&quot;&gt;粒子系统里面使用到的模型，是不是读写开关必须要打开，否则会崩溃？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;这个问题在第六周的内容中有提到原因。在较新的版本上（例如4.7.2，5.3.5 等版本）进行了各种情况的测试后，尚未复现出这一现象。因此，我们建议研发团队可以尝试关闭 Readable选项。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-3&quot;&gt;模型&amp;amp;动画&lt;/h2&gt;
&lt;h4 id=&quot;skinnedmeshrenderermeshsharedmesh&quot;&gt;SkinnedMeshRenderer的Mesh是不是不能动态修改？属性里只开放了SharedMesh。&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;https://blog.uwa4d.com/archives/TechSharing_51.html  mark一下。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-4&quot;&gt;渲染&lt;/h2&gt;
&lt;h4 id=&quot;unitymaterialobjectmaterialbatching&quot;&gt;Unity中修改了Material的一个属性后，该Object就会单独实例化出一个Material，所以它就不能被动态Batching了，是这样吗？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;是的，所以我们在Material使用详情中对内存中驻留的Material进行了详细的检测和分析，如下图所示。
&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog/TechSharing_51/3.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;图中后缀为（Instance）的材质均为修改材质属性而生成的临时材质，对于这种情况，我们建议研发团队应严格将Instance材质数量控制在尽可能小（&amp;lt;10）的范围内，而对于过高数量的Instance材质，建议研发团队考虑是否可以通过动态更换Material的方式来代替修改材质属性的方式，从而来减少不必要的Instance材质，进而提升物体动态合批的几率。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;a2bsetactivefalse&quot;&gt;游戏中有一些静止的建筑，会和整个场景一起烘焙（包括了每个建筑在地表的阴影）。现在希望这些建筑是逐步开放的，比如玩家1级的时候只有建筑A开放，2级的时候建筑B开放，现在的问题是当建筑未开放时（SetActive(false)）地表的相关阴影还在。这种问题一般是怎么处理的？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;这种问题是因为研发团队将整个场景烘焙成一张Lightmap所致。如果地图中的建筑是固定的，且游戏中并没有动态改变方向光的需求（比如Time Of Day模拟），那么可以尝试以下方法来实现需求：&lt;/li&gt;
  &lt;li&gt;（1）如果建筑物是根据等级而批量出现的，那么可以尝试根据等级不同而烘焙相应建筑群的Lightmap，然后在游戏中根据需求动态替换Lightmap；&lt;/li&gt;
  &lt;li&gt;（2）如果是逐个出现且建筑之间相距较为紧密的话，那么建议尝试通过Dynamic Projector（Asset Store插件）或Shadow Map（Unity自带阴影）来进行处理，因为Lightmap方法已无法支持这种需求。同时，可配合Fast Shadow Receiver（Asset Store 插件）来尽可能降低上述实时阴影带来的性能开销。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 23 Oct 2017 09:02:00 +0800</pubDate>
        <link>https://caihua.tech/2017/10/23/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E5%8D%81%E4%BA%8C%E5%91%A8/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/10/23/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E5%8D%81%E4%BA%8C%E5%91%A8/</guid>
        
        <category>UWA</category>
        
        
      </item>
    
      <item>
        <title>LuaFramework&amp;PureMVC</title>
        <description>&lt;h4 id=&quot;luaframeworkhttpsgithubcomjarjinluaframeworkuguigithubtoluatoluapuremvcpuremvc&quot;&gt;&lt;a href=&quot;https://github.com/jarjin/LuaFramework_UGUI&quot;&gt;LuaFramework&lt;/a&gt;是GitHub上一个基于tolua的人更新案例，里面除了tolua的功能外还使用了PureMVC的部分功能。这个文章是对代码中PureMVC部分的一些理解。&lt;/h4&gt;

&lt;h2 id=&quot;puremvc&quot;&gt;PureMVC&lt;/h2&gt;
&lt;h3 id=&quot;structure&quot;&gt;Structure&lt;/h3&gt;
&lt;h4 id=&quot;modelproxy&quot;&gt;Model&amp;amp;Proxy&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Model保存对Proxy对象的引用，Proxy负责操作数据模型，与远程服务通信存取数据。这样保证了Model层的可移植性。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;viewmediator&quot;&gt;View&amp;amp;Mediator&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;View保存对Mediator对象的引用。&lt;/li&gt;
  &lt;li&gt;由Mediator对象来操作具体的视图组件（View Component，例如Flex的DataGrid组件），包括：添加事件监听器，发送或接收Notification ，直接改变视图组件的状态。&lt;/li&gt;
  &lt;li&gt;这样做实现了把视图和控制它的逻辑分离开来。&lt;/li&gt;
  &lt;li&gt;在LuaFramework的初始代码中只有个APPView，在其中的&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;controllercommand&quot;&gt;Controller&amp;amp;Command&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Controller保存所有Command的映射。Command类是无状态的，只在需要时才被创建。&lt;/li&gt;
  &lt;li&gt;Command可以获取Proxy对象并与之交互，发送Notification，执行其他的Command。经常用于复杂的或系统范围的操作，如应用程序的“启动”和“关闭”。应用程序的业务逻辑应该在这里实现。&lt;/li&gt;
  &lt;li&gt;Controller会注册侦听每一个Notification，当被通知到时，Controller会实例化一个该Notification对应的Command类的对象。最后，将Notification作为参数传递给execute方法。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;facade&quot;&gt;Facade&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Façade类应用单例模式，它负责初始化核心层（Model，View和Controller），并能访问它们的Public方法。&lt;/li&gt;
  &lt;li&gt;在实际的应用中，只需继承Façade类创建一个具体的Façade类就可以实现整个MVC模式，并不需要在代码中导入编写Model，View和Controller类。&lt;/li&gt;
  &lt;li&gt;Proxy、Mediator和Command就可以通过创建的Façade类来相互访问通信。&lt;/li&gt;
  &lt;li&gt;Facade保存了Command与Notification之间的映射。当Notification（通知）被发出时，对应的Command（命令）就会自动地由Controller执行。Command实现复杂的交互，降低View和Model之间的耦合性。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;observernotification&quot;&gt;Observer&amp;amp;Notification&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;使用一个简单的观察者模式实现。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;puremvc-in-luaframework&quot;&gt;PureMVC in LuaFramework&lt;/h2&gt;
&lt;h5 id=&quot;noteluaframeworkmodelproxymediator&quot;&gt;NOTE：在LuaFramework的初始代码中是没有model、proxy、mediator这些内容的。&lt;/h5&gt;
&lt;h4 id=&quot;view&quot;&gt;View&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;view部分也只存在一个AppView对象，它监听了一个MessageList，如果需要监听自己的事件可以在messagelist继续添加。从目前情况看，一个AppView基本可以满足所有UI事件的需要。&lt;/li&gt;
  &lt;li&gt;如果需要多个view的时候，在每个view中可以通过RegisterMessage方法来注册多个事件。&lt;/li&gt;
  &lt;li&gt;view的父类Base负责view的notification和command的映射。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;controller&quot;&gt;Controller&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;LuaFramework中Controller是一个singleton的，在一次性command的基础上加入了一个m_viewCmdMap用于处理由view负责处理的事件。&lt;/li&gt;
  &lt;li&gt;上面提到PureMvc中Command类是无状态的，只在需要时才被创建。所以在command的注册上LuaFramework采用的是名字+类型，因为有了类型就可以动态生成对象。&lt;/li&gt;
  &lt;li&gt;具体来说在LuaFramework的初始代码中注册了socketcommand，当facade send某个message时会调用这个command，采用的就是生成一个socketcommand对象，然后执行它的execute方法。这个方法调用了lua的network对象的OnSocket方法。&lt;/li&gt;
  &lt;li&gt;在command的注册上分为一次性的和view的&lt;/li&gt;
  &lt;li&gt;在command的执行上，在Controller的ExecuteCommand方法中可以看到，先从m_commandMap中查询是否有类型，如果有就实例化并执行execute方法。如果没有就在m_viewCmdMa中找，所有订阅了特定消息的view都会被执行OnMessage方法。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;facade-1&quot;&gt;Facade&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;AppFacade是其子对象。&lt;/li&gt;
  &lt;li&gt;在LuaFramework中facade不但负责将notification和command关联，而且负责管理Manager实例。本质一个字典，如果add的时候没有动静就是&lt;/li&gt;
  &lt;li&gt;facade父类负责将一次性的notification和command关联起来。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;observernotification-1&quot;&gt;Observer&amp;amp;Notification&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;m_viewCmdMap是多播，而m_commandMap是单播。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;总结&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;基本上在LuaFramework中的PureMvc只是使用了一部分功能，主要功能在于消息的注册发布和manager的管理。&lt;/li&gt;
  &lt;li&gt;在使用过程中，因为这个框架本身是要使用lua的，所以在源码中lua的部分在解耦上主要依赖event库来实现订阅发布。在C#部分反而不是很能体现MVC架构的优势。&lt;/li&gt;
  &lt;li&gt;在我自己的项目中为了最大化的使用热更新，所以很多逻辑都是写在lua中的，其实可以考虑在lua中实现一套PureMVC，但是这个语言在实现上应该不简单。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 16 Oct 2017 09:54:07 +0800</pubDate>
        <link>https://caihua.tech/2017/10/16/LuaFramework&PureMVC/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/10/16/LuaFramework&PureMVC/</guid>
        
        <category>Lua</category>
        
        
      </item>
    
      <item>
        <title>每天一点UWA：第十一周</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;字体&lt;/h2&gt;
&lt;h3 id=&quot;section-1&quot;&gt;优化字体资源&lt;/h3&gt;

&lt;h4 id=&quot;section-2&quot;&gt;方向：内存和数量峰值&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;主要是因为在字体资源的使用过程中采用了不同的方式。比如一开始的UI没有考虑使用AssetBundle，从而直接从Resources或者其它文件夹加载了字体资源。而后面的UI又依赖了AssetBundle中的字体，虽然也没有主动load，但是因为unity在load asset的时候会自动加载（有待验证）所以导致字体资源又被加载一次。从而峰值数量会不止一个。&lt;/li&gt;
  &lt;li&gt;内存:很多情况下我们对于一个字体库中的字体只是用了个别的，但是却加载了整个字体库。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2FSparkle_Font%2F1.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;优化方案&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;字库裁切
    &lt;ul&gt;
      &lt;li&gt;针对不同字体的应用场景，设计有效精简的裁切字库。&lt;/li&gt;
      &lt;li&gt;需要注意同一个字体资源在AssetBundle内外可能都会有依赖，如果依赖不能避免，那么就要各自设计裁切字库。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;工具：FontSubsetGUI
&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2FSparkle_Font%2F3.png&quot; alt=&quot;image&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-4&quot;&gt;结果&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2FSparkle_Font%2F4.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;ui&quot;&gt;UI&lt;/h2&gt;
&lt;h4 id=&quot;maskablegraphicenable-imagegcsetactivegc&quot;&gt;什么情况下会触发MaskableGraphic.Enable() ？现在我得到的结论是只要用到了Image组件，然后禁用启用带有这个组件的物体，都会触发进而产生GC。大家都怎么显示隐藏图片这种需求的，SetActive这种方式容易产生GC。&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;在UGUI中，Image组件并没有重写其父类的OnEnable函数，所以在激活时会出现MaskableGraphic.OnEnable。其中出现堆内存开销的话，通常是因为其父类函数Graphic.OnEnable中，UGUI在进行全局容器的Add等类似的操作时，遇到了扩容等产生堆内存的操作。&lt;/li&gt;
  &lt;li&gt;总之，在UGUI中，UI元素的激活和禁用所导致的堆内存分配，通常是不会持续出现的，其实不需要特别地处理。但对于其CPU开销，在UI元素数量较大时，依然是可观的，所以我们依然建议，对于激活禁用操作较为频繁的UI元素，可以尝试通过移出屏幕，缩放为0等方式来避免SetActive的调用。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;uwauiui-panelscrollviewitemitempanel&quot;&gt;UWA建议“将较多的动态UI元素分组放在不同的UI Panel中”，那么请问如果是ScrollView里面多个item的话，是否意味着每个Item都加一个Panel会更好一些？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;“动态元素”其实是相对的。在 ScrollView 中，一般情况下，如背包，其中的Item在滑动过程中是相对静止的，因此这种情况下只需要将这些Item放在一个UIPanel中即可。&lt;/li&gt;
  &lt;li&gt;但在类似于聊天界面中，存在一些UI元素是有持续的动画的，那么就需要考虑对这类元素进行特殊处理，可以尝试将这部分有动画的UI放在独立的UIPanel中，或者在个数不多的情况下，各自变为一个UIPanel等。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;uipanelsprite-renderernguispriteuipanel&quot;&gt;如果我在UIPanel下面放的是Sprite Renderer而不是NGUI的Sprite，是否会引起整个UIPanel的重绘？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;在NGUI中使用Unity2D的Sprite有两种情况，一种是直接使用Unity2D的SpriteRenderer组件，这种情况下，NGUI和Unity2D之间是互不影响的，只是在深度的设置上相对会比较麻烦一些。&lt;/li&gt;
  &lt;li&gt;另一种是使用NGUI的UI2DSprite组件，而该组件是NGUI对Unity2D的SpriteRenderer组件上进行封装的，方便使其深度与其他UI元素进行穿插，因此其行为和其他的UI元素一致，在某些情况下是有可能引起UIPanel的重绘。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-5&quot;&gt;模型&amp;amp;动画&lt;/h2&gt;
&lt;h4 id=&quot;abab&quot;&gt;有一个带位移动画A，有位置有旋转的变化，需要播完这个动画后切换到一个原地的动画B。现在我发现动画A没播放就会切换到B了，导致一些位移数据并没有作用到模型上，这种情况怎么处理？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Mecanim动画系统提供了“Apply Root Motion”功能来满足两个动画文件顶点位移不一致的切换的需求。&lt;strong&gt;当开启“Apply Root Motion”功能后，角色的GameObject位置会随着动画的更新而更新&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;因此，问题中的A切到B后，GameObject的位移将不会改变。建议该研发团队检测GameObject Animator组件的“Apply Root Motion”功能是否开启。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-6&quot;&gt;删除模型上动画的缩放&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;http://answers.unity3d.com/questions/668672/removing-scale-curves-from-animation.html&quot;&gt;link&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;防止将来翻不出去了&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void Apply(GameObject g)
     {
         List&amp;lt;AnimationClip&amp;gt; animationClipList = new List&amp;lt;AnimationClip&amp;gt;(AnimationUtility.GetAnimationClips(g));
         if (animationClipList.Count == 0) {
             AnimationClip[] objectList = UnityEngine.Object.FindObjectsOfType (typeof(AnimationClip)) as AnimationClip[];
             animationClipList.AddRange(objectList);
         }
 
         int count = 0;
 
         foreach (AnimationClip theAnimation in animationClipList)
         {
             foreach (AnimationClipCurveData theCurve in AnimationUtility.GetAllCurves(theAnimation))
             {
                 string name = theCurve.propertyName.ToLower();
                 if (name.Contains(&quot;scale&quot;))
                 {
                     for (int i = theCurve.curve.keys.Length - 1; i &amp;gt;= 0; i--) {
                         theCurve.curve.RemoveKey(i);
                     }
                     string propertyName = theCurve.propertyName;
                     // we can't delete &quot;*.x&quot;, e.g. m_LocalScale.x - but only &quot;*&quot;, e.g. m_LocalScale
                     if (propertyName.IndexOf(&quot;.&quot;) &amp;gt; 0) {
                         propertyName = propertyName.Substring(0, propertyName.IndexOf(&quot;.&quot;));
                     }
                     Debug.Log(string.Format(&quot;Fixing: {0} - {1}&quot;, theCurve.path, propertyName));
                     theAnimation.SetCurve(theCurve.path, theCurve.type, propertyName, null);
                     count++;
                 }
             } 
         }
 
         int checkCount = 0;
         foreach (AnimationClip theAnimation in animationClipList)
         {
             foreach (AnimationClipCurveData theCurve in AnimationUtility.GetAllCurves(theAnimation))
             {
                 string name = theCurve.propertyName.ToLower();
                 if (name.Contains(&quot;scale&quot;))
                 {
                     checkCount++;
                 }
             } 
         }
 
         if (count &amp;gt; 0)
         {
             Debug.Log(&quot;Total number of removed curves is &quot; + count + &quot;. GO name: &quot; + g.name);
             Debug.Log(&quot;Number of remaining scale curves is &quot; + checkCount);
         }
     }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-7&quot;&gt;渲染&lt;/h2&gt;
&lt;h4 id=&quot;section-8&quot;&gt;物体的动态合批条件和是否是透明物体没什么关系吧？比如粒子系统的物体一般都是透明的，是不是也可以合批？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;动态合批并不限制物体是否为半透明或不透明物体。&lt;/li&gt;
  &lt;li&gt;合批的首要要求是Material一致，其本身是半透明Material还是不透明Material均没有限制。&lt;/li&gt;
  &lt;li&gt;粒子系统同样是可以合批的，只要其材质一致，深度较为接近且中间没有其他材质的物体阻隔，那么Unity引擎将会将其进行合批。&lt;/li&gt;
  &lt;li&gt;查看Unity引擎的官方文档：https://docs.unity3d.com/Manual/DrawCallBatching.html&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 16 Oct 2017 09:47:00 +0800</pubDate>
        <link>https://caihua.tech/2017/10/16/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E5%8D%81%E4%B8%80%E5%91%A8/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/10/16/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E5%8D%81%E4%B8%80%E5%91%A8/</guid>
        
        <category>UWA</category>
        
        
      </item>
    
      <item>
        <title>Xlua摘要</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;加载机制&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;xlua在加载lua文件时会使用多个loader，LuaEnv的构造函数中有这么一段代码:&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;AddSearcher(StaticLuaCallbacks.LoadBuiltinLib, 2); // just after the preload searcher
AddSearcher(StaticLuaCallbacks.LoadFromCustomLoaders, 3);
#if !XLUA_GENERAL
AddSearcher(StaticLuaCallbacks.LoadFromResource, 4);
AddSearcher(StaticLuaCallbacks.LoadFromStreamingAssetsPath, -1);
#endif
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;从这段代码可以看出xlua主要的4个加载器分别是内置的lua的&lt;code class=&quot;highlighter-rouge&quot;&gt;LoadBuiltinLib&lt;/code&gt;，已经lua可能存在的两个目录，一个是Resources、另一个是StreamingAssets，通常来说我们也很有可能会把lua代码放到这两个里面。尤其是当用lua做热更新的时候，StreamingAssets是一个很好的选择。&lt;/li&gt;
  &lt;li&gt;当LuaEnv遇到一个&lt;code class=&quot;highlighter-rouge&quot;&gt;require&lt;/code&gt;的时候，就开始从这四个文件夹找&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;luac&quot;&gt;lua调用C#代码&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;unity中C#类分为两种，一种是继承了MonoBehaviour的，一种是一般的C#类。这两种都可以在lua中调用，但是调用方式不同。但是都需要给&lt;code class=&quot;highlighter-rouge&quot;&gt;LuaCallCSharp&lt;/code&gt;这个attribute。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对于一般的C#类型，可以使用这样的方式&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;local testClass = CS.Test
local test = testClass()
test.foo()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;对于继承MonoBehaviour的类是不能用上述方法的，因为在实例化的时候会报错。xlua在生wrap的时候没有考虑是否继承自mono，继承自mono的类不能用new，所以会报错。只能用下面的方法，注意第一个是已经在某个游戏对象上挂了脚本的情况，第二个是用lua动态添加脚本。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;self:GetComponent(&quot;MainUI&quot;):LoadScene(&quot;class1/class1&quot;)	

-- 或者

local mainui = self.gameObject:AddComponent(typeof(CS.MainUI))
mainui:LoadScene(&quot;class1/class1&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;需要注意一下对于静态方法是用&lt;code class=&quot;highlighter-rouge&quot;&gt;.&lt;/code&gt;，非静态是用&lt;code class=&quot;highlighter-rouge&quot;&gt;:&lt;/code&gt;，其实也可以用&lt;code class=&quot;highlighter-rouge&quot;&gt;.&lt;/code&gt;但是需要在函数定义的时候带自己self参数。对于unity中的一些函数这里尤为重要，比如&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-- 因为Find是静态方法所以用.
local cubes = GameObject.Find(&quot;Cubes&quot;)
-- 而Transform.Find其实是依赖于一个具体的GameObject的所以要用:
cube1 = cubes.transform:Find(&quot;Cube1&quot;).gameObject
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;luac-1&quot;&gt;lua与C#代码结合&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;如果想使用xlua的LuaBehaviour这个脚本，需要注意的是不能用加载器加载lua代码，而是dostring，否则不能使用self、注入的对象。但是awake方法是可以用的。需要注意要使用GetInPath，get方法我没成功过。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; // 用对象名字作为加载脚本的查询名字
 string luaname = GameRoot.Instance.GlobleUtil.NameDeleteClone(gameObject.name);

 // 直接用byte[] dostring
 AssetBundle bundle = AssetBundle.LoadFromFile(&quot;Assets/StreamingAssets/main/lua&quot;);
 TextAsset lua = bundle.LoadAsset(&quot;MainUI.lua&quot;, typeof(TextAsset)) as TextAsset;
 luaEnv.DoString(lua.bytes, luaname, scriptEnv);

 // 用 custom loader加载 但是无法使用self，也无法获取luaAwake这类的方法
 //luaEnv.DoString(&quot;require  '&quot; + luaname + &quot;'&quot;, luaname, scriptEnv);

 Action luaAwake = scriptEnv.GetInPath&amp;lt;Action&amp;gt;(&quot;MainUI.awake&quot;);
 luaStart = scriptEnv.GetInPath&amp;lt;Action&amp;gt;(&quot;MainUI.start&quot;);
 luaUpdate = scriptEnv.GetInPath&amp;lt;Action&amp;gt;(&quot;MainUI.update&quot;);
 luaOnDestroy = scriptEnv.GetInPath&amp;lt;Action&amp;gt;(&quot;MainUI.ondestroy&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;refout&quot;&gt;关于ref和out修饰符&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;一开始我测试的时候是本以为lua调用ref传入的参数，也会返回出修改的结果，但出乎我的意料，并没能修改，经过作者提示，lua是通过返回值返回的ref参数，如果函数本身就有返回值，那么最后一个参数是返回的ref或者out参数，如果是一个没有返回值的函数（C#中），在lua中同样可以让它给变量赋值，赋的值就是ref的结果。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 05 Oct 2017 14:28:20 +0800</pubDate>
        <link>https://caihua.tech/2017/10/05/Xlua%E6%91%98%E8%A6%81/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/10/05/Xlua%E6%91%98%E8%A6%81/</guid>
        
        <category>Lua</category>
        
        
      </item>
    
      <item>
        <title>每天一点UWA：第十周</title>
        <description>&lt;h2 id=&quot;assetbundle&quot;&gt;AssetBundle&lt;/h2&gt;
&lt;h4 id=&quot;assetbundle-1&quot;&gt;AssetBundle中的脚本&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;首先，需要说明的是，脚本本身的内容是不会被打包到AssetBundle文件中的，AssetBundle文件储存的仅是脚本的索引信息。因此，即便有多个AssetBundle中都存在UIAtlas这一脚本索引，对堆内存也几乎是不产生影响的，且不会产生冗余问题。&lt;/li&gt;
  &lt;li&gt;其次，脚本被当做资源且会产生依赖这一现象，仅在Unity 4.x版本中出现，而在Unity 5.0以后，脚本之间将不会产生依赖关系。因此，如果你目前还在使用Unity 4.x版本进行开发，那么依赖关系打包时确实需要注意这个问题，即依次Push A和B进行打包时，如果AssetBundle之间存在相同脚本，那么B会对A的脚本产生依赖。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;wwwassetbundlewebstreamassetbundlewwwdisposewebstream&quot;&gt;如果我用WWW加载了一个AssetBundle，创建了一块WebStream内存。这时候我用另一个东西保存这个AssetBundle的引用，然后用WWW给Dispose了，那么这块WebStream内存会释放掉么？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;如果仅是www.dispose，但是AssetBundle引用依然保留的话，那么WebStream是不会释放的。WebStream存在两个引用，一个是www对象，一个是加载出来的AssetBundle。仅这两个引用全部消除时，WebStream才会被Unity引擎回收，具体说明可见之前的技术文章：Unity AssetBundle内存管理机制详解。&lt;/li&gt;
  &lt;li&gt;5.4之后似乎没有webstream的概念了。因为很多方法现在都是直接从disk读取，或者先保存在读取。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;unloadunusedassetsinstantiateresoucesunloadassetgameobject-&quot;&gt;我发现如果不调用UnloadUnUsedAssets这个函数，则无法销毁通过Instantiate实例化出来的材质（包括纹理）。如果我尝试用Resouces.UnloadAsset来卸载挂在GameObject上的实例化材质, 则会闪退，请问这种情况该如何解决呢？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;如果想要直接销毁通过Instantiate实例化出来的材质、纹理等资源，则只能使用DestroyImmediate来进行销毁。研发团队可以参考NGUI中UI Draw Call组件里对动态材质的处理，来加深对动态创建以及销毁的理解。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;脚本&lt;/h2&gt;
&lt;h4 id=&quot;section-1&quot;&gt;关于字符串驻留导致的内存占用&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;https://blog.uwa4d.com/archives/USparkle_String-interning.html&lt;/li&gt;
  &lt;li&gt;https://gist.github.com/klkucan/6c51468ca6f92933356477745f0a50e0&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;androidassetbundleloadfromfileapplicationstreamingassetspathassetbundle&quot;&gt;Android用AssetBundle.LoadFromFile读取Application.streamingAssetsPath目录下的AssetBundle文件，用什么样的地址？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Unity 5.3之前，直接使用 Application.streamingAssetsPath 作为目录路径。&lt;/li&gt;
  &lt;li&gt;Unity 5.3之后，通过新增的LoadFromFile接口加载AssetBundle时，则需要改为 Application.dataPath+”!assets。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;nguiuieventlisteneronpressuibuttonpressuibuttonpressbuttonuibuttonnormaluieventlisteneronpresspress&quot;&gt;准确说这个不是一个优化的问题：NGUI的UIEventListener中的OnPress与UIButton的Press状态不能对应上。具体情况是我点击某个按钮并且按住不放，UIButton处于Press状态，然后移出了Button的范围，UIButton的状态变回了Normal，而UIEventListener中的OnPress并没有监听到，必须松开点击才能监听到。它们的Press状态切换有什么不一样呢？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;理论上UIButton的OnPress和UIEventListener的OnPress是在相同时间点触发的，即手指按下和手指抬起这两个时间点上。&lt;/li&gt;
  &lt;li&gt;而手指在按住状态下移开按钮时， UIButton的状态会变为Normal，这是因为其响应了OnHover的消息。因此如果要模拟UIButton的行为，至少要配合使用OnPress和OnHover两个消息。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;模型&amp;amp;动画&lt;/h2&gt;
&lt;h4 id=&quot;meshuv3uv4uvuv2&quot;&gt;求教Mesh导入后这里的uv3和uv4是怎么回事？有的模型只有uv和uv2，有的有四套。&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;如果在模型导入时就存在 uv2，uv3，uv4，那么这是因为在建模软件中添加了这些顶点属性。一般来说uv3和uv4的使用较为少见，通常是用来配合特殊的Shader实现特殊的效果。而uv2通常被用于Lightmap，uv2可以在建模软件中添加，也可以在Unity中通过Generate Lightmap UVs的选项来生成。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-3&quot;&gt;物理&lt;/h2&gt;
&lt;h4 id=&quot;section-4&quot;&gt;伤害检测、还有靠近采集物品时触发可以采集的提示箭头等，我们都使用了碰撞，请问如果不使用碰撞，可以用什么方法代替呢？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;使用Trigger也是较为合理的做法，如果想替代，可尝试根据距离、动画运行的时间点来进行判断。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-5&quot;&gt;性能综合&lt;/h2&gt;
&lt;h4 id=&quot;prefab&quot;&gt;prefab加载时依赖图片何时加载&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;首先说明一下，如果AssetBundle B和AssetBundle A产生依赖，那么在仅仅加载AssetBunde B中的Prefab B_prefab时，其本身开销仅为B_prefab的加载开销，对于AssetBundle A中的依赖资源并无影响。&lt;/li&gt;
  &lt;li&gt;但是在实例化B_prefab时，Unity引擎会去检查AssetBundle A中的依赖资源是否已经被加载好，如果没有加载好，则先加载AssetBundle A中相关资源，然后再实例化B_prefab。这其实就是大家经常遇到的初次实例化一个技能、角色时出现卡顿的主要原因。&lt;/li&gt;
  &lt;li&gt;因此，如果大家想加快B_prefab的实例化效率，那么对于其依赖关系AssetBundle A中的相关资源，可提前进行预加载，从而减少B_prefab实例化时的相关资源加载时间。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;unloadunusedassetsgc&quot;&gt;手动调用UnloadUnusedAssets+GC的问题&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;通过LoadLevel等API来切换场景时，Unity会自动触发Resources.UnloadUnusedAssets的操作，但在切换完成后再次调用Resources.UnloadUnusedAssets来确保卸载完全的做法也是较为常见的。但是在其它时间点不要调用。&lt;/li&gt;
  &lt;li&gt;对于大场景的MMO类型的游戏，因为切换场景的频率较低，也可以考虑每隔几分钟来手动触发一次Resources.UnloadUnusedAssets来降低内存。而GC的话，则不建议手动调用，即使是在切换场景时。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;resources&quot;&gt;Resources目录下的所有内容都会加载到内存里吗？如果里面东西多，是不是会导致占用内存过高？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;不会，Resources.Load也是即用即加载，但就目前我们统计的结果来看，Resources文件下的资源越多，其生成的ResourceManager内存占用也越大。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;font-texture-&quot;&gt;Font Texture 资源是如何生成的，因为我发现好像有重复的出现，如何优化呢？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;这是Unity为动态字体自动产生的纹理，一般来说不用特别关注。即使重复出现，里面的内容一般也是不一样的（内容即屏幕上显示的文字）。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;meshunitygpumeshcreatevbomeshdrawvbo&quot;&gt;重建的Mesh，Unity引擎会将其重新传入GPU端进行渲染，这部分开销主要体现在Mesh.CreateVBO和Mesh.DrawVBO中。&lt;/h4&gt;

&lt;h4 id=&quot;fk--statemachine-&quot;&gt;FK &amp;amp; Statemachine 状态机占用时间比较高，是否有优化的方法呢？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;影响该项的因素较多，一般为：
    &lt;ul&gt;
      &lt;li&gt;是否开启Optimize GameObjects选项，如果没有，建议开启；&lt;/li&gt;
      &lt;li&gt;场景中Active的GameObject（使用并开启了Animator组件的）是否较多，数量越多，则该项目开销越高；&lt;/li&gt;
      &lt;li&gt;GameObject的骨骼数越多、AnimationClip的采样次数越多，则该项开销也越高。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;因此，建议研发团队可从以上三种情况入手来优化FK &amp;amp; Statemachine的开销。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;prefabresourcesunloadassetxxxprefabprefab--destroy--resoucesunloadunused&quot;&gt;对Prefab资源的卸载、预览英雄模块、需要卸载英雄角色的资源、动画和材质都可以通过Resources.UnloadAsset(xxx)来顶点清除，而Prefab不行，Prefab 只能用 Destroy + Resouces.UnloadUnused()卸载吗？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Prefab如果想要单独卸载，只能使用DestroyImmediate来实现。同时，考虑到Prefab本身已经是很小的一个壳了，对内存的影响非常小，一般情况下是在切换场景的时候一起释放的。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 05 Oct 2017 14:25:20 +0800</pubDate>
        <link>https://caihua.tech/2017/10/05/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E5%8D%81%E5%91%A8/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/10/05/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E5%8D%81%E5%91%A8/</guid>
        
        <category>UWA</category>
        
        
      </item>
    
      <item>
        <title>每天一点UWA：第九周</title>
        <description>&lt;h2 id=&quot;assetbundle&quot;&gt;AssetBundle&lt;/h2&gt;
&lt;h4 id=&quot;assetbundle-1&quot;&gt;关于AssetBundle依赖的问题&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;如果Panel A和Panel B，它们均依赖一个共享Atlas C。如果在加载完AtlasC后卸载它所在的AssetBundle，再创建A和B，此时会失败。因为他们的依赖关系在AssetBundle上。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;serializedfileassetbundle&quot;&gt;请教一下，SerializedFile的卸载规则是什么呢？会跟随这AssetBundle一起卸载么？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;绝大部分的SerializedFile均由AssetBundle产生，当AssetBundle被卸载时，与其对应的SerializedFile也将销毁。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;wwwloadfromcacheordownloadwwwassetbundle-assetbundleassetbundle&quot;&gt;WWW.LoadFromCacheOrDownload只是在内存中有个引用，没有实际加载资源，调用WWW.assetbundle后也是么？ 那么依赖此AssetBundle的资源加载的时候，会自动触发此AssetBundle从磁盘加载对应的引用资源么？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;在调用WWW.assetBundle之后，内存中也只是存在较小的SerializedFile（不包含资源数据）。“那么依赖此AB的资源加载的时候”确实会触发该AssetBundle通过磁盘IO加载资源。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;build&quot;&gt;Build&lt;/h2&gt;
&lt;h4 id=&quot;optimize-mesh-data&quot;&gt;细谈Optimize Mesh Data选项&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;第五周的时候说过Optimize Mesh Data选项的问题，但是只是说了和模型上的optimize的区别和一些问题，下面详细说说这个选项，以下内容来自&lt;a href=&quot;http://www.cnblogs.com/yaukey/p/unity-build-setting-optimize-mesh-data.html&quot;&gt;这里&lt;/a&gt;。&lt;/li&gt;
  &lt;li&gt;Unity 在底层默认希望为你做尽可能多的优化，降低使用门槛，比如 BuildSetting 中的 Optimize Mesh Data 选项就是一个典型的例子。这个选项到底有什么用呢？文档描述为：&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Optimize Mesh Data	Remove any data from meshes that is not required by the material applied to them (tangents, normals, colors, UV).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;即是说：如果开启了此选项，将会在 Build 过程中根据场景中 Mesh 所使用的材质（或者说 shader）进行静态分析，来去掉 Mesh 中“无用”的数据（材质不使用的数据），比如：切线，发现，定点色，多余的 uv 等，以此减少数据量和最终构建的游戏包的大小。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;这是一个非常好的功能，如果 unity 不提供自己写插件恐怕还是比较麻烦的，但是在使用过程中有没有“坑”呢？有没有要注意的地方呢？答案当然是：有！&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果你在场景中有动态切换材质（主要是 shader 的改变），比如原始模型中带有法线，默认的材质没有使用法线，但是动态切换的材质却需要使用法线，那么你得注意很可能在编辑器中运行正常，一旦发布到真机就会出现很怪异的现象，会让人以为是 shader 在不同平台的兼容性或者数据精度等问题。譬如描边效果就是一个很好的例子。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;结论：如果使用此选项，请务必注意自己动态切换材质的游戏对象是否在场景中以静态的形式存在，shader 使用了哪些模型的数据，并根据实际情况做相应的调整。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;unity&quot;&gt;有没有什么办法可以提升Unity编辑器中代码的编译速度？我们现在每修改一次代码，等待的编译时间都将近半分钟。&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;对于大型项目来说，这确实是大家经常遇到的情况。一般来说，Unity Editor会按照脚本的依赖关系编译代码，其主要分为以下四个步骤：
    &lt;ul&gt;
      &lt;li&gt;编译Standard Assets、Pro Standard Assets和Plugins文件夹中的Runtime Script；&lt;/li&gt;
      &lt;li&gt;编译以上三个文件夹中Editor文件夹下的Script；&lt;/li&gt;
      &lt;li&gt;编译项目中所有剩余的Runtime Script（Editor文件夹以外Script；&lt;/li&gt;
      &lt;li&gt;编译剩余Script（即Editor文件夹中Script）。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;建议研发团队可以将一些长时间不需要改动的脚本代码（比如各种插件代码）放入到Standard Assets、Pro Standard Assets或Plugins文件夹中，这样这些代码只需要编译一次，后续的时间就都能节省下来。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;纹理&lt;/h2&gt;
&lt;h4 id=&quot;pvrtcios2&quot;&gt;如果纹理尺寸长宽不相等，那么即便是2的幂次，也不会被压缩成PVRTC格式纹理。建议在iOS平台中，尽可能保证纹理尺寸为2的幂次且长宽相等。&lt;/h4&gt;

&lt;h2 id=&quot;ui&quot;&gt;UI&lt;/h2&gt;
&lt;h4 id=&quot;nguipanelwidgetsatlasdcprofilemeshnguiwidgetsmeshatlas&quot;&gt;NGUI中不同panel下的Widgets使用同一个Atlas，会导致DC比较多，而且从profile中会有多个同名的mesh，以为NGUI中这些widgets的mesh是动态生成的，名字采用的就是Atlas的名字。&lt;/h4&gt;

&lt;h4 id=&quot;ngui&quot;&gt;对于NGUI而言，如果界面元素的坐标是非整数的数值，会导致界面元素模糊么？还有哪些原因会造成界面元素模糊？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;导致界面元素模糊的原因主要分为两个，
    &lt;ul&gt;
      &lt;li&gt;一是像素未对齐（通常就是因为坐标非整数造成），在相邻像素色差较大的情况下容易出现模糊，特别是文字部分；&lt;/li&gt;
      &lt;li&gt;二是纹理分辨率相对于屏幕的分辨率被缩小或放大，纹理被缩小通常会表现出锯齿感，而纹理被放大则会表现出模糊。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;而对于动态字体，通常只需要确保像素对齐即可使其不模糊，但需要注意的是，UGUI与NGUI都有全局缩放的功能(分别在Canvas Scaler和UIRoot组件上)，是为了确保不同分辨率下布局相同，也会使动态字体出现缩放，从而造成模糊的问题。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;工具&lt;/h2&gt;
&lt;h4 id=&quot;draw-callsetpass-callsetpass-calluwadraw-call&quot;&gt;Draw Call和Setpass Call，这两个指标主要是看哪一个？关于这点众说纷纭，很多地方都是说看SetPass Call，但是在UWA的性能测试中，还是把Draw Call当成唯一指标。&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;在 Unity 5.x 中，SetPass Call与 Draw Call相比，SetPass Call的指标与性能相关性更大（比如Static Batching的开启不影响Draw Call数，而SetPass Call通常会明显下降）。&lt;/li&gt;
  &lt;li&gt;但 SetPass Call在某些情况下也同样存在问题，比如往一个场景中添加任意个相邻且材质相同的大网格物体（使Dynamic Batching失效）时，SetPass Call并不会变化。因此在UWA中，我们所使用的是类似Profiler 中 Total Batches 这一项指标，通常该数值与 Frame Debugger 中的数值基本一致，因此可以通过该工具来查看每个Batch的内容，从而更有针对性地进行优化。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;shaderparse--shadercreategpuprogram-&quot;&gt;Shader.Parse 和 Shader.CreateGpuProgram 到底是做什么的？它们什么时候执行？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Shader.Parse体现的是Shader的加载和解析， Shader.CreateGpuProgram 是将Shader传入GPU的一次提交，GPU驱动会对其进行编译，以适应于特定的设备或平台。&lt;/li&gt;
  &lt;li&gt;在Unity 5.x版本中，Shader.Parse在Shader资源加载时进行执行，而 Shader.CreateGpuProgram在所在GameObject第一渲染时进行执行。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;模型&amp;amp;动画&lt;/p&gt;
&lt;h3 id=&quot;mesh&quot;&gt;关于Mesh合并的问题&lt;/h3&gt;
&lt;h4 id=&quot;static&quot;&gt;勾选了static的对象&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;只要是勾选的static的对象都会合并mesh，而不考虑材质使用问题。每个对象会变成submesh。&lt;/li&gt;
  &lt;li&gt;Unity 5.3之前，对于渲染顺序相邻且材质相同的SubMesh则会动态将其索引数组拼合，从而合成一个Draw Call。而Unity 5.3之后则不再拼合索引数组，因为在不切换材质时产生多个Draw Call的开销并不大，而这多个Draw Call会被统计为一个Batch。
    &lt;h4 id=&quot;section-2&quot;&gt;对于动态合并的对象&lt;/h4&gt;
  &lt;/li&gt;
  &lt;li&gt;Unity对于任何Mesh的面片都有65536的个数限制，拼合后的面片数也是如此。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;skinned-mesh-renderdraw-call&quot;&gt;请教，角色分部件换装可行吗？比如衣服裤子分开，都是用Skinned Mesh Render，有没有办法合并降低Draw Call？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;可以通过合并网格的方式来达到降低Draw Call的效果，具体可查看Asset Store中的换装例子：Character Customization。但是，在角色换装时需要注意以下几点：
    &lt;ul&gt;
      &lt;li&gt;装备与角色必须是共用一套骨骼的；&lt;/li&gt;
      &lt;li&gt;各装备之间所用的材质必须相同。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;开发者需要注意，只有同时满足以上两个条件时，才能达到只使用少量Draw Call来进行动态换装的效果。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-3&quot;&gt;渲染&lt;/h2&gt;
&lt;h4 id=&quot;shader&quot;&gt;要达到后续Shader都不出现加载开销，需要满足以下两个条件：&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;包含Shader的AssetBundle文件常驻内存；&lt;/li&gt;
  &lt;li&gt;Shader已经全Load加载好；&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 25 Sep 2017 10:58:00 +0800</pubDate>
        <link>https://caihua.tech/2017/09/25/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E4%B9%9D%E5%91%A8/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/09/25/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E4%B9%9D%E5%91%A8/</guid>
        
        <category>UWA</category>
        
        
      </item>
    
      <item>
        <title>每天一点UWA：第八周</title>
        <description>&lt;h2 id=&quot;assetbundle&quot;&gt;AssetBundle&lt;/h2&gt;
&lt;h4 id=&quot;assetbundleassetbundlehash&quot;&gt;打包AssetBundle的时候，我发现切换场景时，即使打同一个场景的AssetBundle，它们的Hash值都是不一样的，可能是什么原因造成的呢？&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;目前很可能是Shader Stripping造成的，其原理可见&lt;a href=&quot;https://docs.unity3d.com/Manual/class-GraphicsSettings.html&quot;&gt;文档&lt;/a&gt;。&lt;/li&gt;
  &lt;li&gt;简单来说就是根据当前场景对Shader进行简化，因此如果打包时包含的场景的Lightmap或Fog设置不同，打出来的AssetBundle包也有可能是不同的。可以尝试通过把Graphics Settings中的Shader Stripping设置进行修改来避免这个问题。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;prefabunloadtrueresourcesunloadunusedassets&quot;&gt;Prefab目前，只能通过Unload(True)和Resources.UnloadUnusedAssets卸载。&lt;/h4&gt;

&lt;h4 id=&quot;nguiatlasassetbudleresourcesunloadunusedassets1&quot;&gt;请教一下，为什么NGUI的Atlas通过AssetBudle载入之后，使用Resources.UnloadUnusedAssets()不能够释放呢？分析器里面引用是1，但是又找不到哪里引用了。&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;如果Unity Profiler中看到了资源的引用计数不为0，则说明该Atlas资源还在被索引，这样使用Resources.UnloadUnusedAssets()是无法进行卸载的。只有将其索引消除，该资源才会被认为是UnUsed资源，这样才能被Resources.UnloadUnusedAssets()卸载。该资源的引用计数不为0的原因可能有以下几种：
    &lt;ul&gt;
      &lt;li&gt;它被缓存在某些Container中，即它从AssetBundle或Resources中加载后，被直接缓存到某个容器中，从而产生了索引，只要它没有被清除出容器，那么索引将一直存在；&lt;/li&gt;
      &lt;li&gt;它被其他Material、Prefab等索引，而这些资源被缓存在某些容器中，即间接被容器缓存，只要索引它的资源不被清楚，那么它的索引页将一直存在。
就目前我们遇到的泄露问题来看，上述两点为最为主要的原因。因此，如果你的项目中也存在类似情况，建议首先以此为基础对容器的使用进行排查。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ui&quot;&gt;UI&lt;/h2&gt;
&lt;h4 id=&quot;uguisrcollview-mask&quot;&gt;UGUI的SrcollView Mask遮挡不住特效，这个有没有可行的解决方案？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;UGUI的Scrollview Mask组件使用的是Stencil Buffer，需要严格确保渲染顺序的正确性，这对于粒子系统或是其他的模型较难控制，因此可以尝试通过其他的方式，如实现一个四边形Alpha 裁剪的Shader，将ScrollView的裁剪区域传入Shader，从而模拟一个特效被“遮罩”的效果。以下是宣雨松博客中提出的一种方式，可以作为参考：
http://www.xuanyusong.com/archives/3518&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;spinenguiscrollviewspinespineshader&quot;&gt;Spine动画在NGUI的ScrollView滚动区域的层级也会出现问题，请问怎么裁剪Spine动画呢，Spine是骨骼，这不就等于给特效换Shader了吗？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;同上&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;uitextureuwa&quot;&gt;我们图标现在是制作成图集后再使用的，但是当图标数量很多的时候，图集的膨胀就很厉害了。对此我们的做法有两种：1）拆为多个图集；2）不再使用图集转而使用UITexture来使用。请问UWA有什么建议呢？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;使用图集的主要缺点在于内存较大，且管理不便；而使用UITexture的主要缺点在于产生的Draw Call较多（每个UITexture都会产生一个Draw Call且无法拼合），影响运行效率。&lt;/li&gt;
  &lt;li&gt;一切在于平衡，dc换内存或者内存换dc。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;uidraw-callenabledui-scrollrectenabled&quot;&gt;我发现当把UI挪到屏幕外时，Draw Call不会减少，只有设置Enabled去掉才能减少。UI是没有遮罩剔除这类功能吗？ 那是否意味着ScrollRect只能自己做动态加载或者动态设置Enabled之类的优化了？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;del&gt;因为UGUI合并网格时是以Canvas为单位的，所以只把一部分UI元素移除屏幕并不能降低Draw Call，在Unity 5.2版本以前需要满足两点：&lt;/del&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;del&gt;1． 使用Screen Space – Camera 的 Render Mode；&lt;/del&gt;&lt;/li&gt;
      &lt;li&gt;&lt;del&gt;2． 需要将移出的UI元素放在独立的Canvas中，然后整体移出屏幕。&lt;/del&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;但在Unity 5.2版本之后，上述方法也已经失效。&lt;/li&gt;
  &lt;li&gt;因此我们建议，在移出后，通过将Canvas的Layer修改为相机Culling Mask中未选中的Layer来去除这部分多余的Draw Call， &lt;strong&gt;但这种方法同样需要将移出的UI元素放在独立的Canvas中&lt;/strong&gt;。这种方法，相比Enabled的设置，可以减少一定的CPU开销。而对于ScrollRect，如果包含的UI元素较多，确实需要自己做动态加载和动态设置Enabled来进行优化。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;uimaskui-&quot;&gt;UI展示动画时，使用Mask做和使用UI本身做 ，哪个效率会更高些?&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;一般来说建议尽可能少用Mask组件，该组件的使用对于Draw Call会有较大的影响，也可尝试用 Rect2D Mask来代替。而如果直接通过改变UI元素本身来做动画，当涉及的UI元素数量较大时，容易引起较高的网格重建开销。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;工具&lt;/h2&gt;
&lt;h4 id=&quot;uwa-profilermanagedstaticreferencesstatic-classaclassbclassb&quot;&gt;关于定位游戏中冗余资源引用的问题。UWA的报告中能定位到具体的引用代码么？ 在Profiler只能看到ManagedStaticReferences但是具体不到引用的位置。比如Static ClassA引用一个ClassB，ClassB上引用了一个资源，就定位不出这个引用的过程。请问这种情况下有没有比较好的方法找到引用关系呢？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;该问题在Unity 5.3 之前的版本中都没有方式来进行定位，只能由研发团队根据对代码的推测了进行定位；而在Unity 5.3之后的版本则可以借助Memory Profiler来尝试定位，而Memory Profiler尚未原生集成在Unity Editor中，需要在以下网址进行下载：
https://bitbucket.org/Unity-Technologies/memoryprofiler&lt;/li&gt;
  &lt;li&gt;只是记一下有这么个工具。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;粒子&lt;/h2&gt;
&lt;h4 id=&quot;prewarm&quot;&gt;粒子系统的Prewarm主要用来做什么的，这个怎么优化呢？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;ParticleSystem.Prewarm的出现表示当前加载、激活或者首次渲染的粒子系统开启了”Prewarm”选项，而开启该选项的粒子系统在加载后会立即执行一次完整的模拟。以“火焰”为例，Prewarm开启时，加载后第一帧即能看到“大火”，而不是从“火苗”开始逐渐变大。但Prewarm的操作通常都有一定的耗时，建议在可以不用的情况下，将其关闭。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;模型&amp;amp;动画&lt;/h2&gt;
&lt;h4 id=&quot;profileranimatorinitializeanimatorinstance-animator&quot;&gt;我在Profiler中看到Animator.Initialize这个耗时很大，这个有什么建议么?Animator.Instance 是因为Animator过多造成的吗？&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2FTechSharing_40%2F1.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;由图中可知，Animator.Initialize主要是在Instantiate实例化时引起（实际上，GameObject.Active操作也会引起Animator.Initialize），而其具体的耗时原因是相关资源（主要是AnimationClip资源）的加载所致。因此，我们的建议如下：
    &lt;ul&gt;
      &lt;li&gt;对GameObject的Instantiate实例化操作进行检测，对于频繁Instantiate的GameObject尝试进行缓存；&lt;/li&gt;
      &lt;li&gt;对Animator Controller中的AnimationClip资源进行精简，可尝试动态加载和替换Animator Controller中的AnimationClip；&lt;/li&gt;
      &lt;li&gt;由（1）引申出来，对于已经在缓存池中通过GameObject.Active操作造成的Animator.Initialize开销，建议通过Active/Deactive Animator组件来代替Active/Deactive GameObject，这种操作可以避免Animator.Initialize时内部组织结构创建的开销，进而降低Animator.Initialize时的CPU开销。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-3&quot;&gt;性能综合&lt;/h2&gt;
&lt;h4 id=&quot;gameobjectinstantiategameobject&quot;&gt;GameObject.Instantiate()每实例化一个GameObject到场景中，会造成卡顿，有什么办法可以优化吗？就算我采用了异步加载，仍然会有稍许的卡顿感。除了缓存池，是否还有别的方法？&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;建议研发团队先通过Unity Profiler来确定该性能卡顿的位置。如果只是一个空的GameObject，Instantiate实例化是很快的。一般来说，Instantiate实例化时间较长，主要由以下三个原因：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;与资源的加载有关：对于这种情况，研发团度需要精简资源，或者预加载资源来降低实例化的开销；&lt;/li&gt;
      &lt;li&gt;序列化信息比较多：当GameObject上的Component比较多时，其Instantiate实例化性能会受到影响，比如说粒子系统，这种情况就只能通过分帧实例化，或者通过缓存池来避免；&lt;/li&gt;
      &lt;li&gt;自定义组件的Awake：在Instantiate实例化时，其GameObject上挂载脚本的Awake函数也会被触发，其中产生的CPU占用，也会被计算在Instantiate实例化内。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;inspectortransformfind&quot;&gt;预设中的变量，拖拽到Inspector面板和Transform.find这两种方法对加载影响是一样的吗？&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;对加载性能有微小的不同。Transform.Find 是可以灵活控制调用时机的，可以真正要用的时候再进行Transform.Find，这样GameObject被实例化时效率会更高一些 。但如果拖上去，GameObject被实例化时，该变量就需要进行序列化。因此，加载和实例化时两者的性能会存在一些微小的变化。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;assetbundlecreatefrommemory&quot;&gt;我有一个关于AssetBundle资源加密问题。CreateFromMemory这里不推荐大规模使用，那是不是我们要放弃对一部分资源的加密？还是说有其它的解决办法？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;由于CreateFromMemory的加载速度相较其他的接口而言，耗时明显增大，因此我们确实不建议大规模使用。&lt;/li&gt;
  &lt;li&gt;就目前而言，除了使用CreateFromMemory，并没有其他高效直接的方法进行资源加密，因此，确实需要放弃对一部分资源的加密。同时，目前存在一些工具可以从更底层的方式来获取和导出渲染相关的资源，如纹理、网格等，因此，对于这部分的资源加密并没有十分的必要性。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 25 Sep 2017 10:54:00 +0800</pubDate>
        <link>https://caihua.tech/2017/09/25/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E5%85%AB%E5%91%A8/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/09/25/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E5%85%AB%E5%91%A8/</guid>
        
        <category>UWA</category>
        
        
      </item>
    
      <item>
        <title>每天一点UWA：UI优化小结</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;说明&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;经过一个半月的学习，对UI的优化有了一些心得，同时也希望把零散的知识点总结到一起，因此有了这个专题。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;那些需要关注的性能指标函数&lt;/h2&gt;
&lt;h4 id=&quot;ugui&quot;&gt;UGUI参考的函数&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;1、Canvas.SendWillRenderCanvases()
该API为UI元素自身发生变化（比如被Enable或者被缩放，移动并不算）时所产生的调用。发生在canvas被渲染之前。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;2、Canvas.BuildBatch
该API为UI元素合并的Mesh需要改变时所产生的调用。通常之前所提到的Canvas.SendWillRenderCanvases()的调用都会引起Canvas.BuildBatch的调用。另外，Canvas中的UI元素发生移动也会引起Canvas.BuildBatch的调用。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;ngui&quot;&gt;NGUI参考的函数&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;UICamera.Update()
该函数通常在点击时出现开销。因此，当该函数的CPU开销较高时，通常都是因为调用了其他的较为耗时的函数引起。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;UIRect.Update()
该函数通常在需要更新锚点位置时出现开销。因此，当该函数的CPU开销持续较高时，通常是因为当前场景中有较多的UI元素绑定了OnUpdate模式的锚点。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;UIPanel.LateUpdate()
该函数为NGUI最主要的CPU开销，包含了对所有UI界面包括其下UI元素的状态更新、网格重建、DrawCall合并等操作。大量的UI变动或者不合理的UIPanel布局都有可能导致该函数出现较高的峰值。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;UIRect.Start()
该函数主要涉及到UI元素的初始化操作，通常在UI界面被实例化时出现并产生一定的CPU开销。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ui&quot;&gt;一些需要知道的UI原理&lt;/h2&gt;

&lt;h4 id=&quot;mesh&quot;&gt;mesh合并&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;一个Canvas下的所有UI元素都是合在一个Mesh中的。&lt;/li&gt;
  &lt;li&gt;而在Batch前，UGUI会根据这些UI元素的材质（通常就是Atlas）以及渲染顺序进行重排，在不改变渲染结果的前提下，尽可能将相同材质的UI元素合并在同一个SubMesh中。所以同一Canvas下不同的材质的UI可能会合并为多个SubMesh。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;ui-1&quot;&gt;UI重建&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;关于UI重建的说明。UI其实是一些3D的quad，这一下就能够理解为什么存在UI的减少少drawcall了，这个和模型的减dc完全一个原理。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;在UGUI中，网格的更新或重建（为了尽可能合并UI部分的DrawCall）是以Canvas为单位的，且只在其中的UI元素发生变动（位置、颜色等）时才会进行。因此，将动态UI元素与静态UI元素分离后，可以将动态UI元素的变化所引起的网格更新或重建所涉及到的范围变小，从而降低一定的开销。而静态UI元素所在的Canvas则不会出现网格更新和重建的开销。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在这再次对更新和重建进行一些详细的说明：&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;更新指的是UI元素本身的某些属性发生变化，从而需要重新生成，或者更新顶点属性。比如颜色变了，在UGUI中颜色的变化是通过修改顶点色实现的，所以就需要更新UI元素对应的每个顶点的顶点色属性（可以认为就是修改下某个数组里的数值）。位置移动一般是不会造成顶点属性的变化的。所以总的来说，“网格更新”更新的是顶点属性。&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;blockquote&gt;
      &lt;p&gt;UI元素和别的网格不同点在于，UI的网格是需要进行合并的，并且在UGUI中是以Canvas为单位的，在提交GPU之前，同一Canvas下的所有UI元素都会被合入一个Mesh中（但包含多个SubMesh）。所以位置的移动，顶点属性的变化，都会导致这个Mesh要重新合并，也就是网格重建。这也是为什么说要“动静分离”的原因，完全静态的Canvas是不需要重建的，但只要里面有一个UI元素在动，就会引起Canvas的重建。&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;blockquote&gt;
      &lt;p&gt;在UGUI里更改了Image的Color属性，其原理是修改顶点色，因此是会引起网格的Rebuild的（即Canvas.BuildBatch操作，同时也会有Canvas.SendWillRenderCanvases的开销）。通过修改顶点色来实现UI元素变色的好处在于，修改顶点色可以保证其材质不变，因此不会产生额外的Draw Call。&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;blockquote&gt;
      &lt;p&gt;Unity自带的UI Shader处理颜色时，改 _Color属性不会触发顶点重建吗？&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;blockquote&gt;
      &lt;p&gt;在UI的默认Shader中存在一个Tint Color的变量，正常情况下，该值为常数(1,1,1)，且并不会被修改。如果是用脚本访问Image的Material，并修改其上的Tint Color属性时，对UI元素产生的网格信息并没有影响，因此就不会引起网格的Rebuild。但这样做因为修改了材质，所以会增加一个Draw Call。&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;blockquote&gt;
      &lt;p&gt;综上所述，移动不一定会更新，但是会重建。而颜色变化或者大小变化带来的都是重建。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;优化建议：&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;动静分离，动的频率不同也分离，减少Mask组件的使用，使用Mask不仅会增加GPU端渲染的压力，同时也会造成CPU端DrawCall的明显上升。可尝试用RectMask2D来进行替换。&lt;/li&gt;
  &lt;li&gt;减少OnEnable和OnDisable，通过移动位置、改变摄像机culling mask。&lt;strong&gt;后者可能会一定程度地提高内存的开销（UIDrawCall中存储的Mesh）&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;修改material改颜色和直接改color属性在性能消耗要权衡。一个加drawcall一个会重建，要根据测试结果来。&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sun, 10 Sep 2017 01:02:01 +0800</pubDate>
        <link>https://caihua.tech/2017/09/10/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-UI%E4%BC%98%E5%8C%96%E5%B0%8F%E7%BB%93/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/09/10/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-UI%E4%BC%98%E5%8C%96%E5%B0%8F%E7%BB%93/</guid>
        
        <category>UWA</category>
        
        
      </item>
    
      <item>
        <title>每天一点UWA：第七周</title>
        <description>&lt;h2 id=&quot;ui&quot;&gt;UI&lt;/h2&gt;
&lt;h4 id=&quot;npot-tolarger-potuipixel-perfect&quot;&gt;NPOT采用 ToLarger 的模式拉成POT，如果是UI界面（开启Pixel Perfect）的话，可能显示时会有较大视觉损失。&lt;/h4&gt;

&lt;h4 id=&quot;unity-5xugui&quot;&gt;在Unity 5.x版本下，我们在用UGUI的过程中发现它把图集都打进了包里，这样就不能自动更新了，请问图集怎么做自动更新呢？&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;在Unity 5.x中UGUI使用的Atlas确实是不可见的，因此无法直接将其独立打包。&lt;/li&gt;
  &lt;li&gt;建议，可以把Packing Tag相同的源纹理文件，打到同一个AssetBundle中（设置一样的AssetBundle Name），从而避免Atlas的冗余。同时这样打包可以让依赖它的Canvas的打包更加自由，即不需要把依赖它的Canvas都打在一个AssetBundle中，在更新时直接更新Atlas所在的AssetBundle即可。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;scrollrectcanvassendwillrendercanvases&quot;&gt;ScrollRect在滚动的时候，会产生Canvas.SendwillRenderCanvases，有办法消除吗？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;ScrollRect在滚动时，会产生OnTransformChanged的开销，这是UI元素在移动时触发的，但通常这不会触发Canvas.SendWillRenderCanvases。&lt;/li&gt;
  &lt;li&gt;如果观察到Canvas.SendWillRenderCanvases耗时较高，可以检查下ScrollRect所在的Canvas是否开启了Pixel Perfect的选项，该选项的开启会导致UI元素在发生位移时，其长宽会被进行微调（为了对其像素），而ScrollRect中通常有较多的UI元素，从而产生较高的Canvas.SendWillRenderCanvases开销。因此可以尝试关闭Pixel Perfect看效果是否可以接受，或者尝试在滚动过程中暂时关闭Pixel Perfect等方式来消除其开销。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;ngui&quot;&gt;对NGUI字体错乱有什么好的解决方案吗？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;有这么几种可能：
    &lt;ul&gt;
      &lt;li&gt;一次展开文字太多了。这种情况在部分高通机型和Unity早期版本上都经常出现，现在也偶尔有，究其原理是FontTexture的扩容操作做得不够快或者收到了硬件驱动的限制。&lt;/li&gt;
      &lt;li&gt;一般来说有两种方法可以解决：（1）减少面板中的字体内容；（2）一开始就用超大量的字体去扩容，将动态字体的FontTexture扩大到足够大；文字渲染与开发团队编写的多线程渲染发生了冲突。这种情况也常有发生，特别是通过GL.IssuePluginEvent方式来开启多线程渲染的项目，就会容易出现问题。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;就我们的优化经验来看，第一种情况发生的可能性比较大。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;工具&lt;/h2&gt;
&lt;h4 id=&quot;draw-callsetpass-callsetpass-calluwadraw-call&quot;&gt;Draw Call和Setpass Call，这两个指标主要是看哪一个？关于这点众说纷纭，很多地方都是说看SetPass Call，但是在UWA的性能测试中，还是把Draw Call当成唯一指标。&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;在 Unity 5.x 中，SetPass Call与 Draw Call相比，SetPass Call的指标与性能相关性更大（比如Static Batching的开启不影响Draw Call数，而SetPass Call通常会明显下降）。但 SetPass Call在某些情况下也同样存在问题，比如往一个场景中添加任意个相邻且材质相同的大网格物体（使Dynamic Batching失效）时，SetPass Call并不会变化。因此在UWA中，我们所使用的是类似Profiler 中 Total Batches 这一项指标，通常该数值与 Frame Debugger 中的数值基本一致，因此可以通过该工具来查看每个Batch的内容，从而更有针对性地进行优化。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;脚本&lt;/h2&gt;
&lt;h4 id=&quot;editor-getcomponent--tgameobject-gc-alloc&quot;&gt;Editor 下，当调用GetComponent() 且 T组件并不在当前的GameObject 上时，确实会出现GC Alloc。&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;首先在发布后是不会出现的。&lt;/li&gt;
  &lt;li&gt;这是因为在Editor下，Unity的MissingComponentException实现所致，在出现以上情况时，Unity 并不是直接返回一个 NULL，而是返回一个代理 Object用来储存一些相关信息，在后续被访问时可以给出更详细的报错信息。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;eventsystemupdate&quot;&gt;EventSystem.Update()占用过高怎么优化？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;EventSystem.Update 的开销分为两个部分：
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;来自被触发的响应事件，这部分的开销实际上并不属于事件系统本身，比如：某次点击触发了一个开销很高的逻辑函数，尤其是涉及到资源的加载和实例化。对于这类开销，我们建议通过Profiler.Begin/EndSample或者UWA提供的UWA API，对这些逻辑函数进行进一步的分析。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;事件检测的开销，在默认情况下所有的UI元素都是事件检测的目标，因此当界面上UI元素数量很多，且长时间接触屏幕时，会有较高的持续开销。对于这类开销，我们建议通过以下几种方式来优化：&lt;/p&gt;
        &lt;ul&gt;
          &lt;li&gt;合理划分子Canvas，只有需要检测事件的界面才需要挂上GraphicRaycaster组件。&lt;/li&gt;
          &lt;li&gt;在Unity5.2之后的版本中，尽可能将不需要参与事件检测的UI元素的 Raycast Target 属性的勾选去掉。而对于Unity 4.x的版本，则可以尝试对UI部分的源码来进行修改以达到类似的效果。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;模型&amp;amp;动画&lt;/h2&gt;
&lt;h4 id=&quot;animator-controlleranimator-controller&quot;&gt;动态替换Animator Controller后删除旧的Animator Controller，但是其中的动画片段资源没有被删除。&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;销毁Animator Controller并不会释放其内所引用的AnimationClip资源的，所以内存没有明显下降是正常的。建议按照以下方式做个试验：&lt;/li&gt;
  &lt;li&gt;销毁Animator Controller 后，通过Unity Profiler立刻真机Take Sample，查看Animation Clip的Ref count是否为0；&lt;/li&gt;
  &lt;li&gt;如果不是，则需要进一步查看这些资源的索引出处；如果为0，则可以通过UnloadUnusedAssets或UnloadAsset来将其从内存中去除。&lt;/li&gt;
  &lt;li&gt;PS:在unity中很多对象只是个包装器，或者只是包含了其它资源的引用，因此消耗这些包装器并不会真正的销毁资源对象。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-3&quot;&gt;渲染&lt;/h2&gt;
&lt;h4 id=&quot;shaderwarmupallshaderscreategpuprogramshaderassetbundleshadervariantcollectionshader&quot;&gt;我使用Shader.WarmupAllShaders操作，在后续加载资源还是有CreateGPUProgram出现。(Shader都在一个AssetBundle文件中，都是常驻内存的，不会删掉)是必须使用ShaderVariantCollection来加载Shader吗？&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;WarmupAllShaders仅能对当前内存中的Shader进行warm up。后续如果又有Shader加载进来，则仍然会出现CreateGPUProgram操作。&lt;/li&gt;
  &lt;li&gt;所以如果出现问题中的现象应该还是有shader打包到别的AssetBundle中了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;materialsetpassfast&quot;&gt;Material.SetPassFast占用很高，这是在第一次实例化一个特效，但是第二次实例化就不会出现高值了，请问能怎么优化吗？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;该过程是在处理Shader，Unity 5.3以后在第一次显示时才会将Shader进行Warmup，所以就会造成一次峰值卡顿。&lt;/li&gt;
  &lt;li&gt;上面那个问题就很好的解决了这个问题，加载完shader后可以主动调用一次Shader.WarmupAllShaders函数。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;unity-3dshader&quot;&gt;在Unity 3D中，shader是何时编译的，在何时加载入显存中的（本条来自知乎）？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Editor中：修改shader并保存时立即编译。&lt;/li&gt;
  &lt;li&gt;Runtime下，无论哪个平台，都是在进入场景时加载shader object内容到内存，但是首次实际调用渲染时才编译，编译完成之后会cache下来。&lt;/li&gt;
  &lt;li&gt;有两种优化方法：
    &lt;ul&gt;
      &lt;li&gt;
        &lt;ol&gt;
          &lt;li&gt;调用Shader.WarmupAllShaders()，自动编译该场景中用到的所有shader。该方法在Unity5中已经废弃。&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;ol&gt;
          &lt;li&gt;在项目设置的GraphicsSettings中，可以导出ShaderVariantCollection，并在Preloaded Shader中导入，这样的话就可以在载入场景时一并编译需要预加载的shader，这样的优化在移动平台上用得比较多。&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//docs.unity3d.com/Manual/OptimizingShaderLoadTime.html&quot;&gt;具体见&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sun, 10 Sep 2017 00:55:48 +0800</pubDate>
        <link>https://caihua.tech/2017/09/10/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E4%B8%83%E5%91%A8/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/09/10/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E4%B8%83%E5%91%A8/</guid>
        
        <category>UWA</category>
        
        
      </item>
    
  </channel>
</rss>
