<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>蔡华的博客</title>
    <description>Be publicly useful and privately happy.</description>
    <link>https://caihua.tech/</link>
    <atom:link href="https://caihua.tech/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Mon, 07 Aug 2017 22:27:40 +0800</pubDate>
    <lastBuildDate>Mon, 07 Aug 2017 22:27:40 +0800</lastBuildDate>
    <generator>Jekyll v3.2.1</generator>
    
      <item>
        <title>每天一点UWA：第二周</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;内存&lt;/h2&gt;

&lt;h3 id=&quot;section-1&quot;&gt;概述&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;内存的开销无外乎以下三大部分：1.资源内存占用；2.引擎模块自身内存占用；3.托管堆内存占用。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-2&quot;&gt;资源内存&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;大头在纹理，其次在网格、动画片段和音频。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-3&quot;&gt;纹理&lt;/h4&gt;

&lt;h5 id=&quot;section-4&quot;&gt;从格式解决内存占用问题&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;选择正确的格式，比如Android上是ETC，ios的PVRTC，PC上DXT。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-5&quot;&gt;不同格式可能出现的问题：&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;因为ETC、PVRTC都是有损压缩因此可能出现色阶问题，如果用RGB32这样的格式虽然能解决问题但是内存占用太大。好的办法是在做纹理的时候减少色差范围，必要做出高对比度的阶梯式的图。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;比如，同样一张1024x1024的纹理，如果不开启Mipmap，并且为PVRTC格式，则其内存占用为512KB，而如果转换为RGBA32位，则很可能占用达到4MB。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;OpenGL ES2的设备只支持ETC1，但是ETC1不支持alpha通道。解决办法是将透明图分成两张，一个RGB24的保存RGB通道，一个alpha8的保存A通道，然后在使用时使用定制的shader去分别读取两个纹理图。&lt;/li&gt;
  &lt;li&gt;PS：OpenGL ES 3.0支持ETC2甚至ASTC，都是很好的支持透明通道的压缩格式。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-6&quot;&gt;选择合适的纹理设置&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;能512解决的事情别用1024&lt;/li&gt;
  &lt;li&gt;选择性的使用mipmap，对于UI这样的纹理使用完全没有必要用mipmap。&lt;/li&gt;
  &lt;li&gt;Read &amp;amp; Write选项会使得纹理的内存使用量增加一倍。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-7&quot;&gt;网格&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;mesh中顶点信息可以进行相关的优化，比如Normal、Color和Tangent这些数据要按照需要来做，不用的就不要做。而且顶点信息超多900还不能动态批处理。不需要就计算发现的时候就可以不用tangent数据了，有贴图的话color数据也不需要。&lt;/li&gt;
  &lt;li&gt;Color数据和Normal数据主要为3DMax、Maya等建模软件导出时设置所生成，而Tangent一般为导入引擎时生成。&lt;/li&gt;
  &lt;li&gt;如果项目对Mesh进行Draw Call Batching操作的话，那么将很有可能进一步增大总体内存的占用。比如，100个Mesh进行拼合，其中99个Mesh均没有Color、Tangent等属性，剩下一个则包含有Color、Normal和Tangent属性，那么Mesh拼合后，CombinedMesh中将为每个Mesh来添加上此三个顶点属性，进而造成很大的内存开销。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-8&quot;&gt;引擎模块自身占用内存&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;引擎自身中存在内存开销的部分纷繁复杂，可以说是由巨量的“微小”内存所累积起来的，比如GameObject及其各种Component（最大量的Component应该算是Transform了）、ParticleSystem、MonoScript以及各种各样的模块Manager（SceneManager、CanvasManager、PersistentManager等)…&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;一般情况下，上面所指出的引擎各组成部分的内存开销均比较小，真正占据较大内存开销的是这两处：WebStream 和 SerializedFile。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;PS：5.4以后没有webStream的概念了，不过还是要考虑WWW和LoadFromMemory中会保存AssetBundle原始数据的问题，参见&lt;a href=&quot;https://docs.unity3d.com/550/Documentation/Manual/AssetBundleCompression.html&quot;&gt;Asset Bundle Compression&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;AssetBundle所占的内存也需要考虑，尽可能做到按需加载，用完后及时的清理。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;mono&quot;&gt;托管堆内存占用/无效的Mono堆内存开销&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Mono的堆内存一旦分配，就不会返还给系统。这意味着Mono的堆内存是只升不降的。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-9&quot;&gt;不必要的堆内存分配主要来自于以下几个方面：&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;高频率地 New Class/Container/Array等。不要再update占用的函数中实例化对象。&lt;/li&gt;
  &lt;li&gt;Log输出，需要适当的减少log，只保留最关键的。&lt;/li&gt;
  &lt;li&gt;UIPanel.LateUpdate。这是NGUI中CPU和堆内存开销最大的函数,是由UI网格的重建造成。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-10&quot;&gt;一些推荐的办法&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;不要一次加载一个过大的资源，比如配置文件、纹理图等。这样会造成一次性申请过多的内存，但是还不回去了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-11&quot;&gt;内存泄漏&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;首先通过工具发现场景切换开始和结束时内存使用没有一致，这个现象不能说明内存就一定有泄漏。比如资源加载后常驻内存以备后续使用、Mono堆内存的只升不降等等，这些均可造成内存无法完全回落。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-12&quot;&gt;检查资源的使用情况，特别是纹理、网格等资源的使用&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;这段主要介绍了如何使用UWA的工具对纹理和网格进行检查，查看是否出现资源的内存泄漏。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;profilerwebstreamserializedfile&quot;&gt;通过Profiler来检测WebStream或SerializedFile的使用情况&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;直接通过Profiler Memory中的Take Sample来对其进行检测，通过直接查看WebStream或SerializedFile中的AssetBundle名称，即可判断是否存在“泄露”情况。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-13&quot;&gt;资源冗余&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;是指在某一时刻内存中存在两份甚至多份同样的资源。导致这种情况的出现主要有两种原因：&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;assetbundle&quot;&gt;AssetBundle打包机制出现问题&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;显而易见，对于公用资源需要进行合理的划分打包。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-14&quot;&gt;资源的实例化所致&lt;/h5&gt;

&lt;blockquote&gt;
  &lt;p&gt;在Unity引擎中，当我们修改了一些特定GameObject的资源属性时，引擎会为该GameObject自动实例化一份资源供其使用，比如Material、Mesh等。以Material为例，我们在研发时经常会有这样的做法：在角色被攻击时，改变其Material中的属性来得到特定的受击效果。这种做法则会导致引擎为特定的GameObject重新实例化一个Material，后缀会加上（instance）字样。其本身没有特别大的问题，但是当有改变Material属性需求的GameObject越来越多时（比如ARPG、MMORPG、MOBA等游戏类型），其内存中的冗余数量则会大量增长。虽然Material的内存占用不大，但是过多的冗余资源却为Resources.UnloadUnusedAssets API的调用效率增加了相当大的压力。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;上面描述的material的问题是个常见的问题。如果是直接改变还好说，会产生一个material instance，但是如果是在一段时间内线性的改变某个属性，那么后果很难说。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;建议&lt;/p&gt;
    &lt;blockquote&gt;
      &lt;p&gt;一般情况下，资源属性的改变情况都是固定的，并非随机出现。比如，假设GameObject受到攻击时，其Material属性改变随攻击类型的不同而有三种不同的参数设置。那么，对于这种需求，我们建议你直接制作三种不同的Material，在Runtime情况下通过代码直接替换对应GameObject的Material，而非改变其Material的属性。这样，你会发现，成百上千的instance Material在内存中消失了，取而代之的，则是这三个不同的Material资源。其中的益处，对于能够阅读到这里的你来说，应该已经不需要我多说了。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-15&quot;&gt;粒子&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Navmesh是不支持动态加载的目前的，办法是将多个场景做成prefab，然后用LoadLevelAdditive的方式加载，去拼接。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;assetbundle-1&quot;&gt;AssetBundle&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;本周第一篇关于AssetBundle的文章可以说有点陈旧了，在5.3以后解决了一些功能，比如AssetBundle.LoadFromFile加载LZMA文件的失败的问题。&lt;/li&gt;
  &lt;li&gt;还有就是在5.4以后已经没有webstream的概念了。&lt;/li&gt;
  &lt;li&gt;最后开始使用UnityWebRequest&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;lightmapsnapshotassetlightmap&quot;&gt;热更新打包时LightmapSnapshot.asset无法导出，导致场景丢失lightmap&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;LightmapSnapshot.asset是editor模式下的无法打包。解决办法是整个scene打包，lightmap信息会打包进去。或者在运行时调用Lightmapsettings.Lightmaps来设置，但是5.x后lightmap信息不会保存在prefab中，因此需要重设Prefab的Lightmap信息（Lightmapindex和Lightmapscaleoffset）。&lt;/li&gt;
  &lt;li&gt;还有一种可能是因为打包场景的时候shader会根据当前场景的使用情况来打包，如果打包是在一个空场景中那么bundle中的shader会失去lightmap和fog的支持。这个&lt;/li&gt;
  &lt;li&gt;PS: 这个问题在5.5.2中也存在，而且打包的时候是按照场景打包的，但是是不是shader丢失确实需要测试。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;prefab&quot;&gt;prefab打包&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;如果有一个Prefab，它的Dependencies都在Resources文件夹中，那么，当我在AssetBundle打包时，只打包这个Prefab（不指定BuildAssetBundleOptions.CompleteAssets和BuildAssetBundleOptionsCollectDependencies）是不能正确实例化的，因为AssetBundle中的资源和Resource文件夹下资源是不会建立依赖关系的（脚本除外，因为开启BuildAssetBundleOptionsCollectDependencies 时，脚本依然不会打包到AssetBundle中）。所以会出现Mesh、Material等的丢失。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;assetbundle-2&quot;&gt;卸载依赖AssetBundle的问题&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;比如prefabA和prefabB依赖于AtlasC，那么分别打包的话首先肯定是要先加载AtlasC的AssetBundle的。&lt;/li&gt;
  &lt;li&gt;但是如果先从AtlasC的AssetBundle中load了AtlasC，然后unload这个AssetBundle，此后加载或实例化A和B时，引擎将无法自动将C绑定给A和B进行使用。这个需要注意。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-16&quot;&gt;纹理格式&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;目前来讲，并不存在一个所有GPU平台都支持硬件解压的压缩格式。&lt;/li&gt;
  &lt;li&gt;ETC1 和 PVRTC 分别是Android和iOS上我们最推荐的格式。 但对于透明纹理，ETC1不支持，而 PVRTC 则可能有较大失真，因此更推荐使用 RGBA 16。&lt;/li&gt;
  &lt;li&gt;一般来说建议直接使用 Unity 默认的压缩格式（即选择 Compressed 即可，不需要做特殊设置），Unity 会做如下处理：
    &lt;ul&gt;
      &lt;li&gt;Android 上不带Alpha通道的图片采用 ETC1，带Alpha通道的图片采用True Color中的RGB16，TrueColor中的 RGBA16 会&amp;gt;比 RGBA32 更节省空间，但图像的显示质量会差一些；&lt;/li&gt;
      &lt;li&gt;iOS 上使用 PVRTC，但PVRTC格式要求纹理的长宽相等，且都是2的幂次（即POT，在ImportSettings中可以将NPOT的纹理自动转换成POT）。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;同时，我们不建议直接使用 RGBA32 格式的纹理，因为它占用了很大的内存。一般建议使用 RGBA16 和 ETC 格式的纹理来进行加载。 如果转换到 RGBA16 格式时出现了类似“色阶”的颜色问题，则建议尽可能避免大量的过渡色使用。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-17&quot;&gt;工具&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;unity的分析工具中的Reserved Total 和 Used Total为Unity引擎在内存方面的总体分配量和总体使用量。 一般来说，引擎在分配内存时并不是向操作系统 “即拿即用”，而是首先获取一定量的连续内存，然后供自己内部使用，待空余内存不够时，引擎才会向系统再次申请一定量的连续内存进行使用。&lt;/li&gt;
  &lt;li&gt;Overhead：
    &lt;ul&gt;
      &lt;li&gt;Overhead的计算方法是：Profiler当前帧统计的总耗时时间减去所有已知选项的累加时间，即引擎当前还无法识别模块的耗时时间。&lt;/li&gt;
      &lt;li&gt;Overhead数值理论上是趋向于0的，但是由于目前市面上的硬件设备、系统框架过于丰富，所以引擎可能无法识别所有模块的CPU开销。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Unity Profiler反馈的则是引擎的真实物理使用内存，有时内存使用数值比原生的分析工具小是正常的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Profiler中ManagedHeap.UsedSize是项目逻辑代码在运行时申请的堆内存， 
ManagedHeap.UsedSize过大，一方面可能会影响一次GC的耗时；另一方面也可能反映出脚本中不合理的GC Alloc。该选项只能通过优化代码来进行降低。 优化方法一般如下：
    &lt;ul&gt;
      &lt;li&gt;尽可能地复用变量，减少new的次数；&lt;/li&gt;
      &lt;li&gt;使用StringBuilder代替String连接，使用for代替foreach；&lt;/li&gt;
      &lt;li&gt;对于局部变量或非常驻变量，尽可能使用Struct来代替Class。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;本周读到的所有关于内存监控的部分都提到了一个概念就是Profiler所监控到的数据和Android上的PSS或者ios上检测到的会不一致，这                                                   个是因为Unity Profiler反馈的是引擎的真实分配的物理内存，而PSS中记录的则包括系统的部分缓存。一般情况下，Android或iOS并不会及时将所有App卸载数据进行清理，为了保证下次使用时的流畅性，OS会将部分数据放入到缓存，待自身内存不足时，OS Kernel会启动类似LowMemoryKiller的机制来查询缓存甚至杀死一些进程来释放内存。因此，并不能通过一两次的PSS内存没有完全回落来说明内存泄露问题。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Reserved GFX 中的内存，主要是纹理和网格资源。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-18&quot;&gt;渲染&lt;/h2&gt;
&lt;h4 id=&quot;lightmappcandroid&quot;&gt;Lightmap在PC上显示正常，但是转到Android平台上存在色差，颜色普遍偏暗的问题&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Unity烘焙的Lightmap是32bit的HDR图，而移动设备通常不支持HDR图(32bit per channel)，会按照LDR图(8bit per channel)的形式进行处理，因此会出现色偏问题。因此需要如下的处理：
    &lt;ul&gt;
      &lt;li&gt;在移动平台下使用Mobile/Diffuse材质，可载入Standard Assets(Mobile) package获得。&lt;/li&gt;
      &lt;li&gt;如果要获得更合适的效果，需要自行修改Lightmap的DecodeLightmap函数，该函数可在Unity\Editor\Data\CGIncludes\UnityCG.cginc文件中找到。需要说明的是，这种方法也不能达到与PC端完全一致的效果。&lt;/li&gt;
      &lt;li&gt;如果需要PC和移动平台的显示效果一致，可以用图像编辑软体修改Lightmap為LDR格式，例如PNG(8bit per channel)。&lt;/li&gt;
      &lt;li&gt;为了避免类似问题，请不要使用过于强烈的Light进行烘焙，因為Light的强度(Intensity)越高，色偏问题会越严重。若有阴影丢失时，可以尝试检查一下模型的Lightmapindex、Lightmapscaleoffset、UV2等影响Lightmap采样的一些参数。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;另一种可能是存在过曝现象，可以尝试将playersettings -&amp;gt; use direct3d 11关闭，看问题是否解决。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;lightmap&quot;&gt;lightmap动态加载&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Lightmap的动态加载，需要通过脚本将烘焙时每个物件的Lightmapindex和Lightmapscaleoffset记录下，并在运行时动态加载后设置回去的方式来实现。因为目前Lightmapindex和Lightmapscaleoffset信息是和场景绑定在一起，储存在Lightmapsnap.assets 中，发布时也是放在场景信息中，因此不会记录在Prefab 上。&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Mon, 07 Aug 2017 22:17:31 +0800</pubDate>
        <link>https://caihua.tech/2017/08/07/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E4%BA%8C%E5%91%A8/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/08/07/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E4%BA%8C%E5%91%A8/</guid>
        
        <category>UWA</category>
        
        
      </item>
    
      <item>
        <title>Lua学习笔记：高级概念</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;高级概念&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;这部分中会记录一些lua语言中的高级概念和技术。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-1&quot;&gt;模块&lt;/h3&gt;

&lt;h4 id=&quot;section-2&quot;&gt;概念&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;从我的理解看，模块更像是一个类。但是因为lua中没有类的概念，模块的实现是依赖于table。&lt;/li&gt;
  &lt;li&gt;一些公共或者私有的变量+函数组成了模块的主体，最后一个return module完成了基本的构造。其实这个return就是返回了这个table。&lt;/li&gt;
  &lt;li&gt;具体实现看教程&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-3&quot;&gt;使用&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-- 创建一个叫Class的模块
Class = {}

Class.Name = &quot;name&quot;

Class.Grades =
{
  &quot;Grade1&quot;,
  &quot;Grade2&quot;,
  &quot;Grade3&quot;
}

temp = &quot;a&quot;
local temp2 = &quot;b&quot;
Class.temp3 = &quot;c&quot;

function Class.FindGrade(key)
   return Class.Grades[key]
end

return Class
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-- temp = &quot;local temp1&quot;

-- 导入模块
require(&quot;Class&quot;)

-- temp = &quot;local temp1&quot;

print(temp)
print(Class.temp2)
print(Class.temp3)

-- 调用模块函数
print(Class.FindGrade(1))

-- 结果
a
nil
c
Grade1-abc
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;分析一下模块的变量，从例子中可以总结，模块中的以模块名+&lt;code class=&quot;highlighter-rouge&quot;&gt;.&lt;/code&gt;形成的变量（Class.temp3）是全局变量，而且即使在模块内部调用用也要用模块名+&lt;code class=&quot;highlighter-rouge&quot;&gt;.&lt;/code&gt;的形式使用。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;没有加模块名的变量其实也是全局变量，外部代码也可以直接访问。注意代码中在require的前后分别定义了一个和模块中名字相同的变量，这里有一个很有意思的事情，就是如果是之前定义的，那么在print时是模块中的值，如果在之后定义那么就是本地定义的值。这说明require这种过程实际上等于在本地定义了一些变量。所以最终输出的值可以按照后定义的输出。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;显示标记为local的变量是本地变量，在模块内部使用是没有问题的，但是外部代码无法访问。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-4&quot;&gt;加载机制&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;基本上遵循C的加载机制，也就是先找同一目录下的文件，然后会找全局变量中path里面定义的文件。&lt;/li&gt;
  &lt;li&gt;通常我们在编写代码的时候肯定是会有物理的文件夹结构的，此时如果我们不去改package.path的值，那么可以在引用时加速文件夹名字，比如我把class和student放到了Module文件夹下，那么代码中写&lt;code class=&quot;highlighter-rouge&quot;&gt;require(&quot;Module/Class&quot;)&lt;/code&gt;即可正常调用。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-5&quot;&gt;协程&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;首先是真的多线程，并非unity的那种主线程内部的线程。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;require(&quot;MyCoroutine&quot;)
cor1 = MyCoroutine.CreatCor()
print(cor1)
for i = 1,  10 do
	MyCoroutine.RunCor(cor1)
end


cor2 = MyCoroutine.CreatCor()
print(cor2)
for i = 1,  10 do
	MyCoroutine.RunCor(cor2)
end

-- 结果
thread: 0089D628
1
2
3
running
thread: 0089D628
4
5
6
7
8
9
10
thread: 00897D60
1
2
3
running
thread: 00897D60
4
5
6
7
8
9
10

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;用法比较繁琐，但是可以明确的控制协程的执行步骤。有点类似python。&lt;/li&gt;
  &lt;li&gt;建议直接看教程。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;metatable&quot;&gt;元表（MetaTable）&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;metatable更像是lua为table提供的依赖倒置的接口&lt;/strong&gt;，以&lt;code class=&quot;highlighter-rouge&quot;&gt;__index&lt;/code&gt;这个函数为例，本身如果lua提供了固定的函数，那么我们在取值时候只能遵从lua的规定。但是现在提供了一个&lt;code class=&quot;highlighter-rouge&quot;&gt;__index&lt;/code&gt;，你可以自定义这个&lt;code class=&quot;highlighter-rouge&quot;&gt;__index&lt;/code&gt;的行为，而lua在运行期间遇到了需要用到&lt;code class=&quot;highlighter-rouge&quot;&gt;__index&lt;/code&gt;的时候就会按照你所规定的准则行事了。这个思维是很好的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;下面是&lt;code class=&quot;highlighter-rouge&quot;&gt;__index&lt;/code&gt;的用法，metatable。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Lua查找一个表元素时的规则，其实就是如下3个步骤:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;1.在表中查找，如果找到，返回该元素，找不到则继续&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;2.判断该表是否有元表，如果没有元表，返回nil，有元表则继续。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;3.判断元表有没有__index方法，如果__index方法为nil，则返回nil；如果__index方法是一个表，则重复1、2、3；如果__index方法是一个函数，则返回该函数的返回值。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;代码示例：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mt = {}

mt.__index =
function (t,key)
	if key == &quot;key3&quot; then
		return 5
	elseif key == &quot;key4&quot;  then
		return 6
	else
		return 0
	end
	
end

mt.__newindex =
function (t,key,value)
	t.key = value
end

mt.__tostring = function (t)
	local tempTable = {}
	local index = 0
	for i,v in pairs(t) do
		index = index + 1
		tempTable[index] = v
		print(i..&quot;/&quot;..v)
	end
	return '{' .. table.concat(tempTable, ', ') .. '}'
end

-- 一旦定义了__metatable，就代表getmetatable只能得到这个函数的值，
-- 而不能再次赋值,否则会报错“cannot change a protected metatable”
mt.__metatable = &quot;不能看啊不能看&quot;


local t = {1, 2, 3, key1 = 3,key2 = 4}
setmetatable(t, mt)
print(t)

print(getmetatable(t))

print(t[&quot;key4&quot;])


mt2 = {}

-- 下面的代码会报错
--setmetatable(t,mt2)


&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;这个东西有个好处，如果我写的key不存在，那么我是可以自定义它的行为的。我可以返回一个数值，也可以执行一段代码。但是一般来说还是提前预置好数据比较好。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;PS：元表本身是一个table，如果按照table就是类这个概念来看的话，元表对应了类类型，而实际的使用中它也是起了这样的作用。元表中以&lt;code class=&quot;highlighter-rouge&quot;&gt;__&lt;/code&gt;开头的方法们算是它保留的方法，我们可以给一个元表定义这些方法实际是一个什么样的行为。比如&lt;code class=&quot;highlighter-rouge&quot;&gt;__tostring&lt;/code&gt;方法，我们可以在一个元表中重新定义它的实现，有点像C#中override ToString方法。&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-6&quot;&gt;面向对象&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;lua的oop是基于table的，table中可以设置全局或局部的变量、方法等。&lt;/li&gt;
  &lt;li&gt;继承通过子类调用父类的构造函数（其实lua没有构造函数一说，只是我们人为的在代码中创造出来了一个创建对象的函数）来创建，然后在扩展，从而实现了继承。&lt;/li&gt;
  &lt;li&gt;从本质上说，lua的继承和C的继承是一样的，依赖的是table嵌套table，而C中是结构体嵌套结构体。&lt;/li&gt;
  &lt;li&gt;具体看下链接里教程的例子吧。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-7&quot;&gt;一些体会&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;其实只要学过一个脚本语言，lua就不算陌生，还算是上手比较快。&lt;/li&gt;
  &lt;li&gt;所有语言的核心在api的使用，所以熟悉标准库是关键。&lt;/li&gt;
  &lt;li&gt;lua与C/C++的交互也是大头，不过目前暂时不用就先不学了，等后续学了再填坑。&lt;/li&gt;
  &lt;li&gt;多写，多写，多写。&lt;/li&gt;
  &lt;li&gt;一个学习lua编程的方法是看WOW的插件源码。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-8&quot;&gt;调试&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;因为用的是LuaStudio，在调试的过程中也遇到了很多的问题。首先正常的自己写的代码都可以require成功，os\io\math这样的库也都没有问题，但是用到socket库的时候怎么都无法require。最后发现在LuaStudio中必须这样设置才行&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://imglf1.nosdn.127.net/img/Nld0N0tacnNuUG45bFJFdFZwNEVuU216QnRPaEtaaHcwTFU3MW1PS2tuUWl2cWkwZE1EWC9RPT0.png?imageView&amp;amp;thumbnail=500x0&amp;amp;quality=96&amp;amp;stripmeta=0&amp;amp;type=jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-9&quot;&gt;参考&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/booirror/article/details/7881820&quot;&gt;table参考&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.runoob.com/lua/lua-tutorial.html&quot;&gt;lua教程&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/klkucan/LuaStudy&quot;&gt;我在学习中写的所有代码&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.jb51.net/list/list_245_3.htm&quot;&gt;脚本之家-lua&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Mon, 07 Aug 2017 22:10:24 +0800</pubDate>
        <link>https://caihua.tech/2017/08/07/Lua%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%AB%98%E7%BA%A7%E6%A6%82%E5%BF%B5/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/08/07/Lua%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%AB%98%E7%BA%A7%E6%A6%82%E5%BF%B5/</guid>
        
        <category>Lua</category>
        
        
      </item>
    
      <item>
        <title>每天一点UWA：第一周</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;初衷&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;首先&lt;a href=&quot;https://www.uwa4d.com&quot;&gt;UWA&lt;/a&gt;一直以来都是一个我很喜欢的网站，因为他们在unity的优化方面是非常专业的，而且他们对于技术的分享也是毫不吝啬的。在他们的网站上有很多的技术文章，很久以来都想系统的阅读一遍，但是一直没有去做。这周开始下定决心要从第一篇开始，把UWA所有的技术分享文章读完，这个系列的文章会对每周读到的技术做一个总结，但是因为文章涉及的方向比较杂，因此会简单的用技术进行一个分类。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;cpu&quot;&gt;CPU方面的优化（很有用）&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;就目前的Unity移动游戏而言，CPU方面的性能开销主要可归结为两大类：引擎模块性能开销和自身代码性能开销。其中，引擎模块中又可细致划分为渲染模块、动画模块、物理模块、UI模块、粒子系统、加载模块和GC调用等等。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-1&quot;&gt;渲染模块&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;减少draw call。减少dc的核心办法在unity里面就是减少材质球。因为如果多个物体共用一个材质球（共同的贴图和shader）那么对于一次draw call来说就是传递顶点数多少的问题。&lt;/li&gt;
  &lt;li&gt;顶点数的多少引出了另一个问题，传输渲染数据的总线带宽。当大量GameObject满足批处理条件时（900个数据值），unity会合并mesh，但是一个超大的mesh数据传输起来也有瓶颈。因此关于draw call的优化不能是无脑的，需要平衡dc次数和总线带宽。&lt;/li&gt;
  &lt;li&gt;简化资源&lt;/li&gt;
  &lt;li&gt;渲染模块在CPU方面的优化方法还有很多，比如LOD、Occlusion Culling和Culling Distance等等&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;ui&quot;&gt;UI模块&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;文中以NGUI为例进行了函数的分析，但是UGUI应该也有借鉴的意义。&lt;/li&gt;
  &lt;li&gt;在NGUI的优化方面，UIPanel.LateUpdate为性能优化的重中之重，它是NGUI中CPU开销最大的函数，没有之一。对于UIPanel.LateUpdate的优化，主要着眼于UIPanel的布局，其原则如下：
    &lt;ul&gt;
      &lt;li&gt;尽可能将动态UI元素和静态UI元素分离到不同的UIPanel中（UI的重建以UIPanel为单位），从而尽可能将因为变动的UI元素引起的重构控制在较小的范围内；&lt;/li&gt;
      &lt;li&gt;尽可能让动态UI元素按照同步性进行划分，即运动频率不同的UI元素尽可能分离放在不同的UIPanel中；&lt;/li&gt;
      &lt;li&gt;控制同一个UIPanel中动态UI元素的数量，数量越多，所创建的Mesh越大，从而使得重构的开销显著增加。比如，战斗过程中的HUD运动血条可能会出现较多，此时，建议研发团队将运动血条分离成不同的UIPanel，每组UIPanel下5~10个动态UI为宜。这种做法，其本质是从概率上尽可能降低单帧中UIPanel的重建开销。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;PS：结合之前关于UI优化的文章，UI优化的核心在于拆分UI元素。始终不变的归为一类，动态变化的归为一类。对于UGUI来说就是拆分Canvas。&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;PS2：关于UI重建的说明。UI其实是一些3D的quad，这一下就能够理解为什么存在UI的减少drawcall了，这个和模型的减dc完全一个原理。多个UI在一个Canvas下就存在多个UI的mesh合并问题（批处理），但是像血条这样的UI一般用的是progress，它的原理就是默认模式下改变quad的顶点数据来实现进度大小的改变，fxxx模式下是顶点和UV一起变，只要改变了顶点位置，那么mesh必要每次dc的时候都要重新计算。和它一起的那些不变的UI的计算是浪费的。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-2&quot;&gt;加载模块&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;目前加载模块性能开销主要在场景切换，分为前一场景的场景卸载和下一场景的场景加载。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;场景卸载：主要是Destroy和Resources.UnloadUnusedAssets两个函数，前者的消耗多少主要取决于事件函数中代码的功能多少。后者耗时开销主要取决于场景中Asset和Object的数量，数量越多，则耗时越慢。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;场景加载：主要是资源加载和Instantiate实例化。
    &lt;ul&gt;
      &lt;li&gt;资源加载几乎占据了整个加载过程的90%时间以上，其加载效率主要取决于资源的加载方式（Resource.Load或AssetBundle加载）、加载量（纹理、网格、材质等资源数据的大小）和资源格式（纹理格式、音频格式等）等等。不同的加载方式、不同的资源格式，其加载效率可谓千差万别。&lt;/li&gt;
      &lt;li&gt;在场景加载过程中，往往伴随着大量的Instantiate实例化操作，比如UI界面实例化、角色/怪物实例化、场景建筑实例化等等。在Instantiate实例化时，引擎底层会查看其相关的资源是否已经被加载，如果没有，则会先加载其相关资源，再进行实例化，这其实是大家遇到的大多数“Instantiate耗时问题”的根本原因，这也是为什么我们在之前的AssetBundle文章中所提倡的资源依赖关系打包并进行预加载，从而来缓解Instantiate实例化时的压力。&lt;/li&gt;
      &lt;li&gt;另一方面，Instantiate实例化的性能开销还体现在脚本代码的序列化上，如果脚本中需要序列化的信息很多，则Instantiate实例化时的时间亦会很长。最直接的例子就是NGUI，其代码中存在很多SerializedField标识，从而在实例化时带来了较多的代码序列化开销。因此，在大家为代码增加序列化信息时，这一点是需要大家时刻关注的。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;以上是游戏项目中性能开销最大的三个模块，当然，游戏类型的不同、设计的不同，其他模块仍然会有较大的CPU占用。比如，ARPG游戏中的动画系统和物理系统，音乐休闲类游戏中的音频系统和粒子系统等。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;PS：关于场景加载在之前的文章中也有讲到，尤其是AssetBundle系列文章中。根据unity对资源的管理方式，Resources文件夹里面的asset会全部加载到PersistentManager，当然这个过程只是建立InstanceID的过程，但是仍旧消耗了时间。&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;代码效率&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;一图胜千言
&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2Foptimzation_cpu%2FDoc1_09.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;assetbundle&quot;&gt;AssetBundle&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;4.x的内容就不考虑写出来了。&lt;/li&gt;
  &lt;li&gt;AssetBundle5.x怎么制作我在之前的一个blog中写过,可以说5.x极大的简化了AssetBundle的打包流程。&lt;/li&gt;
  &lt;li&gt;不考虑5.3前的情况，之后的版本建议使用LZ4打包，因为是按需解压加载的。&lt;/li&gt;
  &lt;li&gt;新增的AppendHashToAssetBundleName选项很不错，可以在生成AssetBundle时加入hash值，便于判定是否有更新，AssetBundleBrowser中支持。&lt;/li&gt;
  &lt;li&gt;几个注意的点：
    &lt;ul&gt;
      &lt;li&gt;新机制打包无法指定Assetbundle.mainAsset，因此无法再通过mainAsset来直接获取资源。&lt;/li&gt;
      &lt;li&gt;开启DisableWriteTypeTree可能造成AssetBundle对Unity版本的兼容问题，但会使Bundle更小，同时也会略微提高加载速度。&lt;/li&gt;
      &lt;li&gt;abName可通过脚本进行设置和清除，也可以通过构造一个AssetBundleBuild数组来打包。&lt;/li&gt;
      &lt;li&gt;Prefab之间不会建立依赖，即如果Prefab-A和Prefab-B引用了同一张纹理，而他们设置了不同的abName，而共享的纹理并未设置abName，那么Prefab-A和Prefab-B可视为分别打包，各自Bundle中都包含共享的纹理。因此在使用UGUI，开启Sprite Packer时，由于Atlas无法标记abName，在设置UI界面Prefab的abName时就需要注意这个问题。&lt;/li&gt;
      &lt;li&gt;5.x中加入了Shader stripping功能,在打包时，默认情况下会根据当前场景的Lightmap及Fog设置对资源中的Shader进行代码剥离。这意味着，如果在一个空场景下进行打包，则Bundle中的Shader会失去对Lightmap和Fog的支持，从而出现运行时Lightmap和Fog丢失的情况.而通过将Edit-&amp;gt;Project Settings-&amp;gt;Graphics下shader Stripping中的modes改为Manual，并勾选相应的mode即可避免这一问题。&lt;/li&gt;
      &lt;li&gt;Shader被打包到不同AssetBundle中了，WarmupAllShaders仅能对当前内存中的Shader进行warm up。后续如果又有Shader加载进来，则仍然会出现CreateGPUProgram操作。&lt;/li&gt;
      &lt;li&gt;PS:这一条在2017中发现custom选项中是全选的。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-4&quot;&gt;纹理&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;对于图片如果可以的话，建议直接将其制作成POT（ power of two，即图片的size是2次幂，这个也是unity建议的）图片，而非进行二次转换。ToLarger确实可以将纹理拉伸成POT纹理，但如果是UI界面（开启Pixel Perfect）的话，可能显示时会有较大视觉损失。&lt;/li&gt;
  &lt;li&gt;Texture占用内存总是双倍：出现这种情况的原因有两种：一种是在真机运行时开启了Read&amp;amp;Write。另一种可能是Unity的Bug，目前的Unity 5.2.3 release note如下 ：
(735644) - OpenGL: Fixed texture memory usage reporting in profiler, was twice the actual size for most textures.&lt;/li&gt;
  &lt;li&gt;纹理Atlas是合成一张2048（尺寸）的纹理还是四张1024的纹理在其他设置一致的情况下，这两种方式无论在加载还是渲染方面其实并没有实质上的差别。在我们接触到的大多数案例中，纹理资源方面的问题除了尺寸外，&lt;strong&gt;纹理格式、Mipmap设置和Read&amp;amp;Write功能&lt;/strong&gt;同样是需要研发团队时刻关注的。&lt;/li&gt;
  &lt;li&gt;PS:看来纹理的Read&amp;amp;Write选项很重要&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;unity&quot;&gt;unity的工具&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Overhead：
    &lt;ul&gt;
      &lt;li&gt;Overhead的计算方法是：Profiler当前帧统计的总耗时时间减去所有已知选项的累加时间，即引擎当前还无法识别模块的耗时时间。&lt;/li&gt;
      &lt;li&gt;Overhead数值理论上是趋向于0的，但是由于目前市面上的硬件设备、系统框架过于丰富，所以引擎可能无法识别所有模块的CPU开销。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;unity的分析工具中的Reserved Total 和 Used Total为Unity引擎在内存方面的总体分配量和总体使用量。 一般来说，引擎在分配内存时并不是向操作系统 “即拿即用”，而是首先获取一定量的连续内存，然后供自己内部使用，待空余内存不够时，引擎才会向系统再次申请一定量的连续内存进行使用。&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sat, 29 Jul 2017 23:18:54 +0800</pubDate>
        <link>https://caihua.tech/2017/07/29/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E4%B8%80%E5%91%A8/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/07/29/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E4%B8%80%E5%91%A8/</guid>
        
        <category>UWA</category>
        
        
      </item>
    
      <item>
        <title>Lua学习笔记：基本语法</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;初步印象&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;语法和python、js这些很像，解释型语言、弱类型等等。写着舒服是真的。&lt;/li&gt;
  &lt;li&gt;while do\repeat until这样的语法其实真心不舒服，感觉在语法上有些累赘。大多数语言都是do while，但是它非要是repeat until，也是无语。&lt;/li&gt;
  &lt;li&gt;我个人认为语法中的then和do设计的很混淆。比如if是和then，for是和do。从我对语言的理解上感觉可以统一用do或者then。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;基本语法&lt;/h2&gt;

&lt;h3 id=&quot;section-2&quot;&gt;变量&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;只有布尔、字符串、数字、table和nil。但是没有一个明确的类型定义，完全按照赋值来进行推断。&lt;/li&gt;
  &lt;li&gt;默认是public，如果想private需要变量前加local。&lt;/li&gt;
  &lt;li&gt;可以一次性多复制，如果变量和值不对称，没有复制的变量为nil。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a,b,c = 1,2
print(a)
print(b)
print(c)

--结果

1
2
nil

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h4 id=&quot;section-3&quot;&gt;作用域&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;在lua中一个local变量的作用域可以是在一个循环中或者在一段if代码中。也可以是贯穿整个的table中（感觉table在某种角度完全可以看做是一个类）。但是如果你想控制一个local变量的值作用域某个区间，那么可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;do  end&lt;/code&gt;来明确划分一个block。下面这个例子的结果是nil，因为x在作用域只在&lt;code class=&quot;highlighter-rouge&quot;&gt;do end&lt;/code&gt;之间。但是这个不适用于全局变量，需要注意。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;do
	local x = 10
end
print(x)

-- 结果

nil
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;对比一下下面两段代码的不同结果。其实尽可能的不要出现变量同名的情况，尤其是第二段代码的行为可能不是我们想要的。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;x = 1
do
	local x = 10
	print(x)
end
print(x)

-- 结果
10
1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;x = 1

local x = 10
print(x)

print(x)

-- 结果
1
1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;关于&lt;code class=&quot;highlighter-rouge&quot;&gt;do  end&lt;/code&gt;还有个用法，在lua中return和break需要在end\else\until之前（发现在print之前也可以），否则编译会出错。此时就需要&lt;code class=&quot;highlighter-rouge&quot;&gt;do  end&lt;/code&gt;来包住return了。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function boo()
	local x = 10
	do
		return
	end
	local i = 10
	print(1)
end
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-4&quot;&gt;循环&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;for\while do\repeat until，最后一个对象do while。&lt;/li&gt;
  &lt;li&gt;for分为数值型和泛型：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-- var从exp1变化到exp2，每次变化以exp3为步长递增var，并执行一次&quot;执行体&quot;。exp3是可选的，如果不指定，默认为1。
for var=exp1,exp2,exp3 do  
    &amp;lt;执行体&amp;gt;  
end  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for i,v in ipairs(a) 
	do print(v) 
end  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;for的循环中没有continue，这样导致了在for中可能出现if嵌套if的情况，因为没办法通过拆解if来实现简练的代码。不爽！！另外lua的&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-5&quot;&gt;迭代&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;需要注意pairs 和 ipairs异同
同：都是能遍历集合（表、数组）
异：ipairs 仅仅遍历值，按照索引升序遍历，索引中断停止遍历。即不能返回 nil,只能返回数字 0，如果遇到 nil 则退出。它只能遍历到集合中出现的第一个不是整数的 key。
pairs 能遍历集合的所有元素。即 pairs 可以遍历集合中所有的 key，并且除了迭代器本身以及遍历表本身还可以返回 nil。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Demo1：
local tabFiles = {
        [1] = &quot;test2&quot;,
        [6] = &quot;test3&quot;,
        [4] = &quot;test1&quot;
    }

for k, v in ipairs(tabFiles) do    --输出&quot;test2&quot;,在key等于2处断开
    print(k, v)
end

Demo2：
local tabFiles = {
    [2] = &quot;test2&quot;,
    [6] = &quot;test3&quot;,
    [4] = &quot;test1&quot;
}

for k, v in ipairs(tabFiles) do  --[[什么都没输出，为什么？因为控制变量初始值是按升序来遍历的，当key为1时，value为nil，此时便停止了遍历， 所有什么结果都没输出]]--
    print(k, v)
end

Demo3：
local tabFiles = {
    [2] = &quot;test2&quot;,
    [6] = &quot;test3&quot;,
    [4] = &quot;test1&quot;
}

for k, v in pairs(tabFiles) do  --输出2 test2, 6 test3, 4 test1
    print(k, v)
end

Demo4：
local tabFiles = {&quot;alpha&quot;, &quot;beta&quot;, [3] = &quot;no&quot;, [&quot;two&quot;] = &quot;yes&quot;}  for i,v in ipairs(tabFiles ) do    --输出前三个   备注：因为第四个key不是整数
    print( tabFiles [i] )   
end   
  
for i,v in pairs(tabFiles ) do    --全部输出   
    print( tabFiles [i] )   
end 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;table&quot;&gt;table&lt;/h3&gt;

&lt;h4 id=&quot;section-6&quot;&gt;概念&lt;/h4&gt;
&lt;blockquote&gt;
  &lt;p&gt;table 是 Lua 的一种数据结构用来帮助我们创建不同的数据类型，如：数字、字典等。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Lua table 使用关联型数组，你可以用任意类型的值来作数组的索引，但这个值不能是 nil。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Lua table 是不固定大小的，你可以根据自己需要进行扩容。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;上面是runoob.com的lua教程中对table的描述。在我看来很难去描述table是个什么东西，但是我们可以通过对它的使用来总结它所扮演的一些角色，或者说什么场景下table能够作为什么来使用。&lt;/li&gt;
  &lt;li&gt;看下第二条，table中索引可以是任何类型的值，&lt;strong&gt;所以索引是个table也是可以的&lt;/strong&gt;。但是必须不是nil，所以&lt;code class=&quot;highlighter-rouge&quot;&gt;look = {[www] = &quot;ok&quot;} 这样是不对的，www没有赋值，所以默认为nil因此出错table index is nil&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-7&quot;&gt;常见用法&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;数组&lt;/strong&gt; ： table一个典型的用法就是作为其它语言中的数组&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;str = { 1,2,3}
print(str[2])
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;字典&lt;/strong&gt; ： 也是常见的用法&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;str = {name=&quot;Sai&quot;,age=33}
print(str[&quot;age&quot;])
print(str.name)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;table-1&quot;&gt;table使用中容易出现的问题&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;看下这段代码&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;temp = 1
tab = {[temp] = 1, 11}
print(tab[1])
for i,v in pairs(tab) do
	print(i,v)
end

-- 输出的结果是 ： 

11
1	11
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;why?第一个print中为何结果不是1，因为tab[]这个用法的参数是key，而像11这样没有显示定义key的value默认的key就是1，所以这句话认为是输出key=1的value了。而且从遍历看居然只有一个数据，也就是说value 1的数据被替换掉了。&lt;/li&gt;
  &lt;li&gt;那么怎么让这个1显示出来呢？以我目前掌握的只能是改temp的值。&lt;/li&gt;
  &lt;li&gt;总结一下就是注意三点：&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;第一，所有元素之间，总是用逗号 “，” 隔开；&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;第二，所有索引值都需要用 “[“和”]”括起来；如果是字符串，还可以去掉引号和中括号； 即如果没有[]括起，则认为是字符串索引&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;第三，如果不写索引，则索引就会被认为是数字，并按顺序自动从 1往后编；&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;数组（lua叫table）下标从1开始，有点不习惯。&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;判断table是否是空&lt;a href=&quot;http://www.jb51.net/article/64378.htm&quot;&gt;（参考）&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a={2}
if next(a) ~= nil then
	print(next(a))
end
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-8&quot;&gt;字符串&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;..&lt;/code&gt;是字符串相加，my god…&lt;/li&gt;
  &lt;li&gt;对于string的处理，除了用string.xxx(strArg)这样的方式外，还可以用strArg:xxx的方法。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-9&quot;&gt;函数&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;function可以返回也可以不返回结果，在定义时没有明确的约束。&lt;/li&gt;
  &lt;li&gt;支持多返回值，nice&lt;/li&gt;
  &lt;li&gt;Lua函数不支持参数默认值，可以通过or来实现。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function sum(a , b)
    a = a or 1.1
    b = b or 2.2
    return a + b
end
 
print(sum())
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;支持闭包&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;tab = {1,2,3,4,5,6,7,8}
 
function iter()
    local index = 0
    return function()
        index = index + 1 
        return tab[index]
    end
end
 
for i in iter() do
   print(i)
end
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;可变参数，这里有点小特别：
    &lt;blockquote&gt;
      &lt;p&gt;Lua将函数的参数放在一个叫arg的表中，#arg 表示传入参数的个数。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function average(...)
   result = 0
   local arg={...}
   for i,v in ipairs(arg) do
      result = result + v
   end
   print(&quot;总共传入 &quot; .. #arg .. &quot; 个数&quot;)
   return result/#arg
end

print(&quot;平均值为&quot;,average(10,5,3,4,5,6))
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这个#还能来取table中元素的个数，但是使用限制比较大。建议还是开启循环来计算个数。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;.&lt;/code&gt;的区别:&lt;/p&gt;

    &lt;p&gt;是个语法糖，调用的函数会自动传递参数self，即：&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;local a = {x = 0}
function a.foo(self, a)
    self.x = a
end
function a:foo2(a)
    self.x = a
end


--调用时：
a.foo(a, 2)
a.foo2(2)

--上述两个操作是等价的，用:时就省去了定义和调用时需要额外添加self用来指代自身的麻烦.

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;需要注意的是如果一个table中的方法调local的非table方法（简单来说就是一个类方法要访问非类方法）需要将非类的方法定义在前面，这个和C的机制一样。同样的，非类方法之间的调用也要有顺序，都尼玛血泪的教训&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;api&quot;&gt;API&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;标准库的API可以在&lt;a href=&quot;https://www.lua.org/manual/5.1/&quot;&gt;这里&lt;/a&gt;查询到。&lt;/li&gt;
  &lt;li&gt;math.random的行为很是奇怪，一次调用永远产生相同的值。如果想得到不同的值，需要多次调用。&lt;/li&gt;
  &lt;li&gt;对于table等的操作建议看参考2的连接。&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sat, 29 Jul 2017 23:15:54 +0800</pubDate>
        <link>https://caihua.tech/2017/07/29/Lua%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/07/29/Lua%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</guid>
        
        <category>Lua</category>
        
        
      </item>
    
      <item>
        <title>Unity返回Value的协程</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;起因&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;其实一直以来就有个想法，希望能让unity中的coroutine返回一个具体的数值，比如int，比如string或者一个GameObject。最近也查了些资料，然后总结一下这个功能如何实现。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-1&quot;&gt;回调函数实现&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;这个算是一个取巧的办法，在调用协程时传递一个回调函数，在执行过程中根据情况调用回调即可。不废话，直接上代码：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; IEnumerator CoroutineWithCallback(Action&amp;lt;string&amp;gt; callback)
{
    WWW www = new WWW(&quot;https://caihua.tech&quot;);
    yield return www;
    if (string.IsNullOrEmpty(www.error))
    {
        callback(www.text);
    }
    else
    {
        callback(&quot;www fail&quot;);
    }
}

// 调用方式

IEnumerator Start()
{
    yield return StartCoroutine(CoroutineWithCallback(s =&amp;gt;
    {
        Debug.Log(s);
    }));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-2&quot;&gt;利于协程的原理来制作一个可以返回数值的包装器&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;协程本身就是利用IEnumerator的可遍历来实现的，在运行期间如果约到yield语句就会等后面的代码执行完成后返回结果。如果在代码块的后面还有yield就会继续执行。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 包装器
public class CoroutineWithData
{
    public Coroutine coroutine { get; private set; }
    public object result;
    private IEnumerator target;
    public CoroutineWithData(MonoBehaviour owner, IEnumerator target)
    {
        this.target = target;
        this.coroutine = owner.StartCoroutine(Run());
    }

    private IEnumerator Run()
    {
        while (target.MoveNext())
        {
            result = target.Current;
            yield return result;
        }
    }
}


// 真正执行逻辑的代码
IEnumerator LoadSomeStuff()
{
    WWW www = new WWW(&quot;https://caihua.tech&quot;);
    yield return www;
    if (string.IsNullOrEmpty(www.error))
    {
        yield return www.text;
    }
    else
    {
        yield return &quot;fail&quot;;
    }
}

// 使用
...
CoroutineWithData cd = new CoroutineWithData(this, LoadSomeStuff());
yield return cd.coroutine;
Debug.Log(&quot;result is &quot; + cd.result);
...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Sun, 23 Jul 2017 23:31:11 +0800</pubDate>
        <link>https://caihua.tech/2017/07/23/Unity%E8%BF%94%E5%9B%9EValue%E7%9A%84%E5%8D%8F%E7%A8%8B/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/07/23/Unity%E8%BF%94%E5%9B%9EValue%E7%9A%84%E5%8D%8F%E7%A8%8B/</guid>
        
        <category>Unity3D</category>
        
        
      </item>
    
      <item>
        <title>AssetBundle学习笔记：Resources文件夹</title>
        <description>&lt;h2 id=&quot;resources&quot;&gt;Resources文件夹&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;这个章节内容不多，但是也很有用。我们可以从这个章节中学习如何更合理的使用它。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;resources-1&quot;&gt;Resources系统的最佳实践&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;不要使用它&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;是的，不要使用它。因为它有以下问题：
    &lt;ul&gt;
      &lt;li&gt;使用 Resources 文件夹会让内存颗粒度管理变得更困难&lt;/li&gt;
      &lt;li&gt;不正确的使用 Resources 文件夹会增加应用启动时间（因为要创建上一章讲的映射图）和包的大小，随着在 Resources 文件中的文件增加，管理这些文件会变得很困难。&lt;/li&gt;
      &lt;li&gt;Resources系统降低了项目自定义分发内容到具体平台的能力，消除了增量更新的可能。AssetBundle 变体是 Unity 用来在不同设备上调整内容的基础。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section&quot;&gt;正确的使用资源文件夹&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;下面两种情况 Resources 系统很有用处：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;1.因为 Resources 系统很容易使用，它很适合是在快速原型制作和试验。但是当项目要转成产品时，强烈建议不要使用 Resources 文件夹.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;2.Resources 文件夹对一些满足如下条件的案例很有用：&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;存储在 Resources 文件夹下的内容不要很大的内存&lt;/li&gt;
    &lt;li&gt;存储在 Resources 文件夹下的内容在整个项目周期都有用&lt;/li&gt;
    &lt;li&gt;内容基本不用升级&lt;/li&gt;
    &lt;li&gt;在各平台都一样的&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-1&quot;&gt;序列化资源&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;一个工程中可能包含了多个名叫Resources的文件夹，所有这些文件夹下的对象和资材会在build的时候全部序列化到一个文件中，这个文件可以理解为一个特殊的AssetBundle。想来这就是为何不利于增量更新的原因了。
    &lt;blockquote&gt;
      &lt;p&gt;AssetBundle包中索引信息里面包括了处理对象名字到对应的文件 GUID 和本地ID 的查找树。它也用来定位对象在序列化文件中的偏移位置。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;用于查找的数据结构是平衡搜索树[1]（在大多数平台上），它的构建时间增长到了 O(nLog(N)), 其中 N 是在查找树内的对象的个数。这个增长也使 Resources 文件夹内的对象增加时，索引的加载时间会比线性增长时间长。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;说了这么多就是告诉大家，应用启动时初始化resources文件夹（按照上一章说的应该是建立实例ID的映射图）这个事是不可避免的，当resources文件夹中内容太多时会严重影响启动速度。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 23 Jul 2017 23:28:45 +0800</pubDate>
        <link>https://caihua.tech/2017/07/23/AssetBundle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Resources%E6%96%87%E4%BB%B6%E5%A4%B9/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/07/23/AssetBundle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Resources%E6%96%87%E4%BB%B6%E5%A4%B9/</guid>
        
        <category>AssetBundle学习笔记</category>
        
        
      </item>
    
      <item>
        <title>AssetBundle学习笔记：资产、对象和序列化</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;前言&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;这篇及后续的几篇笔记是我阅读&lt;a href=&quot;https://unity3d.com/cn/learn/tutoriazals/topics/best-practices/guide-assetbundles-and-resources&quot;&gt;A guide to AssetBundles and Resources&lt;/a&gt;的一些记录。官方的这个系列文章详细的阐述了unity是管理资源的。从一个asset的导入开始，unity就在背后开始了它的工作。它为每个资源创造了一个mate文件，给予了资源一个唯一的ID，从此这个资源的一切都与这个ID紧密结合到了一起。可能我们的一些操作会导致资源丢失它的mate文件，这会造成一些很不好的后果。&lt;/li&gt;
  &lt;li&gt;与此同时，系列文章中还重点阐述了什么是AssetBundle，如何下载AssetBundle和如何从AssetBundle中加载asset。&lt;/li&gt;
  &lt;li&gt;最关键的是最后一章，在这一章中详细的描写了AssetBundle的制作策略。AssetBundle可以说是unity中至关重要的一个概念，但是在日常的工作中按照怎么样的颗粒度来划分AssetBundle，如何平衡AssetBundle的精细度和方便性，这一直以来是一个让人头痛的问题，第四章中给出了一些答案。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;资产、对象和序列化&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;这是系列文章的第一部分（前面还有一个类似介绍的章节），讲述了unity如何处理导入的资源，如何去标识它们，管理它们。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-2&quot;&gt;资产的导入&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;首先asset这个词如果只是看翻译的话可以是&lt;strong&gt;资产&lt;/strong&gt;，其实在我看来它可以是资源，和resource这个词的含义几乎一样。但是因为Resource这个词在unity中有着特殊的含义，它代表了一个特别的文件夹，所以可能需要用一个别的词语来表示资源的概念。&lt;/li&gt;
  &lt;li&gt;asset可以是一个脚本、一个音频文件或者是一个美术从3D建模工具中导出的FBX文件，它保存在unity工程的Assets文件夹下，它的格式可能unity能够直接使用的(比如一个material)，也可能是不能直接使用的（比如FBX）。&lt;/li&gt;
  &lt;li&gt;每一个asset在导入到unity时都会进行一项工作，就是将asset序列化，因为只有只有unity引擎才能够使用它们。在这个导入的过程中可能会对纹理等进行压缩，所以这个过程会比较久。&lt;/li&gt;
  &lt;li&gt;这些被序列化后的数据保存在工程的Library文件夹下，我们不需要修改这些数据，因为这个是unity自动做的，每次你导入新的数据的时候都会生成这些文件。而且如果你留意的话，会发现你切换unity的目标平台时（Android→ios）会重现生成一次序列化文件，因为每个平台能够识别的数据类型不同。同一个纹理文件可能对于了不同的序列化文件。（没事不要删除Library文件夹，因为这个序列化过程非常耗时。）&lt;/li&gt;
  &lt;li&gt;通常我们在unity的IDE中看到的asset文件都是原始的文件，因为导入的过程中虽然做了序列化，但是其实是生成了新的文件，而原始的文件并没有被修改。&lt;a href=&quot;https://docs.unity3d.com/Manual/BehindtheScenes.html&quot;&gt;（给出一个参考文档）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-3&quot;&gt;资产导入的结果是什么&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;答案是序列化文件，那么我们通过什么使用这些序列化文件呢？答案是 UnityEngine.Object,或者是大写O的Object。&lt;/li&gt;
  &lt;li&gt;Object是一套序列化数据用来描述一个具体的资源实例。它（object）的类型可以是任何引擎使用的类型，比如一个mesh、一个音频片段等。基本上所有的内置对象类型都是UnityEngine.Object的子类型，除了ScriptableObject和MonoScript。&lt;/li&gt;
  &lt;li&gt;需要注意的是，一个外部文件的导入可能产生了多个asset，比如FBX文件的导入，可能产了mesh、material和texture。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;scriptableobjectmonoscript&quot;&gt;什么是ScriptableObject和MonoScript&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;ScriptableObject在我看来是一种内置的数据存储格式&lt;/li&gt;
  &lt;li&gt;MonoScript代表了工程中的一个脚本文件，它是个editor类。用法&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#if UNITY_EDITOR

                mediatorClass = RTEditorGUI.ObjectField&amp;lt;MonoScript&amp;gt;(mediatorClass, true);
                if (mediatorClass != null)
                {
                    mediatorName = mediatorClass.GetClass().Name;
                }
#endif

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;unityasset&quot;&gt;unity如何区分这些导入的asset&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;这是一个核心的问题。unity在生成（以FBX文件导入为例，可能一个FBX生成了unity中的多个asset）一个asset时，会同时生成一个mate文件。这个asset会分配一个File GUID，而这个asset中的多个UnityEngine.Object会生成多个Local ID。这个理解起来比较容易，一个asset就是一栋房子，有一个唯一的门牌号。而一栋房子的每个房间又有一个唯一的房间号。&lt;/li&gt;
  &lt;li&gt;unity editor将这个File GUID与asset的路径关联了起来。这样一来，如果你移动了asset的位置，unity会更新这个File GUID对应的路径，这也是为何unity建议我们移动或者重命名或者删除文件已经要在IDE中做，因为unity会监控文件的变化。如果你在外面改了文件名字或者路径，回到unity后会发现unity会给这个asset重新生成一个mate文件，显然这样会分配一个新的GUID。&lt;/li&gt;
  &lt;li&gt;后果是什么？如果你的这个asset中的内容已经被使用，那么会出现丢失的情况。总的来说，unity就是靠File GUID和Local ID来管理资源，一切变化它都会关注，而且也会帮我们处理好。但是外在的变化它无从得知，所以只能出现错误。有趣的一点是，如果你只是删除了mate文件，但是不改变asset的位置，那么unity在重新生成mate时会给asset一个原来的GUID。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;unity&quot;&gt;unity是如何在运行时管理资源的&lt;/h3&gt;

&lt;h4 id=&quot;persistentmanager&quot;&gt;PersistentManager缓存的概念&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;由于GUID在运行时比较的时候效率较低，所以unity使用了一套其它的机制来管理运行时的资源。这就是PersistentManager缓存。unity将File GUID和Local ID翻译（个人认为应该是经过某种变换）成一个叫做Instance ID的整型数据，它在单独的会话（single session，难以理解）中是唯一的。我个人的理解是在一个进程中这个Instance ID是唯一的。&lt;/li&gt;
  &lt;li&gt;缓存维护了一个InstanceID和内存中实例对象的映射图。UnityEngine.Objects通过这个做到了强引用。通过Instance ID可以快速的找到内存中的对象。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;persistentmanager-1&quot;&gt;PersistentManager缓存的初始化和更新&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;这个映射图在游戏启动的时候就会初始化。数据包含：游戏启动时初始场景中用到的对象的映射，Resources文件中所有的对象信息都会被映射到缓存中（这个缓存建立是需要时间的，所以如果Resources文件中内容太多启动会变慢）。&lt;/li&gt;
  &lt;li&gt;在游戏运行的过程中这个缓存也会进行更新。比如在运行时新的asset被导入了（不能理解这是一个什么场景），或者一些对象从AssetBundle中加载的时候，会生成新的Instance ID，新的对象，也就有了新的映射。&lt;/li&gt;
  &lt;li&gt;还有当AssetBundle被卸载的时候（这个卸载应该指的是所有已经实例化对象也被卸载），对应的映射数据会被删除。而当对象重新从AssetBundle中加载时，会产生一个新的Instance ID。这个也是后面会说到的AssetBundle管理的一个重要内容，如何保证无效的资源在卸载时也被删除掉。&lt;/li&gt;
  &lt;li&gt;需要注意一点就是有时一些特别的事件会导致内存中的对象被删除了，比如ios的挂起，此时unity是没有办法重新加载这些数据的（比如材质数据），此时场景中看到的就是品红色的对象了。所以如果手机上出现这个问题了，就要考虑是不是内存中对象被删除了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;resource&quot;&gt;Resource的生命周期&lt;/h3&gt;

&lt;h4 id=&quot;section-4&quot;&gt;加载&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;按照文中的说法有两种方式来加载UnityEngine.Objects，第一是被自动加载，这个需要一个实例ID映射到这个对象，同时这个对象没有加载进内存并被间接引用，而且对象的数据源存在。我对这个的理解是参考初始场景中的对象，前文说过它们会进入缓存中，而且在一开始肯定是内存中不存在的，而且如果这个实例ID对应的FILE ID和local ID是有效的，那么就会被自动的加载；至于说间接引用，讲真，没理解。&lt;/li&gt;
  &lt;li&gt;第二种加载就是代码加载了，这个API就多了，resources的load或者AssetBundle的load都可以做到。&lt;/li&gt;
  &lt;li&gt;当一个对象被加载，Unity 会尝试将所有引用从文件 GUID 和本地 ID 转换成实例 ID。（这个应该是为了把运行时的引用关系都保存在PersistentManager所管理的映射图中。）&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-5&quot;&gt;卸载&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;如果一个fileID和localID没有对应的实例ID，或者实例ID所对应的fileID和localID无效了，那么就会出现missing的情况，此时实例ID仍旧是存在的，在场景中它也被别的对象引用着，但是你可能看不到它或者它显示为品红色。&lt;/li&gt;
  &lt;li&gt;这个情况其实挺常见的，由于操作问题导致asset的fileID发生了变化，但是原来的实例ID没有跟着更新，就容易出现。&lt;/li&gt;
  &lt;li&gt;文中列举了三个被卸载的情况
    &lt;ul&gt;
      &lt;li&gt;在未使用的asset被清理时对象会被自动卸载。这个过程会在场景切换的时候发生。&lt;/li&gt;
      &lt;li&gt;从Resources文件夹中加载的对象在调用Resources.UnloadAsset时会卸载。但是对象对应的实例ID保持有效，而且也对应着有效的fileID和localID。&lt;strong&gt;这些对象如果被其它的mono变了或者对象引用着，那么在调用Resources.UnloadAsset后这些对象会被重新加载。&lt;/strong&gt;（这个就有意思了，代表在Resources.UnloadAsset函数有时不会实现我们想要的效果。）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;当调用AssetBundle.Unload(false)时，unity不会将从这个AssetBundle中加载的还处于激活状态的对象销毁掉，但是会使这些对象对应的实例ID与fileID和localID断开引用。如果这些对象从内存中卸载并且对这些已卸载的对象的引用依然保持着，Unity将无法重新加载对象。&lt;/li&gt;
  &lt;li&gt;上面这段讲的比较奇怪，因为在后面的最后一章中应该是描述了这样的情况，此时是可以重新加载asset的，只不过会造成内存泄漏。&lt;/li&gt;
  &lt;li&gt;在注视中讲到了这个情况的一个例子就是APP被挂起后，GPU内存中的纹理、网格被删除了，那么在APP恢复后需要重新加载这些内容。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-6&quot;&gt;加载大的层次结构&lt;/h3&gt;

&lt;h4 id=&quot;section-7&quot;&gt;几个点&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;在序列化层级结构时会将所有对象和组件都单独的序列化到序列化文件中。这对于层级的加载产生阴影。&lt;/li&gt;
  &lt;li&gt;层级加载时CPU时间消耗在以下内容上：
    &lt;ul&gt;
      &lt;li&gt;读取序列化数据&lt;/li&gt;
      &lt;li&gt;在新创建出的transform中设置层级结构&lt;/li&gt;
      &lt;li&gt;实例化对象和组件&lt;/li&gt;
      &lt;li&gt;唤醒对象和组件（awake）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;后面三条基本上花费的时间是固定的，但是第一条不一样。层级越复杂加载的越慢。&lt;/li&gt;
  &lt;li&gt;在所有平台上，内存读取速度快过磁盘，PC读取快过手机。因此当层级过于复杂时可能读取的时间都要长于实例化的时间。&lt;/li&gt;
  &lt;li&gt;对于层级中数据相同的对象会多次进行序列化，比如UI上30个复制出来的相同的元素会序列化三十次，加载的时候也是加载30个不同的数据，因此很耗时。&lt;/li&gt;
  &lt;li&gt;5.4之后unity修改了transform在内存中的呈现形式。每个根节点下的所有子层级都保存在一段紧密连续的内存中。当实例化一个会导致重新指定父级的新对象时，考虑使用GameObject.Instantiate方法的带父对象参数的重载。使用这个重载可以避免给新物体新分配根 tranform 层次。测试结果中，这个可以提高 5 - 10 % 的实例化时间。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-8&quot;&gt;总结&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;这个章节讲述了unity中对UnityEngine.Objects和asset的管理，从资材的导入到运行时的加载卸载。读完后应该明白一下几点：&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;UnityEngine.Objects与asset的关系&lt;/li&gt;
  &lt;li&gt;asset导入后产生了mate文件，产生了fileID和localID的概念&lt;/li&gt;
  &lt;li&gt;asset在运行时中产生了实例ID的概念，并且实例ID和fileID、localID是通过一个映射图结合到了一起，这个映射图也让内存中的object与磁盘上的asset产生了联系。&lt;/li&gt;
  &lt;li&gt;asset可以被加载也可以被卸载，而它的卸载需要注意不要让资源出现内存泄漏的问题。&lt;/li&gt;
  &lt;li&gt;最后在场景中的层级结构需要合理的规划。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 16 Jul 2017 00:13:52 +0800</pubDate>
        <link>https://caihua.tech/2017/07/16/AssetBundle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%B5%84%E4%BA%A7-%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%BA%8F%E5%88%97%E5%8C%96/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/07/16/AssetBundle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%B5%84%E4%BA%A7-%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%BA%8F%E5%88%97%E5%8C%96/</guid>
        
        <category>AssetBundle学习笔记</category>
        
        
      </item>
    
      <item>
        <title>5.6混合光照</title>
        <description>&lt;h3 id=&quot;httpforumchinaunity3dcomthread-24402-1-1html&quot;&gt;&lt;a href=&quot;http://forum.china.unity3d.com/thread-24402-1-1.html&quot;&gt;原文地址&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;section&quot;&gt;原有混合光照的问题&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;5.6之前的光照存在一个严重的问题就是: &lt;strong&gt;混合光照仅当只有一个定向光时才能正常工作。&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;这是什么个意思呢？
    &lt;ul&gt;
      &lt;li&gt;首先说一下unity的GI一直以来都是依靠烘焙来做的，但是在unity5中加入了PRGI。&lt;/li&gt;
      &lt;li&gt;目前的unity在一个场景中可以混合使用烘焙光照和实时光照，一部分静态对象使用烘焙好的光照和影子，而一些非静态的对象可以继续接受实时光照的影响。这个需要我们把Light Type设置为Mixed。&lt;/li&gt;
      &lt;li&gt;不过静态对象会既受烘焙的影响又受实时光的影响，从而产生不好的效果。mixed模式就是为了解决这个问题而出现的，&lt;code class=&quot;highlighter-rouge&quot;&gt;理想情况下，混合模式会为你料理好一切，照亮相同平衡范围内的动、静态对象（从而保留了视觉逼真度与一致性）。&lt;/code&gt;只是一切都不是那么的美好，事实上是动态物体不会从spotlight上产生阴影。&lt;/li&gt;
      &lt;li&gt;需要特别声明一下，我自己的测试中完全没有发现上面的问题，目前不知道原因。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-1&quot;&gt;5.6引入的混合光照模式&lt;/h3&gt;

&lt;h4 id=&quot;subtractive&quot;&gt;Subtractive&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;这个就是以前的混合方式。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;shadowmask&quot;&gt;Shadowmask&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;在Shadowmask模式中，静态对象通过shadowmask从其他静态对象接收阴影，不必考虑阴影距离。来自动态对象的阴影仅能通过阴影距离内的阴影贴图获得。动态对象通过阴影距离内的阴影贴图接受来自其他动态对象的阴影。来自静态对象的阴影仅能通过光照探针获得。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;这段读着有点绕口，其实分析起来就是针对静态和动态物体获得阴影进行了区分。相对来说静态物体获取阴影会比较简单（至少我认为是）。而动态物理为了得到静态物体的阴影需要使用光照探针。而文中的&lt;code class=&quot;highlighter-rouge&quot;&gt;阴影距离内的阴影贴图&lt;/code&gt;这个推测是阴影图，熟悉unity shader中阴影产生的人应该知道这个东西。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;distance-shadowmask&quot;&gt;Distance Shadowmask&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;Distance Shadowmask的行为是由阴影距离决定的。在阴影距离内，动、静态对象都会渲染进阴影贴图，静态对象可以在动态对象上投射锐阴影。超出阴影距离，静态对象会通过预计算shadowmask接收来自其他静态对象的高质量阴影，而动态对象则通过光照探针与LPPV，接收来自静态对象的低分辨率阴影。
普通的Shadowmask模式要比Distance Shadowmask模式产生更少的Draw Call，因为阴影贴图的性能消耗要高于烘焙阴影（因为它们在每帧都进行渲染，而烘焙阴影是保存在一个纹理/光照贴图中的）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;这个就有意思了，根据阴影距离决定对象是否渲染金阴影贴图（这里的阴影贴图应该就是阴影映射纹理，它是通过ShadowCaster这个pass产生的），动态和静态的对象满足条件时都会参与渲染，所以会有性能消耗。因为每个对象的都要执行一次pass，而这个pass造成了draw call。（这个不是很能理解了，为何不是在一次DC中执行这个pass？）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Distance Shadowmask模式更适合高端PC或游戏主机。而Shadowmask则作为一种更廉价的解决方案，推荐在中低端设备使用。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;baked-indirect&quot;&gt;Baked Indirect&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;Baked Indirect没有使用任何Shadowmask。所以在这个模式中没有远距离阴影。在阴影距离之内，所有静态和动态的对象都投射 实时阴影贴图。但超出阴影距离后，就没有阴影。在Baked Indirect中，除了间接照明之外所有的东西都是实时的。这意味着，实时光照、实时阴影以及实时镜面高光，但是反弹的光照信息储存在光照贴图中，是静态的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;这个东西和shadowmask的区别在于超出阴影距离后就没有阴影了。还有非间接照明是实时的难道说明烘焙出来的静态物体在直线光下其实和没烘焙一样？只有间接光是在lightmap中。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-2&quot;&gt;总结一下：&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;5.6可以说是unity在渲染上又迈进了一步。处理更加精细的影子效果外，还加入了简单的后处理流程，让开发者能够更简单的做出优美的画面。&lt;/li&gt;
  &lt;li&gt;本文只是对官方内容的简单的总结，在实际使用中不同的硬件环境应该有不同的选择。&lt;/li&gt;
  &lt;li&gt;文中的各种不同的选项对应的物体的影子的互相影响需要参考&lt;a href=&quot;https://docs.google.com/spreadsheets/d/1v-LnDOJcsSsa0ViF7kBs6xgY9Q_z-1k6h95LE0lf46U/edit?usp=drive_web&quot;&gt;Reference card for Light Modes&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-3&quot;&gt;如何烘焙&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;主要光的baking是baked，静态物体勾选哪里Lightmap Static。点击bake进行烘焙。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 09 Jul 2017 23:51:01 +0800</pubDate>
        <link>https://caihua.tech/2017/07/09/5.6%E6%B7%B7%E5%90%88%E5%85%89%E7%85%A7/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/07/09/5.6%E6%B7%B7%E5%90%88%E5%85%89%E7%85%A7/</guid>
        
        <category>Unity3D</category>
        
        
      </item>
    
      <item>
        <title>写点东西，证明我还在更新</title>
        <description>&lt;h4 id=&quot;section&quot;&gt;最近的一些情况&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;很久没有更新博客了，从4月份开始为了项目赶进度开始了996模式，实在没有什么时间写东西。这个是公司也是我自己做的第一个VR旅游项目，可以说从零开始吧，毕竟与游戏开发不一样，期间学到了多东西，也走了不少的弯路。&lt;/li&gt;
  &lt;li&gt;在项目期间很神奇的看了一大半冯乐乐写的《Shader入门精要》，在这给这本书打打广告，这是一本很适合入门的Shader书籍，而且紧密的结合了Unity5。对于我这样想要编写shader的人来说是很好的入门。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-1&quot;&gt;后续的计划&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;本来今年的计划是搞定AssetBundle和热更新，然后看完《游戏编程模式》这本书。之前的blog中也陆续写了一些读书笔记，其实在写AssetBundle的最后一篇时的最后一个link指向了AssetBundle的一个官方实践教程，是必须读的文章。我基本已经看完了，后续会写读书笔记，现在年纪大了不写点东西感觉自己记不住了。XD&lt;/li&gt;
  &lt;li&gt;另外就是上面提到的项目完成后会写一点总结。&lt;/li&gt;
  &lt;li&gt;还有就是上半年最大的收获，学会了写unity shader。以前一些特效总要找特效的同事做，而且有时候用了一些特效发现很影响性能但是不知为何，在学了shader之后很多事情知道是怎么回事了，虽然PBR这样的shader还是不能完全写出来，但是基本的写法和理论都已经知道了，遇到问题的时候不会再一脸懵逼。这算是上半年最大的收获吧。当然，读书笔记必不可少，等我刷第二遍书的时候会开始写。&lt;/li&gt;
  &lt;li&gt;下半年的项目计划已经出来了，做一个VR教育的产品，涉及到AssetBundle和热更新，好吧真是太巧了，刚好在项目中要好好学学热更新了。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 04 Jun 2017 21:44:23 +0800</pubDate>
        <link>https://caihua.tech/2017/06/04/%E5%86%99%E7%82%B9%E4%B8%9C%E8%A5%BF-%E8%AF%81%E6%98%8E%E6%88%91%E8%BF%98%E5%9C%A8%E6%9B%B4%E6%96%B0/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/06/04/%E5%86%99%E7%82%B9%E4%B8%9C%E8%A5%BF-%E8%AF%81%E6%98%8E%E6%88%91%E8%BF%98%E5%9C%A8%E6%9B%B4%E6%96%B0/</guid>
        
        <category>杂记</category>
        
        
      </item>
    
      <item>
        <title>AssetBundle学习笔记：4、AssetBundle的下载与asset的加载</title>
        <description>&lt;h2 id=&quot;assetbundle&quot;&gt;AssetBundle的下载&lt;/h2&gt;
&lt;h4 id=&quot;assetbundle-1&quot;&gt;下载AssetBundle&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;首先需要理解的是这个下载就是指的从网络下载。因此只有WWW和 WWW.LoadFromCacheOrDownload两个方法。&lt;/li&gt;
  &lt;li&gt;www是不带缓存的，而后者是带缓存的。&lt;/li&gt;
  &lt;li&gt;LoadFromCacheOrDownload的version参数，如果缓存中不存在，或者version低于指定的版本就会重新下载，否则直接从缓存拿数据。&lt;strong&gt;缓存数据应该是始终在磁盘上的，而5.3以后缓存文件也压缩为LZ4(好像是可配置的)，所以读取cache的数据很可能与LoadFromFile是等效的。&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;如果多个AssetBundle使用WWW.LoadFromCacheOrDownload下载，每帧只能完成一个。&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.unity3d.com/ScriptReference/WWW.LoadFromCacheOrDownload.html&quot;&gt;LoadFromCacheOrDownload&lt;/a&gt;中如果发现缓存文件夹已经满了，会优先删除最近没有使用的cache，但是如果磁盘本身就满了或者说cache folder已经满了（这个东西是有容量限制的）那么会把AssetBundle数据直接按照stream的形式放到内存，这个和new WWW的做法完全一样。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;assetbundle-2&quot;&gt;生成AssetBundle&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;当访问&lt;code class=&quot;highlighter-rouge&quot;&gt; .assetBundle&lt;/code&gt;属性时，会从下载的数据中提取并生产AssetBundle对象。此时就可以加载AssetBundle中的asset了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section&quot;&gt;其它&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;后面在editor中加载asset的demo中API已经过时，可以用&lt;code class=&quot;highlighter-rouge&quot;&gt;AssetDatabase.LoadAssetAtPath&lt;/code&gt;代替。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;asset&quot;&gt;Asset加载&lt;/h2&gt;

&lt;h3 id=&quot;assetbundleapi&quot;&gt;AssetBundle加载API概述&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;具体表格可以参考&lt;a href=&quot;https://docs.unity3d.com/Manual/AssetBundleCompression.html&quot;&gt;原文&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;www&quot;&gt;WWW&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;在使用WWW时需要及时释放，因为它会在内存（WebStream）中保留下载的文件的大小。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;loadfromcacheordownload&quot;&gt;LoadFromCacheOrDownload&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;LoadFromCacheOrDownload没有什么额外的内存使用（其实应该有序列化文件（SerializedFile）的内存使用，而且如果prefab过多，有可能SerializedFile比WebStream还大，&lt;a href=&quot;http://blog.uwa4d.com/archives/ABTheory.html&quot;&gt;来源&lt;/a&gt;）&lt;/li&gt;
  &lt;li&gt;从表中可以看到在性能上也只有读磁盘的操作，然而LoadFromCacheOrDownload本质上是个网络操作，因此它会产生一些例如CRC检测的操作，所以unity的建议是如果是本地的AssetBundle不要用这个函数加载。&lt;/li&gt;
  &lt;li&gt;如果是加载缓存行为与 LoadFromFile一致，但是按照上面的说法看应该有差异吧。&lt;/li&gt;
  &lt;li&gt;补充：关于SerializedFile在4.7上每个的大小并不一定。&lt;code class=&quot;highlighter-rouge&quot;&gt;在5.3-5.5期间Unity引擎目前的做法，为了保证Android端apk解压速度而保证的两个256KB的buffer，在pc上只有7KB&lt;/code&gt;。而到了5.6会改为2x8KB。但是经过测试这个不是必然的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;loadfrommemory-async&quot;&gt;LoadFromMemory (Async)&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;LoadFromMemory (Async)，不推荐使用，因为它的操作几乎都是在内存中完成的。加载AssetBundle需要占用大概AB size两倍的内存，一个API创建的内容还有就是参数里面的数据内存。如果是load一个asset会在内存中出现三个asset的拷贝，一个是托管代码字节数组，一个是 AssetBundle 的本地内存，第三个是在 GPU 或者系统内存中的资产本身。（第一个是参数、一个是AssetBundle本身、一个是Load函数产生的对象内存）。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;loadfromfileasync&quot;&gt;LoadFromFile(Async)&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;LoadFromFile(Async)，&lt;strong&gt;++不能加载LZMA（特么的你敢信）。而且在Android上5.3和之前的unity无法加载StreamingAssets中的AssetBundle。++&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;移动端上：当使用AssetBundle.LoadFromFile加载LZ4格式的文件时，其实不会将问价加载到内容，而是加载AssetBundle的Header。&lt;/li&gt;
  &lt;li&gt;Editor下会将AssetBundle加载到内容，因此在Profiler中会出现峰值，不用担心。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;webrequest&quot;&gt;WebRequest&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.unity3d.com/Manual/UnityWebRequest-HLAPI.html&quot;&gt;WebRequest&lt;/a&gt;。
 (also supports caching)，这个东西算是WWW的替代品，很好用，回头写个总结。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-1&quot;&gt;其它&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;使用WWW, WebRequest下载AssetBundle时，还有一个8x64KB的缓冲池buff来保存socket中的数据。so，这也是内存啊。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-2&quot;&gt;从压缩格式角度看:&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;不压缩没啥优势，除了访问速度快。其实如果是不考虑内存或者磁盘的占用问题，倒是可以用这个。&lt;/li&gt;
  &lt;li&gt;LZ4，从文档看unity应该用的是&lt;a href=&quot;http://www.findbestopensource.com/product/lz4hc&quot;&gt;LZ4HC&lt;/a&gt;，一个LZ4的高压缩版本。由于unity从5.3以后缓存也可以压缩了，而且这个算法是基于块的，所以在综合性上比较好。&lt;/li&gt;
  &lt;li&gt;LZMA，必须先解压在压缩，如果不是因为网络传输需要节省流量，不建议使用。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-3&quot;&gt;加载二进制数据&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;按照建议应该将原始的二进制文件保存为后缀为&lt;code class=&quot;highlighter-rouge&quot;&gt;.bytes&lt;/code&gt;的文件，unity会视这个后缀的文件为TextAsset，作为一个TextAsset文件然后打包到AssetBundle。加载的时候也是一样，从AssetBundle中按照TextAsset类型得到asset，然后TextAsset.bytes属性得到byte数组。
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;string url = &quot;http://www.mywebsite.com/mygame/assetbundles/assetbundle1.unity3d&quot;;
IEnumerator Start () {
  while (!Caching.ready)
      yield return null;

  // Start a download of the given URL
  WWW www = WWW.LoadFromCacheOrDownload (url, 1);

  // Wait for download to complete
  yield return www;

  // Load and retrieve the AssetBundle
  AssetBundle bundle = www.assetBundle;

  // Load the TextAsset object
  TextAsset txt = bundle.Load(&quot;myBinaryAsText&quot;, typeof(TextAsset)) as TextAsset;

  // Retrieve the binary data as an array of bytes
  byte[] bytes = txt.bytes;
}
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-4&quot;&gt;对于加密资源的处理&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;三个套路：
    &lt;ul&gt;
      &lt;li&gt;加密自己的原始数据，然后改后缀为.byte，按照上面说的二进制的套路走。客户端拿到二进制数据后进行解密。&lt;/li&gt;
      &lt;li&gt;加密AssetBundle，后缀名不限。用WWW的形式拿到数据后解密，然后用AssetBundle.CreateFromMemory生成AssetBundle。&lt;/li&gt;
      &lt;li&gt;一个普通的AssetBundle中包含一个加密的AssetBundle（蛋疼不？）。需要经历获取TextAsset-&amp;gt;拿到二进制数据-&amp;gt;解密二进制数据-&amp;gt;生成未加密AssetBundle-&amp;gt;加载AssetBundle中的asset。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;script-asset&quot;&gt;Script Asset的处理&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;script-&amp;gt;assembly(pre-compiled)-&amp;gt;TextAsset-&amp;gt;AssetBundle-&amp;gt;TextAsset-&amp;gt;byte[]-&amp;gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var assembly = System.Reflection.Assembly.Load(txt.bytes);
var type = assembly.GetType(&quot;MyClassDerivedFromMonoBehaviour&quot;);

// Instantiate a GameObject and add a component with the loaded class
GameObject go = new GameObject();
go.AddComponent(type);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;assetassetbundle&quot;&gt;卸载asset或者说AssetBundle&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;AssetBundle.Unload方法是目前AssetBundle唯一能够使用的方法，与Resources.UnloadAsset比起来缺乏灵活性。&lt;/li&gt;
  &lt;li&gt;参数是个bool，传递false&lt;code class=&quot;highlighter-rouge&quot;&gt;unload the compressed data from memory&lt;/code&gt;，按照第二部分的说明，什么是压缩的数据，那就是LZ4的数据，也就是AssetBundle。如果传递true，那么已经load出来的asset也会被清理。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-5&quot;&gt;一些策略&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;一个AssetBundle对象在同一时刻只能存在一份，所以当反复使用www下载并调用www.assetBundle时会报错&lt;code class=&quot;highlighter-rouge&quot;&gt; Cannot load cached AssetBundle. A file of the same name is already loaded from another AssetBundle&lt;/code&gt;。这个时候要么自己unload要么就代码控制只保留一个对象。unity的建议是尽快删除不用的AssetBundle。&lt;/li&gt;
  &lt;li&gt;unity5之前bundle在unload之前如果有load，需要等到load结束才会执行unload。so，可能会卡线程。&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.unity3d.com/560/Documentation/Manual/keepingtrackofloadedassetbundles.html&quot;&gt;文中&lt;/a&gt;有一个完整的解决方案。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;assetbundleseek&quot;&gt;优化AssetBundle的磁盘寻道(Seek)&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;unity序列化数据是为使得数据在读取时是线性的，减少寻道的次数。因为HDDs的硬盘比SSD慢很多。&lt;/li&gt;
  &lt;li&gt;一个场景的数据按照对象类型进行排序，在场景加载时，场景中的asset先按顺序加载，然后画面中的对象才加载。（完全可以理解，场景中摆放的多是prefab，肯定要先加载prefab所需要的资源。）而Scene AssetBundle也是这个顺序。&lt;/li&gt;
  &lt;li&gt;一个来自non-Scene AssetBundles中的asset在序列化上是和Scene AssetBundles一样的，但是加载方式取决于调用的API。LoadAllAssets这样的API会采用线性的方式加载所有的资源。但是如果是LoadAsset会随机读取的形式加载。&lt;/li&gt;
  &lt;li&gt;DeterministicAssetBundles不破坏线性读取和类型排序，但是保留对象位置在一个特点的范围(没看懂)。&lt;/li&gt;
  &lt;li&gt;LZ4不影响线性读取，但是会影响读取的颗粒度。（想来是因为按需加载，所以。。。）&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-6&quot;&gt;一些需要注意的行为&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;一些异步加载API会打破线性读取的模式，即使是读取场景。&lt;/li&gt;
  &lt;li&gt;因为有依赖的存在，所即使AssetBundle.LoadAllAssets这样的API也不能保证是线性读取的。因为可能出现依赖的资源在别的AssetBundle中，所以最好是将所有依赖的资源都读取出来放好了，这样可以使用最小的寻道次数。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-7&quot;&gt;参考&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/huxiao-tee/p/4660352.html&quot;&gt;MMAP&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/lodypig/article/details/51879702&quot;&gt;一些内存测试数据&lt;/a&gt;。第二个测试结果符合unity使用MMAP的结论。&lt;/li&gt;
  &lt;li&gt;一些不错的文章
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;http://minhhh.github.io/posts/unity-asset-bundle&quot;&gt;简单好理解&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;http://blog.shuiguzi.com/2016/12/15/GuideToABAndRes/&quot;&gt;震惊！男人看了会沉默，女人看了会流泪，不看不是中国人之事实的真相系列。&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 04 Apr 2017 12:06:27 +0800</pubDate>
        <link>https://caihua.tech/2017/04/04/AssetBundle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4-AssetBundle%E7%9A%84%E4%B8%8B%E8%BD%BD%E4%B8%8Easset%E7%9A%84%E5%8A%A0%E8%BD%BD/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/04/04/AssetBundle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4-AssetBundle%E7%9A%84%E4%B8%8B%E8%BD%BD%E4%B8%8Easset%E7%9A%84%E5%8A%A0%E8%BD%BD/</guid>
        
        <category>AssetBundle学习笔记</category>
        
        
      </item>
    
  </channel>
</rss>
