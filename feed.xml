<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>笛音夏扇</title>
    <description>Be publicly useful and privately happy.</description>
    <link>https://caihua.tech/</link>
    <atom:link href="https://caihua.tech/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Wed, 12 Oct 2016 21:22:46 +0800</pubDate>
    <lastBuildDate>Wed, 12 Oct 2016 21:22:46 +0800</lastBuildDate>
    <generator>Jekyll v3.2.1</generator>
    
      <item>
        <title>Deepoon的相关设置以及如何玩steam游戏</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;基本&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;保证Deepoon助手、显卡驱动是最新的。&lt;/li&gt;
  &lt;li&gt;安装Deepoon platform sdk。在platform sdk的安装过程中需要阅读其自带的文档，sdk path中不要带中文。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;dpnngetlasterror&quot;&gt;DpnnGetLastError的处理&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;目前发现在安装了steamVR的情况下会出现DpnuGetLastError错误，在启动状态下出现错误后，退出steamVR。然后重启游戏。&lt;/li&gt;
  &lt;li&gt;在setting→play中关闭VR support，这个东西在启动后会被steamVR开启（如果你的程序中用到了steamVR）。&lt;/li&gt;
  &lt;li&gt;按照上述两部则应该不会出现DpnnGetLastError错误，并且只能通过头盔来看游戏内容。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;steam&quot;&gt;玩steam&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;在steam的安装目录下放置xxx\Steam\steamapps\common\SteamVR\drivers\deepoon。如果没有放置这个驱动可能导致steam下无法设置VR房间。设置完成后应该是
&lt;img src=&quot;http://images2015.cnblogs.com/blog/23250/201610/23250-20161012092230578-1855749103.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;经过上面的设置就可以用大朋眼镜玩steam游戏了。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-1&quot;&gt;开发相关&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;目前发现如果用大朋眼镜可以玩steam，则在unity中是不需要使用DpnCameraRig的，而且也不需要开启大朋助手。&lt;/li&gt;
  &lt;li&gt;从这些表现来看大朋应该用的是Oculus的底层。&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Wed, 12 Oct 2016 21:21:12 +0800</pubDate>
        <link>https://caihua.tech/2016/10/12/Deepoon%E7%9A%84%E7%9B%B8%E5%85%B3%E8%AE%BE%E7%BD%AE%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E7%8E%A9steam%E6%B8%B8%E6%88%8F/</link>
        <guid isPermaLink="true">https://caihua.tech/2016/10/12/Deepoon%E7%9A%84%E7%9B%B8%E5%85%B3%E8%AE%BE%E7%BD%AE%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E7%8E%A9steam%E6%B8%B8%E6%88%8F/</guid>
        
        <category>VR</category>
        
        
      </item>
    
      <item>
        <title>LOD初探</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;概念&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;LOD全称是Level of Detail，也就是细节层级。&lt;/li&gt;
  &lt;li&gt;为什么会产生这个技术？根据官方教程的解释是因为在一个很大的场景中，需要进一步考虑性能问题。LOD就是一个很好的解决性能问题的方案，它根据物体与摄像机的距离来展示这个物体不同的mesh，从而使得物体较远是使用面数比较少的mesh，而距离近的时候使用面数多的mesh。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-1&quot;&gt;如何使用&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;LOD在unity中的使用极为简单，基本分为以下几个步骤&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;创建一个空GameObject，然后加上LOD Group组件。
&lt;img src=&quot;http://images2015.cnblogs.com/blog/23250/201610/23250-20161009232106898-784286333.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;LOD Group中选择某个LOD块会出现
&lt;img src=&quot;http://images2015.cnblogs.com/blog/23250/201610/23250-20161009233343045-133617437.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;拖动对象到&lt;code class=&quot;highlighter-rouge&quot;&gt;add&lt;/code&gt;按钮上后就设置了当前level下的模型。
&lt;img src=&quot;http://images2015.cnblogs.com/blog/23250/201610/23250-20161009233221336-502460804.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;依次设置完0、1、2的模型，需要注意LOD 0 表示摄像机最近距离显示，因此模型质量最高，数字越大距离摄像机越远，模型质量越低。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;最终效果
&lt;img src=&quot;http://images2015.cnblogs.com/blog/23250/201610/23250-20161009232136822-2074270500.gif&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我设置的是绿色cube在LOD 2，黄色在LOD 1,红色是0，因此从右下角的camera preview看到摄像机距离对象最远时显示的绿色，依次变为黄色和红色。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;几个参数的设置&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;在setting的quality中有LOD的两个参数&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://images2015.cnblogs.com/blog/23250/201610/23250-20161009234207377-1568794073.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Maximum LOD Level：最大LOD级别，表示游戏中使用的最高LOD级别。在该级别以上的模型不会被使用，并且在编译时忽略。（这将节省存储空间和内存空间）。&lt;/p&gt;

  &lt;p&gt;Bias LOD：LOD偏离 ，LOD级别基于物体在屏幕上的大小。当物体大小在两个LOD级别之间，可以选择使用低细节模型或高细节模型。数值取值范围为0-1，数值越接近0，越偏向于选择低细节模型。即是：如果该值小，那么摄像机离物体距离稍微有些变化，不同细节物体即会切换，该值大，那么摄像机需要与物体有很大的距离才会切换。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-3&quot;&gt;缺点&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;它的缺点是需要占用更多的内存，而且如果没有调整好距离的话，可能会造成模拟的突变。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果不想占用内存还有种办法是只设置一个LOD在group中，可以通过代码实现，这样只用一个模型即可，不过如果刷新不够快或者设置的不合适可能出现视野中突然多了个物体的情况。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 09 Oct 2016 23:47:35 +0800</pubDate>
        <link>https://caihua.tech/2016/10/09/LOD%E5%88%9D%E6%8E%A2/</link>
        <guid isPermaLink="true">https://caihua.tech/2016/10/09/LOD%E5%88%9D%E6%8E%A2/</guid>
        
        <category>Unity3D</category>
        
        
      </item>
    
      <item>
        <title>VR开发环境搭建</title>
        <description>&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;unity3d的安装&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;目前使用的Deepoon
1.安装大朋助手。
2.如果提示require DpnPlatform_x64.dll，则在大朋官网下载platform的sdk，并找到对应的平台的文件夹安装，有个bat文件可以安装。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;安装steam和steamVR。对于steamVR来说正常安装完会显示能识别头盔，但是可能提示未准备好，需要进行房间设置。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 09 Oct 2016 21:59:00 +0800</pubDate>
        <link>https://caihua.tech/2016/10/09/VR%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</link>
        <guid isPermaLink="true">https://caihua.tech/2016/10/09/VR%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</guid>
        
        <category>VR</category>
        
        <category>Unity3D</category>
        
        
      </item>
    
      <item>
        <title>Github Page爬坑指南</title>
        <description>&lt;h4 id=&quot;jekyll&quot;&gt;1.jekyll的使用&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;jekyll的核心命令就几个&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jekyll new blog // 选好文件夹位置
jekyll build    // 在_site文件夹下生成网站内容
jekyll serve    // 可以在本地生成一个服务查看生成网站的内容，IP:127.0.0.1:4000
   
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;模板，参考别人的模板进行了修改，&lt;a href=&quot;https://github.com/Huxpro/huxpro.github.io&quot;&gt;地址&lt;/a&gt;。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;github&quot;&gt;2.github上的设置&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;github上需要设置的反而是最少的，创建一个用户名下的repository，例如sam.github.io，然后直接将jekyll中_site下的文件提交到这个repository即可。如果代码没错就可以直接通过访问sam.github.io进入个人网站了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section&quot;&gt;3.个人域名绑定&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;首先在sam.github.io这个repository下添加一个名为CNAME的文件，内容为你自己的网站地址，比如sam.tech&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;去自己的域名管理中进行解析设置，以阿里云为例。从左侧进入&lt;code class=&quot;highlighter-rouge&quot;&gt;云解析 DNS&lt;/code&gt;，选择域名后点击解析。删除原来的几个默认生成的解析，然后进行如下设置&lt;img src=&quot;http://images2015.cnblogs.com/blog/23250/201610/23250-20161003173328629-236251795.jpg&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;记录值为&lt;code class=&quot;highlighter-rouge&quot;&gt;sam.github.io.&lt;/code&gt;，注意io后面有个点。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;经过上面两步如果你的域名和网站内容没有问题的话就可以通过域名访问了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;https&quot;&gt;4.https的问题&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;经过上面的几步已经可以正常访问网站了，但是会注意到在chrome中会提示网站不安全，因为不支持https。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;解决办法参考了&lt;a href=&quot;https://zhuanlan.zhihu.com/p/22667528&quot;&gt;这篇文章&lt;/a&gt;，在阿里云中通过&lt;code class=&quot;highlighter-rouge&quot;&gt;域名→管理&lt;/code&gt;然后设置新的nameservers即可。只不过一直提示&lt;code class=&quot;highlighter-rouge&quot;&gt;非万网DNS&lt;/code&gt;。
&lt;img src=&quot;http://images2015.cnblogs.com/blog/23250/201610/23250-20161003173334707-1998000533.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-1&quot;&gt;5.图片链接问题&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;目前生成出来的HTML代码中图片的路径是错误的，从网上也找了很多办法但是都不理想，咋这篇文章中使用的图片其实是我把图片上传到博客园，然后拿到URL后使用的。也就是说使用图片存储服务来实现，这样的好处就在于github page容量有限，如果将来图片多了会很麻烦，不如一开始就使用第三方来存储图片。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 03 Oct 2016 13:18:23 +0800</pubDate>
        <link>https://caihua.tech/2016/10/03/github-page%E7%88%AC%E5%9D%91%E6%8C%87%E5%8D%97/</link>
        <guid isPermaLink="true">https://caihua.tech/2016/10/03/github-page%E7%88%AC%E5%9D%91%E6%8C%87%E5%8D%97/</guid>
        
        <category>杂记</category>
        
        
      </item>
    
      <item>
        <title>解决JSONKit在macOS Sierra上crash的问题</title>
        <description>&lt;p&gt;按照如下方法修改代码即可
https://github.com/johnezang/JSONKit/pull/141/commits/ccc0565f0ae4a27371d18309ccb982a9f1f21b63&lt;/p&gt;

&lt;p&gt;懒得改的可以直接clone我修改过的
https://github.com/klkucan/JSONKit&lt;/p&gt;
</description>
        <pubDate>Thu, 22 Sep 2016 18:29:23 +0800</pubDate>
        <link>https://caihua.tech/2016/09/22/%E8%A7%A3%E5%86%B3JSONKit%E5%9C%A8macOS-Sierra%E4%B8%8Acrash%E7%9A%84%E9%97%AE%E9%A2%98/</link>
        <guid isPermaLink="true">https://caihua.tech/2016/09/22/%E8%A7%A3%E5%86%B3JSONKit%E5%9C%A8macOS-Sierra%E4%B8%8Acrash%E7%9A%84%E9%97%AE%E9%A2%98/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>iOS学习笔记-08杂</title>
        <description>&lt;p&gt;##&lt;span id=&quot;other&quot;&gt;8.杂&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;###表达式
表达式，是由数字、算符、数字分组符号（括号）、自由变量和约束变量等以能求得数值的有意义排列方法所得的组合。如：算术表达式、逻辑表达式、关系表达式、赋值表达式、逗号表达式等等。&lt;/p&gt;
</description>
        <pubDate>Fri, 16 Sep 2016 03:32:23 +0800</pubDate>
        <link>https://caihua.tech/2016/09/16/08%E6%9D%82/</link>
        <guid isPermaLink="true">https://caihua.tech/2016/09/16/08%E6%9D%82/</guid>
        
        <category>iOS学习笔记</category>
        
        
      </item>
    
      <item>
        <title>iOS学习笔记-07必要知识</title>
        <description>&lt;p&gt;##&lt;span id=&quot;other&quot;&gt;7.必要知识&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;###7.1 APNS&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;目前在8.0以后的推送需要以下几个步骤：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;1.使用registerUserNotificationSettings: &amp;amp; registerForRemoteNotifications方法&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;```
if ([[UIApplication sharedApplication] respondsToSelector:@selector(registerForRemoteNotifications)]) {
     UIUserNotificationSettings* notificationSettings = [UIUserNotificationSettings settingsForTypes:(UIUserNotificationTypeSound | UIUserNotificationTypeAlert | UIUserNotificationTypeBadge) categories:nil];
     [[UIApplication sharedApplication] registerUserNotificationSettings:notificationSettings]; 
     [[UIApplication sharedApplication] registerForRemoteNotifications];
}
 
```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;关于registerForRemoteNotifications方法有以下说明，它会需要实现两个delegate方法，并且方法能够被执行的条件是通过registerUserNotificationSettings:方法成功注册用户的notification，或者enabled for Background App Refresh。&lt;/p&gt;

&lt;p&gt;// Calling this will result in either application:didRegisterForRemoteNotificationsWithDeviceToken: or application:didFailToRegisterForRemoteNotificationsWithError: to be called on the application delegate. Note: these callbacks will be made only if the application has successfully registered for user notifications with registerUserNotificationSettings:, or if it is enabled for Background App Refresh&lt;/p&gt;

&lt;p&gt;2.实现delegate方法：每个APP都不同，就不写了。&lt;/p&gt;

&lt;p&gt;###7.2 block tips&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;多使用typedef来定义block，因为简洁、可复用、对于结构相同的block可以通过命名来区分。&lt;/li&gt;
  &lt;li&gt;在定义API时多用handle block来降低代码分散程度。&lt;/li&gt;
  &lt;li&gt;注意在使用block时循环引用对象&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	
	&lt;span class=&quot;cp&quot;&gt;#import &quot;BlockHandle.h&quot;
&lt;/span&gt;	&lt;span class=&quot;cp&quot;&gt;#import &amp;lt;Foundation/Foundation.h&amp;gt;
&lt;/span&gt;	
	&lt;span class=&quot;k&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;BlockClass&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;NSObject&lt;/span&gt;
	
	&lt;span class=&quot;k&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;strong&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nonatomic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NSData&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;localData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	
	&lt;span class=&quot;k&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;strong&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nonatomic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BlockHandle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bh&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;download&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	
	&lt;span class=&quot;k&quot;&gt;@end&lt;/span&gt;
	
	&lt;span class=&quot;cp&quot;&gt;#import &quot;BlockClass.h&quot;
&lt;/span&gt;	
	&lt;span class=&quot;k&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;BlockClass&lt;/span&gt;
	
	&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;download&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	    &lt;span class=&quot;c1&quot;&gt;//    BlockHandle* bh
&lt;/span&gt;	    &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bh&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BlockHandle&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;alloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;initWithUrl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;@&quot;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
	    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bh&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;startDownloadwithcompletionHandleBlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSData&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	        &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;localData&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	        &lt;span class=&quot;c1&quot;&gt;// 解除引用，打破保留环
&lt;/span&gt;	        &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bh&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	    &lt;span class=&quot;p&quot;&gt;}];&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	
	&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dealloc&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	    &lt;span class=&quot;n&quot;&gt;NSLog&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;@&quot;BlockClass dealloc&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	
	&lt;span class=&quot;k&quot;&gt;@end&lt;/span&gt;
	
	&lt;span class=&quot;err&quot;&gt;```&lt;/span&gt;
	
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#import &amp;lt;Foundation/Foundation.h&amp;gt;
&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;completionHandleBlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSData&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;BlockHandle&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;NSObject&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;strong&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nonatomic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NSString&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;strong&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nonatomic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;completionHandleBlock&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;block&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;initWithUrl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSString&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;startDownloadwithcompletionHandleBlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;completionHandleBlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;block&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;@end&lt;/span&gt;

&lt;span class=&quot;cp&quot;&gt;#import &quot;BlockHandle.h&quot;
&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;BlockHandle&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;initWithUrl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSString&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;url&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;super&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;url&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;startDownloadwithcompletionHandleBlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;completionHandleBlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;block&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;block&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;block&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;block&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;dispatch_async&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dispatch_get_global_queue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DISPATCH_QUEUE_PRIORITY_DEFAULT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSThread&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;sleepForTimeInterval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;block&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dealloc&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;NSLog&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;@&quot;BlockHandle dealloc&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;@end&lt;/span&gt;

&lt;span class=&quot;err&quot;&gt;```&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Fri, 16 Sep 2016 03:32:23 +0800</pubDate>
        <link>https://caihua.tech/2016/09/16/07%E5%BF%85%E8%A6%81%E7%9F%A5%E8%AF%86/</link>
        <guid isPermaLink="true">https://caihua.tech/2016/09/16/07%E5%BF%85%E8%A6%81%E7%9F%A5%E8%AF%86/</guid>
        
        <category>iOS学习笔记</category>
        
        
      </item>
    
      <item>
        <title>iOS学习笔记-06数据处理</title>
        <description>&lt;p&gt;##&lt;span id=&quot;data&quot;&gt;7.数据处理&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&quot;plsit&quot;&gt;7.1 plsit&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;创建plist文件及添加数值&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;http://images2015.cnblogs.com/blog/23250/201610/23250-20161003182017364-1987540145.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;数据读取，注意因为plist创建的时候可以选择dictionary或者array，这个也决定了后面怎么去读取它。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    NSString* filePath = [[NSBundle mainBundle] pathForResource:@&quot;dict_data&quot; ofType:@&quot;plist&quot;];
    if (!isEmpty(filePath)) {
        NSDictionary* dict = [NSDictionary dictionaryWithContentsOfFile:filePath];
        NSLog(@&quot;%@&quot;, dict[@&quot;name&quot;]);

        NSArray* arr = (NSArray*)dict[@&quot;favor&quot;];
        [arr enumerateObjectsUsingBlock:^(id _Nonnull obj, NSUInteger idx, BOOL* _Nonnull stop) {
            NSLog(@&quot;%@&quot;, obj);
        }];
    }
    
    NSString *filePath2 = [[NSBundle mainBundle] pathForResource:@&quot;arr_plist&quot; ofType:@&quot;plist&quot;];
    NSArray *arr2 = [NSArray arrayWithContentsOfFile:filePath2];
    NSLog(@&quot;%@&quot;, arr2);

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;修改数据，注意工程中的arr_plist文件内容没变，但是实际上安装包里面的文件数据是变了的，可以通过open命令打开filePath2路径下的文件。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ (void)writePlistData
{
    NSString* filePath2 = [[NSBundle mainBundle] pathForResource:@&quot;arr_plist&quot; ofType:@&quot;plist&quot;];
    NSMutableArray* arr2 = [NSMutableArray arrayWithContentsOfFile:filePath2];
    NSLog(@&quot;1 : %@&quot;, arr2);
    [arr2 addObject:@&quot;new obj&quot;];
    [arr2 writeToFile:filePath2 atomically:YES];
    NSMutableArray* arr3 = [NSMutableArray arrayWithContentsOfFile:filePath2];
    NSLog(@&quot;2 : %@&quot;, arr3);
    [arr3 enumerateObjectsUsingBlock:^(id _Nonnull obj, NSUInteger idx, BOOL* _Nonnull stop) {
        NSLog(@&quot;%@&quot;, obj);
    }];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;###7.2 xml&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;###7.2 JSON&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;创建json文件&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;http://images2015.cnblogs.com/blog/23250/201610/23250-20161003181941707-1069570154.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;数据读写&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    NSError* error;
    NSString* path = [[NSBundle mainBundle] pathForResource:@&quot;data&quot; ofType:@&quot;json&quot;];

    // 1.iOS自己的API解析
    NSData* data = [NSData dataWithContentsOfFile:path];
    NSDictionary* jsonDict = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingMutableLeaves error:&amp;amp;error];
    NSLog(@&quot;%@&quot;, jsonDict);

    NSLog(@&quot;name = %@&quot;, [jsonDict objectForKey:@&quot;name&quot;]);

    // 2.JSONKit解析
    NSString* jsonStr = [NSString stringWithContentsOfFile:path encoding:NSUTF8StringEncoding error:&amp;amp;error];
    NSLog(@&quot;%@&quot;, jsonStr);
    NSDictionary* jsonDict2 = [jsonStr objectFromJSONString];
    NSLog(@&quot;%@&quot;, jsonDict2);
    
    //3.反向生成JSON
    NSDictionary* dict = @{ @&quot;age&quot; : @1,
        @&quot;xx&quot; : @&quot;2&quot;,
        @&quot;favor&quot; : @[ @&quot;cai&quot;, @&quot;hua&quot; ] };
    NSData* jsonData = [NSJSONSerialization dataWithJSONObject:dict options:NSJSONWritingPrettyPrinted error:nil];
    NSString* jsonStr = [[NSString alloc] initWithData:jsonData encoding:NSUTF8StringEncoding];

    NSLog(@&quot;%@&quot;, jsonStr);

    NSString* jsonStr2 = [dict JSONString];
    NSLog(@&quot;%@&quot;, jsonStr2);

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;注意：目前的JSONKit是MRC的，需要在编译选项里面加入&lt;code class=&quot;highlighter-rouge&quot;&gt;-fno-objc-arc&lt;/code&gt;,并且修正两个简单的bug。&lt;/p&gt;
</description>
        <pubDate>Fri, 16 Sep 2016 03:32:23 +0800</pubDate>
        <link>https://caihua.tech/2016/09/16/06%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/</link>
        <guid isPermaLink="true">https://caihua.tech/2016/09/16/06%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/</guid>
        
        <category>iOS学习笔记</category>
        
        
      </item>
    
      <item>
        <title>iOS学习笔记-05线程</title>
        <description>&lt;p&gt;##&lt;span id=&quot;thread&quot;&gt;5.线程&lt;/span&gt;
####&lt;span id=&quot;gcd&quot;&gt;5.1 GCD&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;GCD是一套多线程库，可以有效的替换NSThread或者NSOperation。它的基本结构是&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_async(queue, block);&lt;/code&gt;参数中的queue可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_queue_create&lt;/code&gt;或者系统提供的标准dispatch queue。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    // 生成一个serial dispatch queue
    dispatch_queue_t serialQueue = dispatch_queue_create(&quot;com.demo.sai&quot;, NULL);
    // 生成一个concurrent dispatch queue
    dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;com.demo.sai&quot;, DISPATCH_QUEUE_CONCURRENT);

    // 生成的dispatch queue需要手动release，注意ARC不会释放dispatch_queue_t类型的变量
    dispatch_release(serialQueue);
    dispatch_release(concurrentQueue);

    // 使用系统已经提供的方法来create queue
    dispatch_queue_t serialQueue2 = dispatch_get_main_queue();
    dispatch_queue_t concurrentQueue2 = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);

    // 因此真正在代码中经常是这样写的
    dispatch_async(dispatch_get_main_queue(), ^{
        NSLog(@&quot;execute in main thread&quot;);
    });

    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        NSLog(@&quot;execute in a concurrent thread&quot;);
    });

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;GCD中线程分为Serial Dispatch Queue和Concurrent Dispatch Queue，分别为顺序执行和并发执行。在使用dispatch_get_main_queue时获得的是主线程queue，因此它一定是顺序执行的。使用dispatch_get_global_queue获得的queue所能并行的线程数量由系统来确定，并且可以甚至优先级，然后由于XNU内核用于Global Dispatch Queue的线程不保证实时性，因此执行优先级只是大致的判断（说白了就是并不是严格执行的）。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_set_target_queue(dispatch_object_t object, dispatch_queue_t queue);&lt;/code&gt;可以用来改变queue的优先级先度&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 变更queue的priority
dispatch_set_target_queue(concurrentQueue, serialQueue);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;延迟将block添加到queue中，dispatch_after&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, 3 * NSEC_PER_SEC), dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        NSLog(@&quot;dispatch_after&quot;);
    });
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&amp;lt;font size=3 color=red&amp;gt;&lt;strong&gt;注意这个方法可以用来做指定一个时间后执行某段代码但是这个时间参数并不准确,因为这个只是在一段时间后将block加入到queue中，但是并不意味着马上执行。&lt;/strong&gt;&amp;lt;/font&amp;gt;&lt;/p&gt;

&lt;p&gt;PS:关于用到的时间的宏的说明&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;NSEC：纳秒。&lt;/p&gt;

  &lt;p&gt;USEC：微妙。&lt;/p&gt;

  &lt;p&gt;SEC：秒&lt;/p&gt;

  &lt;p&gt;PER：每&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;所以：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;NSEC_PER_SEC，每秒有多少纳秒。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;USEC_PER_SEC，每秒有多少毫秒。（注意是指在纳秒的基础上）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;NSEC_PER_USEC，每毫秒有多少纳秒。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;所以，延时1秒可以写成如下几种：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;dispatch_time(DISPATCH_TIME_NOW, 1 * NSEC_PER_SEC);&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;dispatch_time(DISPATCH_TIME_NOW, 1000 * USEC_PER_SEC);&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;dispatch_time(DISPATCH_TIME_NOW, USEC_PER_SEC * NSEC_PER_USEC);&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;最后一个“USEC_PER_SEC * NSEC_PER_USEC”，翻译过来就是“每秒的毫秒数乘以每毫秒的纳秒数”，也就是“每秒的纳秒数”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_group&lt;/code&gt;，当在并发完成一些处理后，可能需要一个节点来完成某个操作，这个操作必须等到之前的处理全部完成，那么就需要用到dispatch_group来实现。配合&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_group&lt;/code&gt;使用的有两个，&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_group_notify &lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_group_wait&lt;/code&gt;,前者是当处理全部完成后执行，后者是等待一段时间后，用返回值判断是否所有的任务都完成了。当等待时间为&lt;code class=&quot;highlighter-rouge&quot;&gt;DISPATCH_TIME_FOREVER&lt;/code&gt;时返回值一定会是0。另外，&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_group_wait&lt;/code&gt;会阻塞调用的线程。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;       dispatch_queue_t groupQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
    dispatch_group_t group = dispatch_group_create();

    // 第一个处理
    dispatch_group_async(group, groupQueue, ^{
        NSLog(@&quot;first&quot;);
    });

    // 第二个处理
    dispatch_group_async(group, groupQueue, ^{
        NSLog(@&quot;secend&quot;);
    });

    // 完成后最终的处理
    dispatch_group_notify(group, groupQueue, ^{
        NSLog(@&quot;done&quot;);
    });

    long result = dispatch_group_wait(group, DISPATCH_TIME_FOREVER);
    if (result == 0) {
        NSLog(@&quot;done&quot;);
    }
    else {
        NSLog(@&quot;not done&quot;);
    }
    // 需要release
    dispatch_release(group);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;-&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_barrier_async&lt;/code&gt;,在代码中会等待之前加入某个queue的block全部执行完，然后使得concurrent queue变为一个serial queue，只能执行用&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_barrier_async&lt;/code&gt;添加的block，等完成后，queue变回并发。典型应用场景DB read的操作使用&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_async&lt;/code&gt;，当需要write DB时使用&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_barrier_async&lt;/code&gt;，可以保证数据的一致性，也相当于给写操作加了锁（好吧这样说不够严谨）。&lt;/p&gt;

&lt;p&gt;-&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_sync&lt;/code&gt;，同步的将block放到某个queue中，执行这个函数的线程会阻塞等待block执行完成。很容易导致死锁，目前看最好别用。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;关于dispatch_sync导致死锁的问题：
&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_sync(dispatch_get_main_queue, ...)&lt;/code&gt;这样写一定会死锁，dispatch_(a)sync这两个函数本质上是将block放到一个queue中，只不过一个会阻塞当前调用函数的线程，一个不会。&lt;/p&gt;

  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_async(dispatch_get_main_queue, ...)&lt;/code&gt;假设是main thread执行这个函数，那么线程不会等待block执行，虽然这个block是在main thread中执行的，最有可能的是在下一个loop中才会执行block。&lt;/p&gt;

  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_async(dispatch_get_global_queue(...), ...)&lt;/code&gt;假设是main thread执行这个函数，那么线程不会等待block执行，而是由系统分配另一个线程完成block，这个方式就是典型的多线程。&lt;/p&gt;

  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_sync(dispatch_get_main_queue, ...)&lt;/code&gt;假设是main thread执行这个函数，那么线程会等待block执行，但是这个block又是在main thread执行的，导致死锁。&lt;/p&gt;

  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_sync(dispatch_get_global_queue(...), ...)&lt;/code&gt;假设是main thread执行这个函数，那么线程会等待block执行，由系统分配另一个线程完成block，这个方式可用，但是最好不用main thread，而是自己创建一个serial queue。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;最后看一组代码的结果&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  // 使用系统已经提供的方法来create queue
    dispatch_queue_t serialQueue2 = dispatch_get_main_queue();
    dispatch_queue_t concurrentQueue2 = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);

    // 因此真正在代码中经常是这样写的
    dispatch_async(dispatch_get_main_queue(), ^{
        NSLog(@&quot;execute in main thread&quot;);
    });

    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        NSLog(@&quot;execute in a concurrent thread&quot;);
    });

    // 变更queue的priority
    //    dispatch_set_target_queue(concurrentQueue, serialQueue);

    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, 3ull * NSEC_PER_SEC), dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        NSLog(@&quot;dispatch_after&quot;);
    });

    dispatch_queue_t groupQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
    dispatch_group_t group = dispatch_group_create();

    // 第一个处理
    dispatch_group_async(group, groupQueue, ^{
        NSLog(@&quot;first&quot;);
    });

    // 第二个处理
    dispatch_group_async(group, groupQueue, ^{
        NSLog(@&quot;secend&quot;);
    });

    // 完成后最终的处理
    dispatch_group_notify(group, groupQueue, ^{
        NSLog(@&quot;done&quot;);
    });

    long result = dispatch_group_wait(group, DISPATCH_TIME_FOREVER);
    if (result == 0) {
        NSLog(@&quot;result done&quot;);
    }
    else {
        NSLog(@&quot;result not done&quot;);
    }
    // 需要release
    dispatch_release(group);

    dispatch_async(concurrentQueue2, ^{
        NSLog(@&quot;read1&quot;);
    });
    dispatch_async(concurrentQueue2, ^{
        NSLog(@&quot;read2&quot;);
    });

    dispatch_barrier_async(concurrentQueue2, ^{
        NSLog(@&quot;write&quot;);
    });

    dispatch_async(concurrentQueue2, ^{
        NSLog(@&quot;read3&quot;);
    });
    dispatch_async(concurrentQueue2, ^{
        NSLog(@&quot;read4&quot;);
    });

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;2016-07-09 14:46:28.500 CRHelper[3027:231293] execute in a concurrent thread
2016-07-09 14:46:28.500 CRHelper[3027:231294] first
2016-07-09 14:46:28.500 CRHelper[3027:231297] secend
2016-07-09 14:46:28.502 CRHelper[3027:231297] done
2016-07-09 14:46:28.502 CRHelper[3027:231205] result done
2016-07-09 14:46:28.507 CRHelper[3027:231297] read1
2016-07-09 14:46:28.507 CRHelper[3027:231293] read2
2016-07-09 14:46:28.507 CRHelper[3027:231390] write
2016-07-09 14:46:28.507 CRHelper[3027:231294] read3
2016-07-09 14:46:28.507 CRHelper[3027:231297] read4
2016-07-09 14:46:28.546 CRHelper[3027:231205] execute in main thread
2016-07-09 14:46:31.782 CRHelper[3027:231294] dispatch_after
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;“execute in main thread”这句话在代码顺序中是第一个但是却在倒数第二个输出，因为是在main thread执行的，可以很明确的看出来这个代码是在下一个loop中执行的，还有就是dispatch_after也并不是严格的按照3秒后执行的.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dipatch_apply&lt;/code&gt;的应用场合主要是循环在一个queue中调用某个block，可以用于处理集合。这个函数会想wait一样阻塞线程，因此在非主线程中用比较好。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    NSArray* arr = [NSArray arrayWithObjects:@1, @2, nil];
    for (NSInteger i = 0; i &amp;lt; [arr count]; i++) {
        NSLog(@&quot;%@&quot;, [arr objectAtIndex:i]);
    }
    dispatch_async(concurrentQueue2, ^{
        dispatch_apply([arr count], concurrentQueue2, ^(size_t i) {
            NSLog(@&quot;%@&quot;, [arr objectAtIndex:i]);
        });
    });
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;拾遗：&lt;code class=&quot;highlighter-rouge&quot;&gt;dipatch_semaphore&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;dipatch_suspend&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;dipatch_resume&lt;/code&gt;等。基本没用过，懒得写了。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;####&lt;span id=&quot;nsthread&quot;&gt;5.2 NSThread和performSelector&lt;/span&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;看一组代码和结果。可以看出performSelector方法是在main线程执行，而且performSelectorOnMainThread这个方法的输出在4之后，应该是这个方法会在下一个main thread的runloop中执行。1和4在测试中先后顺序不定，也比较好理解。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)doSome:(NSString*)arg
{
    NSLog(@&quot;%@ -&amp;gt; %@&quot;, [NSThread currentThread], arg);
}

- (void)startThread
{
    NSThread* th = [[NSThread alloc] initWithTarget:self selector:@selector(doSome:) object:@&quot;1&quot;];
    BOOL state = [th isMainThread];
    state = [th isCancelled];
    state = [th isFinished];
    state = [th isExecuting];

    [th start];

    [self performSelectorOnMainThread:@selector(doSome:) withObject:@&quot;2&quot; waitUntilDone:NO];
    [self performSelector:@selector(doSome:) withObject:@&quot;3&quot; afterDelay:3];

    [self performSelector:@selector(doSome:) withObject:@&quot;4&quot;];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;2016-08-28 22:40:45.055 ARCTest[3619:236163] &amp;lt;NSThread: 0x7fc0c3501b70&amp;gt;{number = 1, name = main} -&amp;gt; 4
2016-08-28 22:40:45.055 ARCTest[3619:236310] &amp;lt;NSThread: 0x7fc0c3723f30&amp;gt;{number = 2, name = (null)} -&amp;gt; 1
2016-08-28 22:40:45.077 ARCTest[3619:236163] &amp;lt;NSThread: 0x7fc0c3501b70&amp;gt;{number = 1, name = main} -&amp;gt; 2
2016-08-28 22:40:48.056 ARCTest[3619:236163] &amp;lt;NSThread: 0x7fc0c3501b70&amp;gt;{number = 1, name = main} -&amp;gt; 3
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;####&lt;span id=&quot;operation&quot;&gt;5.3 NSOperation&lt;/span&gt;
####&lt;span id=&quot;lock&quot;&gt;5.4 锁&lt;/span&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;使用：NSLock, @synchronized(self),或者使用&lt;code class=&quot;highlighter-rouge&quot;&gt;DISPATCH_QUEUE_SERIAL&lt;/code&gt;这样的形式来实现锁。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;比较：&lt;/p&gt;
    &lt;blockquote&gt;
      &lt;p&gt;NSLock控制麻烦，而且要考虑死锁。&lt;/p&gt;

      &lt;p&gt;@synchronized(self)如果很多方法都用self做锁，那么会导致一个长时间执行的方法阻塞其它方法，所以如果用最好不要都使用一个对象来作为锁对象。&lt;/p&gt;

      &lt;p&gt;GCD的锁不需要关注实现，而且是深层次实现的，比较高效，并且方法众多，可以时间多种锁的需要。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;####&lt;span id=&quot;choose&quot;&gt;5.5 多线程编程的选择&lt;/span&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;NSThread功能完善，比较基础，能够完成简单的任务。当需要同步执行或者有一定的依赖要求时编程较为复杂。&lt;/li&gt;
  &lt;li&gt;performSelector缺点很多，首先执行SEL这个东西，需要判定方法是否存在；第二、在ARC下使用如果方法创建并返回一些对象，此时如果不进行一定的处理会导致内存泄露，因为ARC下默认是不做对象的autorelease的。第三、参数传递个数有限，有时需要自己定义个对象传递多个参数。&lt;/li&gt;
  &lt;li&gt;NSOperation，功能强大尤其是对于依赖性的处理使用起来很方便。&lt;/li&gt;
  &lt;li&gt;GCD，其实使用GCD基本可以完成任何任务，包括有依赖性的任务，和NSOperation搭配起来灵活使用吧。&lt;/li&gt;
  &lt;li&gt;GCD和NSOperation的对比：&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;1）GCD是纯C语言的API,而操作队列则是Object-C的对象。&lt;/p&gt;

  &lt;p&gt;2）在GCD中，任务用块（block）来表示，而块是个轻量级的数据结构；相反操作队列中的『操作』NSOperation则是个更加重量级的Object-C对象。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;3）具体该使用GCD还是使用NSOperation需要看具体的情况&lt;/p&gt;

  &lt;p&gt;4）需要注意，如果直接使用NSOperation的start方法是直接在调用线程执行的，这意味着可能是在UI线程执行。&lt;/p&gt;

&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;NSOperation和NSOperationQueue相对GCD的好处有：&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;1）NSOperationQueue可以方便的调用cancel方法来取消某个操作，而GCD中的任务是无法被取消的（安排好任务之后就不管了）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;2）NSOperation可以方便的指定操作间的依赖关系。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;3）NSOperation可以通过KVO提供对NSOperation对象的精细控制（如监听当前操作是否被取消或是否已经完成等）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;4）NSOperation可以方便的指定操作优先级。操作优先级表示此操作与队列中其它操作之间的优先关系，优先级高的操作先执行，优先级低的后执行。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;5）通过自定义NSOperation的子类可以实现操作重用，&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;####&lt;span id=&quot;concurrent&quot;&gt;5.6 并发&lt;/span&gt;&lt;/p&gt;

</description>
        <pubDate>Fri, 16 Sep 2016 03:32:23 +0800</pubDate>
        <link>https://caihua.tech/2016/09/16/05%E7%BA%BF%E7%A8%8B/</link>
        <guid isPermaLink="true">https://caihua.tech/2016/09/16/05%E7%BA%BF%E7%A8%8B/</guid>
        
        <category>iOS学习笔记</category>
        
        
      </item>
    
      <item>
        <title>iOS学习笔记-04内存管理</title>
        <description>&lt;p&gt;##&lt;span id=&quot;memorymanage&quot;&gt;4.内存管理&lt;/span&gt;
####&lt;span id=&quot;manual&quot;&gt;4.1 手动管理&lt;/span&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;自己生成的对象自己持有，可以调用&lt;code class=&quot;highlighter-rouge&quot;&gt;release&lt;/code&gt;方法减少retain数量。&lt;/li&gt;
  &lt;li&gt;非自己生成的对象也可以持有，通过调用&lt;code class=&quot;highlighter-rouge&quot;&gt;retain&lt;/code&gt;方法可以持有对象，引用数+1。&lt;/li&gt;
  &lt;li&gt;不再需要自己持有的对象要及时释放，注意类中的property要在&lt;code class=&quot;highlighter-rouge&quot;&gt;- (void)dealloc
&lt;/code&gt;方法中赋值nil，这样写相当于release了。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)dealloc
{
    self.arr = nil;
    [super dealloc];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;无法释放非自己持有的对象，注意当一个变量持有一次对象后，只能释放一次。也就是说retainCount必须+1和-1对称。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;alloc的实现。其实就是调用calloc方法申请内存和C语言的差不多，只不过对象的头部位有个地址用于存储引用数。而retain、release就是对引用数加减，dealloc则是free掉对象。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;####&lt;span id=&quot;autorelease&quot;&gt;4.2 Autorelease &lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;autorelease这个玩意本质上是将对象加入到最近的一个NSAutoreleasePool中，当NSAutoreleasePool销毁时会将对象release。因此这里就有个坑了，如果这个pool很久都不销毁，里面的对象就始终存在，有可能会造成内存不足。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSAutoreleasePool* pool = [[NSAutoreleasePool alloc] init];

// 当调用autorelease方法时，其实是将对象obj放到了pool的一个对象列表中
NSObject* obj = [[[NSObject alloc] init] autorelease];

[pool drain]; // obj会被调用release方法

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;注意到main.m中有这样的代码，在最外层就有个autoreleasepool了。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int main(int argc, char * argv[]) {
    @autoreleasepool {
        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;####&lt;span id=&quot;arc&quot;&gt;4.3 ARC&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;我的理解
    &lt;blockquote&gt;
      &lt;p&gt;所谓ARC是通过编译器和运行时的协作来实现自动管理引用计数，编译器在ARC有效的代码中加入额外的代码来加减引用计数。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;标识
    &lt;ol&gt;
      &lt;li&gt;__strong：默认就是&lt;/li&gt;
      &lt;li&gt;__weak：需显式使用&lt;/li&gt;
      &lt;li&gt;__autoreleasing：这个标识一些情况下是不需要显式使用，一些情况下是不需要的，最为致命。&lt;/li&gt;
      &lt;li&gt;__unsafe_unretained：个人感觉已经被弃用了，在没有weak的时代使用的东西。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;__strong
    &lt;blockquote&gt;
      &lt;p&gt;这个修饰符具有持有对象的功能，与retain类似。它的使用分为如下几种情况：
1、&lt;code class=&quot;highlighter-rouge&quot;&gt;id __strong obj = [[NSObject alloc] init];&lt;/code&gt; 这行代码可以理解为如下代码，可见所谓自动管理，就是在编译出来的代码中对强引用变量调用release方法。&lt;/p&gt;

      &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;id obj = objc_msgSend(NSObject, @selector(alloc));
objc_msgSend(obj, @selector(init));
objc_release(obj);
&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;

      &lt;p&gt;2、&lt;code class=&quot;highlighter-rouge&quot;&gt;id __strong obj = [NSMutableArray array];&lt;/code&gt; 这行代码可以理解为以下代码，很有意思的代码。objc_retainAutoreleasedReturnValue是持有(retain)了一个在autoreleasepool中的对象,而这个对象就是array方法的返回值。&lt;/p&gt;

      &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;id obj = objc_msgSend(NSMutableArray, @selector(array));
objc_retainAutoreleasedReturnValue(obj);
objc_release(obj); // 离开作用域后自动释放
&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;

      &lt;p&gt;与&lt;code class=&quot;highlighter-rouge&quot;&gt;objc_retainAutoreleasedReturnValue&lt;/code&gt;成对出现的是这个方法&lt;code class=&quot;highlighter-rouge&quot;&gt;objc_autoreleasedReturnValue&lt;/code&gt;方法，对于NSMutableArray类的array方法可能是这样实现的&lt;/p&gt;
      &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ (id)array
{
  return [[NSMutableArray alloc] init];
}
&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;

      &lt;p&gt;它可以理解为如下代码&lt;/p&gt;

      &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ (id)array
{ 
     id obj = objc_msgSend(NSMutableArray, @selector(alloc));
     objc_msgSend(obj, @selector(init));
     return objc_autoreleasedReturnValue(obj);
}
&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;

      &lt;p&gt;&amp;lt;font color=green&amp;gt;对于外界调用这个方法赋值的变量来说，只是在使用一个autoreleasepool中的对象。在结合&lt;code class=&quot;highlighter-rouge&quot;&gt;objc_retainAutoreleasedReturnValue&lt;/code&gt;使用时，其实生成的对象并没有进入autoreleasepool，而是直接传递给了使用&lt;code class=&quot;highlighter-rouge&quot;&gt;objc_retainAutoreleasedReturnValue&lt;/code&gt;方法赋值的变量。&amp;lt;/font&amp;gt;&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;__weak&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;1、被__weak修饰的&amp;lt;font color=green&amp;gt;&lt;strong&gt;&lt;em&gt;变量的地址&lt;/em&gt;&lt;/strong&gt;&amp;lt;/font&amp;gt;会被放入到weak表中，这个表是个k-v形式的，key是对象的地址，value是所有引用了这个对象的变量的地址。&lt;/p&gt;

      &lt;p&gt;2、一个对象被释放的过程是个复杂的过程，&lt;/p&gt;

      &lt;p&gt;```
objc_release -&amp;gt; dealloc(如果引用计数为0) -&amp;gt; _objc_rootDealloc 
-&amp;gt; object_dispose -&amp;gt; objc_destructInstance 
-&amp;gt; objc_clear_deallocating
{
  1、用对象地址找到weak表中的value
  2、所有变量(weak表中记录了地址)赋值nil
  3、从weak表删除记录
  4、从引用计数表删除废弃对象的地址为键值的记录
}&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;blockquote&gt;
      &lt;p&gt;```
从以上的过程可以看出当对象被销毁后所有引用它的__weak变量都会被赋值为nil，这个过程是比较消耗CPU的，少用。&lt;/p&gt;

      &lt;p&gt;3、&amp;lt;font color=green&amp;gt;&lt;strong&gt;使用被__weak修饰的变量就是使用注册到autoreleasepool中的对象&lt;/strong&gt;&amp;lt;/font&amp;gt;，从以下代码来进行理解这句话，&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;blockquote&gt;
      &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 	  id __weak obj1 = obj;
    NSLog(@&quot;%@&quot;, obj1);
&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
      &lt;p&gt;这句话会大致被编译器翻译成这样&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;blockquote&gt;
      &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  id obj；
  objc_initWeak(&amp;amp;obj1, obj);
  id tmp = objc_loadWeakRetaind(&amp;amp;obj1);
  objc_autorelease(tmp);
  NSLog(@&quot;%@&quot;, tmp);
  objc_destroyWeak(&amp;amp;obj1);
&lt;/code&gt;&lt;/pre&gt;
      &lt;/div&gt;
    &lt;/blockquote&gt;

    &lt;blockquote&gt;
      &lt;p&gt;可以看到为了能够NSLog执行时obj1引用的对象不被销毁，需要将它赋值给一个strong(默认)修饰的临时变量，而这个临时变量需要放到autoreleasepool中，因此存在一个问题，当你多次在一个作用域中多次使用weak修饰的变量，会导致很多临时变量产生而且会放到autoreleasepool中，作用域结束后autoreleasepool有很多工作要做。所以少用weak，一般就是避免循环引用。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;__autoreleasing，核心就是把修饰的变量放入到autoreleasepool中，没啥多说的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;注意事项：
    &lt;ol&gt;
      &lt;li&gt;不能使用retain、release、retainCount、autorelease这样方法&lt;/li&gt;
      &lt;li&gt;不能使用NSAllocateObject和NSDeallocateObject方法，实际上我根本没用过。&lt;/li&gt;
      &lt;li&gt;需要在函数命名时遵守规则，比如alloc\new\copy\mutableCopy必须给与调用者对象持有权限。&lt;/li&gt;
      &lt;li&gt;不能使用NSAutoreleasePool，可以用@autoreleasepool替换。&lt;/li&gt;
      &lt;li&gt;dealloc方法不能显示调用，很明显的例子就是在MRC中写dealloc方法时一定要调用super的dealloc方法，但是在ARC中不行了，不过notificationCenter的删除等处理还是要写在dealloc方法中的，会自动调用。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 16 Sep 2016 03:32:23 +0800</pubDate>
        <link>https://caihua.tech/2016/09/16/04%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</link>
        <guid isPermaLink="true">https://caihua.tech/2016/09/16/04%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</guid>
        
        <category>iOS学习笔记</category>
        
        
      </item>
    
  </channel>
</rss>
