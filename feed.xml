<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>笛音夏扇</title>
    <description>Be publicly useful and privately happy.</description>
    <link>https://caihua.tech/</link>
    <atom:link href="https://caihua.tech/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sat, 25 Feb 2017 17:05:53 +0800</pubDate>
    <lastBuildDate>Sat, 25 Feb 2017 17:05:53 +0800</lastBuildDate>
    <generator>Jekyll v3.2.1</generator>
    
      <item>
        <title>游戏设计模式读书笔记：双缓冲</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;第三篇：序列模型&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;双缓冲模式算是书中第三篇：序列模型中的一个，它与游戏循环和更新方法组成了第三篇。后两者可以说是在我做Unity中最常用到的，而且也是游戏引擎本身已经实现了的。谨以&lt;a href=&quot;http://gpp.tkchu.me/sequencing-patterns.html&quot;&gt;下文&lt;/a&gt;来说明下序列模型部分的重要性。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;电子游戏之所有有趣，很大程度上归功于它们会将我们带到别的地方。 几分钟后（或者，诚实点，可能会更长），我们活在一个虚拟的世界。 创造那样的世界是游戏程序员至上的欢愉。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;大多数游戏世界都有的特性是时间——虚构世界以其特定的节奏运行。 作为世界的架构师，我们必须发明时间，制造推动游戏时间运作的齿轮。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;这本篇的模式是建构这些的工具。 游戏循环是时钟的中心轴。 对象通过更新方法来聆听时钟的滴答声。 我们可以用双缓冲模式存储快照来隐藏计算机的顺序执行，这样看起来世界可以进行同步更新。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section-1&quot;&gt;双缓冲&lt;/h2&gt;
&lt;h4 id=&quot;section-2&quot;&gt;一个典型的例子&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;这个例子非常经典，就是渲染时候的双缓冲。只有当一帧的色值数据完全计算出来后，才能在屏幕上展示出来，如果在计算的同时就开始渲染，那么屏幕只会出现一部分的色彩。所以我们在屏幕看到的色彩值其实往往是GPU算出的上一帧的数据。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-3&quot;&gt;使用场景&lt;/h4&gt;
&lt;blockquote&gt;
  &lt;p&gt;我们需要维护一些被逐步改变着的状态量。&lt;/p&gt;

  &lt;p&gt;同个状态可能会在其被修改的同时被访问到。&lt;/p&gt;

  &lt;p&gt;我们希望避免访问状态的代码能看到具体的工作过程。&lt;/p&gt;

  &lt;p&gt;我们希望能够读取状态但不希望等到写入操作的完成。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;section-4&quot;&gt;我对双缓冲的理解&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;说白了，双缓冲是为了维护完整性。它展示给外界的永远是一个完整的，已经准备好被使用的内容。在其内部，有一个缓冲是用于写入数据的，写入的过程可能是缓慢的，但是没关系，另一个缓冲已经做好了被使用的准备，外界读取的是这个已经写好的缓冲。&lt;/li&gt;
  &lt;li&gt;当写入完成时，两个缓冲互换，刚刚写完的这个缓冲变为准备被读取的一个，而被读取的缓冲开始作为写入缓冲使用。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-5&quot;&gt;设计决策&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;缓冲区如何交互？
    &lt;ul&gt;
      &lt;li&gt;在文中作者使用的是C++，因此交换只不过是一个指针重定向的过程。&lt;/li&gt;
      &lt;li&gt;如果不能指针重定向，就要考虑数据拷贝了。&lt;/li&gt;
      &lt;li&gt;C#中一个集合对象表现出来的也是一个指针（引用），可以直接做重定向。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;缓冲的粒度
    &lt;ul&gt;
      &lt;li&gt;书中提到两个粒度，一个是缓冲区是单个整体，也就是渲染的时候一个图像的内容就在一个缓冲区中。&lt;/li&gt;
      &lt;li&gt;另一种情况就是多个对象中都存在一个缓冲数据。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sat, 25 Feb 2017 16:43:13 +0800</pubDate>
        <link>https://caihua.tech/2017/02/25/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%8F%8C%E7%BC%93%E5%86%B2/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/02/25/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%8F%8C%E7%BC%93%E5%86%B2/</guid>
        
        <category>游戏设计模式读书笔记</category>
        
        
      </item>
    
      <item>
        <title>游戏设计模式读书笔记：观察者模式与事件队列</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;观察者模式&lt;/h2&gt;
&lt;h4 id=&quot;section-1&quot;&gt;定义&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F&quot;&gt;定义&lt;/a&gt;：在此种模式中，一个目标对象管理所有相依于它的观察者对象，并且在它本身的状态改变时主动发出通知。这通常透过呼叫各观察者所提供的方法来实现。此种模式通常被用来实时事件处理系统。&lt;/li&gt;
  &lt;li&gt;看图
&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/e/e2/Observer-pattern-class-diagram.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-2&quot;&gt;模式的理解&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;观察者模式由来已久，其目的就是为了解耦。观察对象保存观察者的链接，使得观察者与被观察者解耦。这一点与C#中的事件刚好相反。&lt;/li&gt;
  &lt;li&gt;传统的观察者模式也有其弊端。比如书中提到的使用链表作为观察者集合时，如果删除某个观察者需要遍历。并且每个观察者只有一个next指针的情况，这就使得它只能观察一个对象。当然作者也给出来解决的办法，就是使用链表节点池来解决一个观察者注册多个被观察者的问题。不过在C#的事件系统中这个是不需要的。&lt;/li&gt;
  &lt;li&gt;当出现被观察者或者观察者销毁时需要额外的注意。一个被观察者销毁产生的问题比较小，因为最多就是不发送消息了。而如果一个观察者销毁但是被观察者还不知道，那么被观察者会发送一个消息给空指针，这样问题就大。 在C#中这个问题也是一样的，当要dispose的时候，需要使用&lt;code class=&quot;highlighter-rouge&quot;&gt;-=&lt;/code&gt;操作来去掉观察引用。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-3&quot;&gt;观察则模式和事件的区别&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;长久以来我都认为C#中的事件就是观察者模式，当然实际上有所差别。因为按照经典的设计模式来说观察者是需要类的支持的，当你需要让某个对象可被观察，并为此创建几个观察者时你需要执行诸如继承这样的典型的面向对象编程，需要做一大摊子的事情。但是，很多情况下我们只是希望一个类中的某个对象被观察，也就是一个对象中可能发生多个&lt;code class=&quot;highlighter-rouge&quot;&gt;事件&lt;/code&gt;。这也是C#中事件系统所作的事情，在C#中我们观察的是一个对象，而不是一个事情。（参考原文的旁白说明。）&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;unity&quot;&gt;在unity中的使用&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;这个其实没啥说的，就按照标准的C#程序中使用事件的方式即可，只不过我比较习惯用Action或者Func来替代delegate+event。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-4&quot;&gt;事件队列&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;对于事件队列，不要只认为是事件，它也包含消息或者请求等等。按照我的理解来说就是一个具体要做的事情。&lt;/li&gt;
  &lt;li&gt;为何要把事件队列和观察者模式写到一起，因为在我看了它们的作用是一样的，就是为了解耦消息的发送者（被观察者）和接受者（观察者）。事件队列在复杂度上要高于观察者模式，这个是因为事件队列在时间上做了进一步的解耦。&lt;/li&gt;
  &lt;li&gt;怎么理解时间上的解耦？事件队列在接收到一个事件后，何时执行是不确定的。考虑到事件会带上发生时的数据，那么在执行时是不需要依赖时间的。&lt;/li&gt;
  &lt;li&gt;时间的解耦有个弊端，就是如果你需要实时反馈，那么这个做不到。&lt;/li&gt;
  &lt;li&gt;还有一个需要注意的是不要形成消息和处理者的循环。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-5&quot;&gt;消息汇总与合并&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;书中作者提到了一个声音播放系统，当队列中存在多个相同音频的请求时需要进行合并。当然这个是因为同一音频短时间内容播放会出现音爆。不过这个也提醒了我们，如果在实际的业务中有这样需要合并的时候，在每个update（也就是要开始执行某个事件时）中要进行合并。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-6&quot;&gt;如何实现队列&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;作者提到了循环缓冲区的问题，通过使用一个数组来实现消息队列，这样可以有效的减少内存的使用。不过我认为弊端就不好定一个数组的大小，如果过小可能来不及做循环，而如果太大一样存在内存的浪费。&lt;/li&gt;
  &lt;li&gt;从C#角度看，这个队列可以Queue来实现，可以说是完美契合的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-7&quot;&gt;设计决策&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;入队的是什么：
    &lt;ul&gt;
      &lt;li&gt;事件：如果是事件需要考虑多监听器的情况下让监听器做过滤。其实这个就是一个观察者模式。在这里就有点像异步观察者模式。&lt;/li&gt;
      &lt;li&gt;消息：一般消息都是一对一的，这个其实也是异步的意思。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;谁能从队列里读取：
    &lt;ul&gt;
      &lt;li&gt;事件的话轮到了执行就好，有没有监听者无所谓。如果是一个固定类型的消息，那么可能就是一个具体的业务的方法来获取队列中的消息了。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;谁能写入队列：
    &lt;ul&gt;
      &lt;li&gt;如果只有一个写入者，那么这个东西在时间上会执行的很快，和同步的观察者模式差不多。&lt;/li&gt;
      &lt;li&gt;如果是多个写入者，需要将发送方本身的引用加入到事件的数据当中。就像我们在C#中开发基于UI的程序一样，如果你有经验会知道每个事件处理函数中第一个参数总是某个具体的控件。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;队列中对象的生命周期
    &lt;ul&gt;
      &lt;li&gt;在我看来应该就是事件出队列时就是其周期的结束，当然因为GC的问题这个对象也许并不会立刻被销毁。&lt;/li&gt;
      &lt;li&gt;书中提到了可以将对象的所有权进行转移，到具体的执行方去。也可以让队列一直拥有它。这个方面我还没有觉得有这个必要保留对象，也许是没有遇到一个典型的例子吧。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Sat, 25 Feb 2017 13:11:05 +0800</pubDate>
        <link>https://caihua.tech/2017/02/25/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E4%B8%8E%E4%BA%8B%E4%BB%B6%E9%98%9F%E5%88%97/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/02/25/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E4%B8%8E%E4%BA%8B%E4%BB%B6%E9%98%9F%E5%88%97/</guid>
        
        <category>游戏设计模式读书笔记</category>
        
        
      </item>
    
      <item>
        <title>《Unity預計算即時GI》笔记：三、Clusters和总结</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;说明&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;这篇文章是对&lt;a href=&quot;http://unitytaiwan.blogspot.tw/2016/12/unity-gi-1.html&quot;&gt;《Unity預計算即時GI》&lt;/a&gt;这个系列文章的笔记。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;clusters&quot;&gt;Clusters&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;叢集，透過修改叢集(Clusters)也是一個降低Unity預計算流程所需要執行的工作數量的好方法。降低叢集數量也能提高執行時的效能。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;當採用PRGI來計算場景光照時，Unity會簡化產生一個立體像素化結構的計算，這些立體像素(Voxel)叫做叢集。叢集實際上是反映到場景靜態幾何表面用於照明的表面，叢集用一種層級關聯的結構來儲存，用來預計算Unity的全域光照漫反射所需要的複雜運算。雖然叢集和光照圖很像，但兩者用途是各自獨立的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;通过设置CPU Usage即可。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;微調光照參數&lt;/h2&gt;

&lt;h4 id=&quot;section-2&quot;&gt;创建&lt;/h4&gt;
&lt;blockquote&gt;
  &lt;p&gt;要建立一個Lightmap Parameters資源，先找到Project視窗,
從Create下拉選單建立(Create &amp;gt; Lightmap Parameters)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;我們也可以在Project介面裡按右鍵選(Asset &amp;gt; Create &amp;gt; Lightmap Parameters) 來建立。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;section-3&quot;&gt;使用&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;從Hierarchy介面選擇你要指定變數集的物件，物件必須是帶有Mesh Renderer元件的靜態物件。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;開啟Lighting介面(Window &amp;gt; Lighting)並選擇Object頁籤&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;從Advance Parameters下拉選單指定你的變數集給物件，右邊的”Edit”按鈕是開啟編輯光照變數的捷徑。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-4&quot;&gt;光照參數集說明&lt;/h3&gt;

&lt;h4 id=&quot;resolution&quot;&gt;Resolution&lt;/h4&gt;
&lt;blockquote&gt;
  &lt;p&gt;解析度的值確訂了物件採用的光照貼圖解析，這個值會和Lighting介面裡的解析度做加乘。比如說，如果場景解析度設為2，這裡的解析度設為0.5，那所有帶有這個參數集的物件都會採用1texel/unit來計算光照貼圖。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;这个&lt;code class=&quot;highlighter-rouge&quot;&gt;Lighting介面裡的解析度&lt;/code&gt;指的是&lt;a href=&quot;https://unity3d.com/cn/learn/tutorials/topics/graphics/fine-tuning-lightmap-parameters?playlist=17102&quot;&gt;Scene-wide Realtime Resolution specified in the Scene tab of the Lighting window&lt;/a&gt;，翻译的时候没说清楚啊。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;irradiance-budget&quot;&gt;Irradiance Budget&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://unity3d.com/sites/default/files/dappling.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;解析度值很大光照貼圖所產生的影子斑點可以把Irradiance Budget這個參數調高來獲得緩解。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;注意，當解析度值很大時，在較低解析度下可能會產生奇怪的陰影，這些陰影在最終的光照貼圖裡可能看起來像是斑點或髒汙。如果有這種情況可以試著把Irradiance Budget參數提高來獲得改善。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;cluster-resolution&quot;&gt;Cluster Resolution&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;叢集解析度用來決定1個像素裡能有多少叢集數量。假如這個值設為1，代表光照圖裡面每個像素都都會有一個叢集，0.5代表一個像素會有2個叢集，換句話說叢集會是光照圖的兩倍大。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;imagine our Scene’s global Realtime Resolution was set to 1. We create a cube with a size of 1x1x1 units, and then assign a Lightmap Parameters asset to this object. If our Lightmap Parameters asset specified a Resolution of 1 and a Cluster Resolution of 1, we would have 1 Cluster per side of the cube. If we then increased our Resolution to 2, the result would be 2x(1x1) Clusters per side of the cube, giving 4 Clusters.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;將光照貼圖解析和叢集解析度保持指定比例，這樣我們可以和場景整體的解析度建立一個相對關係。我們可以把Lighting介面裡面的解析度定義為高解析度作為整體設定，然後針對個別物
件微調各自的光照參數集。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;说白了，数值越大单位像素上cluster越多，与计算时间越长。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;irradiance-budget-1&quot;&gt;Irradiance Budget&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;我們之前說明過光照計算是如何用叢集來計算靜態物件的預計算光照，在預計算的過程裡，叢集之間的關係被建立起來，好讓光線得以在叢集網內快速傳遞。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;在本質上，光照貼圖像素值的算法是基於叢集從該像素的位置對場景的一個檢視所計算得來，這會讓我們可以很快計算叢集之間的光照反射最後產生一個全域光照，這些叢集就能在畫面渲染完之前給予適當的樣本數。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Irradiance Budget(輻照度範圍)用來制訂當叢集採樣時每個光照貼圖像素所使用到的記憶體量，&lt;strong&gt;這會決定照明結果的精度，數值太低代表每個貼圖像素在記錄時使用較少記憶體同時提升CPU效能，代價就是會失真，數值越低光照結果會越模糊。反過來看，數值拉高GI會更準確，但記憶體和CPU的消耗都會提升。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;越低效率越高，适合大精细的模型，很大、模糊或者遥远的模型。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;irradiance-quality&quot;&gt;Irradiance Quality&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;當計算PRGI時，每個光照貼圖像素會開始對場景投出射線，然後將可視資料報告給附近的叢集，然後貼圖像素就會得到每個叢集的百分比數值，這個值用來定義光照貼圖裡每個像素從叢集所分到的可視數據，&lt;strong&gt;而一欄設定就是用來設定每個像素能對場景投射多少射線。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果場景裡的物件和周圍物件光照不合的情況下可以斟酌加大這個值，有時該暗的時候光照結果卻意想不到的亮，有可能是因為投射到場景的射線不足或遮擋到，導致漏算叢集資料。同樣該亮的的放如果射線沒有檢查到，可能會造成過暗。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;提高射線的投射量就能解決類似的問題，代價就是增加預計算的時間，要優化這個時間，我們應該找出最適合的值來達到我們理想的照明效果。請注意，這個值不會影響到Runtime時的效能。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;-还是越大越耗性能。&lt;/p&gt;

&lt;h4 id=&quot;backface-tolerance&quot;&gt;Backface Tolerance&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;當射線從光照貼圖像素投射出，從場景叢集蒐集光線時有時會打到幾何的背面，當計算全域光照時我們只需要關心投射到物體表面的光照，從背面來的光照資源通常都會忽略掉，這些從背面來的光照資料會破壞光照結果，因此調整這個值能防止這類情況發生。
&lt;img src=&quot;https://unity3d.com/sites/default/files/backfacetolerance.png&quot; alt=&quot;image&quot; /&gt;
這裡的地板上的陰影就是Unity在計算期間從物件無效的背面所創造的，增加Backface Tolerance能改善這個問題。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Backface Tolerance必須指定從前方光源來的百分比，好讓正面的像素被判定為有效。假如一個貼圖像素沒通過測試，Unity會採用鄰近的像素值嘗試算得正確光照資料。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;調整這個值並不會影響PRGI運算效能，也不會對預計算時間長度有太大影響。反而是蠻適合在調整Irradiance Budget都無法解決的場景貼圖太亮或太暗問題時，Backface tolerance會是一個不錯的除錯工具。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;調整這個值並不會影響PRGI運算效能，也不會對預計算時間長度有太大影響。2333333333&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-5&quot;&gt;总结&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;學習如何評估專案場景並決定適合的光照解析度
了解光照圖，PRGI過程中最耗效能的元素之一，並學習如何降低它的數量。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;核心，需掌握。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;學習如何幫小物件設定光照探針。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;蛋疼的玩意。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;學習如何調整Unity的預計算參數，讓拆UV過程可以減少光照圖的數量。
了解甚麼是叢集，如何使用與它對全域光照的影響。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;核心，需掌握。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;學習如何微調影響場景物件的光照貼圖變數，在不失真的情況下還能提高預計算效能。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;还是比较有用的，主要还是通过影响cluster。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;个人总结：这个系列的文章本质上是讲的如何减少光照图。通过改变分辨率、优化UV展开的结果等手段来实现。不过这篇文章如果单纯的看有点单薄，建议结合&lt;a href=&quot;http://mp.weixin.qq.com/s/uYX4T-fTgWxz_fWr6G4dPA&quot;&gt;《Unity 5 中的全局光照技术详解！》&lt;/a&gt;这篇文章看。回头看完在写笔记。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-6&quot;&gt;这个系列文章中提到的一些有意思的点&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;PRGI只會呈現場景裡的漫反射(diffuse)和間接照明&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Unity的拆解演算法會嘗試把不同Shell做調整將UV邊緣拼接在一起來簡化UV貼圖&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在某些情況下，網格匯入器可能會拆開幾何圖形。例如，如果有個網格有非常多的三角面，Unity可以為了效能把它分割成幾個獨立的子網格。通常這麼做是為了符合特定硬體需求，例如為了減少每個Draw Call所需要呼叫的三角面數量。分割通常會發生在相鄰的網格面之間法向角度有大變化的區域，比如銳角邊(hard edges)。這樣的拆分網格方式會在模型導入流程時執行，在這個過程中，UV Shell也可能會被拆分開來放到不同的光照圖，造成額外的光照圖消耗。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;當計算PRGI時，每個光照貼圖像素會開始對場景投出射線，然後將可視資料報告給附近的叢集，然後貼圖像素就會得到每個叢集的百分比數值，這個值用來定義光照貼圖裡每個像素從叢集所分到的可視數據&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;當計算PRGI時，每個光照貼圖像素會開始對場景投出射線，然後將可視資料報告給附近的叢集，然後貼圖像素就會得到每個叢集的百分比數值，這個值用來定義光照貼圖裡每個像素從叢集所分到的可視數據。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Wed, 22 Feb 2017 22:47:53 +0800</pubDate>
        <link>https://caihua.tech/2017/02/22/Unity%E9%A0%90%E8%A8%88%E7%AE%97%E5%8D%B3%E6%99%82GI-%E7%AC%94%E8%AE%B0-%E4%B8%89-Clusters%E5%92%8C%E6%80%BB%E7%BB%93/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/02/22/Unity%E9%A0%90%E8%A8%88%E7%AE%97%E5%8D%B3%E6%99%82GI-%E7%AC%94%E8%AE%B0-%E4%B8%89-Clusters%E5%92%8C%E6%80%BB%E7%BB%93/</guid>
        
        <category>Unity預計算即時GI笔记</category>
        
        
      </item>
    
      <item>
        <title>《Unity預計算即時GI》笔记：二、光照图</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;说明&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;这篇文章是对&lt;a href=&quot;http://unitytaiwan.blogspot.tw/2016/12/unity-gi-1.html&quot;&gt;《Unity預計算即時GI》&lt;/a&gt;这个系列文章的笔记。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;光照图&lt;/h2&gt;

&lt;h3 id=&quot;section-2&quot;&gt;什么是光照图&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;光照图在第三章中有如下的定义，读起来很是费解。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;一個光照圖(Chart)是表示一個光照貼圖的區域，用來映射場景物件的光照貼圖UV。你可以想像是能影響物件的一張小磁磚圖，一張光照圖由兩部分組成:輻照度(照明)和方向性(主要光線方向編碼)。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;到了第六章又有如下讲解，读完之后我更加费解了，所以暂时搁置吧。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;產生光照圖(Charts)的目的主要是用來包住靜態網格著色器(Static Mesh Renderer)的UV貼圖座標。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-3&quot;&gt;如何生成&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;一個物件所需要的光照圖數量主要是看物件有多少片UV shell需要拆解。所謂拆UV的學問就是保持幾何面上貼圖像素扭曲度和所需的Shell數量之間的平衡。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;光照圖是在網格導入流程的一個拆解階段(Unwrapping stage)被產生出來的。對於PRGI來說，這些光照圖會在預計算裡的幾何階段(Geometry stage)被打包到不同的圖集(Atlas)裡，這是為了確保它們不會相互重疊。一旦預計算的幾何階段完成之後就會產生可視化數據，我們就能預覽光照圖。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;这个部分要结合&lt;a href=&quot;http://unitytaiwan.blogspot.tw/2016/12/unitygi-6.html&quot;&gt;原文&lt;/a&gt;的图来看，从这个部分的文章中可以看到，在模型导入时决定了它需要几个光照图，而&lt;code class=&quot;highlighter-rouge&quot;&gt;場景裡面有大量的光照圖可能會是PRGI耗時的原因之一&lt;/code&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;从上下文的介绍来看，光照图是光照贴图的映射，记录了实时计算的结果，当计算光照时，需要从中提取信息。&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;看看下列範例圖:&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://unity3d.com/sites/default/files/unwrap01.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;這樣的UV拆解不會變形，但需要多張UV shells&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://unity3d.com/sites/default/files/unwrap02.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;用單一UV shell所產生的結果，但貼圖變形很嚴重&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://unity3d.com/sites/default/files/unwrap03.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;比較理想的結果，單一UV shell且貼圖沒有變形&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;從上面我們可以看到三個拆UV不同的例子&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;從第一張圖裡我們可以看到做為貼圖的棋盤格圖案像磁磚一樣保持比例的貼在方塊表面上並沒有變形。試想如果這個棋盤圖案是一個光照貼圖(一個打在物件上的光照圖像)，我們會得到一個視覺上看起來沒有問題的結果，只是會需要耗費六個UV shells。那就表示待會用Unity PRGI計算的時候也會產生六張光照圖，不管條件如何，每個光照圖最少都需要4x4個貼圖像素來表示，還沒考慮解析度之前最少就會耗掉96個像素。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;在第二張圖裡我們會遇到不同的狀況，物件的UV貼圖座標只用一個UV shell就涵蓋所有範圍，雖然這樣所產生的光照圖最少，但視覺效果卻不是我們要的。我們會看到物件表面上的貼圖歪掉了，貼圖在UV空間裡也相互重疊，代表如果這是一張光照貼圖，物件一面的光照可能會錯投到相反面上。很明顯的這種拆法是有問題的。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;**第三張圖的結果比較理想，棋盤沒有扭曲，磁磚比例也保持正方形。而且還成功用一張UV shell覆蓋物體的所有面。屆時透過連接或縫合對應在模型上的邊緣來把位置合上。 
如果用技術的邏輯來看，整個過程做了哪些事情呢? 首先，我們會將UV圖用正交投影(Orthogonal Projection)在物件上來產生獨立的Shell，然後我們就會分析哪些Shell和物件的邊緣有相連關係，一旦我們找到了這些邊緣，我們就會把UV shell的內容移進去並和相鄰的Shell縫合起來。 **&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-4&quot;&gt;如何查看已经生成的光照图&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;首先需要生成LightingData数据，将场景中的模型勾选static，然后在light window中点击build(也可以选择Auto) 。&lt;/li&gt;
  &lt;li&gt;场景窗口中选择，&lt;code class=&quot;highlighter-rouge&quot;&gt;UV Charts模式會把場景裡不同光照圖用不同顏色表示&lt;/code&gt;
&lt;img src=&quot;https://unity3d.com/sites/default/files/charting.png&quot; alt=&quot;image&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-5&quot;&gt;如何减少光照图&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;需要对以下几个参数进行设置&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://unity3d.com/sites/default/files/maxdistance.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;先放一下原模型的图，后续会有大量的结果图。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://images2015.cnblogs.com/blog/23250/201702/23250-20170214120221660-1264214124.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;auto-uv-max-distanceuv&quot;&gt;Auto UV Max Distance(自動最大UV距離)&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;Unity的拆解演算法會嘗試把不同Shell做調整將UV邊緣拼接在一起來簡化UV貼圖。當Shell放入後還能保持在Auto UV Max Distance規定的範圍內時才會被考慮進來。這個範圍是用Unity的世界空間座標來定義的，在我們的範例裡是1米。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;在許多情況下，預設的0.5就能給出不錯的結果，但對於具有大面積的特大物件可能要提高這個值來防止本來應該被縫合的UV圖被演算法排除在外。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;增加這個值通常會讓物件所需的光照圖數量減少，而降低這個值通常有助於解決貼圖像素被拉扯的問題，當然就會需要產生更多的光照圖來覆蓋。改變這個值後你可以透過檢視場景UV Charts繪製模式，從覆蓋的棋盤圖來評估並實驗出一個最好的平衡點。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;这个属性应该是用于控制拼接UV图的，值越大就会使得原本一些间距比较大的shell能够进行合并，这样就可以减少光照图的数量。&lt;/li&gt;
  &lt;li&gt;做了一个简单的测试，分别设置为0.1、0.5、0.8。明显可以看出来，当数值很小的时候会分出更多的光照图，而且从浅蓝色线条可以看出是模型的边。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://images2015.cnblogs.com/blog/23250/201702/23250-20170213125059160-379163503.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Auto UV Max Distance:0.1  /  Auto UV Max Angle:89&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2015.cnblogs.com/blog/23250/201702/23250-20170213125103254-453985663.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Auto UV Max Distance:0.5  /  Auto UV Max Angle:89&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2015.cnblogs.com/blog/23250/201702/23250-20170213125105004-1204223525.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Auto UV Max Distance:0.8  /  Auto UV Max Angle:89&lt;/p&gt;

&lt;h4 id=&quot;auto-uv-max-angleuv&quot;&gt;Auto UV Max Angle(自動最大UV角度)&lt;/h4&gt;
&lt;blockquote&gt;
  &lt;p&gt;提高這個值會讓Unity的演算法更容易組合UV圖，這也表示能透過這個功能來降低單一物件的光照圖數量，但是如果設的太寬鬆有時候會出現貼圖被拉扯的狀況。反之降低這個值會造成演算法不好把相鄰的UV排一起，雖然拉扯的情況會降低但是會產生更多光照圖。相同，檢視UV Charts繪製模式裡的棋盤圖並試出一個最適合的值。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;基本原理和Auto UV Max Distance一直，更大的数值使得更多比较扭曲的UV Shell能够合并，弊端也说的比较明确。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;以下仍旧是一组对比图&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://images2015.cnblogs.com/blog/23250/201702/23250-20170214111950769-2033724574.jpg&quot; alt=&quot;image&quot; /&gt;
Auto UV Max Distance:0.5  /  Auto UV Max Angle:50&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2015.cnblogs.com/blog/23250/201702/23250-20170213125103254-453985663.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Auto UV Max Distance:0.5  /  Auto UV Max Angle:89&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2015.cnblogs.com/blog/23250/201702/23250-20170214112002129-1529342405.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Auto UV Max Distance:0.5  /  Auto UV Max Angle:120&lt;/p&gt;

&lt;h4 id=&quot;preserve-uvsuv&quot;&gt;Preserve UVs(保留UV)&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;在某些情況下，自動拆UV如果無法獲得理想結果，可能會產生過多的光照圖或是貼圖失真(GI Charts繪製模式可以做拉扯檢查)。在這種情況下可能需要在模型的UV01通道手動建立UV。這必須要在其他工具完成。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果這種情況發生，我們可以在Preserve UVs選項讓Unity演算法強制採用模型UV01通道指定的UV Shell。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;當需要手動保持UV圖時，Preserve UVs選項很有用&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;要注意的是這些Shell會被重新打包來節省光照貼圖空間，它們會被單獨解開保留，而不是只有把在光照貼圖內的座標記錄起來而已。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;使用這個功能時必須小心，當指定的UV貼圖包含著大量的UV shells時，這個功能可能會讓預計算的時間拉長，因為Unity的拆解演算法被跳過，手動保留的UV Shells到時候會全餵給預計算流程。記住，最好的結果是儘可能的降低UV shells和光照圖並保持可以接受的貼圖拉扯範圍。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;感觉大多数时间是不需要这个东西的，即使unity自己UI展开的不好如果不伤大雅也可以不用。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;生成的图放到下面进行对比&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;ignore-normals&quot;&gt;Ignore Normals(忽略法線)&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;在某些情況下，網格匯入器可能會拆開幾何圖形，這也會影響到光照圖的數量。例如，如果有個網格有非常多的三角面，Unity可以為了效能把它分割成幾個獨立的子網格。通常這麼做是為了符合特定硬體需求，例如為了減少每個Draw Call所需要呼叫的三角面數量。分割通常會發生在相鄰的網格面之間法向角度有大變化的區域，比如銳角邊(hard edges)。這樣的拆分網格方式會在模型導入流程時執行，在這個過程中，UV Shell也可能會被拆分開來放到不同的光照圖，造成額外的光照圖消耗。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;信息量略大，首先为了减少Draw Call时三角形面数过多，unity在导入网格是进行拆分，自然这就导致了产生一些多余的UV Shell。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Ignore Normals選項可以防止模型在匯入時光照圖被拆開&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;有時候放著上述的問題不管不太值得，得到的結果讓光照圖數量增加拉長了預計算的時間，還有可能在照明的接縫造成不必要的視覺假象。在這樣的情況下，啟用Ignore Normals選項有助於防止光照圖在預計算的時候被分割開來。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;請注意，這個選項只有對預計算即時光照(PRGI)有影響，物件被拆分的網格仍然會被保留以用在其他用途。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;挺好，只是为了PRGI，正常的网格还是会被拆分已做别的用途。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;最后放下结果对比&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://images2015.cnblogs.com/blog/23250/201702/23250-20170214113959175-1239106089.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Auto UV Max Distance:0.5  /  Auto UV Max Angle:89 / 使用模型UV&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2015.cnblogs.com/blog/23250/201702/23250-20170213125103254-453985663.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Auto UV Max Distance:0.5  /  Auto UV Max Angle:89&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2015.cnblogs.com/blog/23250/201702/23250-20170214114011285-1460825901.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Auto UV Max Distance:0.5  /  Auto UV Max Angle:89  / 忽略法线&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;目测这个模型按照默认设置效果就挺好的。&lt;/li&gt;
  &lt;li&gt;后续讲了一些实际的操作，还是自己读文章吧。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-6&quot;&gt;光照图总结&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;目前来看整个PRGI的大头在于光照图，而如何减少光照图是重中之重。&lt;/li&gt;
  &lt;li&gt;参数虽然都已经很清楚，而且UV Charts中可以看到具体的效果。不过，在多个模型的场景中每个模型做优化也是个很费时间的事情。&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Wed, 22 Feb 2017 22:46:02 +0800</pubDate>
        <link>https://caihua.tech/2017/02/22/Unity%E9%A0%90%E8%A8%88%E7%AE%97%E5%8D%B3%E6%99%82GI-%E7%AC%94%E8%AE%B0-%E4%BA%8C-%E5%85%89%E7%85%A7%E5%9B%BE/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/02/22/Unity%E9%A0%90%E8%A8%88%E7%AE%97%E5%8D%B3%E6%99%82GI-%E7%AC%94%E8%AE%B0-%E4%BA%8C-%E5%85%89%E7%85%A7%E5%9B%BE/</guid>
        
        <category>Unity預計算即時GI笔记</category>
        
        
      </item>
    
      <item>
        <title>《Unity預計算即時GI》笔记：一、基本概念与一些设置</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;说明&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;这篇文章是对&lt;a href=&quot;http://unitytaiwan.blogspot.tw/2016/12/unity-gi-1.html&quot;&gt;《Unity預計算即時GI》&lt;/a&gt;这个系列文章的笔记。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;基本概念&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;在Unity裡，可以用兩種不同的技術來計算全域光照GI或光源反射，就是烘焙全域光照(Baked GI)和預計算即時全域光照(Precomputed Realtime GI)。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;當啟用PRGI時，一個光照預計算就是用來計算靜態幾何物件周圍光的反射，並存成資料給Runtime執行使用的一個過程。這個過程減少了原本必須在Runtime執行時的光照計算數量，讓專案得以在保持FPS的穩定之下還能計算光的反射。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;baked-gi&quot;&gt;与Baked GI有什么不同&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;先看下5.X中Baked GI的定义
    &lt;blockquote&gt;
      &lt;p&gt;當啟用烘焙GI(Baked GI)時，預計算的過程會計算並產生傳統的光照貼圖(Lightmap)，這些貼圖會以資源(Assets)的形式存在專案中，而且無法再Runtime執行時更改。PRGI並非用一樣的方法產生光照貼圖，相反的，PRGI算好的結果會被存成一個光照資料檔(Lighting Data Asset)，這個資料檔存的資料能讓專案在Runtime執行時能即時產生一組低解析度的光照圖。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;从本质上看就是PRGI还是实时计算的，只不过光的反射路径已经提前计算了，因此在实际的光照计算时会减少计算量，进而提升效率。而Baked GI仍旧是传统的light map的机制。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;prgi&quot;&gt;PRGI的相关设置&lt;/h2&gt;

&lt;h4 id=&quot;realtime-resolution&quot;&gt;Realtime Resolution的设置&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;设置的依据&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Realtime Resolution的值可以由你的遊戲規模來制定，例如，是否你的場景是一個小小的，卻有豐富光照變化的室內環境? 在這種情況下，高一點的值比如2-3，可以捕捉更詳細或”高頻”的光照。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果你的場景是一個世界規模較大的大型戶外環境。可能有著幾千或幾百個物件表面幾乎不會去修改光照反射顏色。在這樣的情況下，把適合計算複雜室內場景的設定用在有大量相同特徵的室外環境是很浪費的。我們會浪費寶貴的CPU時間和記憶體儲存/更新那些對整體外觀貢獻不大的光照貼圖。為了教學目的，我們會提高PRGI期間必須考慮貼圖像素的量，這會對預計算的時間造成很大的影響。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;在場景裡有大物件的室外環境情況下，合適的設定可以設在0.5-1之間，針對地形可以設定0.1-0.5之間。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;場景與Realtime Resolution值對照表&lt;/p&gt;

  &lt;p&gt;室內:2-3 像素/單位&lt;/p&gt;

  &lt;p&gt;戶外:0.5-1 像素/單位&lt;/p&gt;

  &lt;p&gt;地形:0.1-0.5 像素/單位&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;与Baked GI在数值上的差异&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Unity PRGI所需要的Realtime Resolution值比傳統光照貼圖密度要小好幾個等級，這是因為我們只從這些光照圖裡擷取間接光源資料，這些資料通常解析度都很低。所以使用PRGI時，清晰的陰影通常都是即時運算而非從高解析度的光照圖來提供。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;在這裡使用傳統光照慣用的值，例如:30 texels，可能會導致預計算失敗或無法計算。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;关于Realtime Resolution的使用&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;當設定場景即時解析度時，Unity會指定給場景內的靜態物件。帶有Mesh Renderer且標有靜態光照標籤(Lightmap Static)的物件，會引用這個值一直到它被外力修改。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;除了幫場景加上解析度設定外，我們還能針對每個物件調整光照貼圖的解析度，在需要高解析度來提供更高真實感的情況下，我們可以選擇性的提高這個值。通常是將場上最多的物件解析度設為預設值，然後手動調高需要更多照明細節物件的值。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;最后放一个不同数值对光照图的影响，可以看出数值越小单个光照图越小，数值 大时导致光照贴图单位面积中像素越多，从而使得对应的光照图变大。（个人理解）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://images2015.cnblogs.com/blog/23250/201702/23250-20170214163630769-1933493116.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;runtime resolution 0.5&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2015.cnblogs.com/blog/23250/201702/23250-20170214163702707-1660489302.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;runtime resolution 1&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2015.cnblogs.com/blog/23250/201702/23250-20170214163712441-606092785.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;runtime resolution 2&lt;/p&gt;

&lt;h4 id=&quot;section-2&quot;&gt;物件的设置&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;需要设置为static&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;light&quot;&gt;Light面板设置&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;auto与否个人认为不重要。只不过在auto模式下如果已经在某些参数的情况下生成过一次后续改动参数再改回来不需要再次生成。这个东西是否在非auto模式下奏效没试过。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-3&quot;&gt;光照探测&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;what &amp;amp; why
    &lt;blockquote&gt;
      &lt;p&gt;我們已經理解場景裡的圖表數量對預計算時間的影響，這樣我們就能從預計算流程裡想辦法降低一些物件計算來讓光照效能大躍進，同時也會減少圖表產生的數量．取而代之的，我們可以對這些物件做光照探測(Probe Lighting)處理，它是一種讓物件接收場景間接照明的好方法，雖然被光照探針指定的物件無法計算場景的光照反射，但通常影響不大。這種方法非常適合用在場景裡的小物件，因為小物件對光照反射計算幾乎沒什麼影響。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;光照探測技術是一個能在遊戲裡讓即時光照更逼真的快速演算法，通常會用在處理遊戲世界的人物角色或是動態物件的光照，它的優點在於Runtime處理效能佳而且還能預先計算好。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;弊端
    &lt;blockquote&gt;
      &lt;p&gt;使用光照探測是有些限制的，其中一個限制是在不提高探針數量的前提下很難在球型範圍上表現出高頻或斑駁的光照，但精度和消耗成本成正比，代表在效能的前提下，我們必須限制較低階的球諧函數。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;實際上一個3D座標只能用一個球體來紀錄照明資料，所以光照探測不適合用在有大量光照投射在大物件的狀況。另外一個限制是當用球諧函數在一個球體上編碼時，通常不擅於處理用有廣大平面的物件或帶有很深的凹洞的物件．如果你正計畫要把光照探測技術用在大型物件上，Unity有提供另一個光照探測代理體(Light Probe Proxy Volumes,LPPV)的技術可以參考手冊說明。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;适用于
    &lt;blockquote&gt;
      &lt;p&gt;儘管有這些限制，光照探測還是很適合和符合條件的小物件一起搭配使用，產生成本低廉效果卓越的結果。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Wed, 22 Feb 2017 22:43:49 +0800</pubDate>
        <link>https://caihua.tech/2017/02/22/Unity%E9%A0%90%E8%A8%88%E7%AE%97%E5%8D%B3%E6%99%82GI-%E7%AC%94%E8%AE%B0-%E4%B8%80-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E4%B8%80%E4%BA%9B%E8%AE%BE%E7%BD%AE/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/02/22/Unity%E9%A0%90%E8%A8%88%E7%AE%97%E5%8D%B3%E6%99%82GI-%E7%AC%94%E8%AE%B0-%E4%B8%80-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E4%B8%80%E4%BA%9B%E8%AE%BE%E7%BD%AE/</guid>
        
        <category>Unity預計算即時GI笔记</category>
        
        
      </item>
    
      <item>
        <title>游戏设计模式读书笔记：命令模式</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;模式定义&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Command_pattern&quot;&gt;定义&lt;/a&gt;：将一个请求封装成一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;看图（图片资源来自于百度，侵删）
&lt;img src=&quot;http://images.cnitblog.com/i/511616/201403/231247427711364.x-png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-1&quot;&gt;模式的理解&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;所谓命令模式说白了就是把一个方法对象化。怎么来理解这句话呢？可以看下UML图中的Command的interface，里面有个execute方法，还有一个undo方法。undo我们后面说，从内容上看这个接口非常的简单，它主要是为一个方法（execute）提供一个对象的载体。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;这样做有什么用?
    &lt;ol&gt;
      &lt;li&gt;使你可用不同的请求对客户进行参数化；&lt;/li&gt;
      &lt;li&gt;对请求排队或者记录请求日志;&lt;/li&gt;
      &lt;li&gt;支持可撤销的操作。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;因为一个方法的执行过程中往往是无法中断或者取消的，另外就是如果不做特殊的编码或者写相对应的方法，一个方法的执行往往不可逆。命令模式通过将方法封装成对象，进而可以制作出一个方法对象的列表，这样在顺序执行列表的过程中就可以将未执行的方法取消掉，而且保留这个列表相当于保留了一个操作的日志，在反向执行undo的操作就相当于对执行顺序进行逆转了。所以undo方法基本上是execute方法的逆向操作。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;unity&quot;&gt;在unity中的使用&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;在这里我没有什么自己的例子，而是推荐&lt;a href=&quot;http://www.habrador.com/tutorials/programming-patterns/1-command-pattern/&quot;&gt;这篇文章&lt;/a&gt;，这里已经很好的讲述的如何在unity中使用，并且也有了示例代码。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-2&quot;&gt;进一步的思考&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;《游戏设计模式》的作者也提到了是类风格化还是函数风格化的问题，他提到了JS写的代码如何实现这个模式。在我看来，C#的Action和Func一样可以替代类来实现方法的封装。因为命令模式的核心是将请求（方法）封装成对象，因此是用类或者一个delegate都是可以的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;那么何时使用类，又何时使用delegate呢？
    &lt;ol&gt;
      &lt;li&gt;如果有undo的需求时采用类比较好，反之可以考虑delegate。&lt;/li&gt;
      &lt;li&gt;如果你的方法中使用了很多的共享的数据，你考虑使用享元模式时应该使用类，如果你的execute方法还调用了父类的方法，需要使用沙盒模式时应该考虑使用类。可以说一个复杂的逻辑方法中往往代表了数据和算法以及调用其它函数，这样的话一个Action可能并不能满足你的需要，因此类是你唯一的选择。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;命令模式的一个很大的用途在于制作录像，也就是说如果我们有一个赛车游戏，那么录像的制作可以考虑只记录玩家的操作（命令），而其它的运动交给游戏逻辑（比如加速后的移动，碰撞后受到的影响等）本身来完成。这个应该是很多录像的实现方式。但是有个问题就是如何保障只使用命令的情况下，每次的游戏过程都能保证一致性。比如说一个赛车游戏中，玩家在躲避障碍的时候发布了左转命令，录像也忠实的记录了这个命令，但是在录像播放（游戏场景重现）时，依赖游戏逻辑是否能够完全正确的重现当时的场景，并且让这个左转的命令看上去是恰当的，这个十分考验引擎的计算准确性。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;在多人联机游戏中是否应该使用命令模式来重现其他玩家的操作？因为我一直做的竞速游戏，所以如果考虑行为的一致性应该是使用命令模式来做的，但是有个问题就是帧率太高的话，可能出现客户端无法快速响应命令的问题，尤其是设备FPS不同的情况下。因此在使用命令模式的同时，做补帧是必要的。当然这个主要针对的是位移这个问题。&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Mon, 26 Dec 2016 22:09:16 +0800</pubDate>
        <link>https://caihua.tech/2016/12/26/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</link>
        <guid isPermaLink="true">https://caihua.tech/2016/12/26/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</guid>
        
        <category>游戏设计模式读书笔记</category>
        
        
      </item>
    
      <item>
        <title>游戏设计模式读书笔记：架构、性能、游戏</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;架构、性能、游戏&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;在开始读第一章的时候会觉得有点混乱，作者提出了什么是架构这个问题，但是并没有像其它书里那样给出一个明确的定义，而是提到了：&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;这本书是关于上面这一切要使用的代码的组织方式。这里少谈代码，多谈代码组织。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;仔细品读这句话，你会发现这里面其实已经提到了什么是架构：所谓架构就是代码的组织方式。但是从我个人的认识来看这并不够全面，在这里在引用几段&lt;a href=&quot;http://www.infoq.com/cn/arch-talk&quot;&gt;《架构漫谈》&lt;/a&gt;中的文字来阐述什么是架构：&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;在每个人都必须自己完成所有生活必须品的生产的时候，是没有架构
的(当然在个人来讲，同一时刻只能做有限的事情，在时间上还是可能会
产生架构的)。一旦产生的分工，就把所有的事情，切分成由不同角色的什么是架构
人来完成，最后再通过交易，使得每个个体都拥有生活必须品，而不需要
每个个体做所有的事情，只需要每个个体做好自己擅长的事情，并具备一
定的交易能力即可。&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;blockquote&gt;
      &lt;p&gt;这实际上就形成了社会的架构。那么怎么定义架构呢?以上面这个例
子为例，把一个整体(完成人类生存的所有工作)切分成不同的部分(分 工)，由不同角色来完成这些分工，并通过建立不同部分相互沟通的机制， 使得这些部分能够有机的结合为一个整体，并完成这个整体所需要的所有 活动，这就是架构。&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;blockquote&gt;
      &lt;p&gt;软件架构实际上包括了:代码架构， 以及承载代码运行的硬件部署架构。实际上，硬件部署架构最终还是由代 码的架构来决定。因为代码架构不合理，是无法把一个运行单元分拆出多 个来的，那么硬件架构能分拆的就非常的有限，整个系统最终很难长的更大。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;关于架构和性能的冲突，我认为这个点写的很好，可以说我之前没有这样的认识。长久以来我都希望写出非常面向对象的代码，在我长久的认知中，代码的灵活性、高扩展性和可维护性是最重要的，因此设计模式是我在编写代码时所追求的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;但是作者提出良好的架构是需要很大的代价的，因为这需要遵守一些列的准则，Coder必须谨慎的组织代码，而且在引入了抽象，引入了可扩展性，引入的某个设计模式时，我们在增加了代码的灵活性的同时也增加了不可读性，增加了代码复杂度，这就增加了理解的难度。过度的架构设计往往会导致代码库失控，也许你会看到接口和抽象无处不在，我们可能需要花费大量时间才能找到真正功能的代码。关于这一点我也是深有体会，最近在看UniRx库，发现各种接口齐飞，大量的重载，梳理起来确实很费劲。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;同时，从代码本身执行角度来说，灵活的代码往往意味着执行速度比较慢。从UNITY的角度来说，因为有类似CLR的东西，当使用面向接口编程时，往往意味这具体类型的判断需要在运行期，JIT做的越多，性能也越差。而且还很可能导致无法实现代码缓存，每次运行都需要实时的做判定。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-1&quot;&gt;原型代码&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;原型代码中可能包含大量的一次性代码，但是原型代码往往意味着不可维护，必须被重写。目前在项目的开发过程中，往往出现原型代码被最终使用在项目中，简直就是灾难。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-2&quot;&gt;寻求平衡&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;快速编写出的代码未必是执行最快的代码，而且这样的代码在后面往往需要花费很多时间来优化，这都是需要时间的。这些都需要平衡。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;我们在工作中就是在不断的寻找平衡，有时候看到自己写的或者别人写的代码，就想去重构一下，但是现实又往往不给这个时间。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sat, 17 Dec 2016 19:45:25 +0800</pubDate>
        <link>https://caihua.tech/2016/12/17/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%9E%B6%E6%9E%84-%E6%80%A7%E8%83%BD-%E6%B8%B8%E6%88%8F/</link>
        <guid isPermaLink="true">https://caihua.tech/2016/12/17/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%9E%B6%E6%9E%84-%E6%80%A7%E8%83%BD-%E6%B8%B8%E6%88%8F/</guid>
        
        <category>游戏设计模式读书笔记</category>
        
        
      </item>
    
      <item>
        <title>由一个美术需求引发的Custom Inspector</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;需求&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Editor模式下，在运行或者非运行状态下，能够按照指定的变化率来自动改变material中属性数值。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-1&quot;&gt;需求分析&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;如何在Editor模式下获得一个游戏对象及其组件，尤其是在非运行状态下？我们知道在Unity IDE运行起来后是很容易获得一个对象和组件的，在GameObject上挂一个脚本即可。但是在非运行状态下呢，&lt;code class=&quot;highlighter-rouge&quot;&gt;transform.GetComponent &lt;/code&gt;这样的方法怎么执行？好在unity已经为我们考虑到了这个问题，提供了&lt;code class=&quot;highlighter-rouge&quot;&gt;[ExecuteInEditMode]&lt;/code&gt;Attribute，通过指定这个attribute使得组件类中的方法可以在edit模式下执行，并且是在非运行状态下的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如何在非运行状态下匀速改变数值呢？update方法中配合&lt;code class=&quot;highlighter-rouge&quot;&gt;Time.deltaTime&lt;/code&gt;是一个完美的方案，但是即使设置了&lt;code class=&quot;highlighter-rouge&quot;&gt;[ExecuteInEditMode]&lt;/code&gt;，update的表现在非运行和运行时也是完全不同的，查资料看到&lt;a href=&quot;https://docs.unity3d.com/ScriptReference/ExecuteInEditMode.html&quot;&gt; is only called when something in the scene changed. &lt;/a&gt;这句话时也有种吐槽的冲动。好在unity又为大家考虑到了这个问题（话说unity editor确实功能强大，AssetAtore里面那些插件真是厉害）,Edit模式下提供了&lt;code class=&quot;highlighter-rouge&quot;&gt;EditorApplication.update&lt;/code&gt;，这是一个事件，我们注册一个自己的方法就可以在非运行状态下实现update的功能。我个人比较推荐使用&lt;a href=&quot;https://gist.github.com/benblo/10732554&quot;&gt;EditorCoroutine&lt;/a&gt;，一个基于&lt;code class=&quot;highlighter-rouge&quot;&gt;EditorApplication.update&lt;/code&gt;的协程实现。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-2&quot;&gt;功能实现&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;使用一个自定义组件来实现material中数值的修改，这个类在UI上要体现出能够设置变化速率和初始值。并且在UI上通过点击按钮的形式来触发改变。&lt;/li&gt;
  &lt;li&gt;使用Custom Inspector来实现组件UI的自定义。&lt;/li&gt;
  &lt;li&gt;在运行状态下通过使用默认的update来实现匀速变化，在非运行状态下通过使用EditorCoroutine来实现。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-3&quot;&gt;代码实现&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;using UnityEngine;
using System.Collections;
using UnityEditor;
public class UVAnimation : MonoBehaviour
{

    public Vector2 TilingSpeed = new Vector2(1, 1);
    public Vector2 OffsetSpeed = new Vector2(0.1f, 0.1f);

    public Vector2 Tiling = new Vector2(1, 1);
    public Vector2 Offset = new Vector2(0, 0);

    float rate = 0.02f;

    EditorCoroutine coroutineOffset;
    EditorCoroutine coroutineTiling;

    bool isOffset = false;
    bool isTiling = false;

    // Use this for initialization
    void Start()
    {
    }

    // Update is called once per frame
    void Update()
    {

    }

    void FixedUpdate()
    {
        if (isOffset)
        {
            transform.GetComponent&amp;lt;Renderer&amp;gt;().sharedMaterials[0].mainTextureOffset += OffsetSpeed * Time.deltaTime;
        }
        if (isTiling)
        {
            transform.GetComponent&amp;lt;Renderer&amp;gt;().sharedMaterials[0].mainTextureScale += TilingSpeed * Time.deltaTime;
        }
    }

    public void ChangeOffset()
    {
        if (EditorApplication.isPlaying)
        {
            isOffset = true;
        }
        else
        {
            if (coroutineOffset != null)
            {
                coroutineOffset.stop();
            }
            coroutineOffset = EditorCoroutine.start(ChangeOffsetCoroutine());
        }

    }

    IEnumerator ChangeOffsetCoroutine()
    {
        while (true)
        {
            yield return new WaitForSeconds(rate);
            transform.GetComponent&amp;lt;Renderer&amp;gt;().sharedMaterials[0].mainTextureOffset += OffsetSpeed * rate;
        }
    }

    public void ChangeTiling()
    {
        if (EditorApplication.isPlaying)
        {
            isTiling = true;
        }
        else
        {
            if (coroutineTiling != null)
            {
                coroutineTiling.stop();
            }
            coroutineTiling = EditorCoroutine.start(ChangeTilingCoroutine());
        }
    }

    IEnumerator ChangeTilingCoroutine()
    {
        while (true)
        {
            yield return new WaitForSeconds(rate);
            transform.GetComponent&amp;lt;Renderer&amp;gt;().sharedMaterials[0].mainTextureScale += TilingSpeed * rate;
        }
    }

    public void SetOffset()
    {
        transform.GetComponent&amp;lt;Renderer&amp;gt;().sharedMaterials[0].mainTextureOffset = Offset;
    }

    public void SetTiling()
    {
        transform.GetComponent&amp;lt;Renderer&amp;gt;().sharedMaterials[0].mainTextureScale = Tiling;
    }

    public void Reset()
    {
        isOffset = false;
        isTiling = false;
        transform.GetComponent&amp;lt;Renderer&amp;gt;().sharedMaterials[0].mainTextureScale = new Vector2(1, 1);
        transform.GetComponent&amp;lt;Renderer&amp;gt;().sharedMaterials[0].mainTextureOffset = new Vector2(0, 0);
        if (coroutineOffset != null)
        {
            coroutineOffset.stop();
        }
        if (coroutineTiling != null)
        {
            coroutineTiling.stop();
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;using UnityEngine;
using System.Collections;
using UnityEditor;

[CustomEditor(typeof(UVAnimation))]
public class UVAnimationBuilderEditor : Editor {


	public override void OnInspectorGUI ()
	{
	   base.OnInspectorGUI ();
		//DrawDefaultInspector ();
		UVAnimation uva = (UVAnimation)target;

		if (GUI.changed) {
			uva.SetTiling ();
			uva.SetOffset ();
		}

		if (GUILayout.Button(&quot;Change Tiling&quot;)) {
			uva.ChangeTiling ();	
			EditorUtility.SetDirty (target);
		}

		if (GUILayout.Button(&quot;Change Offset&quot;)) {
			uva.ChangeOffset ();
		}

		if (GUILayout.Button(&quot;Reset&quot;)) {
			uva.Reset ();
		}
	}
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-4&quot;&gt;代码解析&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[CustomEditor(typeof(UVAnimation))]&lt;/code&gt;为UVAnimation创建的Editor类，在这个类里面可以修改UVAnimation类的UI，可以调用UVAnimation类中的方法。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;OnInspectorGUI&lt;/code&gt;方法，顾名思义在里面可以对UI进行编程，注意一下这个方法会自己生产一句代码&lt;code class=&quot;highlighter-rouge&quot;&gt;base.OnInspectorGUI ();&lt;/code&gt;，我所注释掉的&lt;code class=&quot;highlighter-rouge&quot;&gt;DrawDefaultInspector ();&lt;/code&gt;这句代码都是用来绘制默认UI的，二者只可留其一。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;transform.GetComponent&amp;lt;Renderer&amp;gt;().sharedMaterials&lt;/code&gt;在edit模式下获取材质球的对象需要用&lt;code class=&quot;highlighter-rouge&quot;&gt;sharedMaterials&lt;/code&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;mainTextureScale&lt;/code&gt;对应的就是UI上的Tiling。命名这让人吐槽。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 19 Nov 2016 15:52:25 +0800</pubDate>
        <link>https://caihua.tech/2016/11/19/%E7%94%B1%E4%B8%80%E4%B8%AA%E7%BE%8E%E6%9C%AF%E9%9C%80%E6%B1%82%E5%BC%95%E5%8F%91%E7%9A%84Custom-Inspector/</link>
        <guid isPermaLink="true">https://caihua.tech/2016/11/19/%E7%94%B1%E4%B8%80%E4%B8%AA%E7%BE%8E%E6%9C%AF%E9%9C%80%E6%B1%82%E5%BC%95%E5%8F%91%E7%9A%84Custom-Inspector/</guid>
        
        <category>Unity3D</category>
        
        
      </item>
    
      <item>
        <title>代码生成AnimatorController</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;0.出发点&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;现在的项目需要设置多套动画组合，全部是由策划在XML文件中设置完成，如果完全的手动在AnimatorController中去做不但工作量大而且如果将来有配置修改了还要一个个去找到对应的自状态机并且修改。因此就萌生了用代码去生成状态机的想法，而且在网上也有了很多的教程可以参考，只是每个项目都不同，且对于一些参数和属性的设置也不尽相同，因此还是把自己的代码进行一些修改后分享出来，基本上应该是包含了状态机常用的功能。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;需要注意我的具体代码中是在一个已有的AnimatorController基础上创建的。如果完全是从0开始可以参考别的资料，其实道理是一样的都是代码创建对象。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-1&quot;&gt;1.数据来源&lt;/h3&gt;

&lt;p&gt;一个典型的XML文件&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;config&amp;gt;&lt;/span&gt;
	&lt;span class=&quot;nt&quot;&gt;&amp;lt;datas&amp;gt;&lt;/span&gt;
		&lt;span class=&quot;nt&quot;&gt;&amp;lt;data&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;INDEX=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;1&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Clip1=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;jump&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Clip1Count=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;1&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Clip2=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;BackLeap&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Clip2Count=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;2&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Clip3=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;die&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Clip3Count=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;1&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/data&amp;gt;&lt;/span&gt;
		&lt;span class=&quot;nt&quot;&gt;&amp;lt;data&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;INDEX=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;2&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Clip1=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;BackLeap&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Clip1Count=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;3&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Clip2=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;jump&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Clip2Count=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;0&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Clip3=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;jump&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Clip3Count=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;0&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/data&amp;gt;&lt;/span&gt;
		&lt;span class=&quot;nt&quot;&gt;&amp;lt;data&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;INDEX=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;3&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Clip1=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;BackLeap&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Clip1Count=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;1&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Clip2=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;ForwardLeap&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Clip2Count=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;1&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Clip3=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;jump&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Clip3Count=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;1&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/data&amp;gt;&lt;/span&gt;
	&lt;span class=&quot;nt&quot;&gt;&amp;lt;/datas&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/config&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-2&quot;&gt;2.动画控制器中的主要元素&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Unity中editor的功能十分的强大，能够加载项目中的各种资源，而AnimatorController就是其中之一。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;一个AnimatorController的结构基本如下
&lt;img src=&quot;http://images2015.cnblogs.com/blog/23250/201611/23250-20161112184411358-1002723478.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;AnimatorControllerLayer：一个AnimatorController由多个Layer组成，但是除了BaseLayer外其它的Layer并不主要负责动画逻辑，而是多用于动画遮罩。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;AnimatorControllerParameter：顾名思义是状态机中使用的参数，这个参数可以在不同的Layer和子状态机中使用。在代码添加参数时会选择参数类型，它是个枚举&lt;code class=&quot;highlighter-rouge&quot;&gt;AnimatorControllerParameterType&lt;/code&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;AnimatorStateMachine：动画状态机，核心逻辑实线层。在一个状态机中可以有多个state，也可以有多个Sub AnimatorStateMachine。通过AddStateMachine方法来生成并添加子状态机。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;AnimatorState：动画状态，也是这个系统中的基础单元。其可以设定各种属性，比较常用的是AnimationClip和Speed等。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;AnimatorStateTransition：也就是动画转换，其中可以设定触发参数，而且其中还有一个很重要的东西就是动画过度的设定。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-3&quot;&gt;3.完整代码&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;using UnityEngine;
using System.Collections;
using UnityEditor;
using System;
using UnityEditor.Animations;
using System.IO;
using System.Xml;
using System.Text.RegularExpressions;
using System.Xml.Serialization;
using System.Collections.Generic;
using System.Linq;

//[CustomEditor(typeof(EditorTools))]
public class EditorTools : MonoBehaviour
{
	#region 创建动画控制器

	/// &amp;lt;summary&amp;gt;
	///  记录上一个state，用于自状态机中
	/// &amp;lt;/summary&amp;gt;
	static AnimatorState lastAnimatorState = null;
	static string ParameterName;
	// 动画片段
	static AnimationClip die;
	static AnimationClip jump;
	static AnimationClip BackLeap;
	static AnimationClip ForwardLeap;
	/// &amp;lt;summary&amp;gt;
	/// base layer AnimatorStateMachine
	/// &amp;lt;/summary&amp;gt;
	static AnimatorStateMachine mainASM;
	static int stateHeight = 100;
	static int stateWidth = 220;

	/// &amp;lt;summary&amp;gt;
	/// 根据配置文件创建特技组
	/// &amp;lt;/summary&amp;gt;
	[MenuItem (&quot;Tools/CreateAnimatorState&quot;)]
	static void CreateAnimatorState ()
	{
		// 获取动画片段
		List&amp;lt;object&amp;gt; allAssets = new List&amp;lt;object&amp;gt; (AssetDatabase.LoadAllAssetsAtPath (&quot;Assets/Charactors/player2.FBX&quot;));
		var animationClips = allAssets.Where (o =&amp;gt; o.GetType () == typeof(AnimationClip)).ToList ();
		foreach (var item in animationClips) {
			AnimationClip x = item as AnimationClip;
			switch (x.name) {
			case &quot;die&quot;:
				die = x;
				break;
			case &quot;jump&quot;:
				jump = x;
				break;
			case &quot;BackLeap&quot;:
				BackLeap = x;
				break;
			case &quot;ForwardLeap&quot;:
				ForwardLeap = x;
				break;
			default:
				break;
			}
		}

		// 当每个动画是一个单独的FBX文件中时可以用下面的方法来获取
		//die = AssetDatabase.LoadAssetAtPath (&quot;Assets/Charactors/player2.FBX&quot;, typeof(AnimationClip)) as AnimationClip;


		// 获取状态机
		AnimatorController animatorController = AssetDatabase.LoadAssetAtPath (&quot;Assets/AnimatorController/demo.controller&quot;, typeof(AnimatorController)) as AnimatorController;
		AnimatorControllerLayer layer = animatorController.layers [0];
		mainASM = layer.stateMachine;

		// 获取当前所有的参数
		AnimatorControllerParameter[] paras = animatorController.parameters;
		List&amp;lt;AnimatorControllerParameter&amp;gt; listParas = new List&amp;lt;AnimatorControllerParameter&amp;gt; (paras);

		// 删除指定的参数
		var acps = listParas.Where (p =&amp;gt; p.name.Contains (&quot;GroupParameter&quot;)).ToArray ();
		foreach (AnimatorControllerParameter item in acps) {
			animatorController.RemoveParameter (item);
		}

		// 删除指定的子状态机
		ChildAnimatorStateMachine[] childASM = mainASM.stateMachines;
		List&amp;lt;ChildAnimatorStateMachine&amp;gt; listCASM = new List&amp;lt;ChildAnimatorStateMachine&amp;gt; (childASM);
		var casms = listCASM.Where (c =&amp;gt; c.stateMachine.name.Contains (&quot;Group&quot;)).ToArray ();
		foreach (ChildAnimatorStateMachine item in casms) {
			mainASM.RemoveStateMachine (item.stateMachine);
		}

		// 读配置文件
		XmlConfig xc = ReadXml ();

		Vector3 startPos = mainASM.anyStatePosition;


		// 根据配置创建自状态机
		for (int index = 0; index &amp;lt; xc.datas.Count; index++) {
			Data data = xc.datas [index];

			// 设置特技参数，
			ParameterName = &quot;GroupParameter&quot; + data.INDEX.ToString ();
			animatorController.AddParameter (ParameterName, AnimatorControllerParameterType.Trigger);

			// 创建子状态机
			AnimatorStateMachine sub = AddSubStateMachine&amp;lt;AnimatorEvent&amp;gt; (&quot;Group_&quot; + data.INDEX, ParameterName, mainASM, startPos + new Vector3 (stateWidth * index, -stateHeight, 0));
			// 创建子状态机中的state
			SetStateInSubMachine (sub, data);
			lastAnimatorState = null;
		}
	}

	/// &amp;lt;summary&amp;gt;
	///  创建sub state machine用于放置特效组中的动画
	/// &amp;lt;/summary&amp;gt;
	/// &amp;lt;typeparam name=&quot;T&quot;&amp;gt;&amp;lt;/typeparam&amp;gt;
	/// &amp;lt;param name=&quot;stateName&quot;&amp;gt;&amp;lt;/param&amp;gt;
	/// &amp;lt;param name=&quot;sm&quot;&amp;gt;&amp;lt;/param&amp;gt;
	/// &amp;lt;param name=&quot;position&quot;&amp;gt;&amp;lt;/param&amp;gt;
	/// &amp;lt;param name=&quot;data&quot;&amp;gt;&amp;lt;/param&amp;gt;
	/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
	private static AnimatorStateMachine AddSubStateMachine&amp;lt;T&amp;gt; (string stateName, string para, AnimatorStateMachine sm, Vector3 position) where T : StateMachineBehaviour
	{
		AnimatorStateMachine sub = sm.AddStateMachine (stateName, position);
		sub.AddStateMachineBehaviour&amp;lt;T&amp;gt; ();
		AnimatorStateTransition transition = mainASM.defaultState.AddTransition (sub, false);
		transition.AddCondition (AnimatorConditionMode.If, 0, para);
		return sub;
	}

	/// &amp;lt;summary&amp;gt;
	///  根据配置数据在子状态机中创建state
	/// &amp;lt;/summary&amp;gt;
	/// &amp;lt;typeparam name=&quot;T&quot;&amp;gt;&amp;lt;/typeparam&amp;gt;
	/// &amp;lt;param name=&quot;subSM&quot;&amp;gt;&amp;lt;/param&amp;gt;
	/// &amp;lt;param name=&quot;data&quot;&amp;gt;&amp;lt;/param&amp;gt;
	private static void SetStateInSubMachine (AnimatorStateMachine subSM, Data data)
	{
		AnimatorState newState;
		string stateName;
		Vector3 pos;
		List&amp;lt;AnimationClip&amp;gt; acArray = new List&amp;lt;AnimationClip&amp;gt; ();
		SetAnimationClip (data.Clip1, data.Clip1Count, ref acArray);
		SetAnimationClip (data.Clip2, data.Clip2Count, ref acArray);
		SetAnimationClip (data.Clip3, data.Clip3Count, ref acArray);

		for (int x = 1; x &amp;lt;= acArray.Count; x++) {
			stateName = &quot;GroupState_&quot; + data.INDEX + &quot;_&quot; + x.ToString ();
			pos = subSM.entryPosition + new Vector3 (stateWidth, -stateHeight * x, 0);
			newState = AddState (stateName, subSM, pos, acArray [x - 1], x, acArray.Count);
			lastAnimatorState = newState;
		}
	}

	static void SetAnimationClip (string clipName, int count, ref List&amp;lt;AnimationClip&amp;gt; acArray)
	{
		for (int i = 0; i &amp;lt; count; i++) {
			if (clipName == die.name) {
				acArray.Add (die);
			}
			if (clipName == jump.name) {
				acArray.Add (jump);
			}
			if (clipName == BackLeap.name) {
				acArray.Add (BackLeap);
			}
			if (clipName == ForwardLeap.name) {
				acArray.Add (ForwardLeap);
			}
		}
	}

	static AnimatorState AddState&amp;lt;T&amp;gt; (string stateName, AnimatorStateMachine sm, float threshold, string parameter, Vector3 position,
	                                  AnimationClip clip, bool first = false, bool last = false) where T : StateMachineBehaviour
	{
		AnimatorStateTransition animatorStateTransition;
		//  生成AnimatorState
		AnimatorState animatorState = sm.AddState (stateName, position);
		// 设置动画片段
		animatorState.motion = clip;
		// 创建AnimatorStateTransition
		// entry连接到特技组的第一个动画
		if (first) {
			animatorStateTransition = sm.AddAnyStateTransition (animatorState);
			animatorStateTransition.AddCondition (AnimatorConditionMode.Equals, threshold, parameter);
		}
		// 最后一个动画连接到stand
		if (last) {
			animatorStateTransition = animatorState.AddTransition (mainASM.defaultState);
		}

		// 特技组内的连接创建
		if (!first &amp;amp;&amp;amp; !last) {
			animatorStateTransition = animatorState.AddTransition (mainASM.defaultState);
		}

		animatorStateTransition = lastAnimatorState.AddTransition (animatorState, true);

		//AnimatorStateTransition 的设置
		animatorStateTransition.canTransitionToSelf = false;
		animatorState.AddStateMachineBehaviour&amp;lt;T&amp;gt; ();
		return animatorState;
	}

	static AnimatorState AddState (string stateName, AnimatorStateMachine sm, Vector3 position, AnimationClip clip, int index, int count)
	{
		AnimatorStateTransition animatorStateTransition = null;
		//  生成AnimatorState
		AnimatorState animatorState = sm.AddState (stateName, position);
		// 设置动画片段
		animatorState.motion = clip;
		// 创建AnimatorStateTransition
		// AnyState连接到特技组的第一个动画
		if (index == 1) {
			//animatorStateTransition = sm.AddAnyStateTransition(animatorState);
			//animatorStateTransition.canTransitionToSelf = false;
		}
		// 最后一个动画连接到main animator machine的default state
		if (index == count) {
			animatorStateTransition = animatorState.AddTransition (mainASM.defaultState);
			animatorStateTransition.hasExitTime = true;
		}

		// 特技组内的连接创建
		if (lastAnimatorState != null) {
			animatorStateTransition = lastAnimatorState.AddTransition (animatorState, true);
		}

		return animatorState;
	}

	#endregion

	#region public method

	static XmlConfig ReadXml ()
	{
		//string xmlStr = File.ReadAllText(Application.dataPath.ToString() + &quot;/StreamingAssets/XMLConfigFiles/Stunt.xml&quot;);
		//Debug.Log(xmlStr);
		//string objTxt = Regex.Replace(xmlStr, @&quot;&amp;lt;!--[^-]*--&amp;gt;&quot;, string.Empty, RegexOptions.IgnoreCase);
		//Debug.Log(objTxt);
		return DeserializeFromXml&amp;lt;XmlConfig&amp;gt; (Application.dataPath.ToString () + &quot;/StreamingAssets/XMLConfigFiles/data.xml&quot;);
	}

	/// &amp;lt;summary&amp;gt;
	/// 从某一XML文件反序列化到某一类型
	/// &amp;lt;/summary&amp;gt;
	/// &amp;lt;param name=&quot;filePath&quot;&amp;gt;待反序列化的XML文件名称&amp;lt;/param&amp;gt;
	/// &amp;lt;param name=&quot;type&quot;&amp;gt;反序列化出的&amp;lt;/param&amp;gt;
	/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
	public static T DeserializeFromXml&amp;lt;T&amp;gt; (string filePath)
	{
		try {
			if (!System.IO.File.Exists (filePath))
				throw new ArgumentNullException (filePath + &quot; not Exists&quot;);

			using (System.IO.StreamReader reader = new System.IO.StreamReader (filePath)) {
				System.Xml.Serialization.XmlSerializer xs = new System.Xml.Serialization.XmlSerializer (typeof(T));
				T ret = (T)xs.Deserialize (reader);
				return ret;
			}
		}
		catch (Exception ex) {
			return default(T);
		}
	}

	#endregion
}


#region 序列化需要的model
[XmlType (TypeName = &quot;config&quot;)]
public class XmlConfig
{
	[XmlArray (&quot;datas&quot;)]
	public List&amp;lt;Data&amp;gt; datas { get; set; }
}

[XmlType (TypeName = &quot;data&quot;)]
public class Data
{
	[XmlAttribute]
	public int INDEX;
	[XmlAttribute]
	public string Clip1;
	[XmlAttribute]
	public int Clip1Count;
	[XmlAttribute]
	public string Clip2;
	[XmlAttribute]
	public int Clip2Count;
	[XmlAttribute]
	public string Clip3;
	[XmlAttribute]
	public int Clip3Count;
}

#endregion
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-4&quot;&gt;4.最后的说明&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;其实整个过程基本就是读取XML文件内容，然后按照第二部分中描述的结构来一点一点构建状态机。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在设定具体属性时需要按照具体情况来做。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;有个天坑，就是如果在Base Layer界面多次点击CreateAnimatorState按钮时会出现Unity的crash，或者出现界面所有元素消失并报错。我找了很多资料应该是UnityEditor的bug。有一个很简单的解决办法，就是创建一个新的Layer，切换到新Layer的界面，然后点击CreateAnimatorState按钮，再切回Base Layer，这样就不会出错了。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 12 Nov 2016 17:18:16 +0800</pubDate>
        <link>https://caihua.tech/2016/11/12/%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90AnimatorController/</link>
        <guid isPermaLink="true">https://caihua.tech/2016/11/12/%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90AnimatorController/</guid>
        
        <category>Unity3D</category>
        
        
      </item>
    
      <item>
        <title>向量夹角计算</title>
        <description>&lt;h4 id=&quot;section&quot;&gt;向量夹角&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 基于点积计算，
// a.b = ||a|| * ||b|| * sin(θ) 
// =&amp;gt; θ = arccos(a·b / (||a|| * ||b||))
// =&amp;gt; θ = arccos(a·b) //当a和b按照单位向量算时
float angle = Mathf.Acos(Vector3.Dot(a.normalized, b.normalized)) * Mathf.Rad2Deg;

// 基于叉积计算，
// ||a × b|| = ||a|| ||b|| sinθ             
// =&amp;gt; θ = arcsin(||a × b|| / (||a|| * ||b||))
// =&amp;gt; θ = arcsin(||a × b||) //当a和b按照单位向量算时
// 下面公式中有个Distance的计算是因为||a × b||是有长度的
angle = Mathf.Asin(Vector3.Distance(Vector3.zero, Vector3.Cross(a.normalized, b.normalized))) * Mathf.Rad2Deg;

// 最简单计算方式
Vector3.Angle(a, b)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Sat, 12 Nov 2016 14:15:50 +0800</pubDate>
        <link>https://caihua.tech/2016/11/12/%E5%90%91%E9%87%8F%E5%A4%B9%E8%A7%92%E8%AE%A1%E7%AE%97/</link>
        <guid isPermaLink="true">https://caihua.tech/2016/11/12/%E5%90%91%E9%87%8F%E5%A4%B9%E8%A7%92%E8%AE%A1%E7%AE%97/</guid>
        
        <category>3D数学</category>
        
        
      </item>
    
  </channel>
</rss>
