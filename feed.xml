<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>蔡华的博客</title>
    <description>Be publicly useful and privately happy.</description>
    <link>https://caihua.tech/</link>
    <atom:link href="https://caihua.tech/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Fri, 20 Jul 2018 15:58:11 +0800</pubDate>
    <lastBuildDate>Fri, 20 Jul 2018 15:58:11 +0800</lastBuildDate>
    <generator>Jekyll v3.2.1</generator>
    
      <item>
        <title>开发ECS style项目的思考</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;概述&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;这篇文章是近期在学习Entitas时对于ECS的进一步思考&lt;/li&gt;
  &lt;li&gt;其中会包含在使用ECS时需要注意的一些重要原则&lt;/li&gt;
  &lt;li&gt;这些原则在使用Entitas时如何实现&lt;/li&gt;
  &lt;li&gt;这篇文章不会讲Entitas的具体代码和功能，这需要每个使用者自己去看源码和demo。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ecs&quot;&gt;ECS的使用原则&lt;/h2&gt;

&lt;h4 id=&quot;section-1&quot;&gt;数据驱动一切&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;ECS的目的就是将数据与行为进行解耦，而ECS中行为（System）的执行是依赖于数据（Component）的。&lt;/li&gt;
  &lt;li&gt;这个依赖应该分为两个方向来看，第一是变化的数据，它造成了事件的发生；第二是非变化的数据，它提供了Update中逻辑执行的数据。&lt;/li&gt;
  &lt;li&gt;外部的输入（Input、Net、Bluetooth）改变的是数据，这些数据经过System的处理（非必须）后可能被用来驱动View层，或者用来改变其它的数据，从而产生新一轮的System处理数据。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;ecs-1&quot;&gt;ECS只包含数据与逻辑&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;ECS是一种开发模式、是一种思维方式，它的实现是不依赖与具体语言、引擎或特定环境的。ECS系统中应该只包含entity、component、system，以及其它辅助的类。&lt;/li&gt;
  &lt;li&gt;这样的认知就要求我们在使用时要将ECS的数据、逻辑与具体实现分离开，请细细品味 &lt;code class=&quot;highlighter-rouge&quot;&gt;I am abstracting the logic from the implentation, the what from the how. &lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;ecs-2&quot;&gt;ECS与外部实现解耦&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;ECS与外部实现交互时遵从面向接口编程的原则：从函数调用层面讲不要在ECS系统中直接调用外部对象的函数，因为这必然要求component持有一个具体的对象，导致ECS引用了外部的类定义。此时ECS应该是持有一个接口的实现对象。&lt;/li&gt;
  &lt;li&gt;从数据层面讲，ECS中的类型不依赖于任何第三方的定义。比如表示位置的Vector3，它应该是ECS内部定义的，而不应该依赖于外部定义的类型（比如Unity中的Vector3）。&lt;/li&gt;
  &lt;li&gt;尽量避免component持有对象的引用，哪怕是基于接口的。使用事件机制可以做到更好的解耦。&lt;/li&gt;
  &lt;li&gt;在事件机制的基础上，应该尽量做到上层功能依赖底层功能，反之则不行。也就是说外部实现可以使用ECS的方法、修改component的数据。但是ECS内部可以做到不知道有外部对象这回事，因为在完全使用事件系统的情况下，ECS调用外部函数都可以通过触发事件的方式来调用。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;oop&quot;&gt;忘却OOP&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;这点对于大家来说比较难，MonoBehaviour自身也是OOP的。但是从和大家的讨论结果来看，忘却继承、多态有助于更好的写出ECS style的代码。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;entitas&quot;&gt;如何使用Entitas&lt;/h2&gt;

&lt;h3 id=&quot;section-2&quot;&gt;它山之石可以攻玉&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;下图是一位国外开发者对于使用Entitas，或者说是使用ECS的经验总结。里面用了非常多的代码例子来讲述如何解耦ECS与具体的实现，建议所有使用Entitas的人都看一下，链接在最后。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://camo.githubusercontent.com/c7565ff2582568e06e529dd81eb0bafbc0ac4224/68747470733a2f2f692e696d6775722e636f6d2f5244576b6150582e706e67&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在这幅图中ECS通过interface与View和Service交互，具体的实现可以是unity或者是其它的引擎。&lt;/li&gt;
  &lt;li&gt;里面的箭头也很好定义了一个workflow，service层改变了ECS中component的数据，引发system的处理，最终引发VIEW层的变化。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;entitassystem&quot;&gt;Entitas中的System&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;说到System就要提一下Entitas中两种处理数据变化的方式，一种是响应式的，一种是轮询式的。&lt;/li&gt;
  &lt;li&gt;响应式处理需要使用继承自ReactiveSystem的system，虽然在底层它还是会去轮询，但是在使用层面上它只是处理发生了变化的component。&lt;/li&gt;
  &lt;li&gt;而轮询式的则要求system继承自IExecuteSystem，它会在每帧去调用一次Execute方法。&lt;/li&gt;
  &lt;li&gt;对于不同功能的component应该合理的去选择它对应的system，从之前讨论的结果看，绝大多数component都应该是对应的ReactiveSystem。因为响应式会比较高效，只有当系统中entity上的component发生了Add/Remove操作，或者component中的数据发生了变化后才会执行相关的操作。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;ecs-3&quot;&gt;一些使用ECS实现的功能&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;下面会对一些常见的功能如何使用ECS实现来进行讨论，目前为止这些实现只存在于讨论的层面，当然这些实现是基于Entitas的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;fsm&quot;&gt;FSM&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;FSM的核心是状态（state）和状态变化所引发的函数调用。&lt;/li&gt;
  &lt;li&gt;以点击跳跃按钮触发玩家播放跳跃动画为例：
    &lt;ul&gt;
      &lt;li&gt;ECS中添加一个PlayerAnimatorStateEntity，添加PlayerAnimatorStateComponent，里面的变量是一个string类型的state，利用它的改变来驱动玩家身上动画状态机的切换。&lt;/li&gt;
      &lt;li&gt;在PlayerGameObject创建时需要监听state改变的事件。&lt;/li&gt;
      &lt;li&gt;View层识别到一个按钮的点击（Unity自己的事件机制），ECS中产生一个PlayerJumpEntity，它上面add了一个PlayerJumpComponent。组件中无需任何数据，因为当ECS中出现这个组件时就已经代表jump按钮被按下了。&lt;/li&gt;
      &lt;li&gt;在这里需要注意，如果点击按钮只是改变动画，那么VIEW里面按钮点击可以直接改PlayerAnimatorStateComponent中state变量的值。&lt;/li&gt;
      &lt;li&gt;PlayerJumpSystem是一个ReactiveSystem，它在执行Execute函数时改变state的值引发事件，从而使得PlayerGameObject可以改变animator的状态。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/klkucan/XMind/master/ECS%E5%AE%9E%E7%8E%B0%E5%8A%9F%E8%83%BD.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;伤害技能系统&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;未完待续&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-4&quot;&gt;引用&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/sschmid/Entitas-CSharp/wiki/How-I-build-games-with-Entitas-%28FNGGames%29&quot;&gt;How I build games with Entitas (FNGGames)&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 20 Jul 2018 15:52:19 +0800</pubDate>
        <link>https://caihua.tech/2018/07/20/%E5%BC%80%E5%8F%91ECS-style%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%80%9D%E8%80%83/</link>
        <guid isPermaLink="true">https://caihua.tech/2018/07/20/%E5%BC%80%E5%8F%91ECS-style%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%80%9D%E8%80%83/</guid>
        
        <category>ECS</category>
        
        
      </item>
    
      <item>
        <title>游戏设计模式读书笔记：游戏循环</title>
        <description>&lt;h4 id=&quot;section&quot;&gt;游戏循环&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;游戏循环是一个游戏系统中最为关键的环节，可以说只要开发游戏就会用到这个模式，只不过它很多时候已经被集成到了引擎当中。在使用Unity引擎的过程中，可以体会到一个游戏中所有的表现都依赖于循环。&lt;/li&gt;
  &lt;li&gt;不同于传统软件循环中只等待输入的情况，一个游戏循环在游玩中不断运行。每一次循环，它无阻塞地处理玩家输入，更新游戏状态，渲染游戏。它追踪时间的消耗并控制游戏的速度。&lt;/li&gt;
  &lt;li&gt;有时候在某个平台开发游戏循环时，需要使用平台特有的事件循环。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;fps&quot;&gt;帧率（FPS）&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;如果我们用实际时间来测算游戏循环运行的速度，就得到了游戏的“帧率”(FPS)。 如果游戏循环的更快，FPS就更高，游戏运行得更流畅、更快。 如果循环得过慢，游戏看上去就像是慢动作电影。&lt;/li&gt;
  &lt;li&gt;两个因素决定了帧率:
    &lt;ul&gt;
      &lt;li&gt;一个是每帧要做多少工作。复杂的物理，众多游戏对象，图形细节都让CPU和GPU繁忙，这决定了需要多久能完成一帧。&lt;/li&gt;
      &lt;li&gt;另一个是底层平台的速度。 更快的芯片可以在同样的时间里执行更多的代码。 多核，GPU组，独立声卡，以及系统的调度都影响了在一次滴答中能够做多少东西。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;当前的游戏开发中，游戏循环的一个重要任务就是不管潜在的硬件条件，以固定速度运行游戏。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-1&quot;&gt;循环的演化&lt;/h4&gt;

&lt;h5 id=&quot;section-2&quot;&gt;跑，能跑多快跑多快&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;下面这个可以说是最简单的循环，它完全不控制帧率，可能在性能好的设备上运行的非常快，在不好的设备上运行缓慢。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;while (true)
{
  processInput();
  update();
  render();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;section-3&quot;&gt;休息一下&lt;/h5&gt;
&lt;blockquote&gt;
  &lt;p&gt;假设你想要你的游戏以60FPS运行。这样每帧大约16毫秒。 只要你用少于这个的时长进行游戏所有的处理和渲染，就可以以稳定的帧率运行。 你需要做的就是处理这一帧然后等待，直到处理下一帧的时候，就像这样：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://c1.staticflickr.com/1/785/39792215050_f8590ba1b4_b.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;while (true)
{
  double start = getCurrentTime();
  processInput();
  update();
  render();

  sleep(start + MS_PER_FRAME - getCurrentTime());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;但是如果每帧超过了16ms，那么仍旧无法保障帧率。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-4&quot;&gt;一小步，一大步&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;游戏循环中需要实现变化的时间间隔。如果说我们在每次更新中将游戏时间推动一个固定量，那么当每帧的真实执行时间超过这个固定量时，会导致游戏时间慢与实际时间。&lt;/li&gt;
  &lt;li&gt;因此一般都会将上一帧的真实执行时间作为参考来决定这一帧游戏时间的推动量。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;double lastTime = getCurrentTime();
while (true)
{
  double current = getCurrentTime();
  double elapsed = current - lastTime;
  processInput();
  update(elapsed);
  render();
  lastTime = current;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;每一帧，我们计算上次游戏更新到现在有多少真实时间过去了（即变量elapsed）。 当我们更新游戏状态时将其传入。 然后游戏引擎让游戏世界推进一定的时间量。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;这样处理的问题：不同性能的设备会导致帧率不同，从而计算浮点型数据的结果在一秒内会有偏差。对于联机游戏来说就是问题了。现在很多的联机游戏已经是在服务器计算位置等数据了，避免了不同设备性能差异造成的错误。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-5&quot;&gt;追逐时间&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;其本质是在固定时间间隔更新游戏。但是这个更新的内容却并非是游戏的全部内容，而是与物理、AI等相关的部分。用过unity的同学应该已经感觉有点熟悉了，这个在unity中就是FixedUpdate。&lt;/li&gt;
  &lt;li&gt;对于render，因为它只是将某一个时间点的内容显示出来，因此并不受动态时间间隔的影响，只要保证每一帧都做一次就好。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://c1.staticflickr.com/1/794/40708404425_cfb99f19ab_n.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;double previous = getCurrentTime();
double lag = 0.0;
while (true)
{
  double current = getCurrentTime();
  double elapsed = current - previous;
  previous = current;
  lag += elapsed;

  processInput();

  while (lag &amp;gt;= MS_PER_UPDATE)
  {
    update();
    lag -= MS_PER_UPDATE;
  }

  render();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;上面的代码某种程度是也是unity内部的实现。而里面的update函数可以换做FixedUpdate，这也是为何在输出log的情况下，可能会发现一个Update中会穿插多个FixedUpdate。因为unity中默认是FixedUpdate是一秒执行50次，即0.02秒一次，但是如果说一帧的真实时间超过了0.02s，那么为了追赶时间一帧中会执行多次FixedUpdate。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-6&quot;&gt;卡在中间&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;其实上面一步已经算是比较完善的循环过程，在固定的时间更新游戏，而在任意一个时刻渲染。但是这样也意味着某次渲染可能是在两次更新之间。如下图所示，在第三次渲染时刚好渲染的时间点处于更新的中间。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://c1.staticflickr.com/1/903/40708404465_50b27abb1a_b.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;这个会造成什么问题呢？如果说是一颗子弹在运行，玩家在渲染的一瞬间期望看到的是子弹处于两个更新点之间的位置，但是因为下一个Update没有执行，所以真正看到的是子弹在左边的位置。也就是说期望与现实不符。其实人眼很可能根本看不到这么细微的差别，但是这个问题确实是存在的。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://c1.staticflickr.com/1/935/40708404125_3ac09fe94a_b.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;为了解决这个问题我们可以采用这样的一个方式&lt;code class=&quot;highlighter-rouge&quot;&gt;render(lag / MS_PER_UPDATE);&lt;/code&gt;， 在上面的代码中可以看出，lag经过计算后在render调用前的值为到下一帧的值。因此在渲染时考虑这个时间可以平滑的预计算物体的位置。但是这个位置并不一定是正确的，因为也许物体会碰撞发生位置的变化，但是这个必须要等下一帧中的update里面确认。&lt;/li&gt;
  &lt;li&gt;PS：我并不确定这个操作是否有实际的意义。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-7&quot;&gt;设计决策&lt;/h4&gt;
&lt;h5 id=&quot;section-8&quot;&gt;拥有游戏循环的是你，还是平台？&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;在使用循环的时候我们可能会遇到这样三种情况：
    &lt;ul&gt;
      &lt;li&gt;处于某个特定的平台，而这个平台有自己的循环，比如web browser上开发游戏就会受到浏览器本身的事件驱动机制阻碍。&lt;/li&gt;
      &lt;li&gt;已经在使用某个游戏引擎了，比如说unity引擎，它就已经具备了内置的循环并且通过Update函数开放。&lt;/li&gt;
      &lt;li&gt;编写自己的循环&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;以上三种情况各有利弊：
    &lt;ul&gt;
      &lt;li&gt;平台循环可以让你不必编写和优化自己的核心循环，但是你失去了对于时间的控制。&lt;/li&gt;
      &lt;li&gt;游戏引擎循环与平台的情况基本一致。而且目前我们大多数开发都在使用商业引擎。&lt;/li&gt;
      &lt;li&gt;自己编写当然最大的好处是完全可以自己控制，但是如果你在某个平台或者引擎上开发就需要考虑如何与其它循环协作的问题。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-9&quot;&gt;如何管理能量消耗？&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;随着移动游戏时代的到来，越快越好的策略被舍弃，因为必须考虑手机设备的电量使用和CPU过度使用而造成的发热问题。&lt;/li&gt;
  &lt;li&gt;移动游戏更加注意游戏的体验质量，而不是最大化图像画质。 很多这种游戏都会设置最大帧率（通常是30或60FPS）。 如果游戏循环在分配的时间片消耗完之前完成，剩余的时间它会休眠。这给了玩家“足够好的”游戏体验，也让电池轻松了一点。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-10&quot;&gt;你如何控制游戏速度？&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;固定时间步长，没有同步：也就是最开始的那套循环，完全依赖于硬件设备的性能。这个最大的弊端是影响游戏速度。&lt;/li&gt;
  &lt;li&gt;固定时间步长，有同步：它的前提是游戏运行帧率很高，所以加了限制。这样可以节约电量，但是如果一旦帧率不够高其实也会造成游戏时间比现实时间慢的问题。&lt;/li&gt;
  &lt;li&gt;动态时间步长：能适应并调整，避免运行得太快或者太慢。 如果游戏不能追上真实时间，它用越来越长的时间步长更新，直到追上。但是它也让游戏不确定而且不稳定。这是真正的问题，当然。在物理和网络部分使用动态时间步长会遇见更多的困难。&lt;/li&gt;
  &lt;li&gt;固定更新时间步长，动态渲染：能适应并调整，避免运行得太快或者太慢。 只要能实时更新，游戏状态就不会落后于真实时间。如果玩家用高端的机器，它会回以更平滑的游戏体验。但是它更复杂。主要负面问题是需要在实现中写更多东西。 你需要将更新的时间步长调整得尽可能小来适应高端机，同时不至于在低端机上太慢。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-11&quot;&gt;参考&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.unity3d.com/Manual/ExecutionOrder.html&quot;&gt;Unity中的循环&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.koonsolo.com/news/dewitters-gameloop/&quot;&gt;Game Loop&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://gafferongames.com/post/fix_your_timestep/&quot;&gt;Fix Your Timestep!&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 06 May 2018 15:17:40 +0800</pubDate>
        <link>https://caihua.tech/2018/05/06/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B8%B8%E6%88%8F%E5%BE%AA%E7%8E%AF/</link>
        <guid isPermaLink="true">https://caihua.tech/2018/05/06/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B8%B8%E6%88%8F%E5%BE%AA%E7%8E%AF/</guid>
        
        <category>游戏设计模式读书笔记</category>
        
        
      </item>
    
      <item>
        <title>游戏设计模式读书笔记：状态模式</title>
        <description>&lt;h4 id=&quot;section&quot;&gt;解决了什么问题&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;在游戏开发中状态是一种常见的用于描述游戏对象的方法，在状态比较简单的情况下可能通过多个标志位变量就可以组合出不同的状态。例如书中举得英雄行走、跳跃、蹲下等操作。但是一旦当对象的状态可是变得比较多，而且需要通过比较多的变量才能描述清楚时，只使用标志位变量的弊端就出现了：那就是过多的变量在代码编写时需要的条件语句会很多，而且变量的组合也不利于管理。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;switch&quot;&gt;使用switch管理状态&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;首先需要将状态从变量组合变为一个明确的字段，此时我们可以使用enum来实现这个。&lt;/li&gt;
  &lt;li&gt;在switch中对于每个枚举状态开设分支。这样从一定程度上解决了大量变量带来的编程的复杂度。而且从逻辑上清晰的划分了状态。&lt;/li&gt;
  &lt;li&gt;但是这个仍旧存在问题，用书中的例子来说，当你需要在某个状态中进行一个计时操作时。就需要在switch代码块和update代码块中修改功能，这说明功能没有能很好的封装，你需要修改两处才能实现功能的修改。如果我们在修改功能的时候只修改一个地方就能够避免一些麻烦，比如一次修改就要同时修改多处，万一遗漏了一个就可能造成bug。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-1&quot;&gt;状态模式&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;允许一个对象在其内部状态发生变化时改变自己的行为，该对象看起来好像修改了它的类型。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;这句话有点让人难以理解，实际上状态模式是这么干的：
    &lt;ul&gt;
      &lt;li&gt;定义状态接口&lt;/li&gt;
      &lt;li&gt;让每个状态成为一个类并实现接口&lt;/li&gt;
      &lt;li&gt;对象持有状态对象的引用，从而使得从外部看（实际就是获取对象的某些属性或者调用函数）这个对象具有不同的状态。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;对于一个状态的接口一般都包含如下的函数：Enter、Update、Exit。除此之外也可以根据实际情况设计一些函数，比如设计一个Init函数，它是在状态对象实例化时进行初始化用的。&lt;/li&gt;
  &lt;li&gt;静态状态：如果一个状态它只有函数没有字段，也就是说它是对象无关的，那么完全可以使用静态类来定义状态，这样做可以节省内存，管理起来也比较简单。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;fsm&quot;&gt;有限状态机（FSM）&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;FSM我个人认为其作用在于专职的管理状态，比如状态的创建、切换、销毁等。&lt;/li&gt;
  &lt;li&gt;对象持有的不在是一个具体的状态对象，而是一个FSM对象。而状态的切换也需要在FSM中实现，FSM中有一个所有状态的集合，同时保存当前的状态的引用。&lt;/li&gt;
  &lt;li&gt;在切换状态时先要执行当前状态的Exit函数，然后执行下一个状态的Enter。&lt;/li&gt;
  &lt;li&gt;在unity中对于不同的FSM一般使用一个专门的管理类来管理所有的FSM。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-2&quot;&gt;并发状态机&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;并发状态机和下面谈到的另外两个其实都是在上面所说的基础上的扩展，用于不同的场景。&lt;/li&gt;
  &lt;li&gt;顾名思义，并发状态机实际上就是对象同时拥有两种不同的状态。以书中的例子来说，就是英雄角色具有一个状态机，而英雄手中的武器也具有一个状态机。&lt;/li&gt;
  &lt;li&gt;两个不同的状态机之间可能会有交互，为了完成这个，你也许会在状态的代码中做一些粗糙的if测试其他状态来协同，这不是最优雅的解决方案，但这可以搞定工作。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-3&quot;&gt;分层状态机&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;当不同状态具有某个共同点时使用。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;举个例子，我们的英雄也许有站立、行走、奔跑和滑铲状态。在这些状态中，按B跳，按下蹲。如果使用简单的状态机实现，我们在每个状态中的都重复了代码。如果我们能够实现一次，在多个状态间重用就好了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;状态可以有父状态（这让它变为子状态）。当一个事件进来，如果子状态没有处理，它就会交给链上的父状态。 换言之，它像重载的继承方法那样运作。事实上，如果我们使用状态模式实现FSM，我们可以使用继承来实现层次。 定义一个基类作为父状态：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class OnGroundState : public HeroineState
{
public:
  virtual void handleInput(Heroine&amp;amp; heroine, Input input)
  {
    if (input == PRESS_B)
    {
      // 跳跃……
    }
    else if (input == PRESS_DOWN)
    {
      // 俯卧……
    }
  }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class DuckingState : public OnGroundState
{
public:
  virtual void handleInput(Heroine&amp;amp; heroine, Input input)
  {
    if (input == RELEASE_DOWN)
    {
      // 站起……
    }
    else
    {
      // 没有处理输入，返回上一层
      OnGroundState::handleInput(heroine, input);
    }
  }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;除了使用继承外，还可以显式的使用状态栈而不是单一状态来表示当前状态的父状态链。栈顶的状态是当前状态，在他下面是它的直接父状态，然后是那个父状态的父状态，以此类推。 当你需要状态的特定行为，你从栈的顶端开始，然后向下寻找，直到某一个状态处理了它。（如果到底也没找到，就无视它。）&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-4&quot;&gt;下推自动机&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;下推状态机解决的问题是有限状态机没有任何历史的概念。你记得正在什么状态中，但是不记得曾在什么状态。 没有简单的办法重回上一状态。&lt;/li&gt;
  &lt;li&gt;有限状态机有一个指向状态的指针，下推自动机有一栈指针。 在FSM中，新状态代替了之前的那个状态。 下推自动机不仅能完成那个，还能给你两个额外操作：
    &lt;ul&gt;
      &lt;li&gt;你可以将新状态压入栈中。“当前的”状态总是在栈顶，所以你能转到新状态。 但它让之前的状态待在栈中而不是销毁它。&lt;/li&gt;
      &lt;li&gt;你可以弹出最上面的状态。这个状态会被销毁，它下面的状态成为新状态。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-5&quot;&gt;总结&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;状态模式在游戏开发中使用的最为广泛的就是FSM，它有效的将游戏对象的不同状态进行了封装，从而使得对象的操作更加简单。&lt;/li&gt;
  &lt;li&gt;对于单个的游戏对象不同的状态中可能会有更多的操作，比如对象在行走状态下需要控制移动的方向、速度、对于碰撞体的处理等。这个就需要在状态机中进行功能编写了。&lt;/li&gt;
  &lt;li&gt;对于FSM的实现推荐看下GameFramework中的&lt;a href=&quot;https://github.com/EllanJiang/GameFramework/tree/master/GameFramework/Fsm&quot;&gt;FSM&lt;/a&gt;部分。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 21 Apr 2018 20:15:35 +0800</pubDate>
        <link>https://caihua.tech/2018/04/21/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</link>
        <guid isPermaLink="true">https://caihua.tech/2018/04/21/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</guid>
        
        <category>游戏设计模式读书笔记</category>
        
        
      </item>
    
      <item>
        <title>七周七并发模式：Lambda架构</title>
        <description>&lt;h3 id=&quot;lambda&quot;&gt;Lambda架构&lt;/h3&gt;

&lt;h4 id=&quot;section&quot;&gt;定义&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;Lambda架构使用了可以进行大规模数据批处理的MapReduce技术，也使用了可以快速处理数据并及时反馈的流处理技术，这样的混搭能够为大数据问题提供扩展性、响应性和容错性都很优秀的解决方案。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Lambda架构是站在大规模场景的角度来解决问题的，它可以将数据和计算分布到几十台或几百台机器构成的集群上进行。这种技术不但解决了之前因为规模庞大而无法解决的难题，还可以构建出对硬件错误和人为错误进行容错的系统。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Lambda架构源自于它与函数式编程的相似性。从本质上说，Lambda架构是将计算函数施加于大量数据的一种通用方法。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;不变原始数据是Lambda架构的基础。对于不变的数据进行处理的时候，不在需要锁机制和事物机制。多个线程可以并行地访问数据，而不用担心相互之间的作用。我们可以对数据进行复制，再对副本进行操作，而不用担心数据过期，所以在集群中分布地处理数据就变得非常容易。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-1&quot;&gt;传统数据系统的缺陷&lt;/h4&gt;
&lt;blockquote&gt;
  &lt;p&gt;扩展性：利用某些技术（比如复制、分片等）可以将传统数据库扩展到多台计算机上，但随着计算机数量和查询数量的增加，应用这种方案会变得越来越困难。超过一定程度，增加计算机资源将无法继续改善性能。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;维护成本：维护一个跨多台计算机的数据库的成本是比较高的。如果要求维护时不能停机，那么维护将变得更加困难——比如对数据库进行重新分片。随着数据量和查询数量的增加，容错、备份、确保数据一致性等工作的难度都会呈几何级数增长。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;复杂度：复制和分片通常要求应用层面提供一些支持——应用需要知道将查询发给哪一台计算机，以及应该更新哪一个数据分片（每个更新所对应的分片通常不一样，规则也比较复杂）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;人为错误&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;报表和分析：在独立的数据仓库中用另一种格式来维护历史数据。数据从业务数据库向数据仓库的迁移过程就是著名的萃取（extract）、转置（transform）、加载（load）（简称ETL）。这种方案不仅复杂，而且需要准确预测将来我们需要什么信息。有时会碰到这种情况：由于缺乏必要的信息或者信息格式不对，无法生成所需报表或进行某些分析。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;section-2&quot;&gt;批处理视图（批处理层） &amp;amp; 服务层&lt;/h4&gt;
&lt;blockquote&gt;
  &lt;p&gt;如果能够准确预测出未来会对原始数据进行怎样的查询，就可以预计算出一个批处理视图，这个视图包含这些查询将要返回的衍生信息，或者那些可以计算出这些衍生信息的数据。Lambda架构的批处理层就是用来计算这些批处理视图的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;批处理视图可以包含衍生信息，比如：假设要用一系列编辑记录来构建Wikipedia的页面——批处理视图将只包含从页面的编辑记录中计算得来的页面内容。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;批处理视图也可以包含可以计算出衍生信息的数据，这类情况会稍微复杂一些。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;需要对生成的批处理视图进行索引，这样就可以对索引进行查询了。另外，还需要一个地方来存放程序逻辑（说明一个查询该如何合并批处理视图的逻辑）。这就是服务层的任务。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;总结来说利用不变数据利于并行的特显对海量数据进行加工（mapper + reducer），生成批处理视图。然后再通过简单的查询得到想要的结果。&lt;/li&gt;
  &lt;li&gt;后面提到的Hadoop就是应用于批处理层&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-3&quot;&gt;加速层&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;有新数据产生时，除了会将数据投入到原始数据还会进行扔给加速层生成实时视图，结合最新的批处理视图可以满足对于新数据的查询。&lt;/li&gt;
  &lt;li&gt;当新的批处理视图产生后，实时视图就被丢弃了。&lt;/li&gt;
  &lt;li&gt;这个东西的目的应该是为了快速响应新数据，在批处理层还没有出新版本时，临时使用实时视图+当前最新的批处理视图就组成了未来会出现的批处理视图。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;后面讲的Storm系统应用于加速层&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;最后放一张架构图&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://c1.staticflickr.com/1/890/39792443890_5335cc665b_c.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;mapreduce&quot;&gt;MapReduce&lt;/h3&gt;

&lt;h4 id=&quot;section-4&quot;&gt;定义&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;MapReduce是一个多义的术语。其可以指代一类算法，这类算法分为两个步骤：对一个数据结构首先进行映射（map）操作，然后进行化简（reduce）操作。之前的词频统计的函数式版本正是这样的例子（frequencies就是用reduce函数实现的）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;MapReduce还可以指代一类系统——这类系统使用了上面的算法，将计算过程高效地分布到一个集群上。这类系统不仅可以将数据和数据处理分布到集群的多台计算机上，还可以在一台或多台计算机崩溃时继续正常运转。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;一个MapReduce任务由两种主要的组件构成：mapper和reducer。mapper负责将某种输入格式（通常是文本）映射为许多键值对。reducer负责将这些键值对转换成最终的输出格式（通常也是一系列键值对）。mapper和reducer可以分布在很多不同的计算机上（它们的数目不必相同）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;hadoop&quot;&gt;Hadoop&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;一个包含了MapReduce的&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;输入通常由一个或多个大文本文件构成。Hadoop对这些文件进行分片（每一片的大小是可配置的，通常为64 MB），并将每个分片发送给一个mapper。mapper将输出一系列键值对，Hadoop再将这些键值对发送给reducer。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;一个mapper产生的键值对可以发送给多个reducer。键值对的键决定了哪个reducer会接受这个键值对——Hadoop确保具有相同键的键值对（无论是由哪个mapper产生的）都会发送给同一个reducer处理。这个阶段通常被称为洗牌阶段（shuffle phase）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Hadoop为每个键调用一次reducer，并传入所有与该键对应的值。reducer将这些值合并，再生成最终输出结果（通常是键值对，也可以不是）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;mapper--reducer&quot;&gt;mapper &amp;amp; reducer&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;书中demo的Map继承了Hadoop的Mapper类，其接受四个类型参数：输入的键类型、输入的值类型、输出的键类型、输出的值类型。它里面的方法本质是将一行文本进行拆分，输出一个键值对。&lt;/li&gt;
  &lt;li&gt;对于每个键，都会调用一次reduce()方法，values是这个键对应的所有值的集合。reduce()方法对这些值进行求和，并产生描述某个单词出现总数的键值对。&lt;/li&gt;
  &lt;li&gt;Hadoop在键值对传给reducer前会对键进行排序&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;driver&quot;&gt;Driver&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;从下面的代码看driver就是配置Hadoop。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;这里不需要设置输入的键类型和值类型，因为默认情况下Hadoop认为我们处理的是文本文件。也不需要分别设置mapper输出的键/值类型和reducer输入的键/值类型，因为默认情况下Hadoop认为mapper的输出和reducer的输入具有相同的键/值类型。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;使用setInputFormatClass()将XmlInputFormat设置为分片器，并且配置xmlinput.start和xmlinput.end来告诉分片器我们关注的是哪个标签。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;setCombinerClass()来设置combiner。combiner是一种优化手段，使键值对可以在发往reducer前进行合并。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class WordCount extends Configured implements Tool { 
    public int run(String[] args) throws Exception { 
        Configuration conf = getConf();
        conf.set(&quot;xmlinput.start&quot;, &quot;&amp;lt;text&quot;);
        conf.set(&quot;xmlinput.end&quot;, &quot;&amp;lt;/text&amp;gt;&quot;);
        Job job = Job.getInstance(conf, &quot;wordcount&quot;);
        job.setJarByClass(WordCount.class);
        job.setInputFormatClass(XmlInputFormat.class);
        job.setMapperClass(Map.class);
        job.setCombinerClass(Reduce.class);
        job.setReducerClass(Reduce.class);
        job.setOutputKeyClass(Text.class);  job.setOutputValueClass(IntWritable.class);  FileInputFormat.addInputPath(job, new Path(args[0]));    FileOutputFormat.setOutputPath(job, new Path(args[1]));
        boolean success = job.waitForCompletion(true);
        return success ? 0 : 1;    15  
    } 
    
    public static void main(String[] args) throws Exception {
        int res = ToolRunner.run(new Configuration(), new WordCount(), args);
        System.exit(res);
        
    }   
    
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;hadoop-1&quot;&gt;Hadoop的优势&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;可以在多台计算机上更快地处理海量的数据&lt;/li&gt;
  &lt;li&gt;Hadoop天生就具有处理错误和从错误中恢复的能力，这点很好保证了在使用集群时的稳定性。&lt;/li&gt;
  &lt;li&gt;与上一条相关，不仅要考虑将节点崩溃时正在处理的任务重新执行，还需要考虑当存储发生故障时如何保证数据不丢失。Hadoop默认使用Hadoop分布式文件系统（HDFS），这个有容错能力的分布式文件系统可以在多个节点之间冗余数据。&lt;/li&gt;
  &lt;li&gt;涉及吉字节级别以上的数据时，就不能将所有中间数据或结果全部存放在内存中。Hadoop在处理过程中将键值对存储在HDFS中，这样就可以不受内存限制，完成数据量非常大的任务。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;storm&quot;&gt;Storm&lt;/h3&gt;

&lt;h4 id=&quot;spoutbolttopology&quot;&gt;Spout、Bolt和Topology&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Storm系统处理的是元组（tuple）的流。Storm的元组类似于之前我们在第5章看到的actor模型的元组，但不同于Elixir的元组，Storm元组的元素是有名字的。&lt;/li&gt;
  &lt;li&gt;元组由spout（出水管）组件创建，并由bolt（螺栓）组件进行处理，bolt也会输出元组。用流将spout和bolt连接在一起，就形成了topology（拓扑结构）。&lt;/li&gt;
  &lt;li&gt;topology也可以很复杂——bolt可以消费多个流，而一个流也可以被多个bolt消费，构成一个有向无环图。spout和bolt都是并行化和分布式的。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;worker：spout和bolt不仅相互之间是并行的，而且其内部也都是并行的——每一个个体内部都是由很多worker实现的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;下图是一个topology&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://c1.staticflickr.com/1/913/27731323968_ca81741161_z.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-5&quot;&gt;容错&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;将一个spout或bolt的多个worker分布在多台计算机上的主要原因是容错性。如果集群中的某一台计算机发生故障，topology可以将元组分发给仍存活的计算机，这样topology就可以继续运行。&lt;/li&gt;
  &lt;li&gt;Storm会监视元组之间的依赖——如果某一个元组没能完成，Storm会将其依赖的spout元组置为失败并进行重试。这也就是说Storm默认使用的是“至少会执行一次”的处理策略。应用必须知道这个事实：元组可能会被重试，直到其结果正确。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-6&quot;&gt;总结&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Lambda目前主要作为大数据平台的架构&lt;/li&gt;
  &lt;li&gt;如果用Hadoop作为Batch Layer，而用Storm作为Speed Layer，那就需要维护两份使用不同技术的代码。所以目前有另外的一个解决方案是Apache Spark，它可以作为Lambda Architecture一体化的解决方案。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-7&quot;&gt;引用&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.zhihu.com/question/26568496&quot;&gt;与 Hadoop 对比，如何看待 Spark 技术？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 20 Apr 2018 17:19:43 +0800</pubDate>
        <link>https://caihua.tech/2018/04/20/%E4%B8%83%E5%91%A8%E4%B8%83%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F-Lambda%E6%9E%B6%E6%9E%84/</link>
        <guid isPermaLink="true">https://caihua.tech/2018/04/20/%E4%B8%83%E5%91%A8%E4%B8%83%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F-Lambda%E6%9E%B6%E6%9E%84/</guid>
        
        <category>并发模型</category>
        
        
      </item>
    
      <item>
        <title>七周七并发模式：通信顺序进程（CSP）</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;概念&lt;/h3&gt;

&lt;h4 id=&quot;csp&quot;&gt;CSP&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;与actor模型类似，通信顺序进程（Communicating Sequential Processe，CSP）模型也是由独立的、并发执行的实体所组成，实体之间也是通过发送消息进行通信。但两种模型的重要差别是：CSP模型不关注发送消息的实体，而是关注发送消息时使用的channel（通道）。channel是第一类对象，它不像进程那样与信箱是紧耦合的，而是可以单独创建和读写，并在进程之间传递。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;从这段话可以看出CSP本质上也是独立运行的执行单元，但是它没有mailbox，那么它执行的数据来自哪里呢？来自于channel。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;channel&quot;&gt;Channel&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;一个channel就是一个线程安全的队列，任何任务只要持有channel的引用，就可以向一端添加消息，也可以从另一端删除消息。在actor模型中，消息是从指定的一个actor发往指定的另一个actor的；与之不同，使用channel发送消息时发送者并不知道谁是接收者，反之亦然。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;也就是说CSP更像是在不同的actor之间共享mailbox，但是这里mailbox编程了channel。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;默认情况下，channel是同步的（或称无缓存的）——一个任务向channel写入消息的操作会一直阻塞，直到另一个任务从channel中读出消息。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;emmm，阻塞了一个写入的线程。这样有些浪费线程，因此有了带&lt;code class=&quot;highlighter-rouge&quot;&gt;缓存区&lt;/code&gt;的channel。当channel的缓存区有足够空间时，向其中写入消息的操作会立刻完成，不会阻塞。&lt;/li&gt;
  &lt;li&gt;对于有缓存的channel，一次性写入超过缓存区大小的数据时策略也是不同的，可以是只保留前面写入的（dropping），也可以是保留后面写入的(slide)，甚至是直接阻塞式的（blocking），这个一般都有语言级别的策略支持。&lt;/li&gt;
  &lt;li&gt;PS：是否支持可扩展的buffer这个问题书中提到是不支持，不过可能也只是这个语言不支持。因为我还没有看过其它的编程语言中是如何处理buffer的。&lt;/li&gt;
  &lt;li&gt;channel也可以被关闭，此时read/write的处理不同的语言可能会有不同的处理方式。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;go&quot;&gt;go块&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;在说这个概念之前需要先看看在它之前的线程操作过程中遇到的问题，只有弄清楚了存在什么问题，我们才能理解为何会有go块，而它又是干什么的。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;线程启动和运行时都有一定开销，这正是现在的程序都避免直接创建线程、转而使用线程池的原因。然而线程池并不总是适用。尤其是当程序阻塞时，使用线程池可能会造成麻烦。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;线程池技术是处理CPU密集型任务的利器——任务进行时会占用某个线程，任务结束后将线程返还给线程池，使线程可以被复用。但涉及线程通信时使用线程池是否仍然合适呢？如果线程被阻塞，那么它将无限期被占用，这就削弱了使用线程池技术的优势。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;这种问题是有一些解决方案的，但它们通常会对代码风格加以限制，使之变成事件驱动的形式。虽然这些方案都能解决问题，但它们破坏了控制流的自然的表达形式，让代码变得难以阅读和理解。更糟糕的是，这些方案还会大量使用全局状态，因为事件处理器需要保存一些数据，以便之后的事件处理器使用。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;从上面的摘抄中已经可以看出来多线程、线程池其实是各种局限，而加入了事件驱动后也是有问题的。在这样的情况下，一个能够支持事件驱动，又可以保证代码在编写和阅读时看上去是顺序执行（这样比较符合人的阅读习惯和理解），同时还把状态数据封装起来的东西，emmm，此时我第一个反应就是unity中的Coroutine，而unity的coroutine本质是个状态机。这样一路的推导下来，我们也就明白了go块的本质就是一个状态机。而它的诞生也是为了解决上面说提到的种种问题。&lt;/li&gt;
  &lt;li&gt;本书中对于go块的使用demo使用了Clojure这个语言，我觉得没必要细说具体实现，因为每个语言也不同。不过go块中需要强调一点，它是非阻塞的。当然如果是阻塞的并不是不能工作，但是又回到了线程大量使用而又阻塞的问题了。&lt;/li&gt;
  &lt;li&gt;在书中提到go块的成本很低，这与线程不同，因为目前我所知道的语言中go块这样的概念都是基于协程的。golang中甚至没有线程的概念。而C#中task也是协程的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;csp-1&quot;&gt;使用CSP&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;实际上本章第二节的例子基本都是利用channel的同步性。比如超时处理就可以让一个定时器过一定时间后写入channel，在这之前另一个方法用来读取channel。&lt;/li&gt;
  &lt;li&gt;还有一些异步操作也是利用了channel的同步性，在以前可能异步操作需要使用回调，但是这样的话不同函数就成了互相调用的情况，但是使用CSP可以让函数基于channel来执行。比如：A函数读取一个channel的数据，在channel被写入数据前，调用A的线程阻塞；在IO操作完成后将结果写入channel，这样A函数就可以读取IO的结果了，而且两个函数不需要知道对方的存在，完全依赖channel来通信。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-1&quot;&gt;总结&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;首先与Actor比，CSP更加灵活。Actor负责通信的媒介（mailbox）与执行单元是紧耦合的，而CSP中channel可以被独立的创建、读写数据。从耦合性上将CSP更好。&lt;/li&gt;
  &lt;li&gt;然后CSP的go块使得异步编程更加高效，比起写很长的回调式的代码，CSP的代码更简洁。&lt;/li&gt;
  &lt;li&gt;至于书中提到的CSP的缺点：分布式和容错性支持的不够好，这个我个人觉得因语言而异，因为很少做相关的开发不好发表意见。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-2&quot;&gt;参考&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/ants/p/8601947.html#_label1&quot;&gt;Golang的CSP很酷？其实.NET也可以轻松完成&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://www.voidcn.com/article/p-qrvdpmgk-bnw.html&quot;&gt;CSP与并发编程&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 02 Apr 2018 16:33:43 +0800</pubDate>
        <link>https://caihua.tech/2018/04/02/%E4%B8%83%E5%91%A8%E4%B8%83%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B-%E9%80%9A%E4%BF%A1%E9%A1%BA%E5%BA%8F%E8%BF%9B%E7%A8%8B/</link>
        <guid isPermaLink="true">https://caihua.tech/2018/04/02/%E4%B8%83%E5%91%A8%E4%B8%83%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B-%E9%80%9A%E4%BF%A1%E9%A1%BA%E5%BA%8F%E8%BF%9B%E7%A8%8B/</guid>
        
        <category>并发模型</category>
        
        
      </item>
    
      <item>
        <title>Unity ECS：基本组件和功能</title>
        <description>&lt;h3 id=&quot;ecs&quot;&gt;ECS的组成&lt;/h3&gt;
&lt;h4 id=&quot;entity&quot;&gt;Entity：&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;近似一个轻量级的GameObject对象。&lt;/li&gt;
  &lt;li&gt;内部没有什么东西，这个和GameObject还不一样，毕竟在GameObject的继承链中具有很多成员和函数。&lt;/li&gt;
  &lt;li&gt;可以添加和移除组件&lt;/li&gt;
  &lt;li&gt;具有一个ID，这个是唯一稳定的。这个ID是entity在被保存时的唯一引用。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;icomponentdataisharedcomponentdata&quot;&gt;IComponentData和ISharedComponentData&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;前文说到过，ECS中的Component是一个结构体，里面只有数据。&lt;/li&gt;
  &lt;li&gt;这个结构体可以继承IComponentData或ISharedComponentData，从源码看这两个接口是空的。&lt;/li&gt;
  &lt;li&gt;IComponentData可以理解为不同entity之间不同的数据，而ISharedComponentData代表了相同的数据。其实从后者的名称上也可以看到一些蛛丝马迹。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;entityarchetype&quot;&gt;EntityArchetype&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;其实看到archetype（原型）这个词就大致明白这个类的作用了。&lt;/li&gt;
  &lt;li&gt;EntityArchetype是一个具有唯一性的ComponentType数组，它可以在创建entity时被作为参数使用，一个entity具有什么能力，完全在于它上面挂了什么Component，而多个component组成了一个能力组，这个就是EntityArchetype了。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Using typeof to create an EntityArchetype from a set of components
EntityArchetype archetype = EntityManager.CreateArchetype(typeof(MyComponentData), typeof(MySharedComponent));

// Same API but slightly more efficient
EntityArchetype archetype = EntityManager.CreateArchetype(ComponentType.Create&amp;lt;MyComponentData&amp;gt;(), ComponentType.Create&amp;lt;MySharedComponent&amp;gt;());

// Create an Entity from an EntityArchetype
var entity = EntityManager.CreateEntity(archetype);

// Implicitly create an EntityArchetype for convenience
var entity = EntityManager.CreateEntity(typeof(MyComponentData), typeof(MySharedComponent));
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;entitymanager&quot;&gt;EntityManager&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;一个管理所有EntityData、Archetype、SharedComponentData  和ComponentGroup的类。与ComponentSystems是同等地位的，看来unity ECS确实是一套新的系统。&lt;/li&gt;
  &lt;li&gt;从下面的代码中可以看出，实际上所有的Entity的创建、添加组件、查询live状态等操作的API都在这个类里面。应该是核心类。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Create an Entity with no components on it
var entity = EntityManager.CreateEntity();

// Adding a component at runtime
EntityManager.AddComponent(entity, new MyComponentData());

// Get the ComponentData
MyComponentData myData = EntityManager.GetComponentData&amp;lt;MyComponentData&amp;gt;(entity);

// Set the ComponentData
EntityManager.SetComponentData(entity, myData);

// Removing a component at runtime
EntityManager.RemoveComponent&amp;lt;MyComponentData&amp;gt;(entity);

// Does the Entity exist and does it have the component?
bool has = EntityManager.HasComponent&amp;lt;MyComponentData&amp;gt;(entity);

// Is the Entity still alive?
bool has = EntityManager.Exists(entity);

// Instantiate the Entity
var instance = EntityManager.Instantiate(entity);

// Destroy the created instance
EntityManager.DestroyEntity(instance);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// EntityManager also provides batch APIs
// to create and destroy many Entities in one call. 
// They are significantly faster 
// and should be used where ever possible
// for performance reasons.

// Instantiate 500 Entities and write the resulting Entity IDs to the instances array
var instances = new NativeArray&amp;lt;Entity&amp;gt;(500, Allocator.Temp);
EntityManager.Instantiate(entity, instances);

// Destroy all 500 entities
EntityManager.DestroyEntity(instances);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;entity-1&quot;&gt;对entity的一个小总结&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;EntityManager在生成一个entity时实际使用的是EntityDataManager类中的方法，而EntityDataManager中Entity&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当一个entity添加或者移除一个component时，实际上改变了其archetype的结构，此时会创建（优先从已有的archetype集合中查询）一个新的archetype来赋值给entity。参考EntityManager源码中相关的代码。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;chunk&quot;&gt;Chunk&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;chunk是所有ComponentData存储的方式，或者说在内存中的排列方式。&lt;/li&gt;
  &lt;li&gt;chunk连接着（或者说对应着）一个EntityArchetype。所有使用同一个EntityArchetype的entity都具有相同的内存布局，在内存中这些entity上的components的布局也比较奇特（原谅我用这个词）。它们（components）在存储时按照类型紧密排列的，。同一类型的component实例在内存中被连续的放在一起，后面是另一个类型的所有component实例。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;archetypechunk&quot;&gt;从内存角度看看archetype和chunk&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;从函数GetOrCreateArchetype可以看到每当新创建一个archetype时本质还是mallco一块内存，但是比较复杂的是一个archetype还包含了很多其它的数据，比如所有ISharedComponentData的类型。&lt;/li&gt;
  &lt;li&gt;但是正如上面提到的，chunk对于着一个archetype，其实chunk不过是一个内存地址。ChunkAllocator中的m_LastChunk维护这一个chunk的链表。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;jobcomponentsystem&quot;&gt;JobComponentSystem&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;上一篇最后的代码中提到了JobComponentSystem，它主要是用于自动管理job的依赖。一个例子就是在多个job在操作同一个ComponentData时，如果前面几个是在并行的read数据，突然出现一个write数据的job，此时就要等已经执行的read全部结束后暂停其它的job，让write job完成后在执行其它的。这个东西本质上与.NET的Parallel API是一样的，而大多数并行操作都会采用这样的方式，比如一个典型的例子就是SQLit的操作。&lt;/li&gt;
  &lt;li&gt;同时系统内部还使用Injection和ComponentGroup在管理依赖。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 27 Mar 2018 20:07:00 +0800</pubDate>
        <link>https://caihua.tech/2018/03/27/Unity-ECS-%E5%9F%BA%E6%9C%AC%E7%BB%84%E4%BB%B6%E5%92%8C%E5%8A%9F%E8%83%BD/</link>
        <guid isPermaLink="true">https://caihua.tech/2018/03/27/Unity-ECS-%E5%9F%BA%E6%9C%AC%E7%BB%84%E4%BB%B6%E5%92%8C%E5%8A%9F%E8%83%BD/</guid>
        
        <category>Unity3D</category>
        
        
      </item>
    
      <item>
        <title>Unity ECS：C# Job System</title>
        <description>&lt;h3 id=&quot;job-system&quot;&gt;Job system&lt;/h3&gt;
&lt;h4 id=&quot;job-system-1&quot;&gt;Job system解决了什么问题&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;unity是支持多线程的，虽然有些缺陷。但是我们在代码里面编写大量的线程，即使使用thread pool也无法避免上下文切换的问题。而Job System本质上还是线程(wrok thread)，只不过它的工作线程的数量和CPU逻辑上的核数量一致，这样就避免了上下文切换。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;job-system-2&quot;&gt;Job System如何工作&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;在这个系统中真正发挥作用的是job单元，它类似方法的调用，包含了参数和数据。job被填入Job Queue中，然后work thread负责调用它。&lt;/li&gt;
  &lt;li&gt;job system中有dependency（依赖）的概念，如果job A依赖于job B，那么系统会保证B在A执行前完成。&lt;/li&gt;
  &lt;li&gt;job system不是现存的任何C#线程模型中的一种。&lt;/li&gt;
  &lt;li&gt;它被集成在引擎内部，这意味着我们开发者所编写的代码会让unity引擎共享work thread，这样才能避免对于CPU的竟态使用。&lt;/li&gt;
  &lt;li&gt;PS: 我很怀疑是否代码写的很糟糕的情况下，会影响引擎本身的效率。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;job-system-3&quot;&gt;Job System如何避免竟态&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;我觉得文档想描述的很大程度上是数据原子性的问题&lt;/li&gt;
  &lt;li&gt;job system会检查所有潜在的竟态。&lt;/li&gt;
  &lt;li&gt;让所有的job操作同一份数据拷贝&lt;/li&gt;
  &lt;li&gt;job只能访问blittable data(这种数据在托管和非托管中具有相同的内存结构)，而不是managed types。&lt;/li&gt;
  &lt;li&gt;鉴于上面提到的数据拷贝的就行，为了解决现实世界复杂的问题，提供了NativeContainers：
    &lt;ul&gt;
      &lt;li&gt;类型包括：NativeArray, NativeList, NativeHashMap, and NativeQueue.&lt;/li&gt;
      &lt;li&gt;这些类型能够被unity追踪，谁在读写它们。比如两个job同时写入时需要使用Schedule来安排执行顺序，安全系统会抛出一个明确的异常来说明这些。&lt;/li&gt;
      &lt;li&gt;多个job同时读取一个数据时是并发的&lt;/li&gt;
      &lt;li&gt;读写的限制同样适用于main thread&lt;/li&gt;
      &lt;li&gt;一些container有特殊的规则，以便适应来自&lt;code class=&quot;highlighter-rouge&quot;&gt;ParallelFor jobs&lt;/code&gt;的安全、明确的写入访问。比如&lt;code class=&quot;highlighter-rouge&quot;&gt;NativeHashMap.Concurrent&lt;/code&gt;允许使用&lt;code class=&quot;highlighter-rouge&quot;&gt;IJobParallelFor&lt;/code&gt;并发的添加item。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;job&quot;&gt;调度job&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;job system依赖blittable data和NativeContainer&lt;/li&gt;
  &lt;li&gt;实现步骤：
    &lt;ul&gt;
      &lt;li&gt;定一个实现了IJob接口的struct&lt;/li&gt;
      &lt;li&gt;创建struct对象，填充数据，调用Schedule方法。&lt;/li&gt;
      &lt;li&gt;调用方法后得到一个job handle对象。它可以做为其它job的依赖对象；也可以等待它完成工作。如果说需要在主线程访问传入job的NativeContainer，那就等待这个handle完成。这部分具体看代码比较好理解。&lt;/li&gt;
      &lt;li&gt;需要注意的是在主线程想要访问NativeContainers数据之前，需要让所有的 job依赖都完成，此时只用JobHandle.IsDone来判断是不够的，需要手动调用 JobHandle.Complete方法。Complete方法还会清空jobs debugger中的状态。&lt;/li&gt;
      &lt;li&gt;如果每一帧都调用一个新的job，这个job还依赖于上一帧的job的话，会出现内存泄漏。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;从下面的代码可以看出，一个job就是一个实现了IJob的struct。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;定义struct：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Job adding two floating point values together
public struct MyJob : IJob
{
    public float a;
    public float b;
    NativeArray&amp;lt;float&amp;gt; result;
    public void Execute()
    {
        result[0] = a + b;
    }
}

public struct AddOneJob : IJob
{
    public NativeArray&amp;lt;float&amp;gt; result;
    public void Execute()
    {
        result[0] = result[0] + 1;
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;创建单个job实例，进行调用：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Create a native array of a single float to store the result in. This example will wait for the job to complete, which means we can use Allocator.Temp
NativeArray&amp;lt;float&amp;gt; result = new NativeArray&amp;lt;float&amp;gt;(1, Allocator.Temp);
// Setup the job data
MyJob jobData = new MyJob();
jobData.a = 10;
jobData.b = 10;
jobData.result = result;
// Schedule the job
JobHandle handle = jobData.Schedule();
// Wait for the job to complete
handle.Complete();
// All copies of the NativeArray point to the same memory, we can access the result in &quot;our&quot; copy of the NativeArray
float aPlusB = result[0];
// Free the memory allocated by the result array
result.Dispose();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;使用schedule调用多个job&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NativeArray&amp;lt;float&amp;gt; result = new NativeArray&amp;lt;float&amp;gt;(1, Allocator.Temp);
// Setup the job data
MyJob jobData = new MyJob();
jobData.a = 10;
jobData.b = 10;
jobData.result = result;
// Schedule the job
JobHandle firstHandle = jobData.Schedule();
AddOneJob incJobData = new AddOneJob();
incJobData.result = result;
JobHandle handle = incJobData.Schedule(firstHandle);
// Wait for the job to complete
handle.Complete();
// All copies of the NativeArray point to the same memory, we can access the result in &quot;our&quot; copy of the NativeArray
float aPlusB = result[0];
// Free the memory allocated by the result array
result.Dispose();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;parallelfor-jobs&quot;&gt;ParallelFor jobs&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;ParallelForJob适用于对于多个物体的并发操作，比如集合中的item。&lt;/li&gt;
  &lt;li&gt;并不是每个item对应一个job，而是每个CPU CORE对应一个job。这个也是上文说的为了保证减少上下文切换。&lt;/li&gt;
  &lt;li&gt;在使用ParallelForJob时需要传递两个参数：
    &lt;ul&gt;
      &lt;li&gt;数组的长度，这个数组应该是你要用来迭代的数组。&lt;/li&gt;
      &lt;li&gt;PS：实际上这部分文档上写的很奇怪，通过长度来区分数组？&lt;/li&gt;
      &lt;li&gt;一次批处理的个数，这个决定了job的个数。建议一开始使用的一个job然后慢慢的增加。直到性能提升的不明显了。&lt;/li&gt;
      &lt;li&gt;PS：其实在并行问题上，线程越多未必能够效率越高。以为还存在一个锁的问题。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Job adding two floating point values together
public struct MyParallelJob : IJobParallelFor
{
    [ReadOnly]
    public NativeArray&amp;lt;float&amp;gt; a;
    [Readonly]
    public NativeArray&amp;lt;float&amp;gt; b;
    public NativeArray&amp;lt;float&amp;gt; result;
    public void Execute(int i)
    {
        result[i] = a[i] + b[i];
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var jobData = new MyParallelJob();
jobData.a = 10;  
jobData.b = 10;
jobData.result = result;
// Schedule the job with one Execute per index in the results array and only 1 item per processing batch
JobHandle handle = jobData.Schedule(result.Length, 1);
// Wait for the job to complete
handle.Complete();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;job-system-4&quot;&gt;Job System还存在的问题&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;无法访问static数据，这个功能后续应该会有。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section&quot;&gt;参考&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;//docs.microsoft.com/en-us/dotnet/framework/interop/blittable-and-non-blittable-types&quot;&gt;Blittable and Non-Blittable Types&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 23 Mar 2018 16:07:00 +0800</pubDate>
        <link>https://caihua.tech/2018/03/23/Unity-ECS-C-Job-System/</link>
        <guid isPermaLink="true">https://caihua.tech/2018/03/23/Unity-ECS-C-Job-System/</guid>
        
        <category>Unity3D</category>
        
        
      </item>
    
      <item>
        <title>Unity ECS：概述</title>
        <description>&lt;h4 id=&quot;section&quot;&gt;前言&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;看来unity已经认识到现在编写代码的一些问题了：OO的模型、mono所编译的糟糕的机器码、GC和单线程。emmm&lt;/li&gt;
  &lt;li&gt;ECS的推出就是为了解决上面的问题，同时使用ECS是为了能够利用C# Job System和Burst compiler。job system是支持多线程的（( Ĭ ^ Ĭ )）&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;componentsystem&quot;&gt;ComponentSystem&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;在后面的文章中会说到ECS中的Component，这里简单说下，新的component模型只包含了数据，而ComponentSystem包含了行为。&lt;/li&gt;
  &lt;li&gt;一个ComponentSystem负责在每帧中对物体进行操作，这些物体必须匹配ComponentSystem所定义的一组component。有点类似后面讲到的的EntityArchetype。看下代码的例子：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Rotator : MonoBehaviour
{
    // The data - editable in the inspector
    public float Speed;
}

class RotatorSystem : ComponentSystem
{
    struct Group
    {
        // Define what components are required for this 
        // ComponentSystem to handle them.
        Transform Transform;
        Rotator   Rotator;
    }
    
    override protected OnUpdate()
    {
        // We can immediately see a first optimization.
        // We know delta time is the same between all rotators,
        // so we can simply keep it in a local variable 
        // to get better performance.
        float deltaTime = Time.deltaTime;
        
        // ComponentSystem.GetEntities&amp;lt;Group&amp;gt; 
        // lets us efficiently iterate over all GameObjects
        // that have both a Transform &amp;amp; Rotator component 
        // (as defined above in Group struct).
        foreach (var e in GetEntities&amp;lt;Group&amp;gt;())
        {
            e.Transform.rotation *= Quaternion.AxisAngle(e.Rotator.Speed * deltaTime, Vector3.up);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;Rotator是现在系统中的一个MonoBehaviour，而RotatorSystem是一个ComponentSystem。后者包含了一个Group用于匹配GameObject，而OnUpdate方法则是处理行为的函数。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;componentsystem-1&quot;&gt;如何在现有的系统中使用ComponentSystem&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;目前是需要在每个GameObject上挂一个GameObjectEntity脚本，它在OnEnable方法中会创建一个entity，挂上GameObject上的所有组件。然后就能被ComponentSystem使用了。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;这意味着你可以将所有的行为处理从MonoBehaviour.Updata中转移到 ComponentSystem.OnUpdate中，数据仍旧可以保持在MonoBehaviour中。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;这样做的优势
    &lt;ul&gt;
      &lt;li&gt;数据（MonoBehaviour）与行为（ComponentSystem）的分离&lt;/li&gt;
      &lt;li&gt;一些对象上的系统操作是批量的（应该是基于Job System），便于优化代码。比如上面代码中的deltaTime的使用。&lt;/li&gt;
      &lt;li&gt;可以继续使用现存的inspector、editor工具等。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;劣势
    &lt;ul&gt;
      &lt;li&gt;实例化时间没有改善&lt;/li&gt;
      &lt;li&gt;加载的时间没有改善&lt;/li&gt;
      &lt;li&gt;数据时随机访问的，非线性。线性数据访问的问题下面会说到。&lt;/li&gt;
      &lt;li&gt;非多核的&lt;/li&gt;
      &lt;li&gt;非&lt;a href=&quot;https://en.wikipedia.org/wiki/SIMD&quot;&gt;SIMD&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;总结来说这样的混合方案性能提升有限&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;pure-ecs&quot;&gt;Pure ECS&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;ECS不支持托管类型，支持struct和NativeContainer类型。所以只有IComponentData可以被C# Job安全的访问。&lt;/li&gt;
  &lt;li&gt;EntityManager（后面会提到）保证了线性的内存布局 ，这是性能提升很重要的部分。通过job和IComponentData可以做到。&lt;/li&gt;
  &lt;li&gt;目前想将ComponentData添加到GameObject上需要使用ComponentDataWrapper&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// The rotation speed component simply stores the Speed value
[Serializable]
public struct RotationSpeed : IComponentData
{
    public float Value;
}

// This wrapper component is currently necessary to add ComponentData to GameObjects.
// In the future we want to make this wrapper component automatic.
public class RotationSpeedComponent : ComponentDataWrapper&amp;lt;RotationSpeed&amp;gt; { } 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Using IJobProcessComponentData to iterate over all entities matching the required component types.
// Processing of entities happens in parallel. The main thread only schedules jobs.
public class RotationSpeedSystem : JobComponentSystem
{
    // IJobProcessComponentData is a simple way of iterating over all entities given the set of required compoenent types.
    // It is also more efficient than IJobParallelFor and more convenient.
    [ComputeJobOptimization]
    struct RotationSpeedRotation : IJobProcessComponentData&amp;lt;Rotation, RotationSpeed&amp;gt;
    {
        public float dt;

        public void Execute(ref Rotation rotation, [ReadOnly]ref RotationSpeed speed)
        {
            rotation.Value = math.mul(math.normalize(rotation.Value), math.axisAngle(math.up(), speed.Value * dt));
        }
    }

    // We derive from JobComponentSystem, as a result the system proviides us 
    // the required dependencies for our jobs automatically.
    //
    // IJobProcessComponentData declares that it will read RotationSpeed and write to Rotation.
    //
    // Because it is declared the JobComponentSystem can give us a Job dependency, which contains all previously scheduled
    // jobs that write to any Rotation or RotationSpeed.
    // We also have to return the dependency so that any job we schedule 
    // will get registered against the types for the next System that might run.
    // This approach means:
    // * No waiting on main thread, just scheduling jobs with dependencies (Jobs only start when dependencies have completed)
    // * Dependencies are figured out automatically for us, so we can write modular multithreaded code
    protected override JobHandle OnUpdate(JobHandle inputDeps)
    {
        var job = new RotationSpeedRotation() { dt = Time.deltaTime };
        return job.Schedule(this, 64, inputDeps);
    } 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;这段代码和ComponentSystem的部分有类似的结构，但是它结合了JobSystem，做到了并发执行。而且里面还有依赖注入的部分，下一篇在将ECS功能的时候会详细来说。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-1&quot;&gt;总结&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Unity ECS做到了数据与行为的分离，而且更加轻量级。&lt;/li&gt;
  &lt;li&gt;通过结合JobSystem实现了CPU多核的利用。&lt;/li&gt;
  &lt;li&gt;目前来看在已有系统结构上使用ECS有点累赘的感觉。&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Thu, 22 Mar 2018 01:07:00 +0800</pubDate>
        <link>https://caihua.tech/2018/03/22/Unity-ECS-%E6%A6%82%E8%BF%B0/</link>
        <guid isPermaLink="true">https://caihua.tech/2018/03/22/Unity-ECS-%E6%A6%82%E8%BF%B0/</guid>
        
        <category>Unity3D</category>
        
        
      </item>
    
      <item>
        <title>七周七并发模式：Actor</title>
        <description>&lt;h4 id=&quot;actor&quot;&gt;什么是Actor&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;在本书提到的观点中，认为Actor是一个线程或者进程。在这个线程或者进程中执行了一段代码（函数)，这个代码可以包含状态（数据）也可以不包含。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;所谓Actor模型是Sequential Processes和Functions transforming data values两者的结合，可以理解为是综合了过程式计算和函数式计算的一个计算模型。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;一个Actor会把接收到的消息映射为三个部分，传给其他Actor的消息，一个新的行为（用来处理下一个消息），和创造一些新的Actors。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;actor-1&quot;&gt;为什么会出现Actor&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;在本书的第二章谈到了线程和锁，其中提到了这个并发模式存在的一些问题，比如竞争共享资源所导致的阻塞、多重锁导致的死锁等问题。&lt;/li&gt;
  &lt;li&gt;Actor正是为了解决这些问题而产生的。从定义看actor就是多线程，只不过它避免了对于共享资源的并发调用。一个actor只使用自己的资源，而不是直接使用共享资源，它作用单一，顺序执行。不同的Actor之间使用message来传递数据。&lt;/li&gt;
  &lt;li&gt;PS：这里实际上并不存在真的不使用锁。只要存在多个actor共同访问一个数据对象就存在锁的问题，只不过可能无需开发者自己去写相关的代码。因此书中在提到actor缺点时也提到了可能出现死锁的问题。&lt;/li&gt;
  &lt;li&gt;PS2：在书中最后使用Actor来统计wiki的例子里，实际上是将wiki的页面进行拆分，然后不同的page用不同的Actor开统计。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section&quot;&gt;消息和信箱&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;因为actor模型没有提供直接回复消息的机制，所以将发送进程的标识符包含在消息中。通过这个机制，消息的接收者可以回复消息。&lt;/li&gt;
  &lt;li&gt;异步地发送消息是用actor模型编程的重要特性之一。消息并不是直接发送到一个actor，而是发送到一个信箱（mailbox）。&lt;/li&gt;
  &lt;li&gt;每个Actor都有一个信箱&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-1&quot;&gt;分布式&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;与其说Actor是为了并发，不如说Actor是为了分布式。&lt;/li&gt;
  &lt;li&gt;书中使用Elixir语言进行了demo的编写。在不同的设备或者操作系统中（这里可以是一个设备上有多个不同的虚拟机，也就是逻辑意义上的一个主机），不同的Actor可以进行通信，可以协作来处理一些数据。整个过程是异步的，每个Actor因为都看上去是无状态的，或者说即使有状态也是内部的。所以每个Actor的运行并不会影响其它Actor。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;actor-2&quot;&gt;Actor的实现&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;这个是我比较郁闷的地方，因为书中使用了Elixir这个我完全不熟悉的语言，因此我对于代码也是看个大概，具体某些语法和函数为什么这么写也是一知半解。&lt;/li&gt;
  &lt;li&gt;但是从demo code来看，也是创建纤程（这个概念个人认为和golang里面的应该是一样的）来实现actor，而一个actor本质就是一个module，里面包含了一些函数用于处理逻辑，收发消息。&lt;/li&gt;
  &lt;li&gt;对于Actor可以使用缓存机制来统一进行管理。这样的好处还有可以控制错误的处理。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;actor-3&quot;&gt;Actor的错误处理&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;书中对于Actor的错误处理有这样一个观点：任其崩溃。&lt;/li&gt;
  &lt;li&gt;这个观点得益于Actor的独立性，在一个Actor出现异常后，以为它对于某些消息的处理是失败的，因此消息队列或者信箱可以将没有处理的消息交给其它的Actor来处理。&lt;/li&gt;
  &lt;li&gt;出现异常的Actor什么我们可以不做任何的处理。&lt;/li&gt;
  &lt;li&gt;不过如果出现Actor一启动就崩溃了，那么也不能无限制的创建新的Actor。因此书中提到了Actor创建频率的问题，过高的时候就要考虑错误的问题了。&lt;/li&gt;
  &lt;li&gt;对于Actor的错误处理建议的做法是创建一个错误处理内核，这就有一个要求了：&lt;strong&gt;&lt;em&gt;那么该系统正确运行的前提是其错误处理内核必须正确运行&lt;/em&gt;&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;如何保证错误处理内核正确运行呢？这需要内核是&lt;code class=&quot;highlighter-rouge&quot;&gt;顶层的管理者&lt;/code&gt;，书中是使用actor的缓存来实现的。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://c1.staticflickr.com/1/791/39040480120_d12837240a_z.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;同时在错误处理时还要保证消息的必达性：
    &lt;ul&gt;
      &lt;li&gt;没有异常发生，消息一定能被送达并被处理&lt;/li&gt;
      &lt;li&gt;如果某个环节出现异常，异常一定会通知到使用者（假设使用者已经连接到或正在管理发生异常的进程）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;actor-4&quot;&gt;Actor的优势和缺点&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;从前面的讲述来看，其优点是：
    &lt;ul&gt;
      &lt;li&gt;消息的传输和封装性很好&lt;/li&gt;
      &lt;li&gt;容错能力比较好&lt;/li&gt;
      &lt;li&gt;天然支持分布式。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;而缺点是：
    &lt;ul&gt;
      &lt;li&gt;同样有死锁问题&lt;/li&gt;
      &lt;li&gt;信箱溢出（这个可能是指的actor如果处理不够及时，mailbox可能会数据量过大)&lt;/li&gt;
      &lt;li&gt;actor本身没有直接提供并发，需要通过并发技术来构造并发方案。&lt;/li&gt;
      &lt;li&gt;由于多个actor并不共享状态，仅通过消息传递来进行交流，所以不太适合实施细粒度的并行。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-2&quot;&gt;吐槽&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;这本书是好书，不过其使用的编程语言确实比较丰富，导致我看代码时很痛苦。&lt;/li&gt;
  &lt;li&gt;像是OTP部分完全是依赖于某个编程语言来写的，对于其真正的机制我觉得描述的不够清楚。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-3&quot;&gt;参考&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.zhihu.com/question/37792465/answer/73537924&quot;&gt;为什么我觉得 Actor很难用？&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.zhihu.com/question/266384753&quot;&gt;如果理解并行计算中的参与者模式（Actor Model）？&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;PS：在这里说下C#的进程间通信实现，可以通过pipe来实现。可以参考：https://gist.github.com/klkucan/b76c85c77fdfcde51aa4eeb1c6f7cd0b&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Thu, 15 Mar 2018 22:47:43 +0800</pubDate>
        <link>https://caihua.tech/2018/03/15/%E4%B8%83%E5%91%A8%E4%B8%83%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B-Actor/</link>
        <guid isPermaLink="true">https://caihua.tech/2018/03/15/%E4%B8%83%E5%91%A8%E4%B8%83%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B-Actor/</guid>
        
        <category>并发模型</category>
        
        
      </item>
    
      <item>
        <title>使用整体性学习方法来提高学习效率</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;前言&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;这篇文章可以说是一篇读书笔记，内容来自《如何高效学习：1年完成MIT4年33门课程的整体性学习法》这本书。&lt;/li&gt;
  &lt;li&gt;实际上看到书名的时候我的第一反应这是本讲费曼技巧的书，因为在很多年前我看到过一篇&lt;a href=&quot;https://kb.cnblogs.com/page/162480/&quot;&gt;文章&lt;/a&gt;，标题和这个非常类似，直到我重新翻出来后发现文中所讲的那个人正是这本书的作者。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-1&quot;&gt;书的内容&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;在这里我不打算过多的写书中的内容，只是简单的把一些核心的内容列出来。实际上如果没有时间看书，我觉得看上面链接中的那篇文章是一样的。因为这本书的观点比较简单，大部分内容是来证明这些观点，并且列出了一些如何实践的方法。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-2&quot;&gt;结构、模型和高速公路&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;这本书虽然叫做如何高效学习，但实际上主要讲的是整体性学习方法。作者一上来先讲了三个主要的观点：结构、模型和高速公路。&lt;/li&gt;
  &lt;li&gt;结构：理解是结构高度发达完善的结果，结构是学习新知识时与其它知识建立联系。&lt;/li&gt;
  &lt;li&gt;模型：
    &lt;ul&gt;
      &lt;li&gt;简化的结构、结构的快照&lt;/li&gt;
      &lt;li&gt;模型的目的是压缩信息&lt;/li&gt;
      &lt;li&gt;核心概念联系在一起创建模型&lt;/li&gt;
      &lt;li&gt;模型是逐渐调整和更新的&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;高速公路：结构之间的联系&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;实际上这三点是整体性学习的核心内容或者说是最终形态。在我的理解中所谓的整体性学习更像是用类比的方式来快速对新知识进行学习，而在类比的过程中对于已有的知识需要一个结构或者模型，在这个基础上通过联想、类比等方法来进行学习。不同的知识之间是有相似性或者本身就是有联系的，这就是高速公路。&lt;/li&gt;
  &lt;li&gt;以学习编程语言为例，我们知道目前的编程语言会分成不同的范式，比如有面向对象的、面向过程的、函数式的、命令式的等等。现代的编程语言往往包含了多个范式，以C#为例它是面向对象的，也是命令式和函数式都有的。在学会了C#之后，对于java这样的编程的语言在学习上会很快，因为他们几乎在编程范式是一样的，在语法上的差异和API的时候在使用的过程中再慢慢熟悉即可。但是在赋值、条件判断、循环、多线程、文件操作、lambda等等上都非常的接近，这样就可以通过类比的当时来快速的学习。&lt;/li&gt;
  &lt;li&gt;对于lua、python或者JavaScript这样的脚本语言来说，其在赋值、条件判断、循环这些基本操作上也是一样的，再加上函数式编程的范式使得学习起来也会有一种熟悉的感觉。这也是为啥工作了几年的人在学习一门新的编程语言时会比较快，因为会有一种熟悉感、进而进行类比的学习。快速掌握共同点、重点学习不同点和API就可以很快的掌握。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-3&quot;&gt;五个信息类型&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;书中列出了五种信息类型，也是知识类型。分别是：
    &lt;ul&gt;
      &lt;li&gt;随意信息&lt;/li&gt;
      &lt;li&gt;观点信息&lt;/li&gt;
      &lt;li&gt;过程信息&lt;/li&gt;
      &lt;li&gt;具体信息&lt;/li&gt;
      &lt;li&gt;抽象信息&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;其中随意信息是最难以记忆的，因为它们往往是一些事实，比如历史中的事件的时间，这些东西往往就是枯燥的记忆内容，没有什么很好的类比方式。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-4&quot;&gt;学习的顺序&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;文中还列出了一个学习的顺序，实际上就是一种知识的学习过程：
    &lt;ul&gt;
      &lt;li&gt;获取：快速阅读和笔记法&lt;/li&gt;
      &lt;li&gt;理解：使用内在化、类比、比喻等技巧。所谓内在化更像是观想法，也就是把知识具现化。&lt;/li&gt;
      &lt;li&gt;拓展：同上&lt;/li&gt;
      &lt;li&gt;纠错&lt;/li&gt;
      &lt;li&gt;应用&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;这个没什么特别的地方，基本上就是一个获取知识的过程。实际上，这本书中很多的内容对于天朝读了十几年书的人来说都是没什么新意。&lt;/li&gt;
  &lt;li&gt;书中用了很大的篇幅来描述着5个过程，比如获取就介绍了快速阅读和笔记法。在这里快速阅读推荐指读法，也就是用手指的移动来带动阅读，这样可以让人的注意力集中在手指所在的地方。而笔记法，推荐使用康奈尔笔记法或者与其接近的黄金三分法来做笔记。&lt;/li&gt;
  &lt;li&gt;对于理解和拓展，就是内在化、图表法等。&lt;/li&gt;
  &lt;li&gt;对于随意信息的记忆推荐联想法、信息压缩技术。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-5&quot;&gt;真正的干货 - 费曼技巧&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;费曼技巧的过程：
    &lt;ul&gt;
      &lt;li&gt;选择要学习的概念&lt;/li&gt;
      &lt;li&gt;设想你是老师，正在试图教会一名新生这个知识点&lt;/li&gt;
      &lt;li&gt;当你感到疑惑时，回过头来，重新阅读参考材料、听讲座或找老师解答，直到你觉得搞懂了为止，然后把解释记到纸上。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;总结来说就是小学老师告诉我们的，如果你能给你的同学讲明白一个知识点你就是真的懂了这个知识点。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-6&quot;&gt;我所总结出来的学习方法&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;在学习一个新的知识点的时候尽可能的联系已经学过的知识，通过知识的连接和类比来快速掌握知识。&lt;/li&gt;
  &lt;li&gt;实际上费曼技巧是很实用而且也比较容易实施的方法，费曼技巧的根本理论在于找出自己没有真正掌握的知识，从而查漏补缺。&lt;/li&gt;
  &lt;li&gt;使用思维导图来做联想、类比和内在化。书中很多方法都提到了联想、内在化、图表法等，在我看来都可以总结为思维导图。思维导图的制作本身就是一个查漏补缺和思维拓展的过程。&lt;/li&gt;
  &lt;li&gt;使用方格笔记和黄金三分法，这个技巧也是有人专门写过书的，个人认为还是很有用的。&lt;/li&gt;
  &lt;li&gt;最后这本书的笔记可以看&lt;a href=&quot;https://www.flickr.com/photos/142765619@N07/40075301272/in/dateposted-public/&quot;&gt;这里&lt;/a&gt;
&lt;img src=&quot;https://c1.staticflickr.com/5/4602/40075301272_eb0642788d_b.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 18 Feb 2018 01:49:43 +0800</pubDate>
        <link>https://caihua.tech/2018/02/18/%E4%BD%BF%E7%94%A8%E6%95%B4%E4%BD%93%E6%80%A7%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E6%9D%A5%E6%8F%90%E9%AB%98%E5%AD%A6%E4%B9%A0%E6%95%88%E7%8E%87/</link>
        <guid isPermaLink="true">https://caihua.tech/2018/02/18/%E4%BD%BF%E7%94%A8%E6%95%B4%E4%BD%93%E6%80%A7%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E6%9D%A5%E6%8F%90%E9%AB%98%E5%AD%A6%E4%B9%A0%E6%95%88%E7%8E%87/</guid>
        
        <category>杂记</category>
        
        
      </item>
    
  </channel>
</rss>
