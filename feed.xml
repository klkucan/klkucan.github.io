<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>蔡华的博客</title>
    <description>Be publicly useful and privately happy.</description>
    <link>https://caihua.tech/</link>
    <atom:link href="https://caihua.tech/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Fri, 15 Feb 2019 01:07:23 +0800</pubDate>
    <lastBuildDate>Fri, 15 Feb 2019 01:07:23 +0800</lastBuildDate>
    <generator>Jekyll v3.2.1</generator>
    
      <item>
        <title>How I build games with Entitas 摘要</title>
        <description>&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/sschmid/Entitas-CSharp/wiki/How-I-build-games-with-Entitas-%28FNGGames%29&quot;&gt;这篇文章&lt;/a&gt;并不会讲解entitas的功能，作者在文章中主要谈了谈他如何利用entitas开发清晰、稳定和灵活的代码结构。这篇文章可以说是对于ECS的一种实践的总结，同时也是对于Entitas的使用总结。&lt;/li&gt;
  &lt;li&gt;文章会介绍如下的话题：
    &lt;ul&gt;
      &lt;li&gt;定义：数据、逻辑和视图层&lt;/li&gt;
      &lt;li&gt;维护它们彼此的独立&lt;/li&gt;
      &lt;li&gt;通过接口进行抽象&lt;/li&gt;
      &lt;li&gt;IOC&lt;/li&gt;
      &lt;li&gt;视图层抽象（视图和视图控制器）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;定义&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;数据 Data&lt;/strong&gt;：游戏的 &lt;strong&gt;&lt;em&gt;状态&lt;/em&gt;&lt;/strong&gt; ，比如生命、存量、经验等。在entitas中这些数据存在于 &lt;strong&gt;&lt;em&gt;Component&lt;/em&gt;&lt;/strong&gt; 中。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;逻辑 Logic&lt;/strong&gt;：数据变化的规则，在我们的代码中可能就是一些常见的函数，这些函数在改变着数据。在entitas中表现为 &lt;strong&gt;&lt;em&gt;Systems&lt;/em&gt;&lt;/strong&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;视图 View&lt;/strong&gt;：实际上就是游戏状态的表现，比如渲染、动画、音频、UI等。在作者的example中就是 &lt;em&gt;GameObjects&lt;/em&gt; 上的 &lt;em&gt;MonoBehaviours&lt;/em&gt;。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;服务 Service&lt;/strong&gt;：ECS之外的功能，常见的就是寻路、物理、社会化分享等，在entitas的视角里面游戏引擎也是一种服务（entitas本质是与引擎无关的，这个需要对源码进行一些扩展，比如Math库就不能使用unity引擎相关的数据定义）。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;输入Input&lt;/strong&gt;：ECS外部的输入，比如键盘、鼠标、网络等。个人认为input对于ECS的影响是通过修改component数据来实现的，也就要求了外部是输入是可以操作部分system的，因为我们修改component是通过system。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;架构&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;任何游戏的核心只是CPU中的数值模拟。每一个游戏都只是数据集合（游戏状态）的周期性变化（游戏逻辑）。&lt;em&gt;逻辑&lt;/em&gt; 规定了数据变化的规则。&lt;/li&gt;
  &lt;li&gt;纯粹的数据模拟与游戏的却别在于，游戏中有外部的玩家，能够使用逻辑来改变游戏的状态。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;随之而来的需求是游戏数据与玩家的通信，或者说交互。而这个交互就是&lt;strong&gt;视图层&lt;/strong&gt;，表现为渲染actor到屏幕、播放音频、更新UI等。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;以上是作者对于游戏中数据、逻辑的理解，可谓之醍醐灌顶。而下面的图可以说是对于ECS（Entitas）使用的最佳实践。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/klkucan/ImgLib/master/blog/EntitasCode.png?token=AC5fBlT3eFZWrd9UlHLjMabWRaNvEsIPks5cbtqmwA%3D%3D&quot; alt=&quot;Architecture Diagram&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;action&quot;&gt;Action中的抽象&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;首先抽象是一个移除&lt;strong&gt;What you want to do&lt;/strong&gt;和&lt;strong&gt;How you want to do&lt;/strong&gt;之间耦合的过程。如何理解what和how，简单来说what就是interface，how就是implementation。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;文章中使用了一个常见的例子，就是在开发中的使用log。当然一般来说我们会避免把&lt;code class=&quot;highlighter-rouge&quot;&gt;Debug.Log&lt;/code&gt;方法在代码的各处使用，弊端显而易见。作者提出这个例子和角色控制器是为了提出一个很重要的思想 &lt;strong&gt;&lt;em&gt;关注点分离（Separate your concerns）&lt;/em&gt;&lt;/strong&gt;，这个也是ECS的一个重要的作用。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;那么entitas是如何实现关注点分离的呢？一般会使用&lt;code class=&quot;highlighter-rouge&quot;&gt;LogMessageComponent (string message)&lt;/code&gt;和一个 用于处理它的&lt;code class=&quot;highlighter-rouge&quot;&gt;ReactiveSystem&lt;/code&gt;。代码如下，以后需要修改实现时只要修改这个system就行了。本质就是一个功能交给一个system，和之前定义一个专门负责log的函数或者类是一个概念。entitas中需要输出log只需要创建一个LogEntity就好了。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;UnityEngine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Entitias&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;System.Collections.Generic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// debug message component
&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;[Debug]&lt;/span&gt; 
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sealed&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DebugLogComponent&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IComponent&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// reactive system to handle messages
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;HandleDebugLogMessageSystem&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ReactiveSystem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DebugEntity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// collector: Debug.Matcher.DebugLog
&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// filter: entity.hasDebugLog
&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Execute&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DebugEntity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;entities&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;foreach&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;entities&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;Debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;debugLog&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isDestroyed&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;最后上面代码的弊端是依赖了unity API debug，除此之外如果这里的log功能比较复杂比如json解析、网络发送等时，就会需要更多的依赖甚至关联。如果画出UML可能惨目忍睹。为了解决这个问题作者提出了使用接口。这块其实就没啥特别的了，面向接口编程本身也是OOP里面重要的概念，在上面的图里面，只要不是在虚线框内的代码多数情况是OOP的。而外部代码与ECS代码的交互是基于接口的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;interfaces-by-example&quot;&gt;Interfaces by example&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;在这部分中作者使用大量的例子来展示如何在entitas中使用接口来解耦。对于上面的log功能来说设计出来的接口可能只需要一个方法&lt;code class=&quot;highlighter-rouge&quot;&gt;LogMessage(string message)&lt;/code&gt;。 代码如下：&lt;/li&gt;
  &lt;li&gt;可以看出&lt;code class=&quot;highlighter-rouge&quot;&gt;UnityDebugLogService&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;JsonLogService&lt;/code&gt;对应了不同的log需要。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// the interface 
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ILogService&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;LogMessage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// a class that implements the interface
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;UnityEngine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;UnityDebugLogService&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ILogService&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;LogMessage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// another class that does things differently but still implements the interface
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;SomeJsonLib&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;JsonLogService&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ILogService&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;filepath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;filename&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prettyPrint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// etc...
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;LogMessage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// open file
&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;// parse contents
&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;// write new contents
&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;// close file
&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;下面的代码展示了如何通过system的构造函数来注入interface，最后实现了system与interface的关联，但是不与具体实现产生依赖或关联。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// the previous reactive system becomes 
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;HandleDebugLogMessageSystem&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ReactiveSystem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DebugEntity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;ILogService&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_logService&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    
    &lt;span class=&quot;c1&quot;&gt;// contructor needs a new argument to get a reference to the log service
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;HandleDebugLogMessageSystem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Contexts&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;contexts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ILogService&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;logService&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
         &lt;span class=&quot;c1&quot;&gt;// could be a UnityDebugLogService or a JsonLogService
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;_logService&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;logService&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;c1&quot;&gt;// collector: Debug.Matcher.DebugLog
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// filter: entity.hasDebugLog
&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Execute&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DebugEntity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;entities&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;foreach&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;entities&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;_logService&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;LogMessage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DebugLog&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// using the interface to call the method
&lt;/span&gt;            &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isDestroyed&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;下面的例子是一个较为复杂的&lt;code class=&quot;highlighter-rouge&quot;&gt;IInputService&lt;/code&gt;，可以看到是对unity api的一个封装。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// interface
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IInputService&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Vector2D&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;leftStick&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Vector2D&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rightStick&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;}&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;action1WasPressed&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;}&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;action1IsPressed&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;}&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;action1WasReleased&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;}&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;action1PressedTime&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;}&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// ... and a bunch more
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// (partial) unity implementation
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;UnityEngine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;UnityInputService&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IInputService&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;c1&quot;&gt;// thank god we can hide this ugly unity api in here
&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;Vector2D&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;leftStick&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;get&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Vector2D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;GetAxis&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;horizontal&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;GetAxis&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Vertical&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));}&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
   &lt;span class=&quot;c1&quot;&gt;// you must implement ALL properties from the interface
&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;// ... 
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;EmitInputSystem&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IInitalizeSystem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IExecuteSystem&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;    
    &lt;span class=&quot;n&quot;&gt;Contexts&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_contexts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;IInputService&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_inputService&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;InputEntity&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_inputEntity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    
    &lt;span class=&quot;c1&quot;&gt;// contructor needs a new argument to get a reference to the log service
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;EmitInputSystem&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Contexts&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;contexts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IInputService&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inputService&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;_contexts&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;contexts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;_inputService&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inputService&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Initialize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// use unique flag component to create an entity to store input components        
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;_contexts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isInputManger&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;_inputEntity&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_contexts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;inputEntity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// clean simple api, 
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// descriptive, 
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// obvious what it does
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// resistant to change
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// no using statements
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Execute&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;inputEntity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isButtonAInput&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_inputService&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;button1Pressed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;inputEntity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;ReplaceLeftStickInput&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_inputService&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;leftStick&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// ... lots more queries
&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;inversion-of-control-&quot;&gt;Inversion of control 控制反转&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;这部分是对上面构造函数的进一步升级，无需在每个system的构造函数中注入服务实例，而是在entitas中使用一个helper类来引用每个服务实例。这个引入的时机最好是应用启动时。下面的例子是完整的过程。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;可以看到下面是一个关联了很多service的类，通过构造函数注入实例。特别注意一下暴露出的全局变量都是只读的。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;Services.cs&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Services&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;readonly&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IViewService&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;View&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;readonly&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IApplicationService&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Application&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;readonly&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ITimeService&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;readonly&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IInputService&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;readonly&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IAiService&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Ai&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;readonly&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IConfigurationService&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Config&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;readonly&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ICameraService&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Camera&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;readonly&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IPhysicsService&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Physics&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Services&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IViewService&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;view&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IApplicationService&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;application&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ITimeService&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IInputService&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IAiService&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ai&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IConfigurationService&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ICameraService&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;camera&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IPhysicsService&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;physics&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;View&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;view&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Application&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;application&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Time&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Input&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Ai&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ai&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Config&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Camera&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;camera&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Physics&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;physics&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;实例化Services类&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_services&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Services&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;UnityViewService&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// responsible for creating gameobjects for views
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;UnityApplicationService&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// gives app functionality like .Quit()
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;UnityTimeService&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// gives .deltaTime, .fixedDeltaTime etc
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;InControlInputService&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// provides user input
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// next two are monobehaviours attached to gamecontroller
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;GetComponent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UnityAiService&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;(),&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// async steering calculations on MB
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;GetComponent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UnityConfigurationService&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;(),&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// editor accessable global config
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;UnityCameraService&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// camera bounds, zoom, fov, orthsize etc
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;UnityPhysicsService&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// raycast, checkcircle, checksphere etc.
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;下面的代码是一个不错的方法，使用一个特别的context（MetaContext）中的component中包含这些服务实例。注意这个component是单例的。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In my &lt;code class=&quot;highlighter-rouge&quot;&gt;MetaContext&lt;/code&gt; I have a set of unique components that hold instances of these interfaces. For example:&lt;/p&gt;

&lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;[Meta, Unique]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sealed&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TimeServiceComponent&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IComponent&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ITimeService&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;instance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;下面的两段代码演示了如何将services中包含各个实例引入到ecs系统中。
    &lt;ul&gt;
      &lt;li&gt;首先上面一步已经创建了一些负责持有这些service实例的component，并且是singleton的。&lt;/li&gt;
      &lt;li&gt;使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;Feature&lt;/code&gt;来创建一些IInitializeSystem。&lt;code class=&quot;highlighter-rouge&quot;&gt;Feature&lt;/code&gt;继承自system，但是从它包含了多个system。这个命名在我看来是极具深意的，因为只有多个system的协作才能形成一个特征（feature）。同时feature在执行顺序上非常靠前会先执行。&lt;/li&gt;
      &lt;li&gt;在各个IInitializeSystem类中注入service&lt;/li&gt;
      &lt;li&gt;在system会创建第一步中的component实例，并将service实例赋值进component的成员变量中。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;ServiceRegistrationSystems.cs&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ServiceRegistrationSystems&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Feature&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ServiceRegistrationSystems&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Contexts&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;contexts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Services&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;services&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;Add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;RegisterViewServiceSystem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;contexts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;services&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;View&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;Add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;RegisterTimeServiceSystem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;contexts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;services&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;Add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;RegisterApplicationServiceSystem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;contexts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;services&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Application&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;Add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;RegisterInputServiceSystem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;contexts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;services&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;Add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;RegisterAiServiceSystem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;contexts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;services&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Ai&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;Add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;RegisterConfigurationServiceSystem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;contexts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;services&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Config&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;Add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;RegisterCameraServiceSystem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;contexts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;services&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Camera&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;Add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;RegisterPhysicsServiceSystem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;contexts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;services&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Physics&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;Add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ServiceRegistrationCompleteSystem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;contexts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;em&gt;Example of one of the registration systems&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;RegisterTimeServiceSystem&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IInitializeSystem&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;readonly&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MetaContext&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_metaContext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;readonly&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ITimeService&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_timeService&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;RegisterTimeServiceSystem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Contexts&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;contexts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ITimeService&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;timeService&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;_metaContext&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;contexts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;meta&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;_timeService&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;timeService&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Initialize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;_metaContext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;ReplaceTimeService&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_timeService&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;下面的代码是entitas中ReplaceComponent的源码，可以看到如果没有某个component对象时会创建一个。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;/// Replaces an existing component at the specified index
/// or adds it if it doesn't exist yet.
/// The prefered way is to use the
/// generated methods from the code generator.
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ReplaceComponent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IComponent&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;component&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_isEnabled&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;EntityIsNotEnabledException&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
            &lt;span class=&quot;s&quot;&gt;&quot;Cannot replace component '&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;_contextInfo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;componentNames&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;' on &quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;!&quot;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;HasComponent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;replaceComponent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;component&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;component&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;AddComponent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;component&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;经过上面的处理，在system中使用&lt;code class=&quot;highlighter-rouge&quot;&gt;_contexts.meta.timeService.instance&lt;/code&gt;就能够获得一个service的实例了。这些实例都是在service的构造函数中创建的，便于管理和替换。&lt;/li&gt;
  &lt;li&gt;至于此处IOC的理解，可以回到上面的那个图。中间虚线框内可以认为是一个ECS framework，我们只向framework注入service实现，但是如何使用是framework内部的事情。这种把控制权交给一个framework的做法就是控制反转。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;view-layer-abstraction-&quot;&gt;View Layer Abstraction 视图层抽象&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;这部分是上面图中的右边部分，描述了如何将entitas系统与表现层结合一起。&lt;/li&gt;
  &lt;li&gt;需要注意的是，GameObject的实例是被一个ViewComponent持有的。这个和service是一样的，也就是说ECS系统之外的对象都可以让一个特别的component持有引用。不过需要通过使用interface，将entitas与引擎API进行了解耦。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在这里的View layer用于游戏状态的展示，可以是动画、音频、mesh、渲染器等等。当然也可以是GameObject，或者GameObject上的一个MonoBehaviour对象。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;下面是这部分功能的代码，看起来比较零散，做了个UML的图可以便于理解。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/klkucan/ImgLib/master/blog/%E8%A7%86%E5%9B%BE%E5%B1%82%E6%8A%BD%E8%B1%A1uml.jpg?token=AC5fBuUCXFYdugcg2T_kWbcGM1fJnDkMks5casvGwA%3D%3D&quot; alt=&quot;视图层抽象uml&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;UML图中左边是一个用于创建GameObject的service，中间是entity、system等entitas内容，右边是view层的实现。完美符合开始的那张图。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IViewController&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Vector2D&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Position&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Vector2D&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Scale&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;}&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Active&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;InitializeView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Contexts&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;contexts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IEntity&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Entity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DestroyView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;IViewController的unity实现:&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;UnityGameView&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MonoBehaviour&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IViewController&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Contexts&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_contexts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GameEntity&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_entity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Vector2D&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Position&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;get&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;transform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;ToVector2D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();}&lt;/span&gt; 
        &lt;span class=&quot;k&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;transform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;position&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;ToVector2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Vector2D&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Scale&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// as above but with tranform.localScale
&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Active&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;get&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gameObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;activeSelf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gameObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;SetActive&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);}&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;InitializeView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Contexts&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;contexts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IEntity&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Entity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;_contexts&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;contexts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;_entity&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GameEntity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;entity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DestroyView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Destroy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;持有viewController的component
    &lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;[Game]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sealed&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ViewComponent&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IComponent&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IViewController&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;instance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;IViewService&lt;/code&gt;来创建view，并且绑定到entitas&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IViewService&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;   
    &lt;span class=&quot;c1&quot;&gt;// create a view from a premade asset (e.g. a prefab)
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;IViewController&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;LoadAsset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Contexts&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;contexts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IEntity&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;entity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;assetName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;service的unity实现
    &lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;UnityViewService&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IViewService&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IViewController&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;LoadAsset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Contexts&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;contexts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IEntity&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;entity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;assetName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;viewGo&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GameObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Instantiate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Resources&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GameObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Prefabs/&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;assetName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;viewGo&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;viewController&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;viewGo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GetComponent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IViewController&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;();&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;viewController&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;viewController&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;InitializeView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;contexts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;entity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;viewController&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;LoadAssetSystem用于加载资源（创建view）和绑定view到component&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LoadAssetSystem&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ReactiveSystem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GameEntity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IInitializeSystem&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;readonly&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Contexts&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_contexts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;readonly&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IViewService&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_viewService&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// collector: GameMatcher.Asset
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// filter: entity.hasAsset &amp;amp;&amp;amp; !entity.hasView
&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Initialize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;    
        &lt;span class=&quot;c1&quot;&gt;// grab the view service instance from the meta context
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;_viewService&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_contexts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;meta&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;viewService&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;instance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Execute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GameEntity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;entities&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;foreach&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;entities&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// call the view service to make a new view
&lt;/span&gt;            &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;view&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_viewService&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;LoadAsset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_contexts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;asset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; 
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;view&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;ReplaceView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;view&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;在其它的system中使用抽象的view实例。需要注意entitas中并不知道view对象到底是个什么，下面代码能够改变GameObject的position是因为IViewController中的定义。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SetViewPositionSystem&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ReactiveSystem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GameEntity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// collector: GameMatcher.Position;
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// filter: entity.hasPosition &amp;amp;&amp;amp; entity.hasView
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Execute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GameEntity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;entities&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;foreach&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;entities&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;view&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;instance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Position&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;存在的问题&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;上面的最后一段代码中，当需要修改位置时是直接修改了view的position属性的，这与开始时描述的一个原则相违背。我们希望ECS中执行的就是数据与逻辑，不需要知道这些数据到底是如何表现出来的。但是现在我们在修改数据的同时也必须手动的修改view的position属性。下面的&lt;strong&gt;Event&lt;/strong&gt;章节会来解决这个问题。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;events-&quot;&gt;Events 事件&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;本质还是使用C#的事件功能&lt;/li&gt;
  &lt;li&gt;view MonoBehaviours作为事件监听器&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-2&quot;&gt;下面是修改后的代码&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;首先需要给要监听的数据（component）添加Event标签，这个标签会在代码生成中生成监听器和事件系统。下面的代码会生成&lt;code class=&quot;highlighter-rouge&quot;&gt;PositionListenerComponent&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;IPositionListener&lt;/code&gt;。文章作者写了个&lt;code class=&quot;highlighter-rouge&quot;&gt;IEventListener &lt;/code&gt;，用来将监听器与entity绑定起来。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// [Game, Event(true)] (Event(true) DEPRECATED as of Entitas 1.6.0) 
&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;[Game, Event(EventTarget.Self)]&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// generates events that are bound to the entities that raise them
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sealed&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;PositionComponent&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IComponent&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Vector2D&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IEventListener&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;RegisterListeners&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IEntity&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;entity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;不在需要viewcomponent，同时LoadAsset方法不需要在有返回值。然后需要在UnityViewService中添加一些代码来确定和初始化事件监听器。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Entitas&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IViewService&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// create a view from a premade asset (e.g. a prefab)
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;LoadAsset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Contexts&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;contexts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;IEntity&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;entity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;assetName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;更新后的IViewService实现，前面还是生成GameObject，但是后面认为GameObject默认要有个实现了IEventListener的MonoBehaviour（这里单独写一个MonoBehaviour或者直接写在继承了IViewController的那个脚本中都可以），同时将监听器和entity绑定到一起。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;UnityEngine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Entitas&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;UnityViewService&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IViewService&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// now returns void instead of IViewController
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;LoadAsset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Contexts&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;contexts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IEntity&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;entity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;assetName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;//Similar to before, but now we don't return anything. 
&lt;/span&gt;        &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;viewGo&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GameObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Instantiate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Resources&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GameObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Prefabs/&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;assetName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;viewGo&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;viewController&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;viewGo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GetComponent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IViewController&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;();&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;viewController&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;viewController&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;InitializeView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;contexts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;entity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

            &lt;span class=&quot;c1&quot;&gt;// except we add some lines to find and initialize any event listeners
&lt;/span&gt;            &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eventListeners&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;viewGo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GetComponents&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IEventListener&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;();&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;foreach&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;listener&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eventListeners&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;listener&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;RegisterListeners&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;entity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;在PositionListener中实现接口。此处可以看出来一个viewGo上可以监听了多个数据变化的事件，每个事件都要绑定一次entity。&lt;/li&gt;
  &lt;li&gt;同时&lt;code class=&quot;highlighter-rouge&quot;&gt;_entity.AddPositionListener(this);&lt;/code&gt;方法会把这个MonoBehaviour的引用交给_entity的PositionListenerComponent。当数据发送变化时，system会调用OnPosition方法，&lt;strong&gt;这些方法、接口都是添加了&lt;code class=&quot;highlighter-rouge&quot;&gt;[Event]&lt;/code&gt;标签后自动生成的。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;PositionListener&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MonoBehaviour&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IEventListener&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IPositionListener&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    
    &lt;span class=&quot;n&quot;&gt;GameEntity&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_entity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
 
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;RegisterEventListeners&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IEntity&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;entity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;_entity&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GameEntity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;entity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;_entity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;AddPositionListener&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;OnPosition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GameEntity&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Vector2D&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newPosition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;transform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;position&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newPosition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;ToVector2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;如此以来，GameObject的transform的改变就不需要system专门做什么处理了，view的position与ecs中的PositionComponent实现了解耦。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-3&quot;&gt;附加一些文中没有贴出来的代码，便于阅读&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;自动生成的PositionListener相关的代码
    &lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;AddPositionListener&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IPositionListener&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;listeners&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hasPositionListener&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;positionListener&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;value&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Collections&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Generic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IPositionListener&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;();&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;listeners&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;nf&quot;&gt;ReplacePositionListener&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;listeners&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;AddPositionListener&lt;/code&gt;是在PositionListener中调用的，但是最后它会调用ReplacePositionListener，然后在ECS中创建一个PositionListenerComponent对象。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;同时生成了一个PositionEventSystem&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sealed&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;PositionEventSystem&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Entitas&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ReactiveSystem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GameEntity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;readonly&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Collections&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Generic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IPositionListener&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_listenerBuffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;PositionEventSystem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Contexts&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;contexts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;base&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;contexts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;game&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;_listenerBuffer&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Collections&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Generic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IPositionListener&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;();&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Entitas&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ICollector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GameEntity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;GetTrigger&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Entitas&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IContext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GameEntity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Entitas&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CollectorContextExtension&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;CreateCollector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Entitas&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TriggerOnEventMatcherExtension&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Added&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GameMatcher&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Filter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GameEntity&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;entity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;entity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hasPosition&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;entity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hasPositionListener&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    

    &lt;span class=&quot;k&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Execute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Collections&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Generic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GameEntity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;entities&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;foreach&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;entities&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;component&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;_listenerBuffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Clear&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;_listenerBuffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;AddRange&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;positionListener&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;foreach&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;listener&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_listenerBuffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;listener&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;OnPosition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;component&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;event&quot;&gt;附一个Event的时序图&lt;/h5&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/klkucan/ImgLib/master/blog/PositionEvent.jpg?token=AC5fBknEmIHZGZpDRTltukY7BOMrjAVQks5cbUxMwA%3D%3D&quot; alt=&quot;PositionEvent&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;总结&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;entitas配合面向接口编程&amp;amp;Event，实现了数据+逻辑与表现层的解耦，同时解耦ECS与引擎。&lt;/li&gt;
  &lt;li&gt;需要注意的是，最开始的图是一个横向的，如果纵向的来看，Entitas是在底层，service和view是在上面的。也就是说后面两部分是可以直接持有entitas中的对象的，典型的就是Context、Entity等对象。而entitas则是通过interface、event等手段来操作service和view。&lt;/li&gt;
  &lt;li&gt;当然，较真来说，entitas其实也是持有了后两者的对象。这个目前看来是无法避免的。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 13 Feb 2019 20:51:00 +0800</pubDate>
        <link>https://caihua.tech/2019/02/13/How-I-build-games-with-Entitas-%E6%91%98%E8%A6%81/</link>
        <guid isPermaLink="true">https://caihua.tech/2019/02/13/How-I-build-games-with-Entitas-%E6%91%98%E8%A6%81/</guid>
        
        <category>ECS</category>
        
        
      </item>
    
      <item>
        <title>计算机组成原理：6、高速缓冲存储器</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;概述&lt;/h2&gt;
&lt;h4 id=&quot;cache&quot;&gt;为何使用Cache&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;CPU速度太快了&lt;/li&gt;
  &lt;li&gt;解决CPU空等问题，但是需要保证的是大多数的数据和指令都在cache中。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-1&quot;&gt;程序访问局部性原理&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;时间局部性：当前正在使用的指令和数据，在不久的将来还会被使用。那么这些数据和指令需要放到cache。&lt;/li&gt;
  &lt;li&gt;空间局部性：当前正在使用的指令或者数据的相邻的指令或者数据在不久的将来会被使用，那么把当前使用的和相邻的数据和指令放到cache。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;cache-1&quot;&gt;Cache工作原理&lt;/h4&gt;

&lt;h5 id=&quot;section-2&quot;&gt;主存和缓存的编址&lt;/h5&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/klkucan/ImgLib/blob/master/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E5%99%A8/%E4%B8%BB%E5%AD%98%E5%92%8C%E7%BC%93%E5%AD%98%E7%9A%84%E7%BC%96%E5%9D%80.png?raw=true&quot; alt=&quot;主存和缓存的编址&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;图中主存和cache中块的大小一样，主存分成M个块、cache分成C个，显然C远小于M。&lt;/li&gt;
  &lt;li&gt;标记：主存块和cache块之间的对应关系，如果一个主存块被调入cache，那么主存块号写入到标记中。当CPU想要访问主存时，根据主存块号先去cache中与标记对比。如果找到，那么说明想要在内存中获取的数据已经在cache中了。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;注意：cache-主存这个结构中是按块进行存储和传输的。块的大小和块内地址（本质是偏移量）是完全相同的。在有标记的情况下cache是不需要特别编址的。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-3&quot;&gt;命中与未命中&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;定义：CPU使用主存块时，如果块已经调入缓存则命中；如果没有则是未命中。如果命中那么主存中某些块与缓冲块建立了对于关系（标记）。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;cache-2&quot;&gt;Cache的命中率&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;CPU欲访问的信息在Cache中的比率&lt;/li&gt;
  &lt;li&gt;简单来说和cache的容量和块长有关&lt;/li&gt;
  &lt;li&gt;一般每块取4-8个字，块长取一个周期内从主存调出的信息长，与前面的低位交叉相关。如果是4体交叉，块长就是4个存储字长。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;cache-&quot;&gt;Cache-主存系统的效率&lt;/h5&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/klkucan/ImgLib/blob/master/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E5%99%A8/Cache-%E4%B8%BB%E5%AD%98%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%95%88%E7%8E%87.png?raw=true&quot; alt=&quot;Cache-主存系统的效率&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;cache-3&quot;&gt;Cache的基本机构&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/klkucan/ImgLib/blob/master/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E5%99%A8/Cache%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.png?raw=true&quot; alt=&quot;Cache基本结构&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;上图的流程中其实包含了cache读取的流程。&lt;/li&gt;
  &lt;li&gt;最下面主存和CPU之间是有数据总线的，当cache未命中时主存先把数据送入CPU，同时与cache进行数据交换。&lt;/li&gt;
  &lt;li&gt;地址映射：给出一个规则，主存当中的块如果要放入cache，它可以放入哪一个或哪几个块中。&lt;/li&gt;
  &lt;li&gt;地址变换：主存块号或地址转换成cache块号或地址。&lt;/li&gt;
  &lt;li&gt;替换结构：通过替换算法来决定哪些块从cache退出&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;注意：图中&lt;code class=&quot;highlighter-rouge&quot;&gt;可装进&lt;/code&gt;的判断不是以整个cache为基础的，而是以地址映射的结果为基础。e.g: 未命中发生，经过映射计算后主存的块要进入add1，此时如果add1已经有数据了，就要替换；但是此时cache可能并不满，而只是add1有数据。而且这个还要和具体的映射方式有关，见下面内容。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;cache-4&quot;&gt;Cache的读写操作&lt;/h4&gt;

&lt;h5 id=&quot;section-4&quot;&gt;读操作&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;参考上图，因为读操作的特点是不会改变主存和cache的内容，所以相对比较简单。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-5&quot;&gt;写操作&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;是否实时同步cache和主存就是写操作要关注点了。有两个方法：&lt;/li&gt;
  &lt;li&gt;写直达法（Write-through）：
    &lt;ul&gt;
      &lt;li&gt;写操作时数据既写入cache也写入主存&lt;/li&gt;
      &lt;li&gt;写操作时间就是访问主存时间&lt;/li&gt;
      &lt;li&gt;cache退出块时不需要对主存进行写操作，更新策略比较简单。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;写回法（Write-back）
    &lt;ul&gt;
      &lt;li&gt;写操作只把数据写入cache而不写入主存&lt;/li&gt;
      &lt;li&gt;当cache数据被替换出去时才学会主存&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;比较：
    &lt;ul&gt;
      &lt;li&gt;显然写操作从逻辑上简单，但是操作步骤太多。尤其是做循环加法这样的操作时，我们只关注结果，中间数值没必要写入主存。这点上写回法就好很多，它只写最后的结果。&lt;/li&gt;
      &lt;li&gt;但是写回法在多处理器时就会出现数据一致性问题，并发计算时主存块在多个CPU cache中都有副本，很难保证同步。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;cache-5&quot;&gt;Cache的改进&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;增加cache的级数：
    &lt;ul&gt;
      &lt;li&gt;离CPU比较近或者离CPU中的core比较近的cache直接做入到CPU内部（片载cache），CPU内部接着做多级。现代多核CPU每个core都有自己的cache，core之间还有共享的cache，所以至少都有三级的cache。&lt;/li&gt;
      &lt;li&gt;主板上做大容量cache，片外cache。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;统一缓存和分立缓存：指令和数据分开放（分立缓存）&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;cache--1&quot;&gt;Cache-主存的地址映射&lt;/h2&gt;

&lt;h4 id=&quot;section-6&quot;&gt;直接映射&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/klkucan/ImgLib/blob/master/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E5%99%A8/%E7%9B%B4%E6%8E%A5%E6%98%A0%E5%B0%84.png?raw=true&quot; alt=&quot;直接映射&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;对主存分区，每个区的第0块就放到cache的第0块。从图中可以看到cache的0块可能是任何一个区的第0块。&lt;/li&gt;
  &lt;li&gt;主存区号就是cache的标记，因为只要区号和标记一致，那么主存区中的块和cache的块就能一一对应，同样字块内地址也是一一对应的。&lt;/li&gt;
  &lt;li&gt;弊端：对于cache的使用有浪费，比如一个区只有一个块被用到了，但是如果出现代码的调转等操作导致需要加载新的cache，只能整块的替换。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-7&quot;&gt;全相联映射&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/klkucan/ImgLib/blob/master/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E5%99%A8/%E5%85%A8%E7%9B%B8%E8%81%94%E6%98%A0%E5%B0%84.png?raw=true&quot; alt=&quot;全相联映射&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;主存中任何一个块可以放入cache中任何一个块。&lt;/li&gt;
  &lt;li&gt;弊端：因为是随便放的，所以CPU使用数据时要把主存地址和cache标记一一对比，导致效率低，线路也会比较复杂。同时cache标记记录的是区号+块号，位数比较多，比较器长度比较长。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-8&quot;&gt;组相联映射&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/klkucan/ImgLib/blob/master/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E5%99%A8/%E7%BB%84%E7%9B%B8%E8%81%94.png?raw=true&quot; alt=&quot;组相联&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;cache分成多少组，主存储器中每个区就包含了多少块。&lt;/li&gt;
  &lt;li&gt;主存在往cache放块的时候，只要计算出这个块是该区的第i个，那么就会放入到cache中第i组中。&lt;/li&gt;
  &lt;li&gt;主存的块只能放到指定的组（体现了直接相连），但是这个主存块可以在组的任何位置（体现了全相连）。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-9&quot;&gt;总结&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;直接映射：某一主存块只能固定映射到某一缓冲块，速度快但是不灵活。&lt;/li&gt;
  &lt;li&gt;全相联映射：某一主存块能映射到任一缓冲块，速度慢但cache利用率高。&lt;/li&gt;
  &lt;li&gt;组相联：某一主存块能映射到某一缓存组中的任一缓冲块中。实际上如果每组都只有一块就等于是全相连，而如果只有一组那就是直接相联。&lt;strong&gt;优点就是兼顾速度与利用率。&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;不同的相联模式在多层cache中分别使用：靠近CPU的cache要求高速度，可以用直接映射或者路数比较少的组相联映射；中间层次可以组相联（比如：两路组相联、四路组相联等）；越远的可以用全相连，因为远的对速度要求低，对利用率要求高。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-10&quot;&gt;替换算法&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;先进先出（FIFO）算法：不能很好的体现程序的局部访问原理&lt;/li&gt;
  &lt;li&gt;近期最少使用（LRU）算法：希望替换cache块中CPU不再用，或者距离下次CPU读写这个块时间最长的块。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-11&quot;&gt;一点感悟：&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;学到现在从组成原理的设计上学到一个很好的思路，在解决一个问题的时候如果有明显的两个极端的方案，那么可以在局部采用一个方案，而在整体采用另外一个方案。这个就能很好的融合两者的优点，而尽量较少弊端带来的影响。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Wed, 03 Oct 2018 18:33:00 +0800</pubDate>
        <link>https://caihua.tech/2018/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-6-%E9%AB%98%E9%80%9F%E7%BC%93%E5%86%B2%E5%AD%98%E5%82%A8%E5%99%A8/</link>
        <guid isPermaLink="true">https://caihua.tech/2018/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-6-%E9%AB%98%E9%80%9F%E7%BC%93%E5%86%B2%E5%AD%98%E5%82%A8%E5%99%A8/</guid>
        
        <category>组成原理</category>
        
        
      </item>
    
      <item>
        <title>计算机组成原理：5、主存储器</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;一、概述&lt;/h3&gt;

&lt;h4 id=&quot;section-1&quot;&gt;1、基本构成&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/klkucan/ImgLib/blob/master/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E5%99%A8/%E4%B8%BB%E5%AD%98%E7%BB%93%E6%9E%84.png?raw=true&quot; alt=&quot;主存构成&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;结合上图总结一下之前的数据读取的操作
    &lt;ul&gt;
      &lt;li&gt;CPU在第一个时钟周期时通过地址总线发出要取数据的地址，这个地址是指的存储单元的地址。&lt;/li&gt;
      &lt;li&gt;MAR收到后，经过译码器得到指定的存储单元。&lt;/li&gt;
      &lt;li&gt;CPU在第二个时钟周期时通过控制总线讲读指令发送到主存储器&lt;/li&gt;
      &lt;li&gt;控制电路根据信令来操作读写电路&lt;/li&gt;
      &lt;li&gt;将之前得到主存储器地址中的数据写入MDR&lt;/li&gt;
      &lt;li&gt;通过数据总线讲MDR中的数据送入到IR或者ACC&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;cpu&quot;&gt;2、主存与CPU之间的联系&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/klkucan/ImgLib/blob/master/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E5%99%A8/CPU-%E4%B8%BB%E5%AD%98.png?raw=true&quot; alt=&quot;CPU-主存&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;CPU和主存之间主要是三个总线：地址、数据、命令&lt;/li&gt;
  &lt;li&gt;数据总线是双向的，而地址是单向&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-2&quot;&gt;3、主存中存储单元地址的分配&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/klkucan/ImgLib/blob/master/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E5%99%A8/%E5%AD%98%E5%82%A8%E5%8D%95%E5%85%83%E5%9C%B0%E5%9D%80%E5%88%86%E9%85%8D.png?raw=true&quot; alt=&quot;存储单元地址分配&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;数据在存储器中存储主要有两个方式，大端和小端。&lt;/li&gt;
  &lt;li&gt;图中高位字节指的是0x12345678中的12，其中从左到右为从高高低&lt;/li&gt;
  &lt;li&gt;但是在存储器中，地址小的为低位&lt;/li&gt;
  &lt;li&gt;所以大端中就是高位的12存在了低位，小端就是低位的78存在了低位。&lt;/li&gt;
  &lt;li&gt;关于按字节寻址和按字寻址详见延展阅读，&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-3&quot;&gt;二、半导体存储芯片&lt;/h3&gt;

&lt;h4 id=&quot;section-4&quot;&gt;1、基本结构&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/klkucan/ImgLib/blob/master/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E5%99%A8/%E5%8D%8A%E5%AF%BC%E4%BD%93%E5%AD%98%E5%82%A8%E8%8A%AF%E7%89%87%E7%BB%93%E6%9E%84.png?raw=true&quot; alt=&quot;半导体存储芯片结构&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;芯片容量计算：2^(地址线数量) * 数据线带宽，e.g 地址线10跟，数据线 4bit，那么容量就是 2^10 * 4 = 1k * 4bit&lt;/li&gt;
  &lt;li&gt;片选线：
    &lt;ul&gt;
      &lt;li&gt;片选线的作用是来标记一次数据存储过程中，数据是否存在于一个存储芯片中。&lt;/li&gt;
      &lt;li&gt;两周标识方式:CS\CE，上面的线表示低电平。也就是说如果管脚是低电平就说明这次要访问的是这个芯片。&lt;/li&gt;
      &lt;li&gt;比如内存条上有很多存储芯片，那么一次可能用到的数据在一个或者多个芯片上。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;读写控制线：可以使用一根或者两个线来表示&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-5&quot;&gt;2、片选线的作用&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/klkucan/ImgLib/blob/master/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E5%99%A8/%E5%8D%8A%E5%AF%BC%E4%BD%93%E5%AD%98%E5%82%A8%E8%8A%AF%E7%89%87%E7%89%87%E9%80%89%E7%BA%BF.png?raw=true&quot; alt=&quot;半导体存储芯片片选线&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;上图展示了一个使用片选线的demo&lt;/li&gt;
  &lt;li&gt;每个芯片16K x 1bit，当计算机需要64K x 8bit时需要32个芯片来实现。&lt;/li&gt;
  &lt;li&gt;8个芯片串行，用之前大楼的概念来看，就是整个楼有2^16个房间，每个房间8个床位，但是注意这8个床位其实是跨房间的（或者说是跨楼的）。如果要住8个人（8bit数据），那么并不是全住在第一个房间，而是住在8个楼（一组串行芯片）的编号相同房间中编号相同的床位上（图中每个房间其实只有一个床位）。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-6&quot;&gt;3、译码驱动&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;地址总线传到存储器的地址需要进行译码，然后才能得到在存储器对应的地址。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-7&quot;&gt;线选法&lt;/h5&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/klkucan/ImgLib/blob/master/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E5%99%A8/%E7%BA%BF%E9%80%89%E6%B3%95%E8%AF%91%E7%A0%81%E9%A9%B1%E5%8A%A8.png?raw=true&quot; alt=&quot;线选法译码驱动&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;线选法图中有4根地址线，因此存储单元有 2^4 = 16个，对应字线0-15。&lt;/li&gt;
  &lt;li&gt;根据4根线上的数据得到具体的字线后，字线上的数据读写到MDR。&lt;/li&gt;
  &lt;li&gt;弊端是如果想要一个1M*8大小的存储器，那么地址线需要20条，而字线需要1M条，对于芯片来说很难。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-8&quot;&gt;重合法&lt;/h5&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/klkucan/ImgLib/blob/master/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E5%99%A8/%E9%87%8D%E5%90%88%E6%B3%95%E8%AF%91%E7%A0%81%E9%A9%B1%E5%8A%A8.png?raw=true&quot; alt=&quot;重合法译码驱动&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;相当于笛卡尔坐标系&lt;/li&gt;
  &lt;li&gt;10条地址线可以表达出 32 * 32个位置，每个位置是1bit&lt;/li&gt;
  &lt;li&gt;与线选法比较，1M*8的空间 = 2^20 * 2^3 = 2^23bit , 用重合法可以做 2^12 * 2^11 这样一个矩阵，也就是 4k + 2k = 6k条字线。&lt;/li&gt;
  &lt;li&gt;最初看到这里的时候有个疑惑，就是根据重合法每次只能拿到一个bit，但是看到后面的Intel 2114 RAM矩阵后就知道了如何使用重合法一次获得多个bit。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;ram-&quot;&gt;三、随机存取机器（RAM）→ 内存&lt;/h3&gt;

&lt;h4 id=&quot;ramsram&quot;&gt;1、静态RAM(SRAM)&lt;/h4&gt;

&lt;h5 id=&quot;section-9&quot;&gt;保存0和1的原理&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;双稳态触发器&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-10&quot;&gt;基本单元电路如何构成&lt;/h5&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/klkucan/ImgLib/blob/master/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E5%99%A8/%E9%9D%99%E6%80%81RAM%E5%9F%BA%E6%9C%AC%E7%94%B5%E8%B7%AF.png?raw=true&quot; alt=&quot;静态RAM基本电路&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;ram&quot;&gt;静态RAM芯片如何读写&lt;/h5&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/klkucan/ImgLib/blob/master/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E5%99%A8/%E9%9D%99%E6%80%81RAM%E5%9F%BA%E6%9C%AC%E7%94%B5%E8%B7%AF%E8%AF%BB%E6%93%8D%E4%BD%9C.png?raw=true&quot; alt=&quot;静态RAM基本电路读操作&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/klkucan/ImgLib/blob/master/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E5%99%A8/%E9%9D%99%E6%80%81RAM%E5%9F%BA%E6%9C%AC%E7%94%B5%E8%B7%AF%E5%86%99%E6%93%8D%E4%BD%9C.png?raw=true&quot; alt=&quot;静态RAM基本电路写操作&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;intel-2114-ram-&quot;&gt;Intel 2114 RAM 矩阵&lt;/h5&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/klkucan/ImgLib/blob/master/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E5%99%A8/Inter2114%20%E8%AF%BB.png?raw=true&quot; alt=&quot;Inter2114 读&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;上图很好的解释了在使用重合法时如何一次读取多个bit数据。&lt;/li&gt;
  &lt;li&gt;行地址译码6位，所以范围是0-63，也就是说字线有64条。 列地址译码有4位，也就是说有16个。&lt;/li&gt;
  &lt;li&gt;字长为64bit，将64分成4组，每组是16bit（对应列地址位数）。&lt;/li&gt;
  &lt;li&gt;当行地址是0，列地址也是0时，其实取的是四组中第0位的数据，这样就实现了重合法一次取出多位。&lt;/li&gt;
  &lt;li&gt;写操作基本相同。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;ramdram&quot;&gt;2、动态RAM(DRAM)&lt;/h4&gt;

&lt;h5 id=&quot;section-11&quot;&gt;保存0和1的原理&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;电容，充电是1，没充电是0。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-12&quot;&gt;基本单元电路如何构成&lt;/h5&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/klkucan/ImgLib/blob/master/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E5%99%A8/%E5%8A%A8%E6%80%81RAM%E5%9F%BA%E6%9C%AC%E5%8D%95%E5%85%83%E7%94%B5%E8%B7%AF.png?raw=true&quot; alt=&quot;动态RAM基本单元电路&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;左边3管动态RAM，右边单管。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;ram-1&quot;&gt;动态RAM芯片如何读写&lt;/h5&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/klkucan/ImgLib/blob/master/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E5%99%A8/Inter1103%20%E8%AF%BB.png?raw=true&quot; alt=&quot;Inter1103 读&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;行地址译码器这里参加译码的不止是地址还有读写选择线。&lt;/li&gt;
  &lt;li&gt;三角形是刷新放大器。作用：电容存储电荷的原理，电容会漏掉，经过一段时间电容上信号消失。刷新放大器对电容中保持的信息进行重现。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;ram-2&quot;&gt;动态RAM刷新&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;只和行地址有关，与列地址无关。一次刷新刷的就是一行所有的基本单元电路。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-13&quot;&gt;刷新方式&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;集中式&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/klkucan/ImgLib/blob/master/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E5%99%A8/%E5%8A%A8%E6%80%81RAM%E9%9B%86%E4%B8%AD%E5%88%B7%E6%96%B0.png?raw=true&quot; alt=&quot;动态RAM集中刷新&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;可以看到2毫秒按照存取周期0.5微秒分成了4000份，其中128个周期是用来刷新的。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在死区时间内CPU和IO设备如果想访问动态RAM只能等待。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;分散式&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/klkucan/ImgLib/blob/master/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E5%99%A8/%E5%8A%A8%E6%80%81RAM%E5%88%86%E6%95%A3%E5%88%B7%E6%96%B0.png?raw=true&quot; alt=&quot;动态RAM分散刷新&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;本来每个存取周期是0.5微秒，但是为了刷新又加了0.5，导致一个存取周期变为了1微秒。&lt;/li&gt;
  &lt;li&gt;没有了死区&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;和集中式比较，2毫秒内每行要刷新15.6次，存在过度刷新的问题。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;异步式&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/klkucan/ImgLib/blob/master/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E5%99%A8/%E5%8A%A8%E6%80%81RAM%E5%BC%82%E6%AD%A5%E5%88%B7%E6%96%B0.png?raw=true&quot; alt=&quot;动态RAM异步刷新&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在15.6微秒中可以认为是集中式，在2毫秒的周期内看是分散式的。&lt;/li&gt;
  &lt;li&gt;确实在安排好的情况下不会出现死区。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;sramdram&quot;&gt;3、SRAM和DRAM的比较&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/klkucan/ImgLib/blob/master/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E5%99%A8/SRAM%E5%92%8CDRAM%E7%9A%84%E6%AF%94%E8%BE%83.png?raw=true&quot; alt=&quot;SRAM和DRAM的比较&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;注意引脚数，DRAM行地址和列地址可以分开传输，所以少。但是这样在速度上慢。&lt;/li&gt;
  &lt;li&gt;而且DRAM电容充放电比较慢，所以读取速度慢。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;rom&quot;&gt;四、只读存储器 ROM&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;基本都是电子元器件的内容&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/klkucan/ImgLib/blob/master/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E5%99%A8/PROM.png?raw=true&quot; alt=&quot;PROM&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/klkucan/ImgLib/blob/master/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E5%99%A8/EPROM.png?raw=true&quot; alt=&quot;EPROM&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;cpu-1&quot;&gt;五、存储器与CPU的连接&lt;/h3&gt;

&lt;h4 id=&quot;section-14&quot;&gt;存储器扩展&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;位扩展&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/klkucan/ImgLib/blob/master/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E5%99%A8/%E5%AD%98%E5%82%A8%E5%99%A8%E4%BD%8D%E6%89%A9%E5%B1%95.png?raw=true&quot; alt=&quot;存储器位扩展&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;位扩展利用两个芯片的数据线放到数据总线上不同的线上&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;字扩展&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/klkucan/ImgLib/blob/master/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E5%99%A8/%E5%AD%98%E5%82%A8%E5%99%A8%E5%AD%97%E6%89%A9%E5%B1%95.png?raw=true&quot; alt=&quot;存储器位扩展&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;利用多出来的一条地址线作为片选线，从而实现两个芯片逻辑上的串联。扩展地址线长度。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;位和字扩展&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/klkucan/ImgLib/blob/master/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E5%99%A8/%E5%AD%98%E5%82%A8%E5%99%A8%E5%AD%97%E5%92%8C%E4%BD%8D%E6%89%A9%E5%B1%95.png?raw=true&quot; alt=&quot;存储器字和位扩展&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;多出两根地址线，形成一个范围从0-3的可变数字。&lt;/li&gt;
  &lt;li&gt;将8个芯片分成4组，刚好对应上面的数字。通过地址线A11 A10加不同的电来实现片选译码。&lt;/li&gt;
  &lt;li&gt;对于每组2个芯片正常的位扩展。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-15&quot;&gt;一个连接的练习&lt;/h5&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/klkucan/ImgLib/blob/master/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E5%99%A8/CPU%E4%B8%8E%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E8%BF%9E%E6%8E%A5.png?raw=true&quot; alt=&quot;CPU与存储器的连接&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;开始学位和字的扩展时觉得很奇怪，但是当会后讲到一个如何设计CPU与存储芯片连接的题时就明白了一个核心：因为CPU的地址线和数据线数量与芯片的不同，因此需要进行位的扩展来适应CPU的数据线，需要合理的设计地址线来做片选译码和地址译码。&lt;/li&gt;
  &lt;li&gt;通常地址线的高位做片选译码，低位做地址译码。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-16&quot;&gt;六、提高访存速度的措施&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;高位交叉，高位交叉中很大概率是M0被频繁访问，而后面的不会。因为数据或者指令总是按照内存地址的顺序被使用。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/klkucan/ImgLib/blob/master/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E5%99%A8/%E9%AB%98%E4%BD%8D%E4%BA%A4%E5%8F%89.png?raw=true&quot; alt=&quot;高位交叉&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;低位交叉&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/klkucan/ImgLib/blob/master/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E5%99%A8/%E4%BD%8E%E4%BD%8D%E4%BA%A4%E5%8F%89.png?raw=true&quot; alt=&quot;低位交叉&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;这样的地址布局可以使得M0-3这四个存储体可以依次的被CPU使用。如果报错的是代码指令，就是先调用M0的0000位置，然后是M1的0000位置，依次使用。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/klkucan/ImgLib/blob/master/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E5%99%A8/%E4%BD%8E%E4%BD%8D%E4%BA%A4%E5%8F%89%E4%BD%BF%E7%94%A8%E7%9A%84%E6%97%B6%E9%97%B4.png?raw=true&quot; alt=&quot;低位交叉使用的时间&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;低位交叉被并发的访问，将一个存储周期分成4份。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-17&quot;&gt;延展阅读&lt;/h3&gt;

&lt;h4 id=&quot;section-18&quot;&gt;1、关于按字寻址和按字节寻址的理解&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;设有一个1MB容量的存储器，字长32位，问：按字节编址，字编址的寻址范围以及各自的寻址范围大小?&lt;/p&gt;

  &lt;p&gt;如果按字节编址，则&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1MB = 2^20B 

1字节=1B=8bit 

2^20B/1B = 2^20 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;地址范围为0~(2^20)-1,也就是说需要二十根地址线才能完成对1MB空间的编码，所以地址寄存器为20位,寻址范围大小为 2^20 = 1M&lt;/p&gt;

  &lt;p&gt;如果按字编址，则&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1MB=2^20B

1字=32bit=4B

2^20B/4B = 2^18   
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;地址范围为0~2^18-1，也就是说我们至少要用18根地址线才能完成对1MB空间的编码。因此按字编址的寻址范围是 2^18&lt;/p&gt;

  &lt;p&gt;以上题目注意几点：&lt;/p&gt;

  &lt;p&gt;1.区分寻址空间与寻址范围两个不同的概念，寻址范围仅仅是一个数字范围，不带有单位。而寻址范围的大小很明显是一个数，指寻址区间的大小。而寻址空间指能够寻址最大容量，单位一般用MB、B来表示；本题中寻址范围为0~(2^20)-1,寻址空间为1MB。&lt;/p&gt;

  &lt;p&gt;2.按字节寻址，指的是存储空间的最小编址单位是字节，按字编址，是指存储空间的最小编址单位是字，以上题为例，总的存储器容量是一定的，按字编址和按字节编址所需要的编码数量是不同的，按字编址由于编址单位比较大（1字=32bit=4B），从而编码较少，而按字节编址由于编码单位较小（1字节=1B=8bit），从而编码较多。&lt;/p&gt;

  &lt;p&gt;3.区别M和MB。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;M为数量单位。1024=1K，1024K=1M

MB指容量大小。1024B=1KB，1024KB=1MB.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-19&quot;&gt;参考&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;https://blog.csdn.net/lishuhuakai/article/details/8934540&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 30 Sep 2018 13:59:00 +0800</pubDate>
        <link>https://caihua.tech/2018/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-5-%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8/</link>
        <guid isPermaLink="true">https://caihua.tech/2018/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-5-%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8/</guid>
        
        <category>组成原理</category>
        
        
      </item>
    
      <item>
        <title>Unity ECS：C# Job System文档总结</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;背景、初衷、目标&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;出现的背景、初衷就是：天下苦无多线程久已&lt;/li&gt;
  &lt;li&gt;当然这个说法要进一步的约束，首先unity中可以编写多线程代码，但是最大的问题是多线程中无法使用unity API，当然也无法修改component中的数据了。&lt;/li&gt;
  &lt;li&gt;目前来看似乎这个技术就是为了能够让开发者使用multithread来操作unity API和component 数据。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-1&quot;&gt;优势和劣势&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;多线程就是优势&lt;/li&gt;
  &lt;li&gt;可操作的数据类型限制比较大，目前只能是blittable data type&lt;/li&gt;
  &lt;li&gt;这个多线程是和unity引擎共享work thread，所以变相的侵占了引擎层的性能。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-2&quot;&gt;组成部分和关键点&lt;/h3&gt;

&lt;h4 id=&quot;section-3&quot;&gt;组成&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;job system
    &lt;ul&gt;
      &lt;li&gt;job system管理一组worker thread，通常每个逻辑上的CPU的核（core）可以跑一个worker。这是为了避免上下文切换带来的性能问题。&lt;/li&gt;
      &lt;li&gt;job system会把一些job放入一个队列，然后worker thread从队列中取出job进行执行。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;job：最小工作单元，接受参数和操作作为数据。job是可以自足的，也可以依赖其他的job。&lt;/li&gt;
  &lt;li&gt;NativeContainer：
    &lt;ul&gt;
      &lt;li&gt;一个托管的值类型，对native memory提供安全的C#的包装器。&lt;/li&gt;
      &lt;li&gt;包含一个指向非托管内存地址的指针&lt;/li&gt;
      &lt;li&gt;job system中NativeContainer允许job和主线程共享数据，而不是copy的数据。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-4&quot;&gt;关键点&lt;/h4&gt;

&lt;h5 id=&quot;section-5&quot;&gt;保障执行顺序和数据竟态&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;job system管理job之间的依赖，保证执行的正确。&lt;/li&gt;
  &lt;li&gt;job system通过深拷贝（memcpy）数据来解决竟态问题，带来的问题就是只能访问blittable data type。&lt;/li&gt;
  &lt;li&gt;job system在托管和native之间传递copy的data，调度job时使用memcpy将数据放到native memory，然后在job执行时给托管代码这边访问数据的能力。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;nativecontainer&quot;&gt;NativeContainer&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;safety system的缺点是因为采用了copy数据的方式，所以数据结果在job之间是独立的。可以想象对于有执行顺序依赖的job，这样的结果是错误的。NativeContainer就是以为了解决这个问题。&lt;/li&gt;
  &lt;li&gt;NativeContainer包含的数据结果：
    &lt;ul&gt;
      &lt;li&gt;NativeList - a resizable NativeArray.&lt;/li&gt;
      &lt;li&gt;NativeHashMap - key and value pairs.&lt;/li&gt;
      &lt;li&gt;NativeMultiHashMap - multiple values per key.&lt;/li&gt;
      &lt;li&gt;NativeQueue - a first in, first out (FIFO) queue.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Allocator：分配器，不同的分配器区别主要在对于NativeContainer对象lifetime的影响。
    &lt;ul&gt;
      &lt;li&gt;Allocator.Temp：NativeContainer的lifespan只在一帧内，不能将这样的NativeContainer传递给job。而且要在某个使用了它的函数结束前调研Dispose方法来销毁NativeContainer。内存分配的速度很快（怀疑是在一个已经分配好的shared memory中）。&lt;/li&gt;
      &lt;li&gt;Allocator.TempJob：中速，lifespan 4帧，线程安全。多数比较小的job都使用这个。如果4帧后没有销毁，会有一个来自native code的警告输出。&lt;/li&gt;
      &lt;li&gt;Allocator.Persistent：最慢，NativeContainer长存。本身是malloc的包装器。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;nativecontainersafety-system&quot;&gt;NativeContainer中的safety system&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;注意：所有NativeContainer中的安全监测只在Editor和Play Mode有效。也就是真机无需。&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;DisposeSentinel：发现内存泄漏，然后给出error。&lt;/li&gt;
  &lt;li&gt;AtomicSafetyHandle：转移NativeContainer的控制权。这个有效需要使用宏：ENABLE_UNITY_COLLECTIONS_CHECKS&lt;/li&gt;
  &lt;li&gt;不管是主线程还是job对于NativeContainer的访问仍旧是同一时间只允许一个写操作，但是支持并发读操作。&lt;/li&gt;
  &lt;li&gt;如果NativeContainer被设计为只读的可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;[ReadOnly]&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;注意：job中访问静态数据绕过了所有的保护系统，可能引起unitycrash。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;job&quot;&gt;创建job&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;创建一个inherit IJob的struct&lt;/li&gt;
  &lt;li&gt;添加成员变量，只能是NativeContainer或者blittable types&lt;/li&gt;
  &lt;li&gt;创建Execute函数，job运行时Execute函数在CPU core中会执行一次。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;注意：job中操作的数据除了NativeContainer的外都是一份拷贝。job中访问主线程中数据的唯一方式就是用操作NativeContainer类型的数据。（调用job的代码中很好的体现了这个）&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;代码参考原文文档&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;job-1&quot;&gt;使用job&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;直接调用job的Schedule方法&lt;/li&gt;
  &lt;li&gt;调用Schedule方法将job放到一个队列中，一旦放入就不能中断。&lt;/li&gt;
  &lt;li&gt;Schedule方法只能在主线程调用。&lt;/li&gt;
  &lt;li&gt;注意源码最后释放了NativeArray类型的result，因为它的分配器是TempJob。&lt;/li&gt;
  &lt;li&gt;代码参考原文文档&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;jobhandle&quot;&gt;JobHandle和依赖&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;JobHandle是Schedule函数的返回值&lt;/li&gt;
  &lt;li&gt;在job存在依赖时利用它来设置依赖&lt;/li&gt;
  &lt;li&gt;多依赖时使用CombineDependencies&lt;/li&gt;
  &lt;li&gt;当在主线程需要等待job完成，可以使用Complete方法。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;parallelfor-jobs&quot;&gt;ParallelFor jobs&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;利用多和并发执行job&lt;/li&gt;
  &lt;li&gt;可以通过这种参数决定在native层有多少个batch&lt;/li&gt;
  &lt;li&gt;参数中的lenght应该是作为输出结果的NativeContainer的lenght，它告诉job system有多少execute函数要执行。&lt;/li&gt;
  &lt;li&gt;innerloopBatchCount从字面看应该是batch中有多少个job，从下面代码的注释看也是这个意思。 &lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;// Schedule the job with one Execute per index in the results array and only 1 item per processing batch&lt;/code&gt;   &lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;JobHandle handle = jobData.Schedule(result.Length, 1);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://docs.unity3d.com/uploads/Main/jobsystem_parallelfor_job_batches.svg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;底层原理和关键实现&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;底层实现全部被封装到了DLL中，SHIT!&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-7&quot;&gt;对比&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;对比C#中的Thread类
    &lt;ul&gt;
      &lt;li&gt;Thread使用的是从系统申请来的现场，而job system是与引擎共享的线程，在没有源码的情况下姑且认为是有不同的。&lt;/li&gt;
      &lt;li&gt;对于可操作对象的不同，Thread只能操作非引擎的对象，而job system是操作的引擎对象，虽然是受限的。&lt;/li&gt;
      &lt;li&gt;从管理上也不一样，Thread需要自己控制执行的顺序但是job system的顺序是通过设置后引擎来管理的。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;对比协程
    &lt;ul&gt;
      &lt;li&gt;单线程与多线程的差异&lt;/li&gt;
      &lt;li&gt;但是协程是可以控制所有的unityengine对象的，例如物理、动画等。这些job system还做不到，只能依赖MonoBehaviour。&lt;/li&gt;
      &lt;li&gt;因此在大规模计算的数据是NativeContainer或者blittable types的时候在性能上肯定是碾压协程的。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-8&quot;&gt;原文&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.unity3d.com/Manual/JobSystemOverview.html&quot;&gt;C# Job System&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 26 Sep 2018 10:32:00 +0800</pubDate>
        <link>https://caihua.tech/2018/09/26/Unity-ECS-C-Job-System%E6%96%87%E6%A1%A3%E6%80%BB%E7%BB%93/</link>
        <guid isPermaLink="true">https://caihua.tech/2018/09/26/Unity-ECS-C-Job-System%E6%96%87%E6%A1%A3%E6%80%BB%E7%BB%93/</guid>
        
        <category>Unity3D</category>
        
        
      </item>
    
      <item>
        <title>计算机组成原理：4、存储器概述</title>
        <description>&lt;h4 id=&quot;section&quot;&gt;分类&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;按照介质&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;按照存取方式
    &lt;ul&gt;
      &lt;li&gt;存取时间与物理地址无关（随机访问）
        &lt;ul&gt;
          &lt;li&gt;随机存储器（RAM）: 在程序执行过程中可以读写&lt;/li&gt;
          &lt;li&gt;制度存储器（ROM）：在程序执行过程中只能读&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;存取时间与物理地址有关（串行访问）
        &lt;ul&gt;
          &lt;li&gt;顺序存取存储器：磁带&lt;/li&gt;
          &lt;li&gt;直接存取存储器：磁盘&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;按照作用
    &lt;ul&gt;
      &lt;li&gt;主存储器
        &lt;ul&gt;
          &lt;li&gt;RAM
            &lt;ul&gt;
              &lt;li&gt;静态RAM（cache）&lt;/li&gt;
              &lt;li&gt;动态RAM（内存芯片）&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;ROM（只读，但是不同的）（BIOS ROM）
            &lt;ul&gt;
              &lt;li&gt;MROM：Mask Read-Only Memory，中文全称“掩模式只读存储器”。掩模式只读存储器的内容是由半导体制造厂按用户提出的要求在芯片的生产过程中直接写入的，写入之后任何人都无法改变其内容。&lt;/li&gt;
              &lt;li&gt;PROM：可编程ROM&lt;/li&gt;
              &lt;li&gt;EPROM：可擦除可编程ROM，是一种断电后仍能保留数据的计算机储存芯片。一旦编程完成后，EPROM只能用强紫外线照射来擦除。&lt;/li&gt;
              &lt;li&gt;EEPROM：EEPROM（带电可擦写可编程读写存储器）是用户可更改的只读存储器
（ROM），其可通过高于普通电压的作用来擦除和重编程（重写）。不像EPROM芯片，EEPROM不需从计算机中取出即可修改。&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Flash Memory → SSD&lt;/li&gt;
      &lt;li&gt;高速缓存存储器（Cache）&lt;/li&gt;
      &lt;li&gt;辅助存储器&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-1&quot;&gt;存储器层次&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/klkucan/ImgLib/blob/master/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E5%99%A8/%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png?raw=true&quot; alt=&quot;层次结构&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;寄存器并非只存在于CPU，IO端口中也有。&lt;/li&gt;
  &lt;li&gt;对于指令能够操作的寄存器叫体系结构寄存器，对应的指令无法操作的register就是非体系结构寄存器。&lt;/li&gt;
  &lt;li&gt;早期CPU中是没有cache的，随着发展一部分cache进入到了CPU。cache的作用是做CPU与主存的中间层，因为cache的访问速度更快，可以更CPU更好的配合。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-2&quot;&gt;缓存-主存层次与主存-辅存层次&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/klkucan/ImgLib/blob/master/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E5%99%A8/%E7%BC%93%E5%AD%98-%E4%B8%BB%E5%AD%98-%E8%BE%85%E5%AD%98.png?raw=true&quot; alt=&quot;缓存-主存-辅存&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;缓存-主存是为了速度，由硬件连接&lt;/li&gt;
  &lt;li&gt;主存和辅存是为了容量，有软硬件连接&lt;/li&gt;
  &lt;li&gt;主存和辅存构成虚拟存储器，在程序使用时识别的是虚拟地址（逻辑地址），所以我们写程序的时候往往看到的初始内存地址为0。当程序被装入内存或指令要执行的时候，由特定的机构把逻辑地址转化为内存中的物理地址。&lt;/li&gt;
  &lt;li&gt;缓存和主存使用的地址是主存的实地址（物理地址）&lt;/li&gt;
  &lt;li&gt;缓存按内容查找&lt;/li&gt;
  &lt;li&gt;缓存中保存的指令中的地址码保存的是主存的地址，把这个主存地址转化成缓存中的块号和块内偏移地址。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-3&quot;&gt;参考&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;https://baike.baidu.com/item/MROM&lt;/li&gt;
  &lt;li&gt;https://baike.baidu.com/item/EEPROM&lt;/li&gt;
  &lt;li&gt;https://baike.baidu.com/item/EPROM&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 21 Sep 2018 20:48:00 +0800</pubDate>
        <link>https://caihua.tech/2018/09/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-4-%E5%AD%98%E5%82%A8%E5%99%A8%E6%A6%82%E8%BF%B0/</link>
        <guid isPermaLink="true">https://caihua.tech/2018/09/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-4-%E5%AD%98%E5%82%A8%E5%99%A8%E6%A6%82%E8%BF%B0/</guid>
        
        <category>组成原理</category>
        
        
      </item>
    
      <item>
        <title>计算机组成原理：3、总线</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;概要&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;总线（bus）：是连接各个部件的信息传输线，是各个部件共享的传输介质。&lt;/li&gt;
  &lt;li&gt;一条总线是总是主模块向从模块发出地址和命令，但是在分离式通信时是没有从模块的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-1&quot;&gt;总线解决的是什么问题？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;计算机的不同模块需要用线连接起来，如果采用分散连接（两两连接）那么需要的线路太多，都设计在电路板上难度太大，而且设备的连接接口太多。&lt;/li&gt;
  &lt;li&gt;分散连接还存在一个扩展困难的问题，如果新加一个接口就要将这个接口与已存在的接口相连。&lt;/li&gt;
  &lt;li&gt;计算机总线使用有限的线路数量将所有的部件连接起来，解决了上面两个问题。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-2&quot;&gt;劣势是什么&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;因为总线是共享的，在一个时刻只能有一对（两个）部件进行数据的传输，因此会成为系统的瓶颈。e.g IO与主存在数据传输时，CPU与主存就无法传输了。因此在传输周期上设计了分离式的传输方式，用于解决总线被占用期间出现无效的等待。&lt;/li&gt;
  &lt;li&gt;总线并行传输在线路比较长时会出现信号干扰，所以一般并行都是在PC机箱内。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-3&quot;&gt;多总线&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;为了解决同一时刻只能一对部件使用总线的问题，引入了多路的总线。&lt;/li&gt;
  &lt;li&gt;其中一种是：以主存作为中心，一条存储总线，一条系统总线。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-4&quot;&gt;总线分类&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;芯片内总线：芯片内部&lt;/li&gt;
  &lt;li&gt;系统总线：计算机各部件之间的信息传输线。根据传输信号类型的不同分为：
    &lt;ul&gt;
      &lt;li&gt;数据总线：
        &lt;ul&gt;
          &lt;li&gt;双向；&lt;/li&gt;
          &lt;li&gt;宽度通常小于等于机器字长、存储字长。&lt;/li&gt;
          &lt;li&gt;e.g 64位计算器，数字总线可以是8位，要进行一次64位计算，需要传输64位的数据，那么就需要传输8次。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;地址总线：
        &lt;ul&gt;
          &lt;li&gt;通过地址才能找到存储单元和设备。&lt;/li&gt;
          &lt;li&gt;通常单向：CPU到IO和主存；&lt;/li&gt;
          &lt;li&gt;与存储地址、IO地址有关。&lt;/li&gt;
          &lt;li&gt;地址总线的条数与地址单元个数相关。在本书中地址总线宽度和MAR寄存器宽度一样。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;控制总线：
        &lt;ul&gt;
          &lt;li&gt;向系统各个部件传递控制信号；&lt;/li&gt;
          &lt;li&gt;或者各个部件向外传递状态信号。&lt;/li&gt;
          &lt;li&gt;e.g : 存储器的读写、总线使用的许可、中断确认。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;通信总线：
    &lt;ul&gt;
      &lt;li&gt;计算机之间或者与其它设备的连接。&lt;/li&gt;
      &lt;li&gt;串行&lt;/li&gt;
      &lt;li&gt;并行&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-5&quot;&gt;总线的特效&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;机械特性：尺寸、形状、管脚数、排列顺序&lt;/li&gt;
  &lt;li&gt;电器特性：传输方向（上面的单双向），有效电平范围&lt;/li&gt;
  &lt;li&gt;功能特性：地址、数据、控制&lt;/li&gt;
  &lt;li&gt;时间特性：信号的时序关系&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-6&quot;&gt;性能指标&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;总线宽度：数据线的根数&lt;/li&gt;
  &lt;li&gt;标准传输率：每秒传输的最大字节数 MBps&lt;/li&gt;
  &lt;li&gt;时钟同步/异步：同步、不同步&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;总线复用：地址线与数据线的复用，这个复用其实是共享使用。这样设计是为了减少CPU管脚数。e.g 8086CPU，20个地址线中16跟还作为数据线使用。&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;信号线数：地址线、数据线、控制箱总和&lt;/li&gt;
  &lt;li&gt;总线控制方式：突发、自动、仲裁、逻辑、计算&lt;/li&gt;
  &lt;li&gt;其他指标：负载&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-7&quot;&gt;总线结构&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;总结结构有很多，不同的硬件的设计也不同，但是总结来看有几个原则:
    &lt;ul&gt;
      &lt;li&gt;CPU与主存之间总是有一条专门的总线，或者CPU与cache与主存之间。&lt;/li&gt;
      &lt;li&gt;高速设备与低俗设备使用不同的总线。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;四总线结构&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/klkucan/ImgLib/blob/master/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E6%80%BB%E7%BA%BF/%E5%9B%9B%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84.png?raw=true&quot; alt=&quot;四总线结构&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-8&quot;&gt;总线占有控制&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;前面说了总线在同一时刻只能由一对部件来使用，那么当多个部件同时请求使用时是如何来控制的呢？这个就是总线判优的问题了。&lt;/li&gt;
  &lt;li&gt;总线判优有两种主要方式集中式和分布式。集中式只指优先度是总线控制部件来决定的，它分为三种方式：
    &lt;ul&gt;
      &lt;li&gt;链式查询方式&lt;/li&gt;
      &lt;li&gt;计数器定时查询&lt;/li&gt;
      &lt;li&gt;独立请求方式&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-9&quot;&gt;链式查询方式&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/klkucan/ImgLib/blob/master/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E6%80%BB%E7%BA%BF/%E9%93%BE%E5%BC%8F%E6%9F%A5%E8%AF%A2.png?raw=true&quot; alt=&quot;链式查询&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;链式查询实际上是从接口0开始逐个的去询问是谁申请了总线的使用。如果1和N都申请了，但是因为先询问的1所以1就会占有总线。&lt;/li&gt;
  &lt;li&gt;优先级由接口的顺序来决定，比较死板。&lt;/li&gt;
  &lt;li&gt;弊端是如果BG上有线路的损坏后续就询问就无法继续了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-10&quot;&gt;计数器定时查询&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/klkucan/ImgLib/blob/master/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E6%80%BB%E7%BA%BF/%E8%AE%A1%E6%97%B6%E5%99%A8%E5%AE%9A%E6%97%B6%E6%9F%A5%E8%AF%A2.png?raw=true&quot; alt=&quot;计数器定时查询&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;总线控制器中有个计数器&lt;/li&gt;
  &lt;li&gt;多了一条设备地址，这条线是用来将计数器的值向外输出的。&lt;/li&gt;
  &lt;li&gt;当有多个IO接口申请总线时走的还是BR，总线控制器收到申请后如果判断可以交出总线的权限就会将当前的计数器的值通过设备地址线传递出去。&lt;/li&gt;
  &lt;li&gt;e.g 一开始计数器的值是0，当1和N申请总线时，就会对IO接口0进行查询是否申请了。如果IO接口0没有申请，那么计数器+1，然后开始对接口1进行查询。&lt;/li&gt;
  &lt;li&gt;这种方式的优势：因为计数器是可以设置的，所以优先级是可以设定的。&lt;/li&gt;
  &lt;li&gt;设备地址线宽度与设备数量相关&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-11&quot;&gt;独立请求方式&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/klkucan/ImgLib/blob/master/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E6%80%BB%E7%BA%BF/%E7%8B%AC%E7%AB%8B%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F.png?raw=true&quot; alt=&quot;独立请求方式&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;这个方式在效率上是最高的，因为每个部件都有自己的BR，因此总线控制器在同意后可以很明确的用BG来返回。&lt;/li&gt;
  &lt;li&gt;缺点是线路太多&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-12&quot;&gt;总线通信&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;总线在一段时间内被一对主从设备占用，总线通信的目的是为了解决通信双方协调配合问题。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-13&quot;&gt;总线传输周期&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;申请分配阶段：主模块申请，总线仲裁决定&lt;/li&gt;
  &lt;li&gt;寻址阶段：主模块通过地址找到从模块，并给出命令。&lt;/li&gt;
  &lt;li&gt;传数阶段：主模块和从模块数据交换。&lt;/li&gt;
  &lt;li&gt;结束阶段：主、从模块撤销相关信息。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-14&quot;&gt;总线通信的方式&lt;/h4&gt;
&lt;h5 id=&quot;section-15&quot;&gt;同步通信：&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;由统一定宽定距的时标控制数据传输，主从模块强制同步，在同一个时限内完成规定的操作。&lt;/li&gt;
  &lt;li&gt;对于速度不同的模块要选择速度最慢的模块作为统一的时标，对于高速模块来说没有发挥它的作用。&lt;/li&gt;
  &lt;li&gt;同步通信的使用场景是总线比较短，并且各个模块存取时间比较一致的情况。&lt;/li&gt;
  &lt;li&gt;下面举例说明一下同步式的数据读取（输入）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/klkucan/ImgLib/blob/master/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E6%80%BB%E7%BA%BF/%E5%90%8C%E6%AD%A5%E9%80%9A%E4%BF%A1%E6%95%B0%E6%8D%AE%E8%BE%93%E5%85%A5.png?raw=true&quot; alt=&quot;同步通信输入&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;T1时钟上升沿主设备CPU要给出地址信号&lt;/li&gt;
  &lt;li&gt;T2时钟上升沿要给出读命令信号，告诉从设备CPU要读取数据&lt;/li&gt;
  &lt;li&gt;T3时钟上升沿之前从设备要给出数据信号&lt;/li&gt;
  &lt;li&gt;T4时钟上升沿之前数据信号和读信号（控制信号）  撤销&lt;/li&gt;
  &lt;li&gt;T4结束地址信号撤销&lt;/li&gt;
  &lt;li&gt;NOTE：上图中每一行的空白区域是对应的信号的存在时间&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-16&quot;&gt;异步通信：&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;采用应答方式，没有公共时钟标准。&lt;/li&gt;
  &lt;li&gt;在通信控制过程中分为不互锁、半互锁和全互锁。&lt;/li&gt;
  &lt;li&gt;按照下图所展示的进行说明：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/klkucan/ImgLib/blob/master/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E6%80%BB%E7%BA%BF/%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1.png?raw=true&quot; alt=&quot;异步通信&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;不互锁：指的是主设备发出请求信号后从设备发应答信号，然后主设备和从设备依次退出信号。过程中主设备不管是否接收到了应答信号，经过一定延迟后都会撤销请求信号，而从设备也不管主设备是否接受到了应答信号，经过一段时间后就撤销信号。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;半互锁：主设备发出请求信号，从设备发应答信号。区别在于主设备的请求信号只有在收到应答信号后才撤销，而从设备仍旧经过一段时间后就撤销了信号。造成的问题就是可能从设备一直不回复，那么主设备就一直等待。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;全互锁：本质和TCP三次握手一样。主设备发请求、从设备应答，主设备只有收到应答后才撤销，而从设备只有请求信号撤销后才撤销应答信号。在传输期间发生错误的话，主设备可以要求从设备重新发送或者接受数据。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-17&quot;&gt;半同步通信：&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;同步异步结合，解决两个不同速度的设备交换数据。&lt;/li&gt;
  &lt;li&gt;同步方面：发送方用系统时钟前沿发信号，接收方用系统时钟后沿判断、识别。&lt;/li&gt;
  &lt;li&gt;异步方面：运行不同速度的模块和谐工作，增加一条“等待”响应信号”WAIT”，信号线。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/klkucan/ImgLib/blob/master/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E6%80%BB%E7%BA%BF/%E5%8D%8A%E5%90%8C%E6%AD%A5%E9%80%9A%E4%BF%A1%E6%95%B0%E6%8D%AE%E8%BE%93%E5%85%A5.png?raw=true&quot; alt=&quot;半同步通信&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;从上图可以看出前面在T1和T2都和同步通信是一致的，但是在T3前，如果从设备没有能够准备好数据的传输那么久会发出TW信号。主设备检查到TW存在时就会等待一个时钟周期，然后每过一个时钟周期就检查一下TW是否在低位。知道从设备准备好数据传输了，然后TW变成高电位。然后就继续T3、T4。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-18&quot;&gt;前三种小总结&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;主模块发地址、命令→占用总线&lt;/li&gt;
  &lt;li&gt;从模块准备数据→不占用总线，总线空闲&lt;/li&gt;
  &lt;li&gt;从模块想主模块发数据→占用总线&lt;/li&gt;
  &lt;li&gt;在准备数据时是有总线浪费的，所以有了分离式的通信。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-19&quot;&gt;分离式通信：&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;充分挖掘系统总线每个瞬间的潜力。&lt;/li&gt;
  &lt;li&gt;本质上分离式通信是讲一个原来的总线传输周期分割成多个子周期
    &lt;ul&gt;
      &lt;li&gt;子周期1：主模块申请占用总线，使用完后放弃总线控制权&lt;/li&gt;
      &lt;li&gt;子周期2：从模块申请占用总线，讲各种信息送到总线上&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;特点：
    &lt;ul&gt;
      &lt;li&gt;各模块都有权申请占用总线，所以都是主模块。&lt;/li&gt;
      &lt;li&gt;采用同步方式通信，不等对方回答。&lt;/li&gt;
      &lt;li&gt;各模块准备数据时不占用总线&lt;/li&gt;
      &lt;li&gt;总线被占用时无空闲（这不是废话么）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-20&quot;&gt;延伸阅读&lt;/h3&gt;

&lt;h4 id=&quot;section-21&quot;&gt;总线频率&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;1.主频：主频也叫时钟频率，单位是MHz，用来表示CPU的运算速度。主频由外频和倍频决定，其计算公式
为 主频＝外频 * 倍频。外频就是系统总线的工作频率；而倍频则是指CPU外频与主频相差的倍数。如
Intel Pentium4 3.06GHz处理器的外频为133，倍频23，则主频＝133*23＝3.06Ghz&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;2.外频：外频是CPU的基准频率，单位也是MHz。外频是CPU与主板之间同步运行的速度，而且目前的绝大
部分电脑系统中，外频也是内存与主板之间的同步运行的速度，在这种方式下，可以理解为CPU的外频直接
与内存相连通，实现两者间的同步运行状态。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;3.前端总线：前端总线频率直接影响CPU与内存直接数据的交换速度。由于数据传输最大带宽取决于所有同
时传输的数据的宽度和传输频率，即数据传输量＝（总线频率&lt;em&gt;数据带宽）/8。外频与前端总线频率的区别：
前端总线的速度指的是数据传输的速度，外频是CPU与主板之间同步运行的速度。比如说，100MHz外频特
指数字脉冲信号在每秒钟震荡一千万次：而100MHz前端总线指的是每秒钟CPU可接受的数据传输量是
100MHz&lt;/em&gt;64bit/（8Byte/bit）＝800MB/s。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;4.倍频系数：倍频系数是指CPU主频与外频之间的相对比例关系。在相同的外频下，倍频越高CPU的频率也
越高。但实际上，在相同外频的前提下，倍频高的CPU本身意义并不大。这是因为CPU与系统之间数据传
输速度是有限的，一味追求高倍频而得到高主频的CPU就会出现明显的“瓶颈”效应——CPU从系统得到数据
的极限速度不能满足CPU运算的速度。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;5.内存总线速度：CPU处理的数据来自存储器，而主存储器就是内存。一般放在外存（磁盘或者各种存储介
质）上面的数据都要通过内存，再进入CPU进行处理。所以CPU与内存之间的通道的内存总线速度对整个
系统性能就显得很重要。由于内存和CPU之间的运行速度或多或少会有差异，因此便出现了二级缓存，来协
调两者之间的差异，而内存总线速度就是指CPU与二级高速缓存和内存之间的通信速度。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;6.扩展总线速度：扩展总线指的是安装在计算机系统上的局部总线如VESA或PCI总线，我们打开电脑的时候
会看见一些插槽般的东西，这些就是扩展槽，而扩展总线就是CPU联系这些外部设备的桥梁。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;section-22&quot;&gt;时钟周期&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;时钟周期也称为振荡周期，定义为时钟频率的倒数。时钟周期是计算机中最基本的、最小的时间单位。在一个时钟周期内，CPU仅完成一个最基本的动作。时钟周期是一个时间的量。时钟周期表示了SDRAM所能运行的最高频率。更小的时钟周期就意味着更高的工作频率。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-23&quot;&gt;参考&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;https://blog.csdn.net/commandow/article/details/5844617&lt;/li&gt;
  &lt;li&gt;https://baike.baidu.com/item/%E6%97%B6%E9%92%9F%E5%91%A8%E6%9C%9F&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 20 Sep 2018 20:48:00 +0800</pubDate>
        <link>https://caihua.tech/2018/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-3-%E6%80%BB%E7%BA%BF/</link>
        <guid isPermaLink="true">https://caihua.tech/2018/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-3-%E6%80%BB%E7%BA%BF/</guid>
        
        <category>组成原理</category>
        
        
      </item>
    
      <item>
        <title>计算机组成原理：2、基本组成</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;冯·诺依曼计算机基本概念&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;本文中的内存结构只是课程中用到的一个特定的机器的设计，并非所有的计算机都是这样的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;现在的计算机都是程序存储计算机，也就是冯诺依曼计算机。&lt;/li&gt;
  &lt;li&gt;特点：
    &lt;ul&gt;
      &lt;li&gt;计算机有五大部件组成：输入、输出、控制器（CU）、运算器(ALU)、存储器(主存、辅存)&lt;/li&gt;
      &lt;li&gt;指令和数据以同等地位存于存储器中，按地址寻访。&lt;/li&gt;
      &lt;li&gt;指令和数据按照二进制保存&lt;/li&gt;
      &lt;li&gt;指令由操作码和地址码组成（e.g 0001 00001000，0001代表读取，00001000代表要读取 数据在内存（寄存器）中的位置）。&lt;/li&gt;
      &lt;li&gt;存储程序，存储在存储器中。&lt;/li&gt;
      &lt;li&gt;以运算器为中心。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;现代计算机：
    &lt;ul&gt;
      &lt;li&gt;ALU + CU = CPU&lt;/li&gt;
      &lt;li&gt;CPU + 主存（RAM\ROM\Cache（inter上cache有L1\L2\L3）） = 主机&lt;/li&gt;
      &lt;li&gt;输入 + 输出 + 辅存 = IO设备&lt;/li&gt;
      &lt;li&gt;主机 + IO = 计算机系统硬件&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;CU控制数据的读取+写入，操作的是存储器，还可以控制指令的执行顺序操作的是运算器。&lt;/li&gt;
  &lt;li&gt;如果以运算器为中心进行硬件设计会是的运算器成为系统的瓶颈（overhead）。所以改进成以存储器为中心，这样可以是的IO设备直接和存储器关联。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-1&quot;&gt;计算机解决问题的步骤：&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;建立数学模型&lt;/li&gt;
  &lt;li&gt;确定计算方法&lt;/li&gt;
  &lt;li&gt;编制程序：程序就是运算的全部步骤，指令就是每一个步骤。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/klkucan/ImgLib/blob/master/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90/%E7%A8%8B%E5%BA%8F%E6%B8%85%E5%8D%95.png?raw=true&quot; alt=&quot;程序清单&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;计算机主要组成&lt;/h3&gt;

&lt;h4 id=&quot;section-3&quot;&gt;存储器&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;存储器的组成由以下：
    &lt;ul&gt;
      &lt;li&gt;存储体:  大楼-&amp;gt;若干房间-&amp;gt;如果床位
        &lt;ul&gt;
          &lt;li&gt;存储单元：房间
            &lt;ul&gt;
              &lt;li&gt;存储原件：床位，本质就是0/1了&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;存储单元：存放一串二进制代码&lt;/li&gt;
          &lt;li&gt;存储字：存储单元中二进制代码的组合&lt;/li&gt;
          &lt;li&gt;存储字长：存储单元中二进制代码的位数&lt;/li&gt;
          &lt;li&gt;每一个存储单元都有一个地址，通过地址进行访问。存储单元保存的可以是数据，也可以是指令。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;MAR：存储器地址寄存器，保存存储单元地址或编号。反应存储单元个数。&lt;/li&gt;
      &lt;li&gt;MDR：存储器数据寄存器，要保持到存储体的数据，或者刚刚从存储体取出的数据。反应了存储字长。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;硬件结构&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/klkucan/ImgLib/blob/master/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90/%E5%AD%98%E5%82%A8%E4%BD%93.png?raw=true&quot; alt=&quot;存储体&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-4&quot;&gt;运算器&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;在我理解中运算器是真正进行数据计算的地方，都是采用二级制的加减乘除。具体实现应该是数字电路方面的知识了。&lt;/li&gt;
  &lt;li&gt;对于不同的运算，在指令执行过程中使用到的寄存器数量不同。比如加减法是不需要MQ（乘商寄存器，multiplication &amp;amp; quotient的缩写）的。&lt;/li&gt;
  &lt;li&gt;ALU：运算器核心&lt;/li&gt;
  &lt;li&gt;ACC：累加寄存器&lt;/li&gt;
  &lt;li&gt;X：保存数据的寄存器&lt;/li&gt;
  &lt;li&gt;MQ：乘商寄存器&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/klkucan/ImgLib/blob/master/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90/%E5%8A%A0%E6%B3%95.png?raw=true&quot; alt=&quot;加&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/klkucan/ImgLib/blob/master/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90/%E5%87%8F%E6%B3%95.png?raw=true&quot; alt=&quot;减&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/klkucan/ImgLib/blob/master/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90/%E4%B9%98%E6%B3%95.png?raw=true&quot; alt=&quot;乘&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/klkucan/ImgLib/blob/master/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90/%E9%99%A4%E6%B3%95.png?raw=true&quot; alt=&quot;除&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/klkucan/ImgLib/blob/master/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90/%E8%BF%90%E7%AE%97%E5%99%A8%E6%93%8D%E4%BD%9C.png?raw=true&quot; alt=&quot;运算器操作&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-5&quot;&gt;控制器&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;功能：
    &lt;ul&gt;
      &lt;li&gt;解释指令&lt;/li&gt;
      &lt;li&gt;保证指令的按序执行&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;解释指令过程，也是一个指令的执行过程：
    &lt;ul&gt;
      &lt;li&gt;取指令：从内存单元中取指令。→ PC&lt;/li&gt;
      &lt;li&gt;分析指令：把操作码部分送到控制单元进行分析 → IR&lt;/li&gt;
      &lt;li&gt;执行指令：控制单元控制相应的执行部件来执行操作 → CU&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;硬件结构
    &lt;ul&gt;
      &lt;li&gt;PC：程序计数器：寄存器，存放当中要执行的指令的地址，具有计数功能（PC）+ 1-&amp;gt; PC，（类似指针操作）&lt;/li&gt;
      &lt;li&gt;IR：指令寄存器，存放当前要执行的指令。控制单元从IR中取出操作码进行分析。&lt;/li&gt;
      &lt;li&gt;CU：发出控制信号&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/klkucan/ImgLib/blob/master/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90/%E6%8E%A7%E5%88%B6%E5%99%A8.png?raw=true&quot; alt=&quot;控制器&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;所以控制器的执行顺序是：CU（不确定，因为没有讲清楚）从PC取当前要执行指令的地址，根据地址找到指令后存到IR，CU分析指令后得到操作码，然后执行。PC++后就是到了下一条指令的地址，然后继续之前的操作。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-6&quot;&gt;存储器、运算器和控制器是如何协作的&lt;/h3&gt;

&lt;h4 id=&quot;section-7&quot;&gt;取数例子&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/klkucan/ImgLib/blob/master/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90/%E5%8F%96%E6%95%B0.png?raw=true&quot; alt=&quot;取数&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;PC中保存着指令的地址，将地址放入MAR。&lt;/li&gt;
  &lt;li&gt;用MAR中的地址从存储体中得到指令（操作码+操作数据地址码）&lt;/li&gt;
  &lt;li&gt;将得到的指令放到MDR&lt;/li&gt;
  &lt;li&gt;将指令从MDR放到IR
    &lt;blockquote&gt;
      &lt;p&gt;——————–取指令结束——————–&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;IR将操作码送到CU，CU译码，开始操作元器件。&lt;/li&gt;
  &lt;li&gt;IR中地址码送到MAR，这个地址码就是我们真正要操作的数据。&lt;/li&gt;
  &lt;li&gt;MAR从存储体取到数据&lt;/li&gt;
  &lt;li&gt;数据保存到MDR&lt;/li&gt;
  &lt;li&gt;MDR讲输入送到ACC
    &lt;blockquote&gt;
      &lt;p&gt;——————–整个操作结束——————&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;NOTE: 在这个图中没有体现的是如何将最初的取值指令地址放到PC中&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-8&quot;&gt;存数例子&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/klkucan/ImgLib/blob/master/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90/%E5%AD%98%E6%95%B0.png?raw=true&quot; alt=&quot;存数&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;PC中保存着指令的地址，将地址放入MAR。&lt;/li&gt;
  &lt;li&gt;用MAR中的地址从存储体中得到指令（操作码+操作数据地址码）&lt;/li&gt;
  &lt;li&gt;将得到的指令放到MDR&lt;/li&gt;
  &lt;li&gt;将指令从MDR放到IR
    &lt;blockquote&gt;
      &lt;p&gt;——————–取指令结束——————–&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;IR将操作码送到CU，CU译码，开始操作元器件。&lt;/li&gt;
  &lt;li&gt;IR中地址码送到MAR，这个地址码就是我们真正要操作的数据。&lt;/li&gt;
  &lt;li&gt;MAR将地址告诉存储体，这个数据要存起来&lt;/li&gt;
  &lt;li&gt;ACC中的数据保存到MDR&lt;/li&gt;
  &lt;li&gt;MDR将数据放到存储体
    &lt;blockquote&gt;
      &lt;p&gt;——————–整个操作结束——————&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;section-9&quot;&gt;计算机执行程序的过程&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/klkucan/ImgLib/blob/master/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90/%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C.png?raw=true&quot; alt=&quot;程序执行&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;这里就回答了之前的问题，在程序被输入到计算机的内存后，第一个指令的地址会被放入到PC中。在指令执行的过程中，PC+1操作使得能够不断的执行新的指令。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-10&quot;&gt;延展阅读&lt;/h3&gt;

&lt;h4 id=&quot;section-11&quot;&gt;主存、副存、内存、外存&lt;/h4&gt;
&lt;blockquote&gt;
  &lt;p&gt;存储器是计算机的重要组成部分，用于存储程序与数据，可分为：计算机内部的存储器（内存储器，简称内存）、计算机外部的存储器（外存储器，简称外存）&lt;/p&gt;

  &lt;p&gt;一般来说，主存指的是内存；但是在一些专业性较强的场合，主存与内存还是有一定区别的。内存储存器还有其他形式。而外存指的是辅存，比如硬盘、U盘、光盘及软盘等。&lt;/p&gt;

  &lt;p&gt;cpu中的存储器和主存是两个概念。处理器需要自己的内存储器，它们以寄存器的形式存在。&lt;/p&gt;

  &lt;p&gt;内存：&lt;/p&gt;

  &lt;p&gt;内存又称主存，是CPU能直接寻址的存储空间，它的特点是存取速率快。内存是电脑中主要部件，它是相对于外存来说。&lt;/p&gt;

  &lt;p&gt;内存一般采用半导体存储单元，包括随机存储器（RAM）、只读存储器（ROM）和高级缓存（Cache）。&lt;/p&gt;

  &lt;p&gt;RAM（Random Access Memory）：&lt;/p&gt;

  &lt;p&gt;高速存取，支持读写数据，读写时间相等，且与地址无关，但是断电后其中的数据会丢失。&lt;/p&gt;

  &lt;p&gt;ROM（Read Only Memory）：&lt;/p&gt;

  &lt;p&gt;断电后信息不丢失，如计算机启动用的BIOS芯片。存取速度很低，（较RAM而言）且不能改写。由于不能改写信息，不能升级，现已很少使用。&lt;/p&gt;

  &lt;p&gt;Cache：&lt;/p&gt;

  &lt;p&gt;介于CPU与内存之间，常用有一级缓存（L1）、二级缓存（L2）、三级缓存（L3）（一般存在于Intel系列）。它的读写速度比内存还快，当CPU在内存中读取或写入数据时，数据会被保存在高级缓冲存储器中，当下次访问该数据时，CPU直接读取高级缓冲存储器，而不是更慢的内存。&lt;/p&gt;

  &lt;p&gt;外存：&lt;/p&gt;

  &lt;p&gt;外储存器是指除计算机内存及CPU缓存以外的储存器，此类储存器一般断电后仍然能保存数据。外存需要通过I/O系统与之交换数据，又称为辅助存储器。常见的外储存器有硬盘、软盘、光盘、U盘等&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-12&quot;&gt;参考&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;https://blog.csdn.net/lewky_liu/article/details/78147842&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 19 Sep 2018 20:47:00 +0800</pubDate>
        <link>https://caihua.tech/2018/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-2-%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90/</link>
        <guid isPermaLink="true">https://caihua.tech/2018/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-2-%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90/</guid>
        
        <category>组成原理</category>
        
        
      </item>
    
      <item>
        <title>计算机组成原理：1、组成原理到底研究的什么</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;这是对哈尔滨工业大学网络课程《计算机组成原理》的笔记&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;计算机系统层次从程序的角度看分为下面5层：
    &lt;ul&gt;
      &lt;li&gt;高级语言层：Java、C、C++、C#等，需要编程成机器语言&lt;/li&gt;
      &lt;li&gt;汇编层：也需要编译成机器语言，符号语言和机器语言的指令基本是一一对应的。&lt;/li&gt;
      &lt;li&gt;操作系统：提供机器语言与编程语言的&lt;/li&gt;
      &lt;li&gt;机器语言：就是计算机所提供的语言了，根据地址从存储器读取-&amp;gt;送往控制器译码-&amp;gt;计算器。操作有顺序要求，并非全部是并发。&lt;/li&gt;
      &lt;li&gt;微指令系统：机器指令的细化，在某个时间点上可以执行的操作放到一个微指令当中，执行上有先后顺序的放到不同的微指令中。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;从下往上看这个层级：
    &lt;ul&gt;
      &lt;li&gt;多个微指令构成一个微程序，&lt;strong&gt;微指令是由硬件直接执行的。&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;一个微程序对应一个机器指令，用微指令解释机器指令。&lt;/li&gt;
      &lt;li&gt;用机器指令解释操作系统&lt;/li&gt;
      &lt;li&gt;————软硬件分割线—————&lt;/li&gt;
      &lt;li&gt;用汇编程序翻译成机器语言程序&lt;/li&gt;
      &lt;li&gt;用编译程序翻译成汇编语言程序&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;实际上OS除了管理硬件、软件外。从编程的角度看OS提供了编程语言与机器语言的接口。&lt;/li&gt;
  &lt;li&gt;对于在机器上编写程序的人来说，计算机组成在设计上就要提供一套微指令集给程序员，并且要定义哪些指令可以操作什么类型的数据（数据表示）。实际上在机器指令集设计的时候对于不同数据类型的相同操作可能会有不同的指令（e.g 整数和浮点数的加法运算）&lt;/li&gt;
  &lt;li&gt;计算机组成原理所研究是就是硬件部分的设计，需要实现计算机体系结构所体现的属性。比如：当程序员询问有没有乘法指令？这个指令能对什么类型的数据操作？长度限制是多少？那种做计算机组成设计的人就要负责具体指令的实现。&lt;strong&gt;（从纯软件编程的角度说，计算机组成可以理解为一个lib，在设计的时候要确定有什么接口，接口的实现要怎么做，里面有哪些定义的数据，这些数据哪些接口理由操作、怎么操作等问题）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 19 Sep 2018 20:46:00 +0800</pubDate>
        <link>https://caihua.tech/2018/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-1-%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%88%B0%E5%BA%95%E7%A0%94%E7%A9%B6%E7%9A%84%E4%BB%80%E4%B9%88/</link>
        <guid isPermaLink="true">https://caihua.tech/2018/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-1-%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%88%B0%E5%BA%95%E7%A0%94%E7%A9%B6%E7%9A%84%E4%BB%80%E4%B9%88/</guid>
        
        <category>组成原理</category>
        
        
      </item>
    
      <item>
        <title>Unity人工智能游戏开发笔记</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;前言&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;本着学习一下游戏AI开发的目的看了书，总体来说本书涉及的技术比较浅显，但是胜在面面俱到，很适合没有做过AI开发的同学。&lt;/li&gt;
  &lt;li&gt;但是本书关于模糊逻辑部分非常坑，令人发指。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-1&quot;&gt;概要内容&lt;/h3&gt;

&lt;h5 id=&quot;fsm&quot;&gt;FSM&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;有限状态机算是最简单的一种AI的实现，它的核心是状态，逻辑运算的结果表现为状态的变化。主要包含三个要点：
    &lt;ul&gt;
      &lt;li&gt;转换：状态间的关系&lt;/li&gt;
      &lt;li&gt;规则：触发某一状态转换&lt;/li&gt;
      &lt;li&gt;事件：触发规则检查&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;关于FSM我之前有写过，包括网上也有很多教程。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-2&quot;&gt;感知系统&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;重要概念：
    &lt;ul&gt;
      &lt;li&gt;Entity：包含玩家主体对象和环境对象&lt;/li&gt;
      &lt;li&gt;Aspect：标记卡。这个用于让AI判断检测到的物体是不是搜索的目标。&lt;/li&gt;
      &lt;li&gt;Sense&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Sense：字面翻译过来就是个感知，它包含了视觉、听觉、触觉、嗅觉和超自然的感知（忽悠人的^_^）。&lt;/li&gt;
  &lt;li&gt;实现：以下罗列出unity引擎中的实现
    &lt;ul&gt;
      &lt;li&gt;视觉：通常用于表达AI是否看到，unity用可以使用多条射线来制作。在视觉中也有FOV的概念，这个在制作射线的时候可以作为因素考虑进去。&lt;/li&gt;
      &lt;li&gt;听觉、触觉、嗅觉：球体实现。触觉用碰撞体其实是比较好理解，听觉和嗅觉有点抽象，但是本质还是不同的碰撞体检测不同的layer。&lt;/li&gt;
      &lt;li&gt;超自然的感知：直接通过获取系统数据来实现感知，作弊的行为。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-3&quot;&gt;寻路&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;寻路是游戏中很重要的AI行为，书中提到了A star，也用到了unity的NavMesh组件，在这里就不具体说了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-4&quot;&gt;集群行为&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;三个基本的概念：
    &lt;ul&gt;
      &lt;li&gt;分离性：个体之间保持固定距离&lt;/li&gt;
      &lt;li&gt;排列的整齐性：整体间相同的方向和速度&lt;/li&gt;
      &lt;li&gt;内聚性：个体与集群中心位置进保持最小距离&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;书中实现了多个不同的算法，也利用unity引擎的一些内置功能俩实现。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-5&quot;&gt;行为树&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;行为树体现为任务节点。在行为树中有很多功能不同的节点，有完成基础任务的叶子节点，也有用于逻辑的复合节点和修饰节点。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;节点的状态一般分为三种：成功、失败、运行状态（等待）&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-6&quot;&gt;复合节点&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;序列（Sequence）：逐个执行node，当出现失败时返回失败；否则一直执行完。node之间是and关系。&lt;/li&gt;
  &lt;li&gt;选择器（Selector）：只要一个node成功就返回成功，如果运行完了都没有成功的则为false。node之间是or关系。&lt;/li&gt;
  &lt;li&gt;注意，节点之间的and、or的关系是可以自己控制的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-7&quot;&gt;修饰节点&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;定义：
    &lt;ul&gt;
      &lt;li&gt;修饰节点只包含一个子节点，接受子节点返回的状态。&lt;/li&gt;
      &lt;li&gt;可以自由组合使用&lt;/li&gt;
      &lt;li&gt;根据自身的参数估算子节点结果，可以根据设置重新得到一个子节点结果（反相器）或者设置子节点频率（重复器、限制器）。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;反相器：NOT标识符，接受与其子节点返回状态相反的结果。&lt;/li&gt;
  &lt;li&gt;重复器：重复估算子节点特定的次数，直至满足修饰节点定义的条件。&lt;/li&gt;
  &lt;li&gt;限制器：限制子节点估算次数。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-8&quot;&gt;模糊逻辑&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;在以往的二元逻辑中，基本只有true和false。但是在模糊逻辑中，数值是&lt;code class=&quot;highlighter-rouge&quot;&gt;[0,1]&lt;/code&gt;，在这个区间内的值代表着一种模糊的状态。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;三个步骤
    &lt;ul&gt;
      &lt;li&gt;模糊化：根据隶属度函数从具体的输入得到对模糊集隶属度的过程。&lt;/li&gt;
      &lt;li&gt;推理方法：从模糊规则和输入对相关模糊集的隶属度得到模糊结论的方法。&lt;/li&gt;
      &lt;li&gt;去模糊化：将模糊结论转化为具体的、精确的输出的过程。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;这部分的内容请移步&lt;a href=&quot;https://blog.csdn.net/Jurbo/article/details/75949360&quot;&gt;游戏开发中的人工智能（十）：模糊逻辑&lt;/a&gt; 。 本书模糊逻辑部分根本就是不完整的，内容质量非常的差。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 29 Aug 2018 21:07:00 +0800</pubDate>
        <link>https://caihua.tech/2018/08/29/Unity%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</link>
        <guid isPermaLink="true">https://caihua.tech/2018/08/29/Unity%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</guid>
        
        <category>Unity3D</category>
        
        
      </item>
    
      <item>
        <title>开发ECS style项目的思考</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;概述&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;这篇文章是近期在学习Entitas时对于ECS的进一步思考&lt;/li&gt;
  &lt;li&gt;其中会包含在使用ECS时需要注意的一些重要原则&lt;/li&gt;
  &lt;li&gt;这些原则在使用Entitas时如何实现&lt;/li&gt;
  &lt;li&gt;这篇文章不会讲Entitas的具体代码和功能，这需要每个使用者自己去看源码和demo。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ecs&quot;&gt;ECS的使用原则&lt;/h2&gt;

&lt;h4 id=&quot;section-1&quot;&gt;数据驱动一切&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;ECS的目的就是将数据与行为进行解耦，而ECS中行为（System）的执行是依赖于数据（Component）的。&lt;/li&gt;
  &lt;li&gt;这个依赖应该分为两个方向来看，第一是变化的数据，它造成了事件的发生；第二是非变化的数据，它提供了Update中逻辑执行的数据。&lt;/li&gt;
  &lt;li&gt;外部的输入（Input、Net、Bluetooth）改变的是数据，这些数据经过System的处理（非必须）后可能被用来驱动View层，或者用来改变其它的数据，从而产生新一轮的System处理数据。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;ecs-1&quot;&gt;ECS只包含数据与逻辑&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;ECS是一种开发模式、是一种思维方式，它的实现是不依赖与具体语言、引擎或特定环境的。ECS系统中应该只包含entity、component、system，以及其它辅助的类。&lt;/li&gt;
  &lt;li&gt;这样的认知就要求我们在使用时要将ECS的数据、逻辑与具体实现分离开，请细细品味 &lt;code class=&quot;highlighter-rouge&quot;&gt;I am abstracting the logic from the implentation, the what from the how. &lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;ecs-2&quot;&gt;ECS与外部实现解耦&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;ECS与外部实现交互时遵从面向接口编程的原则：从函数调用层面讲不要在ECS系统中直接调用外部对象的函数，因为这必然要求component持有一个具体的对象，导致ECS引用了外部的类定义。此时ECS应该是持有一个接口的实现对象。&lt;/li&gt;
  &lt;li&gt;从数据层面讲，ECS中的类型不依赖于任何第三方的定义。比如表示位置的Vector3，它应该是ECS内部定义的，而不应该依赖于外部定义的类型（比如Unity中的Vector3）。&lt;/li&gt;
  &lt;li&gt;尽量避免component持有对象的引用，哪怕是基于接口的。使用事件机制可以做到更好的解耦。&lt;/li&gt;
  &lt;li&gt;在事件机制的基础上，应该尽量做到上层功能依赖底层功能，反之则不行。也就是说外部实现可以使用ECS的方法、修改component的数据。但是ECS内部可以做到不知道有外部对象这回事，因为在完全使用事件系统的情况下，ECS调用外部函数都可以通过触发事件的方式来调用。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;oop&quot;&gt;忘却OOP&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;这点对于大家来说比较难，MonoBehaviour自身也是OOP的。但是从和大家的讨论结果来看，忘却继承、多态有助于更好的写出ECS style的代码。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;entitas&quot;&gt;如何使用Entitas&lt;/h2&gt;

&lt;h3 id=&quot;section-2&quot;&gt;它山之石可以攻玉&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;下图是一位国外开发者对于使用Entitas，或者说是使用ECS的经验总结。里面用了非常多的代码例子来讲述如何解耦ECS与具体的实现，建议所有使用Entitas的人都看一下，链接在最后。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://camo.githubusercontent.com/c7565ff2582568e06e529dd81eb0bafbc0ac4224/68747470733a2f2f692e696d6775722e636f6d2f5244576b6150582e706e67&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在这幅图中ECS通过interface与View和Service交互，具体的实现可以是unity或者是其它的引擎。&lt;/li&gt;
  &lt;li&gt;里面的箭头也很好定义了一个workflow，service层改变了ECS中component的数据，引发system的处理，最终引发VIEW层的变化。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;entitassystem&quot;&gt;Entitas中的System&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;说到System就要提一下Entitas中两种处理数据变化的方式，一种是响应式的，一种是轮询式的。&lt;/li&gt;
  &lt;li&gt;响应式处理需要使用继承自ReactiveSystem的system，虽然在底层它还是会去轮询，但是在使用层面上它只是处理发生了变化的component。&lt;/li&gt;
  &lt;li&gt;而轮询式的则要求system继承自IExecuteSystem，它会在每帧去调用一次Execute方法。&lt;/li&gt;
  &lt;li&gt;对于不同功能的component应该合理的去选择它对应的system，从之前讨论的结果看，绝大多数component都应该是对应的ReactiveSystem。因为响应式会比较高效，只有当系统中entity上的component发生了Add/Remove操作，或者component中的数据发生了变化后才会执行相关的操作。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;ecs-3&quot;&gt;一些使用ECS实现的功能&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;下面会对一些常见的功能如何使用ECS实现来进行讨论，目前为止这些实现只存在于讨论的层面，当然这些实现是基于Entitas的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;fsm&quot;&gt;FSM&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;FSM的核心是状态（state）和状态变化所引发的函数调用。&lt;/li&gt;
  &lt;li&gt;以点击跳跃按钮触发玩家播放跳跃动画为例：
    &lt;ul&gt;
      &lt;li&gt;ECS中添加一个PlayerAnimatorStateEntity，添加PlayerAnimatorStateComponent，里面的变量是一个string类型的state，利用它的改变来驱动玩家身上动画状态机的切换。&lt;/li&gt;
      &lt;li&gt;在PlayerGameObject创建时需要监听state改变的事件。&lt;/li&gt;
      &lt;li&gt;View层识别到一个按钮的点击（Unity自己的事件机制），ECS中产生一个PlayerJumpEntity，它上面add了一个PlayerJumpComponent。组件中无需任何数据，因为当ECS中出现这个组件时就已经代表jump按钮被按下了。&lt;/li&gt;
      &lt;li&gt;在这里需要注意，如果点击按钮只是改变动画，那么VIEW里面按钮点击可以直接改PlayerAnimatorStateComponent中state变量的值。&lt;/li&gt;
      &lt;li&gt;PlayerJumpSystem是一个ReactiveSystem，它在执行Execute函数时改变state的值引发事件，从而使得PlayerGameObject可以改变animator的状态。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/klkucan/XMind/master/ECS%E5%AE%9E%E7%8E%B0%E5%8A%9F%E8%83%BD.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;伤害技能系统&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;未完待续&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-4&quot;&gt;引用&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/sschmid/Entitas-CSharp/wiki/How-I-build-games-with-Entitas-%28FNGGames%29&quot;&gt;How I build games with Entitas (FNGGames)&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 20 Jul 2018 15:52:19 +0800</pubDate>
        <link>https://caihua.tech/2018/07/20/%E5%BC%80%E5%8F%91ECS-style%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%80%9D%E8%80%83/</link>
        <guid isPermaLink="true">https://caihua.tech/2018/07/20/%E5%BC%80%E5%8F%91ECS-style%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%80%9D%E8%80%83/</guid>
        
        <category>ECS</category>
        
        
      </item>
    
  </channel>
</rss>
