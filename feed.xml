<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>蔡华的博客</title>
    <description>Be publicly useful and privately happy.</description>
    <link>https://caihua.tech/</link>
    <atom:link href="https://caihua.tech/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sun, 03 Dec 2017 23:19:33 +0800</pubDate>
    <lastBuildDate>Sun, 03 Dec 2017 23:19:33 +0800</lastBuildDate>
    <generator>Jekyll v3.2.1</generator>
    
      <item>
        <title>每天一点UWA：第十八周</title>
        <description>&lt;h2 id=&quot;assetbundle&quot;&gt;AssetBundle&lt;/h2&gt;
&lt;h4 id=&quot;assetbundleshaderalways-includeshadershaderbundleshadershaderbundleunity534f1&quot;&gt;最近的项目使用了AssetBundle的资源管理方案，对于Shader的部分全部放到了Always include里面（这里不仅是系统内置的Shader，还包括自定义的Shader），然后打Bundle资源的目录里是不包含任何Shader的。但是现在发现，Shader还是被作为依赖关系打进了最终的Bundle里，而且造成了冗余，问问大家有没有遇到这个情况呢？我的Unity版本是5.3.4f1。&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;首先，只要资源在工程里并且需要用到它，就会被打包进AssetBundle。&lt;/li&gt;
  &lt;li&gt;然后Always include里built-in Shader不会被打包进AssetBundle，这是一个特例。这个特例仅限于没有放到工程里的部分，有些项目会自己下载built-in Shader放到工程里，这样的Shader和自己写的没有区别，也会被打包。&lt;/li&gt;
  &lt;li&gt;最后，你遇到的问题是正常现象，需要你们通过资源管理的策略避免掉。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;shaderalways-includebundle-shader-shader-feature-enableclipshaderbundleshader-feature-shader-variant&quot;&gt;自定义Shader放入Always include里面，造成Bundle 资源冗余。项目中的某一个自定义的Shader 使用了Shader feature ENABLE_CLIP，Shader被打进最终的Bundle包的时候，这个Shader feature 不起作用了，是因为这个Shader Variant没有被打入最终包吗，官方文档里的说明是：&lt;/h4&gt;
&lt;blockquote&gt;
  &lt;p&gt;the only difference is that unused variants of shader_feature shaders will not be included into game build. So shader_feature makes most sense for keywords that will be set on the materials, while multi_compile for keywords that will be set from code globally.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;shader-featureshader-variant-bundle&quot;&gt;但是我确实有个材质是使用了这个Shader Feature的，为什么这个Shader Variant 没有进入最终的Bundle包呢？&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;据了解，Unity官方有在英文论坛里提到Asset Bundle team正在解决这个问题。如果不将Shader对应的Material与Shader一同打包，当前另外的解决方案包括：
    &lt;ul&gt;
      &lt;li&gt;使用dummy materials / ShaderVariantCollection 与shader打在同一ab内。&lt;/li&gt;
      &lt;li&gt;使用multi_compile替换shader_feature。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;fbxfbxmeshuvreadwrite-able&quot;&gt;我把FBX和粒子系统分开打包了。加载的时候先加载FBX文件，然后再加载粒子系统，结果那些粒子系统是Mesh模式的时候，它们的UV会消失。怎么办呢？开了Read/Write able就不会消失。不分开打包也不会消失，这种情况如何破？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;建议考虑在 FBX 的 AssetBundle 里再放一个带粒子系统，并且引用这个 Mesh 的 Prefab（但不去加载，也不去使用它），只是为了让 UV 可以被正确获得。 理论上这样做的话，基本不需要修改原来的加载方式，也不用开Read/Write。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;gameplay&quot;&gt;Gameplay&lt;/h2&gt;
&lt;h4 id=&quot;shadershadercullcull-off&quot;&gt;我写了一个顶点动画的Shader，对物体顶点位置进行了修改，使其能够跟随相机移动，并总是出现在相机前面。当游戏运行后，开始时物体能够正常显示。相机在场景中移动一段距离后，物体便不再显示，但相机换一下朝向，物体又能显示。目前排除了面剔除的原因，在Shader中已经关闭了Cull（Cull Off），请问还可能是什么其他原因呢？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;消失的原因应当是Unity的Frustum Culling引起。因为顶点动画是在shader中修改的顶点位置，而Frustum Culling是根据顶点修改之前的Mesh的bounds进行的，因此随着相机移动，Mesh实际已经出了Frustum的范围。最简单的解决方法是直接将Mesh的bounds设置足够大，让Unity始终不对其进行Culling：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mesh.bounds = new UnityEngine.Bounds(transform.position, new Vector3(float.MaxValue, float.MaxValue,
float.MaxValue));
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;systeminfographicsdevicenamegpuarmmalit880-mp2t880-mp12t880mp&quot;&gt;使用SystemInfo.graphicsDeviceName获取的GPU信息不太详细。比如ARM系列的Mali，T880 MP2与T880 MP12相差甚远，但是只能获取到T880，无法获取MP的信息。各位是否有办法？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;对于获取GPU名称信息，在Android的Java层中可以利用API：GLES20.glGetString(GLES20.GLRENDERER)获取显示设备名。可以尝试在Unity中利用AndroidJavaClass(https://docs.unity3d.com/ScriptReference/AndroidJavaClass.html)来调用该API，尝试获取更详细的型号。&lt;/li&gt;
  &lt;li&gt;如果获取GPU名称的目的是判断GPU性能，可以看下SystemInfo中其他graphicsDevice相关的GPU性能信息是否够用。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;物理&lt;/h2&gt;
&lt;h4 id=&quot;colliderrigidbodyoncollisionenteroncollsionenter&quot;&gt;两个挂了Collider的物体，一个物体挂了Rigidbody，去碰撞另一物体，为什么每次OnCollisionEnter这个函数在实际还没有碰撞的时候就调用了呢？如下图，这时OnCollsionEnter已经被调用，但从图上可以看到两物体实际还没有接触，这个函数调用之后才会真正碰撞在一起。&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;物理系统在FixedUpdate中触发，包括OnCollisionEnter。而FixedUpdate早于Frame Rendering，因此碰撞实际已经发生，只是画面还没更新。其实在运行时这点时间差几乎应该可以忽略。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;性能综合&lt;/h2&gt;
&lt;h4 id=&quot;unityocclusion-cullingunityocclusion-cullingdrawcalltriangleocclusion-cullingnavmeshdata&quot;&gt;想对场景中的静态物件做一个遮挡剔除，不知道Unity自带的Occlusion Culling对性能优化的提升有多少呢？我们用Unity官方例子测试，启用Occlusion Culling后发现DrawCall、Triangle几乎没有变化。另外也想获知，Occlusion Culling的数据能否像NavMeshData那样可以动态加载呢？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Occlusion Culling在使用后具体能提升多少，这个其实是没有明确数值的，甚至可能不升反降！这个只能题主在自己的项目中进行尝试。&lt;/li&gt;
  &lt;li&gt;一般来说，Occlusion Culling功能特别适合第一人称或第三人称跟随的平视角相机（比如传统意义上的MMO等类似游戏），且适用于在场景中存在大量的遮挡情况。因此，在城市街道漫游、峡谷漫游等特定场景中，比较推荐开启Occlusion Culling功能。&lt;/li&gt;
  &lt;li&gt;但是Occlusion Culling功能本身存在一定的性能开销，因为需要每帧均遍历烘焙的Cell来明确哪些物体需要或不需要渲染，所以场景中Cell越细，那么其查询开销也就越大。因此，如果场景中本身没有大量的遮挡关系，那么开启Occlusion Culling功能后，其节省下来的渲染耗时可能抵不上其Cell查询耗时来的大，这样就得不偿失了。&lt;/li&gt;
  &lt;li&gt;最后，Occlusion Culling的Data目前并不能动态加载，只能随场景来进行加载。因此，可以尝试创造一个拥有Occlusion Culling Data的“空场景”，然后通过LoadLevelAdditive方式来进行加载，从而来达到“动态”加载的效果。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;profilergetmonoheapsizeuiui68mbprofiler&quot;&gt;通过Profiler.GetMonoHeapSize()获取到的堆内存，在操作UI的时候，打开某个节点比较多的UI界面，根据上面接口取到的堆内存会突然涨6~8MB，但是Profiler取不到这个数据，该怎么办呢？我不是固定打开某个界面，而是随机出现在某个界面上，这样的问题该如何入手呢？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Mono总体堆内存一次性涨6-8MB是比较正常的。Mono内存并不是随用随分配的，而是当其发现不够用时，一次性从系统中获取一段连续的内存。在游戏运行一段时间后，这个值一般是8MB。所以，题主遇到的情况很有可能是在连续操作UI界面时，Mono发现堆内存不够用了，于是就有了题主观察到的内存分配。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;渲染&lt;/h2&gt;
&lt;h4 id=&quot;drawcallgpu20msxcode-profilercpu78ms&quot;&gt;下图这一项是指渲染透明物体的渲染消耗么，主要是提交DrawCall是么，现在游戏的GPU消耗在20ms以内Xcode Profiler结果。但是有些粒子系统比较耗CPU，就是这个涨得比较厉害，峰值有7~8ms，请问有没有什么优化建议?&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2FTechSharing_71%2F1.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;首先，需要说明的是，Draw Call是CPU端的耗时开销，XCode上GPU上的开销统计与其关系不大。&lt;/li&gt;
  &lt;li&gt;其次，图中红框所示确实表示的是半透明物体渲染在CPU端的耗时，其不仅与Draw Call数量相关，也和渲染State的切换相关（从图中可以看出，项目使用的是Unity 4.x版本，对应的需要关注Shader.SetPass的开销）。&lt;/li&gt;
  &lt;li&gt;再次，粒子系统的耗时开销很高，如果还是持续在7~8ms左右，那么研发团队关注较高耗时处的游戏场景，并控制粒子系统的使用数量，粒子系统的优化并没有“神奇”的方案，目前研发团队需尽可能控制粒子系统的使用数量。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 03 Dec 2017 22:59:12 +0800</pubDate>
        <link>https://caihua.tech/2017/12/03/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E5%8D%81%E5%85%AB%E5%91%A8/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/12/03/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E5%8D%81%E5%85%AB%E5%91%A8/</guid>
        
        <category>UWA</category>
        
        
      </item>
    
      <item>
        <title>每天一点UWA：第十七周</title>
        <description>&lt;h2 id=&quot;assetbundle&quot;&gt;AssetBundle&lt;/h2&gt;
&lt;h4 id=&quot;texturematerialspritetexture&quot;&gt;当一个Texture被一个material和sprite都引用的时候，将三者分别打包，出现texture内存重复问题。&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.uwa4d.com/archives/TechSharing_66.html&quot;&gt;原文&lt;/a&gt;较长，总结一下就是：如果一个贴图一方面被当成Sprite使用，另一方面被当成Texture使用(譬如RawImage或者Material)，就会断开引用产生多份。目前解决办法是保证用Sprite的Prefab及Material打包在一个AssetBundle。&lt;/li&gt;
  &lt;li&gt;这是一个重要的问题，而且这个问题也是看unity版本的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;assetbundleunloadtrueanimationclip--animationclipprofiler&quot;&gt;使用AssetBundle.Unload(true)释放AnimationClip , 但发现AnimationClip在Profiler看到还存在，请问要怎样才释放干净呢？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;如果这个AnimaitonClip是从AssetBundle中加载过来的，那么当这个AssetBundle调用unload(true)时，该AnimationClip理论上是会被强行卸载的。如果Profiler中查看还有，那么只有两种情况：
    &lt;ul&gt;
      &lt;li&gt;仍然存在的AnimationClip是从其他地方加载来的，而不是来自于该卸载的AssetBundle；&lt;/li&gt;
      &lt;li&gt;Unity引擎的Bug，这种概率不是没有，但很小。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;assetbundlenameassetbundleunityassetbundlenamegetallassetnamesloadallassets&quot;&gt;在打包的时候，有一部分资源是没有设置AssetBundleName的，打包的时候会和依赖它们的资源打到同一个AssetBundle包里（Unity自动完成）。在资源加载的时候，无法主动获取到这些没有设置AssetBundleName的资源。GetAllAssetNames、LoadAllAssets这些接口的返回值中都没有这部分资源。&lt;/h4&gt;
&lt;blockquote&gt;
  &lt;p&gt;请问，在你们看来，这种情况是Unity的设计还是Bug？如果是如此设计的话，有什么特别的意义吗？ 提供一个简单的情景，如下：
１）有A、B两个Prefab，其中A上挂个脚本引用了B
２）打包的时候，设置A的AssetBundleName＝”prefab.unity3d”，B的AssetBundleName=None
３）打包，只产生prefab.unity3d这一个AB包，其中包含了A、B两个资源
４）加载代码使用AssetBundle.LoadAllAssets()，返回的数组里只有一个资源（A）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;我们刚刚在Unity 5.5.2版本上进行了一个测试，得到与题主一样的结论。
我们更加倾向于它是一种设计，而非Bug。&lt;/li&gt;
  &lt;li&gt;因为Prefab B是作为一种参数被引用在A的脚本中，所以在AssetBundle中，它将以GameObject B的形式存在，但是不会存在于AssetBundle的映射表中。&lt;/li&gt;
  &lt;li&gt;而对于题主的这种打包方式而言，AssetBundle的映射表中只会有一个，就是Prefab A。而AssetBundle.LoadAllAssets虽然会把GameObject A、B及其关联的资源全部加载，但其返回的Object[]内容应该就只有一个，也就是Prefab A。&lt;/li&gt;
  &lt;li&gt;所以，UWA推测，AssetBundle中在打包时是自己维护了一个map的，只有明确被设置ABName的资源才会被放入map中，也只有map中的资源才可以通过特定名称进行Load，而其关联的资源则会被打包到AssetBundle中的其他container中，是无法通过LoadAsset或LoadAllAssets API来获取到的。&lt;/li&gt;
  &lt;li&gt;PS：==这是一个需要注意的问题==&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;assetbundlebitmap-aassetbundlealtas-bb&quot;&gt;AssetBundle包字体bitmap A的使用到AssetBundle包Altas B时B冗余&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;出现冗余是因为vip和betaCommon两个Prefab实际上并没有建立其依赖关系（虽然mainfest上注明了存在dependencies）。&lt;/li&gt;
  &lt;li&gt;问题解决方式，只需要将BetaCommon Material设置为一个“显式”的AssetBundleName，那么冗余问题就不会存在了。&lt;/li&gt;
  &lt;li&gt;PS:让bitmap A的material被显示打包。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;font&quot;&gt;Font&lt;/h2&gt;
&lt;h4 id=&quot;unity-55uguitestmesh-prongui&quot;&gt;Unity 5.5版本下的UGUI，我将字体设置为粗体，发现字体只是变宽不加粗，不像正常的粗体，如下图所示。另外，TestMesh Pro需要预渲染，不能用动态字体，只能用于特定范围，有像NGUI(效果还不错)那种对动态字体加粗的方法么？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;动态字体加粗显示的外观是和字体本身有关系的，如果字体中没有包含“粗体”的字形，那么Unity会通过拉伸来“模拟”加粗，因此得到的效果是有问题的。&lt;/li&gt;
  &lt;li&gt;而这个行为在UGUI和NGUI中是一样的。因此，如果要确保加粗显示正确，则需要使用包含了“粗体”字形的字体，甚至需要考虑是否将其include到发布包中（因为某些设备中的内置字体也有可能被精简过）。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;texture&quot;&gt;Texture&lt;/h2&gt;
&lt;h4 id=&quot;uguitaggroupdrawcallgroup&quot;&gt;UGUI自动打包图集时，有时候同一个Tag会自己打出多个Group图集，导致DrawCall增加，有什么解决方法吗？这个分Group的原理是什么？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;产生Group的原因主要有两种：
    &lt;ul&gt;
      &lt;li&gt;纹理的格式不同 。举例来说，有这样四张纹理格式分别为：RGB24，ETC1，RGBA32和ETC2，那么设置一样的Tag后，对应的图集就会有四个Group。&lt;/li&gt;
      &lt;li&gt;纹理量太大。一个Group放不进，这个原因是容易理解的，就不解释了。&lt;/li&gt;
      &lt;li&gt;其中特别容易忽略的一点是，某些小纹理可能没有Alpha通道，导致了图集被分成两个Group，引起DrawCall的增高，这种情况下可以直接修改纹理，也可以强制设定为Aalpha通道的格式。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ui&quot;&gt;UI&lt;/h2&gt;
&lt;h4 id=&quot;ugui-image-sprite-profilerspritemeshgeneratortraceshape-&quot;&gt;请问UGUI Image 在切换Sprite（网络图片） 的时候有卡顿，从Profiler中看到具体卡在SpriteMeshGenerator.TraceShape 这个方法上，如下图所示，有没有什么优化的方法呢？&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2FTechSharing_66%2F9.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;图中的==SpriteMeshGenerator.TraceShape/Decompose/Simplify==的函数，通常出现在加载或者创建（Sprite.Create）SpriteMeshType为==Tight类型==的Sprite时，==Tight类型的Sprite在加载或创建时，需要检测图片的alpha区域从而生成多边形==。计算量较大，建议将其改为FullRect模式。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;工具&lt;/h2&gt;
&lt;h4 id=&quot;unity-profiler&quot;&gt;Unity Profiler中如下函数的耗时异常高，请问是什么原因导致呢？这些函数分别是什么意思，有什么具体优化方法呢？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Profiler.FinalizeAndSendFrame: 这个是Unity Profiler在记录和传输性能数据的开销，研发团队可忽略，因为在release版本中，该项并不存在；&lt;/li&gt;
  &lt;li&gt;WaitForJobGroup:是主线程在等待子线程完成的耗时开销，如果该项较高，那么说明该帧中某子线程的开销很大。就目前我们优化过的项目而言，绝大部分均为UGUI在子线程的开销所致。更多的参考资料建议研发团队参考UWA问答之前的记录：
https://answer.uwa4d.com/question/search?q=waitingforjob&lt;/li&gt;
  &lt;li&gt;Camera.Render:是Unity引擎的主要渲染函数，其中负责了绝大部分场景的渲染工作&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;gfxprocesscommands&quot;&gt;Gfx.ProcessCommands包含哪些行为操作？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;该行为是在RenderThread中，导致该行为耗时的主要原因是DrawCall。&lt;/li&gt;
  &lt;li&gt;另外过程耗时统计还包括顶点、材质贴图以及Shader等从内存到GPU的IO时间。&lt;/li&gt;
  &lt;li&gt;即使是多线程渲染，图形API的调用也需要在同一个线程中。其一，是Android系统的EGLContext一般不是线程独共享的，也就是只有一个线程能向同一个EGLContext里面发送GL指令。其二，如果使用共享的EGLContext，多个线程都能提交图形API，渲染的结果很难保证正确性。比如：如何保证线程A绑定了VBO或者Texture之后，线程B提交DrawCall时一定是它需要的呢。综上所述，我们认为这些行为应该都在一个线程里面执行的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;模型和动画&lt;/h2&gt;
&lt;h4 id=&quot;newmeshmesh&quot;&gt;New出来的Mesh好像都是可读写的，在我填充完数据以后，有什么办法能把这个Mesh改为只读么？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;通过&lt;code class=&quot;highlighter-rouge&quot;&gt;public void UploadMeshData(bool markNoLogerReadable);&lt;/code&gt;来设置。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;meshrendercanvasuimeshrendersortingorderimagerendersortingorder-&quot;&gt;请问我一个MeshRender的显示层级能不能夹在一个Canvas下的两个UI节点下？我通过设置MeshRender.sortingOrder数值在两个Image的Render的sortingOrder数值之间 ，是否能做到呢？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Image的sortingorder设置通常是无效的，因为UGUI会对DrawCall进行合并，调整其渲染顺序。因此，需要将Mesh前后的UI元素拆分到不同的Canvas中，从而直接设置Canvas的sortingorder。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;物理&lt;/h2&gt;
&lt;h4 id=&quot;physicsgameobjectboxcolliderprofilephysicsprocessingprofilerphysicsunity536f1&quot;&gt;在游戏里没有使用物理（Physics)相关功能时，怎么把物理相关的性能消耗降到最低？我们游戏里完全没用到物理相关的功能，只是因为需要做点击碰撞检测，所以GameObject上需要加上BoxCollider组件，但是Profile时会时不时看到Physics.Processing的消耗有点高，也不算非常高，但是理论上如果完全没用物理相关功能的话，总感觉这部分消耗是可以完全干掉的，对于Profiler中Physics模块中给的几个统计不太清楚是怎么计算的，目前使用的Unity版本是5.3.6f1版本。&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;就我们目前的分析来看，在Unity5.4版本之前，物理模块是会每帧都运行的。而在Unity5.4版本之后，如果没有使用任何物理相关的功能时（Rigidbody、CharacterController、Rogdoll、Cloth模拟等等），物理模块会被关闭。所以，就你的问题而言，物理模块的开销只能降低，而不能完全消除。&lt;/li&gt;
  &lt;li&gt;对于物理模块的开销，我们建议从宏观上进行了解，当你的项目完全没有使用物理模块时，那就需要从它的调用次数入手了。&lt;/li&gt;
  &lt;li&gt;Physics.Processing调用次数高：可以看到，很多时候，该函数的CPU耗时其实并不是物理开销过高，而是调用次数过多。这主要是因为Unity 5.x默认设置的Fixed Timestep为0.02，Maximum Allowed TimeStep为0.333。也就是说，物理模块每20ms更新一次，所以如果某一帧很卡（200ms），那么物理模块会被调用10次，这样耗时就直接上去了。而0.333表示如果该帧CPU开销超过333ms了，那么就不会再调用物理模块，所以上图中调用次数中最大是17次。&lt;/li&gt;
  &lt;li&gt;所以，如果想进一步降低物理模块的开销，在完全没有使用物理的情况下，可以将Fixed Timestep设置为0.05或0.1均可，降低它被调用的频率。同时，尽可能优化其他模块耗时，让每帧的总体耗时尽可能降低。&lt;/li&gt;
  &lt;li&gt;另外，需要注意的是，修改Fixed Timestep也会影响FixedUpdate的调用，在修改之前一定要检测项目中是否有使用FixedUpdate。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-3&quot;&gt;性能综合&lt;/h2&gt;
&lt;h4 id=&quot;monobehaviourprefabloadprefab&quot;&gt;MonoBehaviour中包含了被加载出来的Prefab上的组件（通过Load接口加载出来的），而这部分组件只能在Prefab被销毁的时候才会释放。&lt;/h4&gt;

&lt;h4 id=&quot;opengl-es-20ios--metal&quot;&gt;工程里还是选择只使用 OpenGL ES 2.0吗？iOS 是否该加上 Metal？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;目前都是用的Auto，主要有两个原因：
    &lt;ul&gt;
      &lt;li&gt;Metal测试下来CPU Overhead会比GLES低很多&lt;/li&gt;
      &lt;li&gt;GLES3能够有tex2Dlod支持 兼容性上来说只有实在老的机器和模拟器会fallback到GLES2，可能效果上会略差一些不过我们测试下来都可以接受。&lt;/li&gt;
      &lt;li&gt;选ES3.0还有一个原因，就是发现AssetBundle打出来的资源会比选Auto小很多。&lt;/li&gt;
      &lt;li&gt;PS:如果游戏面对的是高端机玩家可以放弃ES2&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;uiassetbundle&quot;&gt;切换UI场景使用AssetBundle加载慢，怎么优化界面进入速度，是应该预加载吗？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;界面加载慢主要的原因有，图集纹理的加载以及大量UI元素的实例化操作。&lt;/li&gt;
  &lt;li&gt;针对图集的加载，可以尝试合理的规划图集，尽量控制界面所引用的图集数量（即使用到了某个图集中的一个Sprite，也会加载整个图集）；&lt;/li&gt;
  &lt;li&gt;可以尝试对公共图集进行预加载，通常公共图集较大，且被使用的概率很大。&lt;/li&gt;
  &lt;li&gt;针对大量UI元素的实例化，这项开销大通常只发生在背包等复杂的界面中，而对于这类复杂界面可以考虑进行分步实例化，即首先实例化如外框、容器等部分的UI元素，然后分帧实例化背包中的UI元素，从而提高界面打开的速度以及流畅性。&lt;/li&gt;
  &lt;li&gt;PS： ==分帧是关键。在FPS60的情况下，只要100ms内响应即可。一帧是16.7，也就是说5~6帧做完就可以了。==&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-4&quot;&gt;渲染&lt;/h2&gt;
&lt;h4 id=&quot;unityshaderios&quot;&gt;Unity官方半透明Shader代码在iOS上运行出现问题&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;PS:遇到了看https://blog.uwa4d.com/archives/TechSharing_70.html&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 02 Dec 2017 22:53:34 +0800</pubDate>
        <link>https://caihua.tech/2017/12/02/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E5%8D%81%E4%B8%83%E5%91%A8/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/12/02/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E5%8D%81%E4%B8%83%E5%91%A8/</guid>
        
        <category>UWA</category>
        
        
      </item>
    
      <item>
        <title>Gamma校正与线性空间</title>
        <description>&lt;h4 id=&quot;section&quot;&gt;前言&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;近期看了&lt;a href=&quot;https://blog.uwa4d.com/archives/1882.html&quot;&gt;一篇文章&lt;/a&gt;，主要讲了如何处理lightmap在Android平台下下偏暗的问题。引发了对gamma校正的好奇。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;gamma&quot;&gt;Gamma校正的由来和计算方式&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;所谓Gamma校正指的是在传统的拍摄相机中会对照片中的亮度进行修正，计算公式为&lt;code class=&quot;highlighter-rouge&quot;&gt;Lout = pow(Lin, 0.45)  &lt;/code&gt;，说白了就是如果某个像素的亮度为0.5，那么保存后的照片的亮度就是0.5的0.45次方，即0.732。从下图可以看到绿色的线就是经过校正后的亮度曲线。在这个坐标系中，x轴为原始亮度，y轴是校正后的数值。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://static1.squarespace.com/static/525ed7ade4b0924d2f499223/t/575f41b427d4bdc48f225b5d/1465860589637/A+graph+of+pow%28x%2C+gamma%29?format=750w&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果以原始亮度0.5作为一个分界线，很明显的看出来0.5之前的亮度在校正后占据了70%（0.732)以上的数据空间。这也是为何会有gamma校正的根本原因，即：肉眼对较暗区域的变化更为敏感，而0.5为灰度的界限，原始亮度小于0.5的部分可以认为是较暗的区域。因此将0.5之前的亮度经过校正，使得其结果的范围变大到0-0.732，这就可以进一步的放大黑暗区域的范围，从而使得照片更加真实。&lt;/li&gt;
  &lt;li&gt;但是从这个曲线我们看到，除了0和1以外的像素的亮度整体的变大了，因此就出现了下图的中左边图中的现象，即经过0.45的gamma校正后图片变亮。但是为何我们最后在电视或者电脑屏幕上看到的图像基本和肉眼看到的真实亮度一样呢， 是因为显示器的硬件也会做一次gamma校正，而这个指数是2.2，即&lt;code class=&quot;highlighter-rouge&quot;&gt;pow(0.732，2.2） ≈ 0.5035&lt;/code&gt; ，和0.5有数值上的差异但是基本接近。这只是个巧合。&lt;/li&gt;
  &lt;li&gt;同理，如果是原始像素的图片不经过gamma校正而直接输出到显示器，其结果就是下图中右边图的结果，也就是亮度整体变暗。这个和上图中蓝色曲线的结果也相同。计算方法也是幂计算。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://static1.squarespace.com/static/525ed7ade4b0924d2f499223/t/575f4222e321408871d71230/1465860711911/Images+representing+various+gamma+values?format=1000w&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;unity&quot;&gt;导入unity中的图片&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;基本上所有的绘图软件在输出的结果上都是做过gamma校正的，否则在电脑屏幕上看到的就是偏暗。&lt;/li&gt;
  &lt;li&gt;因此在导入到unity后，在作用到shader时也是gamma校正后的图片。&lt;/li&gt;
  &lt;li&gt;当然我们也可以在绘图软件中就输出不经过gamma校正的图，这个后面说。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;unity-1&quot;&gt;unity中的颜色空间&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;unity的颜色空间就是gamma或者liner space&lt;/li&gt;
  &lt;li&gt;gamma选项下默认unity在shader中直接用gamma校正后的图片进行光照计算，然后输出到现实设备时硬件会做一次gamma校正，最终输出结果。&lt;/li&gt;
  &lt;li&gt;线性空间选项中，unity shader会对输入的图片进行一次gamma校正（2.2），得到真正的亮度值后进行光照计算。最后在进入颜色缓存区之前做一次gamma校正（0.45），然后图像进入显示设备，再次进行gamma校正（2.2）。&lt;/li&gt;
  &lt;li&gt;两者在最终结果的比对可以参考下图&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://static1.squarespace.com/static/525ed7ade4b0924d2f499223/t/575f42e327d4bdc48f2261e4/1465860851928/An+image+comparing+gamma+and+linear+pipelines?format=1000w&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;可以看出来线性空间下产生的最终渲染效果比较接近于真实。&lt;/li&gt;
  &lt;li&gt;我们以一个亮度为1的点为例进行两种模式的计算，对比下结果，假设这个点的法线与点到光源的向量的夹角为60°。根据Lambert公式，此时该点的亮度（用亮度代替像素值）为Clight * Cdiffuse * max(0, dot(n,I))，为了简化计算我们认为Clight也就是光照颜色也是1， n和I都是1。
    &lt;ul&gt;
      &lt;li&gt;gamma下原始亮度是1的点，Cdeffuse为1，60°的点积是0.5，计算出来的颜色是0.5，输出到屏幕经过gamma校正（2.2）后值为0.218。&lt;/li&gt;
      &lt;li&gt;线性空间下线移除gamma校正，亮度1的移除后结果也是1，60°的光照结果也是0.5，输出到颜色缓冲区线做一次校正（0.45），到屏幕做一次校正（2.2），期结果应该是0.5035。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;可以看出来两者在最后的结果上，线性空间的结果比较接近真实的60°情况下的亮度，这个真实值就是0.5。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-1&quot;&gt;线性空间工作流&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;现在unity中移动平台已经支持线性空间，只是需要OpenGL ES3。那么如果使用线性空间就需要一套类似PBR的流程。&lt;/li&gt;
  &lt;li&gt;首先就是纹理图是移除了gamma校正的。&lt;/li&gt;
  &lt;li&gt;在烘焙光照贴图的时候也要移除gamma校正。&lt;/li&gt;
  &lt;li&gt;后期处理的时候倒是不用额外做什么，因为unity已经对颜色值做了处理。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-2&quot;&gt;引用&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.kinematicsoup.com/news/2016/6/15/gamma-and-linear-space-what-they-are-how-they-differ&quot;&gt;GAMMA AND LINEAR SPACE - WHAT THEY ARE AND HOW THEY DIFFER&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;ps&quot;&gt;PS&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;开头提到的lightmap偏暗的问题，在2017.2.0p1中移动平台lightmap处理LDR时已经加入了是否是gamma的判定，然后根据结果会对LDR的亮度进行不同的补偿。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 30 Nov 2017 00:54:00 +0800</pubDate>
        <link>https://caihua.tech/2017/11/30/Gamma%E6%A0%A1%E6%AD%A3%E4%B8%8E%E7%BA%BF%E6%80%A7%E7%A9%BA%E9%97%B4/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/11/30/Gamma%E6%A0%A1%E6%AD%A3%E4%B8%8E%E7%BA%BF%E6%80%A7%E7%A9%BA%E9%97%B4/</guid>
        
        <category>Unity3D</category>
        
        
      </item>
    
      <item>
        <title>Unity Android二次开发经(血)验(泪)谈(史)</title>
        <description>&lt;h4 id=&quot;httpwwwcnblogscomxtqqkssp6387271html&quot;&gt;主要参考的是&lt;a href=&quot;http://www.cnblogs.com/xtqqkss/p/6387271.html&quot;&gt;这篇文章&lt;/a&gt;，不过在这个期间遇到了各种的问题，在这里写出来，希望看到的人能够少走弯路。&lt;/h4&gt;

&lt;h2 id=&quot;section&quot;&gt;准备工作&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;安装Android Studio（以下用AS代替），然后通过它下载Android SDK和tools。&lt;/li&gt;
  &lt;li&gt;AS目前已经是3.0版本，在3之前不支持java8，也就是说没有lambda和一些新的特性。&lt;/li&gt;
  &lt;li&gt;从AS上可以下载到的build-tool是27，但是最新的tools是unity不支持，会在输出工程的时候报错，目前我使用的是26。&lt;/li&gt;
  &lt;li&gt;PS:实际上在这几天的尝试过程中使用27在unity端会有一个&lt;code class=&quot;highlighter-rouge&quot;&gt;can not get xx list&lt;/code&gt;的错误，通过网上查询说是build tools版本的问题。而AS端似乎也有问题，不过没有记清楚。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;as&quot;&gt;AS中做的事情&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;按照文中的说法做即可。&lt;/li&gt;
  &lt;li&gt;其实作者本人也提到了几个点：
    &lt;ul&gt;
      &lt;li&gt;在建立module后要删除原来的app内存。&lt;/li&gt;
      &lt;li&gt;module名字和unity工程名字相同。&lt;/li&gt;
      &lt;li&gt;这是一个很坑的地方，在最开始的时候，我不断的遇到一个提示错误：library和project使用了同样的package name，而且unity的文档也说了不能同名。但是实际上是完全可以同名的。而且不管是直接用module还是把APP改成module，这两种方式都需要包名相同。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;build-aar&quot;&gt;build AAR&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;其实在AS中只要把工程设置成了module，那么选择build apk出来的也是AAR。&lt;/li&gt;
  &lt;li&gt;AAR文件放到&lt;code class=&quot;highlighter-rouge&quot;&gt;Assets\Plugins\Android\libs&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;或者通过gradle直接生成，这个方式是目前用这最方便的。看下图，双击即可build。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://imglf5.nosdn.127.net/img/Nld0N0tacnNuUGtyd2tYaDIzbUF2MEYyMUkyRlJuZlExM3VTUUJCUkpVeWdBc3JxQ3JkcDJ3PT0.jpg?imageView&amp;amp;thumbnail=500x0&amp;amp;quality=96&amp;amp;stripmeta=0&amp;amp;type=jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;图中的classes.jar就是我们自己的代码，libs文件夹下的是我们拷贝unity的，要删除掉。
&lt;img src=&quot;http://imglf4.nosdn.127.net/img/Nld0N0tacnNuUGx4UzhpR2QzUzFkejc3S3V3eGVEL3hUVWRtczVhU3NGMnFieGJkcjFJdXhBPT0.png?imageView&amp;amp;thumbnail=500x0&amp;amp;quality=96&amp;amp;stripmeta=0&amp;amp;type=jpg&quot; alt=&quot;image&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;unitybuild-apk&quot;&gt;unity中build apk&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;这块分开说下，因为我在整个尝试的过程中尝试了直接使用module方法（以下用方法1替代），这个方法不需要用到AS中的manifest。还有就是将app改造成module（以下用方法2替代），这个需要提供manifest。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;manifest&quot;&gt;方法1因为不需要提供manifest，所以省了很多事。&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;首先按照文中的方法先在AS中改造下manifest文件。&lt;/li&gt;
  &lt;li&gt;拷贝到Plugins/Android文件夹下。&lt;/li&gt;
  &lt;li&gt;在unity的PlayerSetting中进行设置。保证包名一致，保证minimum api level和AS中设置的一样。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在AS中我设置了&lt;code class=&quot;highlighter-rouge&quot;&gt;compileSdkVersion&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;targetSdkVersion&lt;/code&gt;为25，开始按照文中和其他人的说法，在unity中target api level也设置的是25，==但是导出project时遇到android:configChanges错误：==&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;unity  CommandInvokationFailure: Gradle build failed. ‘configChanges’ with value…&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;真正的解决这个问题应该是在unity中Player Setting中将target API level设置为auto，这个要比minimum高才行。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-1&quot;&gt;方法2会遇到的问题：&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;因为开始没有把AndroidManifest.xml放到Plugin下，导致每次unity编译的时候都生成一个新的build-id，与AS中的不一致。这个问题其实只要把AS中的manifest文件放到unityPlugin中，就保证了不会每次编译都ID变的问题。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;==合并manifest==：AS的Gradle插件默认会启用Manifest Merger Tool，若Library项目中也定义了与主项目相同的属性（例如默认生成的android:icon和android:theme），则此时会合并失败。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;解决方法有以下2种：1有效，2没试：&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;方法1：在Manifest.xml的application标签下添加tools:replace=”android:icon, android:theme”（多个属性用,隔开，并且记住在manifest根标签上加入xmlns:tools=”http://schemas.android.com/tools”，否则会找不到namespace哦）&lt;/li&gt;
      &lt;li&gt;PS：其实是这样写&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;category tools:replace=&quot; android:name&quot; android:name=&quot;com.google.intent.category.CARDBOARD&quot; /&amp;gt;&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;方法2：在build.gradle根标签上加上useOldManifestMerger true （懒人方法）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;各种错误的处理&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://kotlintc.com/articles/3938&quot;&gt;Failed to resolve:com.android.support:appcompat-v7:27+:报错处理&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;这个问题本质在于AS或者说本地的工具版本低，从下图中可以找到本地的版本。可以看到时26，所以需要在build.gradle中设置&lt;code class=&quot;highlighter-rouge&quot;&gt;compile 'com.android.support:appcompat-v7:26.+'&lt;/code&gt;，将27改为26即可。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://imglf3.nosdn.127.net/img/Nld0N0tacnNuUG5EUnpPWTVFTzMrZzJGdm5VMHhqWmUveENURXZnajJPUTRPcWpvY010eldBPT0.png?imageView&amp;amp;thumbnail=500x0&amp;amp;quality=96&amp;amp;stripmeta=0&amp;amp;type=jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;在project structure中可以设置java语言的版本，1.7的时候是不支持lambda的。需要注意。如果仍旧抽风般的提示lambda的问题就重启AS.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;AS2.3使用java8，本来3.0直接用的，2.3需要做如下处理。设置成功后也解决了&lt;code class=&quot;highlighter-rouge&quot;&gt;unity Can't read classes.jar&lt;/code&gt;这个问题，&lt;code class=&quot;highlighter-rouge&quot;&gt;是因为项目使用的Java（JDK）版本比较高，而ProGuard, version 4.4支持的版本（最高到1.6），所以产生该问题。&lt;/code&gt;，看了AS是一样的问题。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;android {
  ...
  defaultConfig {
    ...
    jackOptions {
      enabled true
    }
  }
  compileOptions {
    sourceCompatibility JavaVersion.VERSION_1_8
    targetCompatibility JavaVersion.VERSION_1_8
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;下面这个错误印象中是改AS中工程的target版本，或者删除了对应的代码。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Error:(4) Error retrieving parent for item: No resource found that matches the given name ‘android:TextAppearance.Material.Widget.Button.Inverse’.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;AS3版本好像不能支持gradle4.1，找到dependencies改成如下。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dependencies {
		classpath 'com.android.tools.build:gradle:3.0.0'
	}
	
...	

apply plugin: 'com.android.library'

....

defaultConfig {
		targetSdkVersion 27
		//applicationId 'xxxx'
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;这个错误的情况是用unity生成并导出Android的代码，在2017.2p1的情况下输出的代码中gradle是4.1的。&lt;/li&gt;
  &lt;li&gt;如果是用AS自己生成APP或者module就没这样的问题。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;adbexe-&quot;&gt;adb.exe 已停止工作&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;这个问题最终发现是360手机助手占用了5037端口造成的&lt;/li&gt;
  &lt;li&gt;排查过程记录一下：
    &lt;ul&gt;
      &lt;li&gt;在\platform-tools目录下调用adb devices命令&lt;/li&gt;
      &lt;li&gt;提示这个错误：&lt;code class=&quot;highlighter-rouge&quot;&gt;adb server version (31) doesn't match this client (39); killing...
error: could not install *smartsocket* listener: cannot bind to 127.0.0.1:5037: 通常每个套接字地址(协议/网络地址/端口)只允许使用一次。 (1
0048)&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CMD:netstat -ano | findstr &quot;5037&quot;&lt;/code&gt; //查看占用这个端口的APP，发现是进程15128&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CMD:tasklist | findstr &quot;14152&quot;&lt;/code&gt;    //查看这个进程对应的应用&lt;/li&gt;
      &lt;li&gt;下图中的14152进程是adb.exe，此时adb就允许正常了。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://imglf3.nosdn.127.net/img/Nld0N0tacnNuUG16ZHdGdmd1MEpFMkxkdWJUTEdTTURSc1NYYnhuSkUzZkY3MURnYnhRZ0JRPT0.png?imageView&amp;amp;thumbnail=500x0&amp;amp;quality=96&amp;amp;stripmeta=0&amp;amp;type=jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;后记&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;其实在整个的使用过程中还遇到了非常多的问题，都是遇到一个搜索一个。所以也不可能完全的记录下来。&lt;/li&gt;
  &lt;li&gt;另外遗留了一个问题就是目前还不能调用Android中的类方法。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 20 Nov 2017 00:47:54 +0800</pubDate>
        <link>https://caihua.tech/2017/11/20/Unity-Android%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E7%BB%8F(%E8%A1%80)%E9%AA%8C(%E6%B3%AA)%E8%B0%88(%E5%8F%B2)/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/11/20/Unity-Android%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E7%BB%8F(%E8%A1%80)%E9%AA%8C(%E6%B3%AA)%E8%B0%88(%E5%8F%B2)/</guid>
        
        <category>Unity3D</category>
        
        
      </item>
    
      <item>
        <title>PHP的OOP</title>
        <description>&lt;ul&gt;
  &lt;li&gt;在类中可以使用public（公有），protected（受保护）或 private（私有）来修饰属性和方法。如果不修饰默认是public。&lt;/li&gt;
  &lt;li&gt;类中用var定义变量，&lt;code class=&quot;highlighter-rouge&quot;&gt;var $name&lt;/code&gt;，使用方式&lt;code class=&quot;highlighter-rouge&quot;&gt;$this-&amp;gt;name&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;构造函数&lt;code class=&quot;highlighter-rouge&quot;&gt;function __construct()&lt;/code&gt;，析构函数&lt;code class=&quot;highlighter-rouge&quot;&gt;function __destruct()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;继承&lt;code class=&quot;highlighter-rouge&quot;&gt;class Child_Site extends Site&lt;/code&gt;，使用extends关键字&lt;/li&gt;
  &lt;li&gt;实例化类&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Login
{
    var $m_user;
    var $m_pw;

    function __construct($user, $pw)
    {
        $this-&amp;gt;m_user = $user;
        $this-&amp;gt;m_pw = $pw;
    }

    function Login()
    {
        echo $this-&amp;gt;m_user .'-'. $this-&amp;gt;m_user;
    }
}

$user = $_POST['user'];
$pw = $_POST['pw'];

$login = new Login($user, $pw);
$login-&amp;gt;Login();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;可以使用interface&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;?php

// 声明一个'iTemplate'接口
interface iTemplate
{
    public function setVariable($name, $var);
    public function getHtml($template);
}


// 实现接口
class Template implements iTemplate
{
    private $vars = array();
  
    public function setVariable($name, $var)
    {
        $this-&amp;gt;vars[$name] = $var;
    }
  
    public function getHtml($template)
    {
        foreach($this-&amp;gt;vars as $name =&amp;gt; $value) {
            $template = str_replace('{' . $name . '}', $value, $template);
        }
 
        return $template;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;常量&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;?php
class MyClass
{
    const constant = '常量值';

    function showConstant() {
        echo  self::constant . PHP_EOL;
    }
}

echo MyClass::constant . PHP_EOL;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;静态属性不能通过一个类已实例化的对象来访问（但静态方法可以）。&lt;/li&gt;
  &lt;li&gt;静态属性不可以由对象通过 -&amp;gt; 操作符来访问。调用方法是&lt;code class=&quot;highlighter-rouge&quot;&gt;::&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;抽象类与C#一样&lt;/li&gt;
  &lt;li&gt;Final 关键字，作用与C#的sealed一样。&lt;/li&gt;
  &lt;li&gt;子类中调用父类的方法&lt;code class=&quot;highlighter-rouge&quot;&gt;parent::Login();&lt;/code&gt;，与C#的&lt;code class=&quot;highlighter-rouge&quot;&gt;base.Login&lt;/code&gt;结构上一样。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 19 Nov 2017 22:00:09 +0800</pubDate>
        <link>https://caihua.tech/2017/11/19/PHP%E7%9A%84OOP/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/11/19/PHP%E7%9A%84OOP/</guid>
        
        <category>PHP</category>
        
        
      </item>
    
      <item>
        <title>每天一点UWA：第十六周</title>
        <description>&lt;h2 id=&quot;texture&quot;&gt;Texture&lt;/h2&gt;

&lt;h4 id=&quot;etcargb32&quot;&gt;如何处理ETC压缩完图片质量模糊和ARGB32内存占用太大这种关系？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;使用ETC压缩的图片尽量减少过渡，这是美术制作时需要注意的，很多情况下并不需要明显的过渡，只是需要半透明而已；&lt;/li&gt;
  &lt;li&gt;当然，有部分过渡色是必须的，这时候就要把相关小图整合到一张RGBA32的图片上；&lt;/li&gt;
  &lt;li&gt;在资源管理上入手。一般情况下，我们是允许部分资源使用RGBA32，但是要注意，及时卸载掉不使用的资源，以保证内存峰值在可控范围内。&lt;/li&gt;
  &lt;li&gt;果ETC压&amp;gt; 缩效果不好的，会使用RGBA32并降一个尺寸规格来压缩，这样虽然图片会模糊点，但是过渡还是平滑的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;astcandroidmalirgba32astc&quot;&gt;ASTC格式并不是所有机型都支持，在Android端只有配有高端Mali芯片的机器才支持，对于不支持的，引擎会将其解压成RGBA32进行处理，所以图片中的内存值过大，很可能是项目在不支持ASTC格式的设备上所看到的结果。&lt;/h4&gt;

&lt;h2 id=&quot;section&quot;&gt;工具&lt;/h2&gt;

&lt;h4 id=&quot;putgeometryjobfence&quot;&gt;PutGeometryJobFence开销较高&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;就目前我们所优化过的项目而言，推测PutGeometryJobFence是Unity项目的主线程在等子线程的一些网格计算操作完成，其在不同的模块中均有出现（UGUI模块、渲染模块、Mesh.Skin操作、Animator动画模块等等），出现的地方不同，其本身含义也并不相同，不能一概而论。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;transformsetposition&quot;&gt;Transform.set_position的开销很大&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Deep Profiler本身对于耗时的统计影响很大，通常在Deep Profiler下调用次数越多的函数，其耗时的统计就会越明显地偏高，因此，我们首先建议关闭Deep Profiler，同时用Profiler.BeginSample/EndSample将修改Position的代码包进来，再查看其耗时，相对会更加准确。&lt;/li&gt;
  &lt;li&gt;CanvasRenderer.OnTransformChanged过多，移动UI元素相比于移动其他的元素确实会有额外的开销。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;unity-profilercanvasrendersubbatchui&quot;&gt;Unity Profiler中的Canvas.RenderSubBatch是否属于UI上渲染的开销？和重建有关系吗？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;是UI模块（UGUI）的渲染开销，但是跟UI的重建并无太大关系，主要还是跟UI界面的渲染Draw Call相关。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;clear&quot;&gt;Clear的耗时过大&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2FTechSharing_65%2F7.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Clear操作一般是用来清除Camera的各种Render Buffer，当图像后处理使用的越多，则同一帧中开辟更多的Buffer的概率也越大，从而造成Clear的开销也较高。&lt;/li&gt;
  &lt;li&gt;项目中Clear耗时较高，且高耗时较为频繁，则建议先关闭图像后处理操作，来查看该情况是否有所好转。然后再逐步开启各个图像后处理操作，逐步定位造成Clear较高的耗时根源&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;模型&amp;amp;动画&lt;/h2&gt;
&lt;h4 id=&quot;uwa&quot;&gt;如何降低动画文件的浮点数精度？之前UWA给过思路，但具体怎么个执行方法？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;动画文件后处理可以做两件事，1）精度压缩，2）scale曲线剔除。比起用工具修改原始fbx文件，这样比较灵活。
实际测试，在开启Optimal压缩的情况下，加上这个后处理，能再节省40%左右。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 19 Nov 2017 01:04:30 +0800</pubDate>
        <link>https://caihua.tech/2017/11/19/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E5%8D%81%E5%85%AD%E5%91%A8/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/11/19/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E5%8D%81%E5%85%AD%E5%91%A8/</guid>
        
        <category>UWA</category>
        
        
      </item>
    
      <item>
        <title>每天一点UWA：卡通渲染笔记</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;描边的方法&lt;/h2&gt;
&lt;h4 id=&quot;section-1&quot;&gt;基于视角的勾边&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;PS：这个是最简单的绘制边界的做法。计算方式就是dot(viewDir, normal)。根据 三角函数的定义值越小说明视角与模型某个点的表面法线的夹角越大，夹角为90°时说明这个triangle是视角看不到的，也就是边界了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-2&quot;&gt;基于几何生成方法的描边&lt;/h4&gt;
&lt;h5 id=&quot;shell-method&quot;&gt;shell method&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;首先在绘制结束正常的模型后，将需要描边的物体改用正面剔除再绘制一遍，在VS中将顶点沿着法线方向膨胀一定距离，然后在FS中将模型用纯色输出。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;z-bias&quot;&gt;z-bias&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;也是绘制背面，但不膨胀，而是把背面顶点的Z值稍微向前偏移一点点，使得背面的些许部分显示出来形成描边效果。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-3&quot;&gt;基于图像处理的描边&lt;/h4&gt;

&lt;h5 id=&quot;section-4&quot;&gt;什么是“边缘”呢？&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;边缘就是在深度或者法线上不连续的位置。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-5&quot;&gt;做法：&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;需要将深度信息和法线信息以贴图的形式传入，运用边缘检测算法去寻找这些像素。&lt;/li&gt;
  &lt;li&gt;这类方法的优点是描边的线宽一致，缺点是需要额外的法线和深度信息，当然，由于近年来流行的延迟渲染框架，法线和深度本来就是G-Buffer的一部分，因此往往不需要额外绘制法线和深度的信息。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-6&quot;&gt;美式卡通中的做法&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;美式卡通中往往倾向于使用基于图像处理的描边方法来生成均匀一致的描边效果。在《英雄联盟》中小兵和英雄的勾边效果就是用Sobel算子对深度信息进行边缘检测来获得的。&lt;/li&gt;
  &lt;li&gt;当物体较多时在进行正常绘制的阶段用stencil buffer标记出需要描边的物体，然后用一个全屏的后处理，对stencil buffer标记的像素进行边缘检测，当然这样的话，就很难给每个物体单独指定描边颜色了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-7&quot;&gt;日式卡通中的做法&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;日式卡通中往往倾向于使用基于几何体生成的方法去描边，这类描边方法相较于另两类方法的好处在于线宽更容易为美术所控制。&lt;/li&gt;
  &lt;li&gt;在《GUILTY GEAR Xrd》中，角色的描边就是通过几何体生成的方法，结合了shell method和z-bias method，并引入了逐物体的顶点色来控制描边细节，同时也是为了保证描边粗细不会随着摄像机视距发生变化，具体来说，顶点色存储的信息包括：
    &lt;ul&gt;
      &lt;li&gt;R通道：控制toon shading的阈值，和描边无关，和着色有关，这个我们后面描述&lt;/li&gt;
      &lt;li&gt;G通道：控制顶点根据视距膨胀的强度（这个部分具体操作我也没有完全弄清楚，希望了解的朋友来补充）&lt;/li&gt;
      &lt;li&gt;B通道：控制描边的z-bias，越大则描边越不可见&lt;/li&gt;
      &lt;li&gt;A通道：控制描边的粗细&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-8&quot;&gt;着色&lt;/h2&gt;

&lt;h4 id=&quot;cel-shading&quot;&gt;Cel Shading&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;只考虑光线&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2Fsparkle_cartoonshading%2FGS1.png&quot; alt=&quot;image&quot; /&gt;
&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2Fsparkle_cartoonshading%2FGS2.png&quot; alt=&quot;image&quot; /&gt;
&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2Fsparkle_cartoonshading%2F10.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;同时考虑光线和视角&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2Fsparkle_cartoonshading%2FGS3.png&quot; alt=&quot;image&quot; /&gt;
&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2Fsparkle_cartoonshading%2FGS4.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2Fsparkle_cartoonshading%2F11.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;tone-based-shading&quot;&gt;Tone Based Shading&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Tone Based Shading的风格化是基于美术指定的色调插值，并且插值得到的色阶是连续的。首先需要由美术指定冷色调和暖色调，而最终模型的着色将根据法线和光照方向的夹角，在这两个色调的基础上进行插值，具体算法如下：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2Fsparkle_cartoonshading%2FGS5.png&quot; alt=&quot;image&quot; /&gt;
&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2Fsparkle_cartoonshading%2FGS25.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;其中，Kd仍是模型自身色彩贴图，Kblue，Kyellow和alpha，beta则均是自定义的参数。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2Fsparkle_cartoonshading%2F12.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;基于tone based shading绘制的球体&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;section-9&quot;&gt;日式卡通中的着色&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;以《GUILTY GEAR Xrd》为例，它也一定程度上包含了Cel Shading和Tone Based Shading的部分思想，将色阶离散成为“明暗”两个色调，并由美术指定冷暖色调的颜色：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2Fsparkle_cartoonshading%2FGS7.png&quot; alt=&quot;image&quot; /&gt;
&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2Fsparkle_cartoonshading%2FGS8.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;上述公式表示了这个卡通渲染的漫反射部分&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;threshold表示明暗交界的阈值，在游戏中通过顶点色的R通道来实现逐顶点的控制。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Kcool和Kwarm由美术逐物体地指定，Ksss是对模型次表面散射效果的模拟，对皮肤而言一般呈粉红色，通过美术绘制的SSS贴图来实现逐像素控制，并且只有暗部的像素才会受SSS贴图的影响。Kd是模型自身的颜色贴图。darkness表示了某个像素的明暗程度，用于确定色调的冷暖。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;美术绘制的AO贴图，来实现一些边角缝隙的暗部效果。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;高光的计算更简单一些：基本上与blinn-phong一样&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2Fsparkle_cartoonshading%2FGS10.png&quot; alt=&quot;image&quot; /&gt;
&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2Fsparkle_cartoonshading%2FGS11.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-10&quot;&gt;美式卡通中的着色&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Valve在其游戏《军团要塞2》将卡通渲染着色分为了view dependent term和view independent term。两部分的计算分别如下：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2Fsparkle_cartoonshading%2FGS12.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2Fsparkle_cartoonshading%2FGS13.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2Fsparkle_cartoonshading%2FGS14.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;PS：从公式中可以看到不依赖view的版本是l也就是光照向量，而依赖view的中是r，也就是反射计算。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://wikimedia.org/api/rest_v1/media/math/render/svg/d5acd56487631512ad0fc984bf3c11ce700589c4&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-11&quot;&gt;风格化高光和阴影&lt;/h2&gt;
&lt;h4 id=&quot;section-12&quot;&gt;可变形状的高光&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;从日式着色的高光公式看，改变形状的关键在于H向量。这个H就是半角向量，参考Blinn-Phong公式。具体做法有：
    &lt;ul&gt;
      &lt;li&gt;平移，改变高光的位置： &lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2Fsparkle_cartoonshading%2FGS17.png&quot; alt=&quot;image&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;有方向的缩放，沿着切线空间的某个轴缩放高光形状：&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2Fsparkle_cartoonshading%2FGS18.png&quot; alt=&quot;image&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;分割，将一块连续的高光切分成两块：&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2Fsparkle_cartoonshading%2FGS19.png&quot; alt=&quot;image&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;方块化，将趋于圆形的高光变成方形：&lt;/p&gt;

        &lt;p&gt;&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2Fsparkle_cartoonshading%2FGS20.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

        &lt;p&gt;&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2Fsparkle_cartoonshading%2FGS21.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

        &lt;p&gt;&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2Fsparkle_cartoonshading%2FGS22.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2Fsparkle_cartoonshading%2F16.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-13&quot;&gt;风格化阴影&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;类似于风格化的高光，风格化的阴影也是在标准的阴影计算流程之后，定义了一系列针对标准阴影的操作，通过这些操作，配合用户自定义的参数，便可以达到风格化阴影的效果，总的来说，共有四类操作：
    &lt;ul&gt;
      &lt;li&gt;膨胀/腐蚀（Inflation）：扩大或者缩小阴影范围，用参数i来控制&lt;/li&gt;
      &lt;li&gt;亮度（Brightness）：阴影区域的亮度，可以用于模拟半影区的效果，用参数b控制&lt;/li&gt;
      &lt;li&gt;柔度（Softness）：阴影边界处的柔和程度，用参数s控制&lt;/li&gt;
      &lt;li&gt;抽象度（Abstraction）：阴影形状的抽象程度，用参数alpha控制&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2Fsparkle_cartoonshading%2F17.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-14&quot;&gt;几种操作和相应的效果&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;整个风格化阴影的生成是基于图像空间的，从一个已经生成的精确阴影图开始。可以分成五个阶段：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;精确阴影的生成，由于是基于图像空间的，因此对精确阴影图的生成方法没有特别要求，可以是shadow volume，shadow map，ray tracing或者其他阴影生成技术，但必须要注意的是这里的阴影值一定是二值化的。&lt;/li&gt;
      &lt;li&gt;有向距离场的生成，基于图像空间的精确阴影，计算每个像素距离最近阴影边界的有向距离，这是文中算法的核心，也是后面风格化的基础，在文中给出了一种有向距离场的计算方法，当然也可以采用其他方案。&lt;/li&gt;
      &lt;li&gt;有向距离场的高斯模糊，这一步是抽象阴影生成的关键。&lt;/li&gt;
      &lt;li&gt;过滤，通过一个转移函数，将模糊后的有向距离场重新映射为阴影图。&lt;/li&gt;
      &lt;li&gt;使用过滤后的阴影进行光照计算。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2Fsparkle_cartoonshading%2F18.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;PS：如果是unity的话可能要做屏幕后处理，如果是延迟渲染的的话G-buffer不确定有没有阴影信息。而且移动平台也不推荐。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-15&quot;&gt;结束语&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;除了好好学习还能有啥好说的呢╮(╯▽╰)╭&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 14 Nov 2017 14:24:54 +0800</pubDate>
        <link>https://caihua.tech/2017/11/14/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E5%8D%A1%E9%80%9A%E6%B8%B2%E6%9F%93%E7%AC%94%E8%AE%B0/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/11/14/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E5%8D%A1%E9%80%9A%E6%B8%B2%E6%9F%93%E7%AC%94%E8%AE%B0/</guid>
        
        <category>UWA</category>
        
        
      </item>
    
      <item>
        <title>每天一点UWA：第十五周</title>
        <description>&lt;h2 id=&quot;assetbundle&quot;&gt;AssetBundle&lt;/h2&gt;
&lt;h4 id=&quot;unityprefabassetbundleassetbundleassetbundleobjectobjectobjectdestroyinstantiateobjectobjectdestroyloadassetbundle&quot;&gt;我们想请教一个Unity的普适性的资源管理问题。举个例子，我们现在的一个特效Prefab包含的贴图打成AssetBundle时没有单独拆分出来，就会存在一个问题，这个特效AssetBundle会存在重复加载的问题进而导致重复的特效贴图在内存中。（针对“重复加载”说明下：我们首先通过AssetBundle出来一个Object，这个Object会缓存一段时间，在这段缓存时间过后这个Object会被Destroy掉，而需要释放的特效是通过Instantiate这个Object出来的。当这个Object过了缓存时间被destroy掉后，下次需要释放相同的特效还是通过load同样的AssetBundle进行再实例化出来，这样内存中存在两份贴图了。）&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;一般是团队中自行做一些资源的引用计数来进行管理。频繁调用UnloadUnusedAssets是不可取的（该函数的主要作用是查找并卸载不再使用的资源。游戏场景越复杂、资源越多，该函数的开销越大，一般在300~2000 ms范围内），但可以调用UnloadAsset来释放资源。&lt;/li&gt;
  &lt;li&gt;PS:典型的释放prefab后没有释放对于的资源。确实应该用UnloadAsset，或者一开始这个图片资源就应该做成单独的AssetBundle。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;materialassetbundleassetbundleassetbundle&quot;&gt;美术做粒子的时候，粒子与粒子之间共用资源的情况很多，例如某几个粒子共用一个Material，某几个粒子共用一个贴图等，应该如何组织AssetBundle？要是对应到最细的那个程度，凡是共用过的资源都单独打一个AssetBundle，好像又会很琐碎，假如不那么做，粒子与粒子之间的AssetBundle又会有冗余。这方面有什么好的建议？&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;AssetBundle打包没有标准的方式，单就粒子系统而言，因为其个体本身比较小，并且在项目中经常大量出现，所以并不建议将粒子系统逐个打包，而是建议根据其出现频率进行打包，比如将同一段时间、同一出现场景等的粒子系统打包在一起。同时，由于粒子系统的Shader基本上都是Unity内置Shader，因此，尽可能将Shader进行依赖打包。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;gameplay&quot;&gt;Gameplay&lt;/h2&gt;
&lt;h4 id=&quot;optimize-game-objectsavatar&quot;&gt;我把骨骼文件的Optimize Game Objects”开启了，然后骨骼信息就没有了，那Avatar换装时候需要处理的骨骼信息怎么办？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;在开启“Optimize GameObject”选项后，因为Avatar信息消失，所以并不能通过原始的合并骨骼、合并Mesh的方法再来实现换装功能。对于开启“Optimize GameObject”选项的模型，Unity本身有另外一套更为方便的换装方式，即只要所换装模型的骨骼结点信息与Avatar自身骨骼信息可以匹配，那么直接将换装模型挂在Avatar模型下做为子节点即可，而不必再通过骨骼合并的方式来进行换装。&lt;/li&gt;
  &lt;li&gt;PS:mark一下，没看懂。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ui&quot;&gt;UI&lt;/h2&gt;
&lt;h4 id=&quot;mipmap&quot;&gt;关于Mipmap的设置&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;通过修改Texture的mipMapbias这个值可以改变使用的mipmap的层级。但是这个值目没有办法在全局设置，在导入图片的时候要用代码设置。&lt;/li&gt;
  &lt;li&gt;unit官方建议&lt;code class=&quot;highlighter-rouge&quot;&gt;Note that using large negative bias can reduce performance, so it’s not recommended to use more than -0.5 negative bias.&lt;/code&gt;，但是Mipmap的层级数的确是一个整数。mipMapbias是由Unity引擎定义的一个参数，按照Unity官网解释来看整数代表了比当前层级更低（级数更大，更模糊）的Mipmap，负数代表了比当前层级更高的Mipmap。“-0.5”具体是偏移多少层级目前也不是很清楚。&lt;/li&gt;
  &lt;li&gt;Trilinear应该是会比Bilinear效果好一些，但是也差强人意。原因是这样：传统的Mipmap（不采用Anisotropic Filtering）都是每层将u，v两个方向缩减一半，即：512x512的下一层是256x256。这就导致在两层交界处在不同层采样出来的纹理在u，v两个方向都被拉伸（或者叫变模糊）。Anisotropic Filtering的方式可以简单理解为在交界处只在某一个方向上被拉伸，另一个方向保持原有采样率（或者叫纹理分辨率），这样才能明显降低突变的模糊感。&lt;/li&gt;
  &lt;li&gt;使用Anisotropic Filtering不仅纹理内存占用会增高，而且采样率也增高（因为有一个方向的保持不变），因此它比传统的mipmap更耗时，耗时在于GPU端对纹理进行采样时增加了访存，在CPU端没有影响。虽然Anisotropic Filtering 耗时增加，但是相比于直接增加mipmap level（也就是设置-0.5的偏移），要达到相同的效果，Anisotropic Filtering的时间耗时还是相对更低的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;canvascanvasuguispriterenderer&quot;&gt;我在改血条，我原来是一个Canvas里放了所有血条，后来改成每个血条一个Canvas，再改成每个血条完全不用UGUI，直接用SpriteRenderer绘制，感觉性能越来越差了，怎么办呢？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;对于“所有血条放一个Canvas”和“一个血条放一个Canvas”做一个比较：
    &lt;ul&gt;
      &lt;li&gt;前者的开销主要在于网格的更新，在Unity5.2之后主要是在子线程中通过Timeline来查看。因此只看主线程的话，这种方法肯定是更高效的；&lt;/li&gt;
      &lt;li&gt;后者的开销主要在于DrawCall的数量（前者理论上能做到只用1个DrawCall，后者一个Canvas即一个DrawCall），开销被包含在了Camera.Render或者Canvas.RenderOverlays中。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;因此，在选择时，需要考虑的就是“网格更新”和“DrawCall”的权衡。&lt;/li&gt;
  &lt;li&gt;还是建议尽可能降低血条的顶点数，然后选择前者。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;模型&amp;amp;动画&lt;/h2&gt;
&lt;h4 id=&quot;generichumanoid&quot;&gt;优化动画精度时发现针对Generic效果明显，而Humanoid变化不大。&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;精度优化降内存（并非通过减少位数降低文本体积降内存），其实质是将曲线上过于接近0的数值（例如有效数字出现在小数点6位以后）直接归零，使部分曲线变为constant曲线来降低内存消耗。&lt;/li&gt;
  &lt;li&gt;在Generic中，大量曲线存在这样的数值，因而降低精度后，constant曲线增加，内存降低。&lt;/li&gt;
  &lt;li&gt;但在Humanoid中，动画信息被转化到Muscle空间后，muscle曲线上的数值很少约等于零，很难因为精度降低变为constant曲线，因此内存占用受精度降低的影响不大。&lt;/li&gt;
  &lt;li&gt;但归一化的Muscle空间本身就对动画信息进行了精简，自身内存占用相比Generic已经降低了不少，如果需要继续降低，可以尝试提高压缩选项下的Error值。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;animatoranimationclip&quot;&gt;Animator会把所有状态的AnimationClip加载到内存，有什么好的办法可以动态加载？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Animator Controller结构不需要改变，但动画需要变化。比如随着人物等级或技能升级，同种的攻击动作随着变化等。该种需求可以通过AnimatorOverrideController来进行完成，即按需加载新的AnimationClip，然后替换AnimatorOverrideController中相应的AnimationClip即可。目前，Unity的AnimatorOverriderController不仅可以进行单个替换，同时也可以ApplyOverrides成组替换；&lt;/li&gt;
  &lt;li&gt;Animator Controller结构需要改变，类似于Animation老版本动画的AddClip功能。这种需求需要替换AnimatorController，研发团队可以在动态加载AnimationClip的同时，动态加载相应的Animator Controller，然后进行替换即可。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;transformparentanimatorparentnull&quot;&gt;为什么Transform.设置Parent会触发Animator的初始化吗？Parent是等于null的。&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;把 Parent 设为null，相当于把这个 GameObject 变为根节点。如果在设置之前这个 GameObject 本身是激活状态，但其的父节点是未激活状态，那么设置之后，相当于把这个GameObject 激活。而激活GameObject 时就会触发 Animator.Initialize 等操作了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;物理&lt;/h2&gt;
&lt;h4 id=&quot;unity--profilerwarning&quot;&gt;在Unity 的 Profiler里，有些记录右边会有Warning的个数信息，请问这个是否影响性能，或者是否有必要修改呢？&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2FTechSharing_62%2F1.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;这种字符的出现很可能会导致后续的物理更新出现较大的性能开销，包含在Physics.Simulate/Processing中。&lt;/li&gt;
  &lt;li&gt;针对这个图是受限于Unity版本中的PhysX在移动静态碰撞体是开销较高的问题（虽然文档中说5.x下已经解决，但我们确实发现在5.x的项目中该项仍然存在）。&lt;/li&gt;
  &lt;li&gt;建议给需要移动的Collider加上RigidBody并勾选Is Kinematic复选框，从而将其变为动态碰撞体。对于不移动的物体，则直接将模型的Apply Root Motion选项进行关闭，从而直接省去Static Collider.Move的性能开销。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;性能综合&lt;/h2&gt;
&lt;h4 id=&quot;targetframerate30&quot;&gt;我们设置了TargetFrameRate为30，想避免过高的耗电和发热，请问这样做是合理的么？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;这种设置仅在帧率本身很好的情况下，才会起到减少耗电和发热的作用。但如果本身游戏已经较为卡顿，那么该设置方法意义不大。对于耗电和发热，研发团队需从CPU、GPU和IO入手，尽可能降低这三方面的负载压力。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;materialsetpassfast&quot;&gt;项目渲染中Material.SetPassFast的开销高&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Material.SetPassFast是Unity引擎在渲染过程中Material的轮循切换开销，一般在Unity5.0~Unity5.3版本中出现。它的开销主要分为两种：
    &lt;ul&gt;
      &lt;li&gt;Shader.CreateGPUProgram峰值开销：这种情况主要出现在Shader第一次渲染时。在Unity5.0以后，引擎为了避免Shader加载时过高的CPU峰值出现，已经将Shader.Parse和Shader.CreateGPUProgram两种操作分开执行，前者在Shader加载时，后者在Shader第一次渲染时。&lt;/li&gt;
      &lt;li&gt;渲染状态切换开销：这种情况是几乎每一帧都发生的，有渲染的地方就会有Material的切换。从问题图中可以看出，在运行的16000帧中，Material.SetPassFast一共被调用137万次。这里可以认为几乎全部是渲染时Material的切换操作。因此，该项较高的主要原因还是材质切换操作过多所致。所以，建议研发团队在报告中的详细材质页面查看是否有过多“冗余”的材质出现，如有则尽可能降低材质的使用冗余度。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-3&quot;&gt;渲染&lt;/h2&gt;
&lt;h4 id=&quot;shaderassetbundleshadershader-variantsshaderwarmupallshadersshadervariantcollectionwarmup&quot;&gt;将需要的Shader打到一个AssetBundle包中（包含一个关联了所有Shader的Shader Variants），分别用Shader.WarmupAllShaders和ShaderVariantCollection.WarmUp两种方式进行预加载，后者耗时更少。&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;根据官方的文档的描述，确实是ShaderVariantCollection的效率更高，详见：
https://docs.unity3d.com/Manual/OptimizingShaderLoadTime.html&lt;/li&gt;
  &lt;li&gt;因为在ShaderVariantCollection中，是可以给每个Shader添加指定的Keyword的，ShaderVariantCollection.WarmUp的调用只会对ShaderVariantCollection中指定的Keyword进行Warmup操作；而Shader.WarmupAllShaders则是对所有的Keyword全部进行Warmup操作（其中大多数很可能都不会用到）。&lt;/li&gt;
  &lt;li&gt;因此在Shader.WarmupAllShaders的文档中也提到，建议使用ShaderVariantCollection.Warmup来进行细粒度的Warmup操作，避免大量多余的Keyword被Warmup，造成严重的卡顿，大家可以参考下文：
https://docs.unity3d.com/ScriptReference/Shader.WarmupAllShaders.html&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;unity-56directional-modedirectional-specular&quot;&gt;在Unity 5.6版本中如何解决预渲染缺少高光的问题？该版本中光照预渲染Directional Mode选项中少了Directional Specular选项，渲染出来的效果场景缺少高光。&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;如果需要在使用Lightmap时渲染高光，替代方案是采用Mix Lights模式下的Shadow Mask以及Distance Shadow Mask选项。即将场景中的Directional Light改成Mix Lighting类型，并且在Lighting Mode选Shadow Mask或者Distance Shadow Mask。&lt;/li&gt;
  &lt;li&gt;其原理是：LIghtmap中仅仅存储indirect的光照，而direct光照是实时计算的，所以包括高光、阴影等都可以是实时的（阴影也可以是预计算好的）。这样做的好处是给Lightmap光照一定的灵活度，原来的Lightmap是完全静态的，现在是部分静态（direct的实时，indirect静态）。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;unity-5--shader-variant-collection-&quot;&gt;Unity 5 的 Shader Variant Collection 功能&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;经过测试，在较新的版本中（如Unity 5.5.3），将ShaderVariantCollection与Shader打包在相同的AssetBundle中后，其中会包含该Shader在ShaderVariantCollection中指定的Variant。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;shader-shader--shader-&quot;&gt;使用 Shader 变体之后，Shader 是否还能走资源更新？抑或 Shader 不推荐走资源更新？&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;使用 ShaderVariantCollection后依然可以进行资源更新（通过更新AssetBundle，来更新Shader的实现或者ShaderVariantCollection中包含的Variant）。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;shader--shader-always-include-&quot;&gt;Shader 变体和 Shader Always Include 的主要区别是什么？二者对内存和帧率影响如何？&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;ShaderVariantCollection与Always Included Shaders的区别主要在于打包时所包含的Variant。Always Included Shaders中的Shader，其所有的Variant都会被包含，好处是，理论上不会出现Variant丢失的情况；坏处是，会导致更大的发布包以及额外的内存占用，而影响最大的是手动进行Warmup时的耗时以及ShaderLab的内存占用。因此一般来说，对于Variant特别多的Shader（如Standard Shader），并不推荐放入Always Included Shaders中。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;unity-5-shader-bug&quot;&gt;在 Unity 5 较早的版本中，Shader 变体功能似乎有一些Bug，现在是否可靠？&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;目前即使是较新的版本，其可靠性我们也并不能确保，依然建议在使用前进行一些测试来验证。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;==PS: 需要关注的问题==&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 13 Nov 2017 09:22:09 +0800</pubDate>
        <link>https://caihua.tech/2017/11/13/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E5%8D%81%E4%BA%94%E5%91%A8/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/11/13/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E5%8D%81%E4%BA%94%E5%91%A8/</guid>
        
        <category>UWA</category>
        
        
      </item>
    
      <item>
        <title>每天一点UWA：动画重定向笔记</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;基本原理&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;动画重定向技术主要是针对骨骼动画的方案，由骨骼来描述动作信息，用蒙皮来表示模型网格与骨骼之间的关系，从而得到模型最终的样子。
&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2FAnimationRetargeting%2F2.png&quot; alt=&quot;image&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;PS：这张图很形象&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;动画就是每一帧为模型制作一个Pose（姿势），在每帧之间的姿势可以通过差值获得。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;最简单的情况：只有骨骼大小不一致的情况&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;此时因为骨骼在模型空间中具有一个对应的位置，因此以大人和小孩的骨骼为例，是没办法直接将大人的动画信息用在小孩的骨骼上的。&lt;/li&gt;
  &lt;li&gt;如何解决这个问题的呢？unity使用了一个参考姿势（通常情况下，会把T-Pose作为参考姿势）来计算不同大小骨骼之间的差值，然后应用到动画数据上。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;a1是A骨架的参考姿势，b1是B骨架的参考姿势，动画中某一帧的姿势是a2，我们想得到的结果是b2，我们认为，a2与参考姿势a1的差异应当和b2与其对应的参考姿势b1的差异相同，即：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;a2 - a1 = b2 - b1&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;我们可以得到计算过程为： b2 = a2 - a1 + b2 = a2 + (b1 - a1)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;参考姿势a1和b1都是提前得到的，因此可以进行预先计算好b1-a1的值。要知道这里的加法和减法要转换为每根骨骼的PRS计算，因此还是有不少CPU消耗的。下图给出了使用一个简单整数代替骨骼的PRS数据来模拟动画重定向的计算过程。
&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2FAnimationRetargeting%2F3.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;不同引擎的实现上可能不一样，文中提到了Havok的实现。&lt;/li&gt;
  &lt;li&gt;以上就解决了骨骼长度不一致的问题。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;真实的世界：骨骼名称、数量、父子关系不一致的情况&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;首先在如果项目中确定使用动画重定向，那么在模型制作时就需要约定好名称、数量和关系。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-3&quot;&gt;骨骼名称不一致&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;对于CS骨骼，由于在3DS Max中通常美术只会添加不同的前缀，因此可以通过去除前缀的方式进行模糊匹配来做骨骼映射；&lt;/li&gt;
  &lt;li&gt;Unity的做法细节不清楚，但是感觉会根据整个骨架的父子关系和结构来进行映射关系的计算；&lt;/li&gt;
  &lt;li&gt;而对于Bone骨骼，在没有预先定义好类似最大化骨骼这样规范的情况下，非常难通过程序来判断映射关系，可以提供可视化编辑的功能来让美术自己定义它们之间的映射关系。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-4&quot;&gt;骨骼数量不一致&lt;/h4&gt;

&lt;h5 id=&quot;cs&quot;&gt;在非CS骨骼或者不重要的部分存在多余的骨骼&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;如果动画文件的骨架中存在多余骨骼，通常的做法是把这些骨骼忽略掉，而如果目标骨架上存在多余的骨骼，即有些骨骼原始动画中并不存在，这其实没有办法为它生成动画，只需要保证其保留在原始姿势的local space当中，即让其跟着父骨骼移动。比如身上的飘带，如果原始动画中没有，在不使用布料系统等物理方案的情况下，只能让其按照参考姿势中的样子，“僵硬”地跟随角色移动。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-5&quot;&gt;在重要的位置存在骨骼不一致&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;多图，请直接看原文。解决的办法就是使用链式映射。&lt;/li&gt;
  &lt;li&gt;链式映射要做的就是将多根骨骼组成的骨链A和另外一个骨骼中多根骨骼组成的骨链B进行映射，做到整条B骨链的样子和A骨链的样子相近。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-6&quot;&gt;骨骼父子关系不一致&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;当两套骨骼的父子关系都不一致的情况下，其实很难得到正确的映射，简单的不一致可能可以容忍，但是可以想象，把一个人形骨骼的动画映射给四足动物甚至蜘蛛这样的八脚动物，是一件非常难做的事情。&lt;/li&gt;
  &lt;li&gt;也因为这样的原因，目前大范围应用的动画重定向，基本还是在人形骨骼上，当然，用相同的算法，把四足的战马动画映射到不同的体型的战马上也是可以的。基本的原则是骨架尽量具有更多的相似性，重定向的效果也就会更好。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;unity&quot;&gt;Unity中的重定向&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Unity引擎中动画重定向的实现不是一个直观的方法，而是封装在了Humanoid类型的动画系统里面，&lt;strong&gt;==也就是必须是人形的骨架、==使用Humanoid才可以使用它====&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;Unity没有像前文描述的基本原理那样去定义两套骨架之间的映射关系，而是自己在内部定义一套骨架模板，所有的Avatar骨骼都必须映射到这套模板上才可以由同一个Animator来驱动产生Retargeting之后的动画效果。&lt;/li&gt;
  &lt;li&gt;关于如何预览一个重定向之后的动画的效果，只能把模型放到Scene中，设置同一个Animator来观察。在动画文件的预览窗口，&lt;strong&gt;如果拖拽另外一个模型文件到其中，并不能预览到正确的效果。&lt;/strong&gt; PS：话说我以前都是这么干的。。&lt;/li&gt;
  &lt;li&gt;PS：具体操作过程参考原文或者unity文档吧，就是avatar设置那套流程。不过unity的avatar里面还能改变肌肉控制。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-7&quot;&gt;使用中的一些问题&lt;/h4&gt;
&lt;h5 id=&quot;humanoid&quot;&gt;角色的武器或者飘带在使用Humanoid类型的动画系统之后不会移动了，或者移动的位置有了很大的偏差。&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;这时候可以在动画文件的属性设置里，查看Mask下的Transform选项，里面可能存在没有被勾选的骨骼。目前的做法是把Transform下的所有骨骼对象都勾选上。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-8&quot;&gt;角色的武器在动作中出现了乱飘的情况，与手部无法紧密地绑定在一起&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;由于我们最初为了方便美术制作武器的动作，把其父骨骼设置给了盆骨这样一根相对稳定的骨骼，但是经过Retargeting计算之后，由于角色身材不同产生了一些偏差导致。最终我们还是把武器骨骼的父骨骼设置为手部的骨骼，才解决了这一问题。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-9&quot;&gt;某些角色在重定向之后的动画中表现为脚不贴地，和地面之间有缝隙，原始动画中没有&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;可能是重定向算法或者是参考姿势这两个因素导致&lt;/li&gt;
  &lt;li&gt;在avatar设置中，可以看看目标骨骼在T-POSS是否正常。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-10&quot;&gt;性能消耗&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;通过前面的原理分析可以看出，即使在有预计算的情况下，与普通的动画计算，Retargeting的过程还是有一定的CPU消耗的，但是这与通常会造成CPU瓶颈的蒙皮、渲染指令提交等相比，其实消耗并不算大。&lt;/li&gt;
  &lt;li&gt;Unity与Retargeting相关的还制作了肌肉控制的功能，Humanoid形式的动画系统相对于Generic形式的动画系统虽然有一部分额外的性能消耗，但是Unity内部做了比较好的优化，差别不是很大，因此可以放心使用。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-11&quot;&gt;补充&lt;/h2&gt;
&lt;h4 id=&quot;section-12&quot;&gt;一些概念&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;CAT和CS之前都是插件形式出现的&lt;/li&gt;
  &lt;li&gt;CS主要是用来创建两足动物的比如人类&lt;/li&gt;
  &lt;li&gt;CAT不但可以创建两足动物还能创建多足动物，这就是CAT相对于CS最大的优势了。&lt;/li&gt;
  &lt;li&gt;bones是3DMAX原始的骨骼系统，这个骨骼你需要自己手动创建才行，而CAT和CS可以自动生成&lt;/li&gt;
  &lt;li&gt;skin是蒙皮系统，就是用骨骼对模型进行蒙皮后模型和骨骼产生关联，这样模型就能跟着骨骼一起运动了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-13&quot;&gt;原文&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;https://blog.uwa4d.com/archives/AnimationRetargeting.html&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 08 Nov 2017 09:51:58 +0800</pubDate>
        <link>https://caihua.tech/2017/11/08/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E5%8A%A8%E7%94%BB%E9%87%8D%E5%AE%9A%E5%90%91%E7%AC%94%E8%AE%B0/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/11/08/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E5%8A%A8%E7%94%BB%E9%87%8D%E5%AE%9A%E5%90%91%E7%AC%94%E8%AE%B0/</guid>
        
        <category>UWA</category>
        
        
      </item>
    
      <item>
        <title>每天一点UWA：第十四周</title>
        <description>&lt;h2 id=&quot;assetbundle&quot;&gt;AssetBundle&lt;/h2&gt;
&lt;h4 id=&quot;assetbundleassetbundle&quot;&gt;AssetBundle划分过细的问题，比如每个资源都是AssetBundle。&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;加载IO次数过多，从而增大了硬件设备耗能和发热的压力；&lt;/li&gt;
  &lt;li&gt;Unity 5.3 ~ 5.5 版本中，Android平台上在不Unload的情况下，每个AssetBundle的加载，其每个文件的SerializedFile内存占用均为512KB（远高于其他平台），所以当内存中贮存了大量AssetBundle时，其SerializedFile的内存占用将会非常巨大。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;buildassetbundleoptionsdisablewritetypetree&quot;&gt;BuildAssetBundleOptions.DisableWriteTypeTree这个选项的实际用处是什么？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;在Unity 5.x版本中，AssetBundle在制作时会默认写入TypeTree信息，这样做的好处是可以保证AssetBundle文件的向下兼容性，即高版本可以支持以前低版本制作的AssetBundle文件。&lt;/li&gt;
  &lt;li&gt;所以，如果开启DisableWriteTypeTree选项，则可能造成AssetBundle对Unity版本的兼容问题，虽然关闭TypeTree会使Bundle更小，但我们一般都不建议研发团队在制作AssetBundle文件时开启该选项。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;assetbundlecscriptpublicassetbundlescriptassetbundlecsmd5&quot;&gt;我们项目做AssetBundle打包时，发现如果资源所依赖的C#Script的Public成员变量有变化时，用新代码加载旧的AssetBundle就会不兼容。有没有什么方法能判断这些Script在变化时是否需要重新打AssetBundle呢？目前我们使用.CS文件的MD5来判断是否需要重新打包，但其实这样应该有很多不必要的重复打包，对吗？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;该问题的本质原因是新代码的序列化信息变化所致。建议研发团队使用Unity 5的新的AssetBundle打包方式，默认情况下，Unity 5引擎会自动检测其脚本的序列化信息是否进行改变，从而自动进行增量打包。&lt;/li&gt;
  &lt;li&gt;PS: 虽然已经可以通过升级来解决，但是这个是个需要关注的点。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;assetbundle-1&quot;&gt;AssetBundle颗粒度问题&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;详见https://blog.uwa4d.com/archives/TechSharing_59.html 第一个问题&lt;/li&gt;
  &lt;li&gt;总结一下：
    &lt;ul&gt;
      &lt;li&gt;不要一个资源一个AssetBundle，因为Android上面一个serializedFile有512k,但是5.6后应该是32k。不过实际测试的情况是不一定是32K。WTF。。&lt;/li&gt;
      &lt;li&gt;对于AssetBundle小于1MB的限制在5.4后没意义，之前是因为www走webstream，会导致内存中占用AssetBundle大小4-5倍的空间。但是LZ4后基于其Chunk的加载特点，AB加载很快，且内存占用要比之前小很多。&lt;/li&gt;
      &lt;li&gt;仍旧需要注意的：&lt;/li&gt;
      &lt;li&gt;对于需要热更新的AB，也如问答中其他朋友的所言，要考虑实际情况控制AB的大小；- PS:可能是考虑网络下载的问题，以为过大的文件如果不做断点续传会是恶梦。&lt;/li&gt;
      &lt;li&gt;即便是LZ4的AB，其加载方式不同，加载效率也可能完全不一致。&lt;/li&gt;
      &lt;li&gt;对于AB的打包，尽可能把逻辑上同时出现（一个Prefab中非Share的Asset）、小而细碎的资源（Shader、Material、粒子系统等）尽可能打包在一起，并通过LoadAll来进行加载，因为这样会带来更好的加载效率。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;loadfromcacheordownloadversion&quot;&gt;使用LoadFromCacheOrDownload时如果用version参数，缓存的资源如何清除。&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;AssetBundle，其Version版本号变化时，新的解压Data是不会覆盖旧的解压Data的。清除旧的解压Data主要有三种方式：
    &lt;ul&gt;
      &lt;li&gt;设置缓存的过期日期，默认情况下是150天；&lt;/li&gt;
      &lt;li&gt;调用Caching.CleanCache来全部清空缓存；&lt;/li&gt;
      &lt;li&gt;当本地Cache已满时，Unity会从最早的AssetBundle来进行自动清理。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;wwwloadfromcacheordownloadsystemstring-url-int32-versionunity-4x500unityunity-5x-&quot;&gt;WWW.LoadFromCacheOrDownload(System.String url, Int32 version)这个接口加载资源，如果是Unity 4.x的版本，会有500个资源的数量限制，如果超过这个限制，Unity会删除之前缓存的每个资源，是这样吗？那在Unity 5.x 版本上是否还存在这样的问题呢？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;在Unity 4.x的版本中，如果通过LoadFromCacheOrDownload来加载AssetBundle，那么有两种情况需要考虑：
  -内存中加载的AssetBundle数量。在iOS平台上，通过该接口加载、同时存在于内存中的AssetBundle数量确实是有限的，接近300个，这是由于iOS上文件句柄数的限制导致。而该限制在Unity 5.0以后则被完善了，因为Unity 5引入了虚拟文件系统，所以不再有这个限制；在Android平台上，则没有这个限制，或者说数量限制值非常大，基本可以忽略。
    &lt;ul&gt;
      &lt;li&gt;本地Cache中缓存的AsseBundle数量。无论是iOS、Android还是PC版本，都没有500的数量限制，而是有一个硬盘占用大小限制。具体来说，在WebPlayer平台上，有50MB的缓存限制，而在其他平台上，则是4GB的缓存限制。所以只要硬盘占用大小不超过限定值即可。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;font&quot;&gt;Font&lt;/h2&gt;
&lt;h4 id=&quot;unity-534p6uguiatexttextdisableloada-managedstaticrefrences-font-textdisableafont&quot;&gt;我们在内存优化时发现一个问题，编辑器版本 Unity 5.3.4p6，使用UGUI，场景A中一个Text控件使用自定义字体资源，然后把该控件Text属性勾选为空（disable），再Load一个空场景，看场景A卸载后在内存中的残留，发现有一份引用是 ManagedStaticRefrences（）的 Font 内存。如果不是把Text属性disable，则场景A卸载后内存里不会再残留被引用的Font内存，请问可能是什么原因造成的呢？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;UWA对于该例子进行了检测，的确能够在 Editor 复现。查了下 UGUI 代码，能对 Font 产生引用的，主要是这个函数 FontUpdateTracker.TrackText(Text)，其中会把 t.font 引用起来；而对应的解引用的函数为 FontUpdateTracker.UntrackText。因此，如果出现了两者的调用不匹配，就有可能造成 font 的 ManagedStaticRefrences 引用。&lt;/li&gt;
  &lt;li&gt;进一步查看后，可以看到在定义了 UNITY_EDITOR 宏时，UI 元素会增加一个名为 OnValidate 的函数，Text 组件则在其中进行了 TrackText 的操作。
而最关键的是，该函数在 Text 组件以“未激活”的状态被实例化时同样会被触发，同时，如果这样的 Text 组件在后续没有被激活过就被销毁，其 OnDestroy 和 OnDisable 函数是不会被调用的，参见文档中的这句话：OnDestroy will only be called on game objects that have previously been active.
而 OnDisable 中才会调用 Untrack 解引用，所以造成了不匹配，导致了 font 的 ManagedStaticRefrences。&lt;/li&gt;
  &lt;li&gt;但是，OnValidate 函数只在 Editor 上才有，真机上不会发生上面说到的不匹配的情况。所以建议研发团队先在真机上测试下是否还有这种情况，如果确实没有，那么就忽略该问题即可。&lt;/li&gt;
  &lt;li&gt;PS:Mark&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;gameplay&quot;&gt;Gameplay&lt;/h2&gt;
&lt;h4 id=&quot;mask&quot;&gt;我想了解如何使用顶点色Mask控制明暗关系，才能达到类似崩坏琪亚娜效果？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;https://blog.uwa4d.com/archives/TechSharing_60.html 第五个问题，NB&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ui&quot;&gt;UI&lt;/h2&gt;
&lt;h4 id=&quot;nguihud600panel2drawcall&quot;&gt;我们游戏中用到NGUI的HUD，单位主要是一个进度条和一个倒计时文本(持续更新)，同屏数量达600左右，单位本身在持续移动。现已将这些设置为独立Panel，且只有2个DrawCall(进度条所在图集和文本)，但还是卡顿得很厉害，请问是否有优化的方法？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;简化元素的几何：进度条中的元素尽量避免Sliced 模式（改Simple）；倒计时部分如果使用了Outline或者Shadow，将其转为“图片字”；&lt;/li&gt;
  &lt;li&gt;降低更新频率：如倒计时按“秒”统一更新；进度条按1%甚至5%的间隔更新一次；移动速度较慢时可以尝试隔帧更新位置等；&lt;/li&gt;
  &lt;li&gt;拆分子UIPanel：尽可能将更新频率相同的UI元素放在一个UIPanel中，从而降低每次更新时涉及到的UI元素数量。具体的拆分数量，则可能要通过较多的测试来确定。需要说明的是，此处即使增加10到20个DrawCall，对渲染上的影响并不大。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;粒子&lt;/h2&gt;
&lt;h4 id=&quot;prefab100-200gameobjectgameobjectprefab&quot;&gt;我们项目中有大量的特效，一个特效Prefab可能包含100-200个GameObject，每个GameObject上都挂有一个粒子系统，但是实际上很多特效只有延时和坐标旋转之类的参数的区别。我看了Prefab文件后发现每个粒子系统分别记录了各自的信息，从而导致整体文件很大，内存占用也比较大。请问是否有优化的方法？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;如果开发的是一个手游项目，那么一个Prefab下含有100-200个粒子系统是非常不足取的，主要会造成以下几种问题：
    &lt;ul&gt;
      &lt;li&gt;同时播放100个以上的ParticleSystem，其ParticleSystem.Update本身的CPU占用会很高。下图为一款游戏在华为6Plus上的表现。可以看到Active Particle数量还没有达到100，其Update耗时就已经占到了5ms；&lt;/li&gt;
      &lt;li&gt;ParticleSystem.ScheduleGeometryJobs开销会很高。其耗时主要体现在渲染模块中的Culling阶段，与粒子系统的数量相关，场景中Active粒子系统的数量越多，其开销越高；&lt;/li&gt;
      &lt;li&gt;子线程中的渲染压力较大。Unity5.3版本以后，粒子系统的渲染虽然在主线程中占用很小，但并不意味它没有耗时，其耗时在渲染线程中，当渲染线程压力过大时，主线程同样会出现等待（Gfx.WaitForPresent），因此同样可能对帧率产生影响；&lt;/li&gt;
      &lt;li&gt;GPU的渲染压力较高。同屏中渲染的粒子系统越多，其屏幕每帧的填充率越高，从而更加容易造成设备的发热；&lt;/li&gt;
      &lt;li&gt;内存压力较高。如果一个Prefab上有100-200个粒子系统，并且如果场景中有10个以上这样的Prefab存在，那么其内存占用将在10~25MB内存区间内。就目前而言，粒子系统仍然是以Clone的形式存在，所以虽然粒子系统可能仅仅是某些参数不同，但其仍然是多个不同的粒子系统。因此，我们在UWA报告中会显示粒子系统在项目运行时的具体显示数量，以方便研发团队对粒子系统进行关注。如下图所示，一般来说，每帧中粒子系统的数量建议在400以下。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;模型&amp;amp;动画&lt;/h2&gt;
&lt;h4 id=&quot;fbxreadwrite-staticbatchingutilitycombinemesh&quot;&gt;网格模型FBX文件在不开启Read/Write选项时， 如果通过StaticBatchingUtility的CombineMesh来合批的话，内存会增加么？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;增加内存，主要表现在内存中CombinedMesh的增加以及一定量堆内存的增加。&lt;/li&gt;
  &lt;li&gt;该API使用的前提必须是网格Fbx模型开启Read/Write，如果不开启，则无法读到网格数据，进而不能完成网格的拼合操作。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-2&quot;&gt;如下图，请问这几个参数的单位是什么？&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog/TechSharing_58/2.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Rotation Error使用角度（degree）作为单位。Position和Scale是距离偏差的百分比（曲线调节前后的距离偏差与某距离值之比，取决于Unity内部实现），取值范围1~100，但实际可以高于100，并有作用。
我们建议研发团队在调节该误差时，将调节前后的动画效果进行对比，使文件体积压缩得尽量小，同时使动画效果在视觉上偏差不会太大。&lt;/li&gt;
  &lt;li&gt;PS:没找到，可能是动画导入的选项。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;resamplecurves&quot;&gt;如下图，这个ResampleCurves选项的作用，以及是否和对内存性能的影响？&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog/TechSharing_58/1.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;ResampleCurves选项是在Unity 5.3版本后加入的，在之前的版本中是隐藏并且默认勾选的。该选项会改变Unity动画数据的存储方式。&lt;/li&gt;
  &lt;li&gt;动画文件在导入到Unity之前，其关键帧的数据通常是以欧拉角（Euler format）的方式存储。在勾选该选项时导入，Unity会将欧拉角转换为四元数（Quaternion）表示，并且会生成逐帧的数据（不只是关键帧）。新生成的逐帧数据是为了解决四元数插值问题。关闭该选项会使动画文件保持欧拉角表示，但在应用于GameObject时仍会转换为四元数。&lt;/li&gt;
  &lt;li&gt;建议保持默认勾选该选项，只有当发现Unity中的动画播放效果与在动画编辑工具中的效果出现较大偏差时，尝试取消该选项，查看是否是该选项的原因导致动画偏差。我们在测试中发现该选项对运行性能影响并不明显。在内存方面，勾选该选项会使动画文件略微增加。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;scale&quot;&gt;动画提出scale&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;参见https://blog.uwa4d.com/archives/TechSharing_58.html第五个。&lt;/li&gt;
  &lt;li&gt;PS:很不错。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;animatorsprocessanimationsjobanimatorswritejobcpu&quot;&gt;动画模块中，Animators.ProcessAnimationsJob和Animators.WriteJob的CPU占用较高，这些与什么因素有关？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Animators.WriteJob受模型骨骼数目影响较大（受animation curves影响不明显），骨骼数目越多，该函数耗时越大。同时，开启Optimize GameObject选项能够降低该函数耗时。Animators.ProcessAnimationsJob 同样受骨骼数目影响较大，同时也受animation curves数目影响，二者数目越多，该函数耗时越大。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-3&quot;&gt;性能综合&lt;/h2&gt;
&lt;h4 id=&quot;cpugpugpuprofiler&quot;&gt;在整体的性能消耗上，CPU和GPU各占一半合理吗？如果不是，各占多少为好？还是说需要根据机型来看？其次，我如何知道游戏在手机上的GPU消耗？Profiler是看不到的，有工具推荐吗？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;首先，CPU和GPU是并行的，也就是CPU在运算的时候GPU也在运算，一帧的结束时间是两者中比较晚结束的那个。因此，一般我们在考虑这个问题的时候，经常会说是CPU bound还是GPU bound，也就是GPU在等CPU还是CPU在等GPU。&lt;/li&gt;
  &lt;li&gt;最理想的情况是两者都并行均衡，且都没有出现互相等待的情况。但在目前的大多数移动游戏中，都是CPU耗时为主要性能瓶颈。这也是为什么有多线程渲染的原因，多线程渲染就是利用CPU端的并行性，让CPU处理得更快，不拖后腿。&lt;/li&gt;
  &lt;li&gt;对于GPU的压力分析，可以尝试用Intel GPA，Mali或者高通出的针对自家芯片的工具。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;unityprefabgc-allocated&quot;&gt;为什么Unity里实例化一个Prefab会产生那么多GC Allocated?&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;这是一个特例，但是从里面可以总结出一个问题，就是在Instantiate一个对象时会发生或者&lt;strong&gt;可能发生&lt;/strong&gt;以下的事情
    &lt;ul&gt;
      &lt;li&gt;序列化和反序列化的处理，因为用prefab生成对象本身就是需要反序列化的。而直接clone一个对象可能还有先序列化在反序列化。&lt;/li&gt;
      &lt;li&gt;可能的资源的加载，比如prefab上用到的mesh、贴图等。&lt;/li&gt;
      &lt;li&gt;可能的shader编译，如果用了一个之前没有用过的shader就会实时的编译。&lt;/li&gt;
      &lt;li&gt;对象身上脚本的初始化。如果实例化一个prefab发现很占用时间要注意是不是脚本里面在awake或者start里面的功能太多了。&lt;/li&gt;
      &lt;li&gt;UI界面的Active和Deactive也会造成UI代码底层的一些相关OnEnable和OnDisable操作，同样会造成一定的堆内存分配。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-4&quot;&gt;渲染&lt;/h2&gt;
&lt;h4 id=&quot;unityskip&quot;&gt;Unity的材质的宏是有材质用到时才会被编译吗？还是说不手动Skip都会编译？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;在Unity中shader variant也包含两种类型，一种是通过 shader_feature 定义，一种是通过 multi_compile 定义。而只有通过 shader_feature 定义的 variant 在发布时会根据其使用情况来进行剥离。&lt;/li&gt;
  &lt;li&gt;具体可见Unity官方的文档：https://docs.unity3d.com/Manual/SL-MultipleProgramVariants.html&lt;/li&gt;
  &lt;li&gt;需要注意的是，放在Always Included Shaders中的Shader，其包含的所有 variant 都不会被剥离，因此对于Standard Shader这类包含了大量 shader_feature的Shader，不推荐将其放入。&lt;/li&gt;
  &lt;li&gt;PS:没有回答根本的问题：
    &lt;ul&gt;
      &lt;li&gt;Editor中：修改shader并保存时立即编译。
  Runtime下，无论哪个平台，都是在进入场景时加载shader object内容到内存，但是首次实际调用渲染时才编译，编译完成之后会cache下来。
  有两种优化方法：
  调用Shader.WarmupAllShaders()，自动编译该场景中用到的所有shader。该方法在Unity5中已经废弃。
  在项目设置的GraphicsSettings中，可以导出ShaderVariantCollection，并在Preloaded Shader中导入，这样的话就可以在载入场景时一并编译需要预加载的shader，这样的优化在移动平台上用得比较多。
  具体见&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;cpugfxwaitforpresent&quot;&gt;听说移动端开启多线程，把后期效果移动到渲染线程会节省后期的消耗。我测试了一下，虽然主线程中后期显示的CPU占用降低了，但是却多了Gfx.WaitForPresent的时间，最后两者相加基本还是一样的。那开启多线程这个功能，对后期到底有没有帮助呢？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;开启多线程渲染一般情况下会极大降低主线程的渲染耗时，但并不会降低其本身的总体计算量。因为这并不是底层算法或硬件上的提升，而是将部分计算从主线程搬到了子线程。所以，开启多线程的好处在于为主线程带来了大量空间来执行其他耗时模块（如代码逻辑等）。&lt;/li&gt;
  &lt;li&gt;但这并不意味着开启多线程渲染就“万事大吉”。如果渲染模块本身开销就很高，那么子线程一样会很耗时，更有可能出现主线程等待子线程的现象，也就是WaitForPresent开销较高的情况。所以，开启多线程是会降低主线程的渲染压力，但其帧率未必会大幅提升，还需研发团队自行在自己项目中进行尝试和比较。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 05 Nov 2017 10:07:00 +0800</pubDate>
        <link>https://caihua.tech/2017/11/05/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E5%8D%81%E5%9B%9B%E5%91%A8/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/11/05/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E5%8D%81%E5%9B%9B%E5%91%A8/</guid>
        
        <category>UWA</category>
        
        
      </item>
    
  </channel>
</rss>
