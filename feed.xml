<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>笛音夏扇</title>
    <description>Be publicly useful and privately happy.</description>
    <link>https://caihua.tech/</link>
    <atom:link href="https://caihua.tech/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sat, 17 Dec 2016 19:49:17 +0800</pubDate>
    <lastBuildDate>Sat, 17 Dec 2016 19:49:17 +0800</lastBuildDate>
    <generator>Jekyll v3.2.1</generator>
    
      <item>
        <title>游戏设计模式读书笔记：一</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;架构、性能、游戏&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;在开始读第一章的时候会觉得有点混乱，作者提出了什么是架构这个问题，但是并没有像其它书里那样给出一个明确的定义，而是提到了：&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;这本书是关于上面这一切要使用的代码的组织方式。这里少谈代码，多谈代码组织。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;仔细品读这句话，你会发现这里面其实已经提到了什么是架构：所谓架构就是代码的组织方式。但是从我个人的认识来看这并不够全面，在这里在引用几段&lt;a href=&quot;http://www.infoq.com/cn/arch-talk&quot;&gt;《架构漫谈》&lt;/a&gt;中的文字来阐述什么是架构：&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;在每个人都必须自己完成所有生活必须品的生产的时候，是没有架构
的(当然在个人来讲，同一时刻只能做有限的事情，在时间上还是可能会
产生架构的)。一旦产生的分工，就把所有的事情，切分成由不同角色的什么是架构
人来完成，最后再通过交易，使得每个个体都拥有生活必须品，而不需要
每个个体做所有的事情，只需要每个个体做好自己擅长的事情，并具备一
定的交易能力即可。&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;blockquote&gt;
      &lt;p&gt;这实际上就形成了社会的架构。那么怎么定义架构呢?以上面这个例
子为例，把一个整体(完成人类生存的所有工作)切分成不同的部分(分 工)，由不同角色来完成这些分工，并通过建立不同部分相互沟通的机制， 使得这些部分能够有机的结合为一个整体，并完成这个整体所需要的所有 活动，这就是架构。&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;blockquote&gt;
      &lt;p&gt;软件架构实际上包括了:代码架构， 以及承载代码运行的硬件部署架构。实际上，硬件部署架构最终还是由代 码的架构来决定。因为代码架构不合理，是无法把一个运行单元分拆出多 个来的，那么硬件架构能分拆的就非常的有限，整个系统最终很难长的更大。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;关于架构和性能的冲突，我认为这个点写的很好，可以说我之前没有这样的认识。长久以来我都希望写出非常面向对象的代码，在我长久的认知中，代码的灵活性、高扩展性和可维护性是最重要的，因此设计模式是我在编写代码时所追求的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;但是作者提出良好的架构是需要很大的代价的，因为这需要遵守一些列的准则，Coder必须谨慎的组织代码，而且在引入了抽象，引入了可扩展性，引入的某个设计模式时，我们在增加了代码的灵活性的同时也增加了不可读性，增加了代码复杂度，这就增加了理解的难度。过度的架构设计往往会导致代码库失控，也许你会看到接口和抽象无处不在，我们可能需要花费大量时间才能找到真正功能的代码。关于这一点我也是深有体会，最近在看UniRx库，发现各种接口齐飞，大量的重载，梳理起来确实很费劲。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;同时，从代码本身执行角度来说，灵活的代码往往意味着执行速度比较慢。从UNITY的角度来说，因为有类似CLR的东西，当使用面向接口编程时，往往意味这具体类型的判断需要在运行期，JIT做的越多，性能也越差。而且还很可能导致无法实现代码缓存，每次运行都需要实时的做判定。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-1&quot;&gt;原型代码&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;原型代码中可能包含大量的一次性代码，但是原型代码往往意味着不可维护，必须被重写。目前在项目的开发过程中，往往出现原型代码被最终使用在项目中，简直就是灾难。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-2&quot;&gt;寻求平衡&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;快速编写出的代码未必是执行最快的代码，而且这样的代码在后面往往需要花费很多时间来优化，这都是需要时间的。这些都需要平衡。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;我们在工作中就是在不断的寻找平衡，有时候看到自己写的或者别人写的代码，就想去重构一下，但是现实又往往不给这个时间。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sat, 17 Dec 2016 19:45:25 +0800</pubDate>
        <link>https://caihua.tech/2016/12/17/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E4%B8%80/</link>
        <guid isPermaLink="true">https://caihua.tech/2016/12/17/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E4%B8%80/</guid>
        
        <category>游戏设计模式读书笔记</category>
        
        
      </item>
    
      <item>
        <title>由一个美术需求引发的Custom Inspector</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;需求&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Editor模式下，在运行或者非运行状态下，能够按照指定的变化率来自动改变material中属性数值。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-1&quot;&gt;需求分析&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;如何在Editor模式下获得一个游戏对象及其组件，尤其是在非运行状态下？我们知道在Unity IDE运行起来后是很容易获得一个对象和组件的，在GameObject上挂一个脚本即可。但是在非运行状态下呢，&lt;code class=&quot;highlighter-rouge&quot;&gt;transform.GetComponent &lt;/code&gt;这样的方法怎么执行？好在unity已经为我们考虑到了这个问题，提供了&lt;code class=&quot;highlighter-rouge&quot;&gt;[ExecuteInEditMode]&lt;/code&gt;Attribute，通过指定这个attribute使得组件类中的方法可以在edit模式下执行，并且是在非运行状态下的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如何在非运行状态下匀速改变数值呢？update方法中配合&lt;code class=&quot;highlighter-rouge&quot;&gt;Time.deltaTime&lt;/code&gt;是一个完美的方案，但是即使设置了&lt;code class=&quot;highlighter-rouge&quot;&gt;[ExecuteInEditMode]&lt;/code&gt;，update的表现在非运行和运行时也是完全不同的，查资料看到&lt;a href=&quot;https://docs.unity3d.com/ScriptReference/ExecuteInEditMode.html&quot;&gt; is only called when something in the scene changed. &lt;/a&gt;这句话时也有种吐槽的冲动。好在unity又为大家考虑到了这个问题（话说unity editor确实功能强大，AssetAtore里面那些插件真是厉害）,Edit模式下提供了&lt;code class=&quot;highlighter-rouge&quot;&gt;EditorApplication.update&lt;/code&gt;，这是一个事件，我们注册一个自己的方法就可以在非运行状态下实现update的功能。我个人比较推荐使用&lt;a href=&quot;https://gist.github.com/benblo/10732554&quot;&gt;EditorCoroutine&lt;/a&gt;，一个基于&lt;code class=&quot;highlighter-rouge&quot;&gt;EditorApplication.update&lt;/code&gt;的协程实现。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-2&quot;&gt;功能实现&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;使用一个自定义组件来实现material中数值的修改，这个类在UI上要体现出能够设置变化速率和初始值。并且在UI上通过点击按钮的形式来触发改变。&lt;/li&gt;
  &lt;li&gt;使用Custom Inspector来实现组件UI的自定义。&lt;/li&gt;
  &lt;li&gt;在运行状态下通过使用默认的update来实现匀速变化，在非运行状态下通过使用EditorCoroutine来实现。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-3&quot;&gt;代码实现&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;using UnityEngine;
using System.Collections;
using UnityEditor;
public class UVAnimation : MonoBehaviour
{

    public Vector2 TilingSpeed = new Vector2(1, 1);
    public Vector2 OffsetSpeed = new Vector2(0.1f, 0.1f);

    public Vector2 Tiling = new Vector2(1, 1);
    public Vector2 Offset = new Vector2(0, 0);

    float rate = 0.02f;

    EditorCoroutine coroutineOffset;
    EditorCoroutine coroutineTiling;

    bool isOffset = false;
    bool isTiling = false;

    // Use this for initialization
    void Start()
    {
    }

    // Update is called once per frame
    void Update()
    {

    }

    void FixedUpdate()
    {
        if (isOffset)
        {
            transform.GetComponent&amp;lt;Renderer&amp;gt;().sharedMaterials[0].mainTextureOffset += OffsetSpeed * Time.deltaTime;
        }
        if (isTiling)
        {
            transform.GetComponent&amp;lt;Renderer&amp;gt;().sharedMaterials[0].mainTextureScale += TilingSpeed * Time.deltaTime;
        }
    }

    public void ChangeOffset()
    {
        if (EditorApplication.isPlaying)
        {
            isOffset = true;
        }
        else
        {
            if (coroutineOffset != null)
            {
                coroutineOffset.stop();
            }
            coroutineOffset = EditorCoroutine.start(ChangeOffsetCoroutine());
        }

    }

    IEnumerator ChangeOffsetCoroutine()
    {
        while (true)
        {
            yield return new WaitForSeconds(rate);
            transform.GetComponent&amp;lt;Renderer&amp;gt;().sharedMaterials[0].mainTextureOffset += OffsetSpeed * rate;
        }
    }

    public void ChangeTiling()
    {
        if (EditorApplication.isPlaying)
        {
            isTiling = true;
        }
        else
        {
            if (coroutineTiling != null)
            {
                coroutineTiling.stop();
            }
            coroutineTiling = EditorCoroutine.start(ChangeTilingCoroutine());
        }
    }

    IEnumerator ChangeTilingCoroutine()
    {
        while (true)
        {
            yield return new WaitForSeconds(rate);
            transform.GetComponent&amp;lt;Renderer&amp;gt;().sharedMaterials[0].mainTextureScale += TilingSpeed * rate;
        }
    }

    public void SetOffset()
    {
        transform.GetComponent&amp;lt;Renderer&amp;gt;().sharedMaterials[0].mainTextureOffset = Offset;
    }

    public void SetTiling()
    {
        transform.GetComponent&amp;lt;Renderer&amp;gt;().sharedMaterials[0].mainTextureScale = Tiling;
    }

    public void Reset()
    {
        isOffset = false;
        isTiling = false;
        transform.GetComponent&amp;lt;Renderer&amp;gt;().sharedMaterials[0].mainTextureScale = new Vector2(1, 1);
        transform.GetComponent&amp;lt;Renderer&amp;gt;().sharedMaterials[0].mainTextureOffset = new Vector2(0, 0);
        if (coroutineOffset != null)
        {
            coroutineOffset.stop();
        }
        if (coroutineTiling != null)
        {
            coroutineTiling.stop();
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;using UnityEngine;
using System.Collections;
using UnityEditor;

[CustomEditor(typeof(UVAnimation))]
public class UVAnimationBuilderEditor : Editor {


	public override void OnInspectorGUI ()
	{
	   base.OnInspectorGUI ();
		//DrawDefaultInspector ();
		UVAnimation uva = (UVAnimation)target;

		if (GUI.changed) {
			uva.SetTiling ();
			uva.SetOffset ();
		}

		if (GUILayout.Button(&quot;Change Tiling&quot;)) {
			uva.ChangeTiling ();	
			EditorUtility.SetDirty (target);
		}

		if (GUILayout.Button(&quot;Change Offset&quot;)) {
			uva.ChangeOffset ();
		}

		if (GUILayout.Button(&quot;Reset&quot;)) {
			uva.Reset ();
		}
	}
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-4&quot;&gt;代码解析&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[CustomEditor(typeof(UVAnimation))]&lt;/code&gt;为UVAnimation创建的Editor类，在这个类里面可以修改UVAnimation类的UI，可以调用UVAnimation类中的方法。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;OnInspectorGUI&lt;/code&gt;方法，顾名思义在里面可以对UI进行编程，注意一下这个方法会自己生产一句代码&lt;code class=&quot;highlighter-rouge&quot;&gt;base.OnInspectorGUI ();&lt;/code&gt;，我所注释掉的&lt;code class=&quot;highlighter-rouge&quot;&gt;DrawDefaultInspector ();&lt;/code&gt;这句代码都是用来绘制默认UI的，二者只可留其一。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;transform.GetComponent&amp;lt;Renderer&amp;gt;().sharedMaterials&lt;/code&gt;在edit模式下获取材质球的对象需要用&lt;code class=&quot;highlighter-rouge&quot;&gt;sharedMaterials&lt;/code&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;mainTextureScale&lt;/code&gt;对应的就是UI上的Tiling。命名这让人吐槽。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 19 Nov 2016 15:52:25 +0800</pubDate>
        <link>https://caihua.tech/2016/11/19/%E7%94%B1%E4%B8%80%E4%B8%AA%E7%BE%8E%E6%9C%AF%E9%9C%80%E6%B1%82%E5%BC%95%E5%8F%91%E7%9A%84Custom-Inspector/</link>
        <guid isPermaLink="true">https://caihua.tech/2016/11/19/%E7%94%B1%E4%B8%80%E4%B8%AA%E7%BE%8E%E6%9C%AF%E9%9C%80%E6%B1%82%E5%BC%95%E5%8F%91%E7%9A%84Custom-Inspector/</guid>
        
        <category>Unity3D</category>
        
        
      </item>
    
      <item>
        <title>代码生成AnimatorController</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;0.出发点&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;现在的项目需要设置多套动画组合，全部是由策划在XML文件中设置完成，如果完全的手动在AnimatorController中去做不但工作量大而且如果将来有配置修改了还要一个个去找到对应的自状态机并且修改。因此就萌生了用代码去生成状态机的想法，而且在网上也有了很多的教程可以参考，只是每个项目都不同，且对于一些参数和属性的设置也不尽相同，因此还是把自己的代码进行一些修改后分享出来，基本上应该是包含了状态机常用的功能。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;需要注意我的具体代码中是在一个已有的AnimatorController基础上创建的。如果完全是从0开始可以参考别的资料，其实道理是一样的都是代码创建对象。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-1&quot;&gt;1.数据来源&lt;/h3&gt;

&lt;p&gt;一个典型的XML文件&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;config&amp;gt;&lt;/span&gt;
	&lt;span class=&quot;nt&quot;&gt;&amp;lt;datas&amp;gt;&lt;/span&gt;
		&lt;span class=&quot;nt&quot;&gt;&amp;lt;data&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;INDEX=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;1&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Clip1=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;jump&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Clip1Count=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;1&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Clip2=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;BackLeap&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Clip2Count=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;2&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Clip3=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;die&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Clip3Count=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;1&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/data&amp;gt;&lt;/span&gt;
		&lt;span class=&quot;nt&quot;&gt;&amp;lt;data&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;INDEX=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;2&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Clip1=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;BackLeap&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Clip1Count=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;3&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Clip2=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;jump&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Clip2Count=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;0&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Clip3=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;jump&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Clip3Count=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;0&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/data&amp;gt;&lt;/span&gt;
		&lt;span class=&quot;nt&quot;&gt;&amp;lt;data&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;INDEX=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;3&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Clip1=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;BackLeap&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Clip1Count=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;1&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Clip2=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;ForwardLeap&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Clip2Count=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;1&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Clip3=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;jump&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Clip3Count=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;1&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/data&amp;gt;&lt;/span&gt;
	&lt;span class=&quot;nt&quot;&gt;&amp;lt;/datas&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/config&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-2&quot;&gt;2.动画控制器中的主要元素&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Unity中editor的功能十分的强大，能够加载项目中的各种资源，而AnimatorController就是其中之一。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;一个AnimatorController的结构基本如下
&lt;img src=&quot;http://images2015.cnblogs.com/blog/23250/201611/23250-20161112184411358-1002723478.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;AnimatorControllerLayer：一个AnimatorController由多个Layer组成，但是除了BaseLayer外其它的Layer并不主要负责动画逻辑，而是多用于动画遮罩。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;AnimatorControllerParameter：顾名思义是状态机中使用的参数，这个参数可以在不同的Layer和子状态机中使用。在代码添加参数时会选择参数类型，它是个枚举&lt;code class=&quot;highlighter-rouge&quot;&gt;AnimatorControllerParameterType&lt;/code&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;AnimatorStateMachine：动画状态机，核心逻辑实线层。在一个状态机中可以有多个state，也可以有多个Sub AnimatorStateMachine。通过AddStateMachine方法来生成并添加子状态机。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;AnimatorState：动画状态，也是这个系统中的基础单元。其可以设定各种属性，比较常用的是AnimationClip和Speed等。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;AnimatorStateTransition：也就是动画转换，其中可以设定触发参数，而且其中还有一个很重要的东西就是动画过度的设定。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-3&quot;&gt;3.完整代码&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;using UnityEngine;
using System.Collections;
using UnityEditor;
using System;
using UnityEditor.Animations;
using System.IO;
using System.Xml;
using System.Text.RegularExpressions;
using System.Xml.Serialization;
using System.Collections.Generic;
using System.Linq;

//[CustomEditor(typeof(EditorTools))]
public class EditorTools : MonoBehaviour
{
	#region 创建动画控制器

	/// &amp;lt;summary&amp;gt;
	///  记录上一个state，用于自状态机中
	/// &amp;lt;/summary&amp;gt;
	static AnimatorState lastAnimatorState = null;
	static string ParameterName;
	// 动画片段
	static AnimationClip die;
	static AnimationClip jump;
	static AnimationClip BackLeap;
	static AnimationClip ForwardLeap;
	/// &amp;lt;summary&amp;gt;
	/// base layer AnimatorStateMachine
	/// &amp;lt;/summary&amp;gt;
	static AnimatorStateMachine mainASM;
	static int stateHeight = 100;
	static int stateWidth = 220;

	/// &amp;lt;summary&amp;gt;
	/// 根据配置文件创建特技组
	/// &amp;lt;/summary&amp;gt;
	[MenuItem (&quot;Tools/CreateAnimatorState&quot;)]
	static void CreateAnimatorState ()
	{
		// 获取动画片段
		List&amp;lt;object&amp;gt; allAssets = new List&amp;lt;object&amp;gt; (AssetDatabase.LoadAllAssetsAtPath (&quot;Assets/Charactors/player2.FBX&quot;));
		var animationClips = allAssets.Where (o =&amp;gt; o.GetType () == typeof(AnimationClip)).ToList ();
		foreach (var item in animationClips) {
			AnimationClip x = item as AnimationClip;
			switch (x.name) {
			case &quot;die&quot;:
				die = x;
				break;
			case &quot;jump&quot;:
				jump = x;
				break;
			case &quot;BackLeap&quot;:
				BackLeap = x;
				break;
			case &quot;ForwardLeap&quot;:
				ForwardLeap = x;
				break;
			default:
				break;
			}
		}

		// 当每个动画是一个单独的FBX文件中时可以用下面的方法来获取
		//die = AssetDatabase.LoadAssetAtPath (&quot;Assets/Charactors/player2.FBX&quot;, typeof(AnimationClip)) as AnimationClip;


		// 获取状态机
		AnimatorController animatorController = AssetDatabase.LoadAssetAtPath (&quot;Assets/AnimatorController/demo.controller&quot;, typeof(AnimatorController)) as AnimatorController;
		AnimatorControllerLayer layer = animatorController.layers [0];
		mainASM = layer.stateMachine;

		// 获取当前所有的参数
		AnimatorControllerParameter[] paras = animatorController.parameters;
		List&amp;lt;AnimatorControllerParameter&amp;gt; listParas = new List&amp;lt;AnimatorControllerParameter&amp;gt; (paras);

		// 删除指定的参数
		var acps = listParas.Where (p =&amp;gt; p.name.Contains (&quot;GroupParameter&quot;)).ToArray ();
		foreach (AnimatorControllerParameter item in acps) {
			animatorController.RemoveParameter (item);
		}

		// 删除指定的子状态机
		ChildAnimatorStateMachine[] childASM = mainASM.stateMachines;
		List&amp;lt;ChildAnimatorStateMachine&amp;gt; listCASM = new List&amp;lt;ChildAnimatorStateMachine&amp;gt; (childASM);
		var casms = listCASM.Where (c =&amp;gt; c.stateMachine.name.Contains (&quot;Group&quot;)).ToArray ();
		foreach (ChildAnimatorStateMachine item in casms) {
			mainASM.RemoveStateMachine (item.stateMachine);
		}

		// 读配置文件
		XmlConfig xc = ReadXml ();

		Vector3 startPos = mainASM.anyStatePosition;


		// 根据配置创建自状态机
		for (int index = 0; index &amp;lt; xc.datas.Count; index++) {
			Data data = xc.datas [index];

			// 设置特技参数，
			ParameterName = &quot;GroupParameter&quot; + data.INDEX.ToString ();
			animatorController.AddParameter (ParameterName, AnimatorControllerParameterType.Trigger);

			// 创建子状态机
			AnimatorStateMachine sub = AddSubStateMachine&amp;lt;AnimatorEvent&amp;gt; (&quot;Group_&quot; + data.INDEX, ParameterName, mainASM, startPos + new Vector3 (stateWidth * index, -stateHeight, 0));
			// 创建子状态机中的state
			SetStateInSubMachine (sub, data);
			lastAnimatorState = null;
		}
	}

	/// &amp;lt;summary&amp;gt;
	///  创建sub state machine用于放置特效组中的动画
	/// &amp;lt;/summary&amp;gt;
	/// &amp;lt;typeparam name=&quot;T&quot;&amp;gt;&amp;lt;/typeparam&amp;gt;
	/// &amp;lt;param name=&quot;stateName&quot;&amp;gt;&amp;lt;/param&amp;gt;
	/// &amp;lt;param name=&quot;sm&quot;&amp;gt;&amp;lt;/param&amp;gt;
	/// &amp;lt;param name=&quot;position&quot;&amp;gt;&amp;lt;/param&amp;gt;
	/// &amp;lt;param name=&quot;data&quot;&amp;gt;&amp;lt;/param&amp;gt;
	/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
	private static AnimatorStateMachine AddSubStateMachine&amp;lt;T&amp;gt; (string stateName, string para, AnimatorStateMachine sm, Vector3 position) where T : StateMachineBehaviour
	{
		AnimatorStateMachine sub = sm.AddStateMachine (stateName, position);
		sub.AddStateMachineBehaviour&amp;lt;T&amp;gt; ();
		AnimatorStateTransition transition = mainASM.defaultState.AddTransition (sub, false);
		transition.AddCondition (AnimatorConditionMode.If, 0, para);
		return sub;
	}

	/// &amp;lt;summary&amp;gt;
	///  根据配置数据在子状态机中创建state
	/// &amp;lt;/summary&amp;gt;
	/// &amp;lt;typeparam name=&quot;T&quot;&amp;gt;&amp;lt;/typeparam&amp;gt;
	/// &amp;lt;param name=&quot;subSM&quot;&amp;gt;&amp;lt;/param&amp;gt;
	/// &amp;lt;param name=&quot;data&quot;&amp;gt;&amp;lt;/param&amp;gt;
	private static void SetStateInSubMachine (AnimatorStateMachine subSM, Data data)
	{
		AnimatorState newState;
		string stateName;
		Vector3 pos;
		List&amp;lt;AnimationClip&amp;gt; acArray = new List&amp;lt;AnimationClip&amp;gt; ();
		SetAnimationClip (data.Clip1, data.Clip1Count, ref acArray);
		SetAnimationClip (data.Clip2, data.Clip2Count, ref acArray);
		SetAnimationClip (data.Clip3, data.Clip3Count, ref acArray);

		for (int x = 1; x &amp;lt;= acArray.Count; x++) {
			stateName = &quot;GroupState_&quot; + data.INDEX + &quot;_&quot; + x.ToString ();
			pos = subSM.entryPosition + new Vector3 (stateWidth, -stateHeight * x, 0);
			newState = AddState (stateName, subSM, pos, acArray [x - 1], x, acArray.Count);
			lastAnimatorState = newState;
		}
	}

	static void SetAnimationClip (string clipName, int count, ref List&amp;lt;AnimationClip&amp;gt; acArray)
	{
		for (int i = 0; i &amp;lt; count; i++) {
			if (clipName == die.name) {
				acArray.Add (die);
			}
			if (clipName == jump.name) {
				acArray.Add (jump);
			}
			if (clipName == BackLeap.name) {
				acArray.Add (BackLeap);
			}
			if (clipName == ForwardLeap.name) {
				acArray.Add (ForwardLeap);
			}
		}
	}

	static AnimatorState AddState&amp;lt;T&amp;gt; (string stateName, AnimatorStateMachine sm, float threshold, string parameter, Vector3 position,
	                                  AnimationClip clip, bool first = false, bool last = false) where T : StateMachineBehaviour
	{
		AnimatorStateTransition animatorStateTransition;
		//  生成AnimatorState
		AnimatorState animatorState = sm.AddState (stateName, position);
		// 设置动画片段
		animatorState.motion = clip;
		// 创建AnimatorStateTransition
		// entry连接到特技组的第一个动画
		if (first) {
			animatorStateTransition = sm.AddAnyStateTransition (animatorState);
			animatorStateTransition.AddCondition (AnimatorConditionMode.Equals, threshold, parameter);
		}
		// 最后一个动画连接到stand
		if (last) {
			animatorStateTransition = animatorState.AddTransition (mainASM.defaultState);
		}

		// 特技组内的连接创建
		if (!first &amp;amp;&amp;amp; !last) {
			animatorStateTransition = animatorState.AddTransition (mainASM.defaultState);
		}

		animatorStateTransition = lastAnimatorState.AddTransition (animatorState, true);

		//AnimatorStateTransition 的设置
		animatorStateTransition.canTransitionToSelf = false;
		animatorState.AddStateMachineBehaviour&amp;lt;T&amp;gt; ();
		return animatorState;
	}

	static AnimatorState AddState (string stateName, AnimatorStateMachine sm, Vector3 position, AnimationClip clip, int index, int count)
	{
		AnimatorStateTransition animatorStateTransition = null;
		//  生成AnimatorState
		AnimatorState animatorState = sm.AddState (stateName, position);
		// 设置动画片段
		animatorState.motion = clip;
		// 创建AnimatorStateTransition
		// AnyState连接到特技组的第一个动画
		if (index == 1) {
			//animatorStateTransition = sm.AddAnyStateTransition(animatorState);
			//animatorStateTransition.canTransitionToSelf = false;
		}
		// 最后一个动画连接到main animator machine的default state
		if (index == count) {
			animatorStateTransition = animatorState.AddTransition (mainASM.defaultState);
			animatorStateTransition.hasExitTime = true;
		}

		// 特技组内的连接创建
		if (lastAnimatorState != null) {
			animatorStateTransition = lastAnimatorState.AddTransition (animatorState, true);
		}

		return animatorState;
	}

	#endregion

	#region public method

	static XmlConfig ReadXml ()
	{
		//string xmlStr = File.ReadAllText(Application.dataPath.ToString() + &quot;/StreamingAssets/XMLConfigFiles/Stunt.xml&quot;);
		//Debug.Log(xmlStr);
		//string objTxt = Regex.Replace(xmlStr, @&quot;&amp;lt;!--[^-]*--&amp;gt;&quot;, string.Empty, RegexOptions.IgnoreCase);
		//Debug.Log(objTxt);
		return DeserializeFromXml&amp;lt;XmlConfig&amp;gt; (Application.dataPath.ToString () + &quot;/StreamingAssets/XMLConfigFiles/data.xml&quot;);
	}

	/// &amp;lt;summary&amp;gt;
	/// 从某一XML文件反序列化到某一类型
	/// &amp;lt;/summary&amp;gt;
	/// &amp;lt;param name=&quot;filePath&quot;&amp;gt;待反序列化的XML文件名称&amp;lt;/param&amp;gt;
	/// &amp;lt;param name=&quot;type&quot;&amp;gt;反序列化出的&amp;lt;/param&amp;gt;
	/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
	public static T DeserializeFromXml&amp;lt;T&amp;gt; (string filePath)
	{
		try {
			if (!System.IO.File.Exists (filePath))
				throw new ArgumentNullException (filePath + &quot; not Exists&quot;);

			using (System.IO.StreamReader reader = new System.IO.StreamReader (filePath)) {
				System.Xml.Serialization.XmlSerializer xs = new System.Xml.Serialization.XmlSerializer (typeof(T));
				T ret = (T)xs.Deserialize (reader);
				return ret;
			}
		}
		catch (Exception ex) {
			return default(T);
		}
	}

	#endregion
}


#region 序列化需要的model
[XmlType (TypeName = &quot;config&quot;)]
public class XmlConfig
{
	[XmlArray (&quot;datas&quot;)]
	public List&amp;lt;Data&amp;gt; datas { get; set; }
}

[XmlType (TypeName = &quot;data&quot;)]
public class Data
{
	[XmlAttribute]
	public int INDEX;
	[XmlAttribute]
	public string Clip1;
	[XmlAttribute]
	public int Clip1Count;
	[XmlAttribute]
	public string Clip2;
	[XmlAttribute]
	public int Clip2Count;
	[XmlAttribute]
	public string Clip3;
	[XmlAttribute]
	public int Clip3Count;
}

#endregion
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-4&quot;&gt;4.最后的说明&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;其实整个过程基本就是读取XML文件内容，然后按照第二部分中描述的结构来一点一点构建状态机。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在设定具体属性时需要按照具体情况来做。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;有个天坑，就是如果在Base Layer界面多次点击CreateAnimatorState按钮时会出现Unity的crash，或者出现界面所有元素消失并报错。我找了很多资料应该是UnityEditor的bug。有一个很简单的解决办法，就是创建一个新的Layer，切换到新Layer的界面，然后点击CreateAnimatorState按钮，再切回Base Layer，这样就不会出错了。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 12 Nov 2016 17:18:16 +0800</pubDate>
        <link>https://caihua.tech/2016/11/12/%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90AnimatorController/</link>
        <guid isPermaLink="true">https://caihua.tech/2016/11/12/%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90AnimatorController/</guid>
        
        <category>Unity3D</category>
        
        
      </item>
    
      <item>
        <title>向量夹角计算</title>
        <description>&lt;h4 id=&quot;section&quot;&gt;向量夹角&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 基于点积计算，
// a.b = ||a|| * ||b|| * sin(θ) 
// =&amp;gt; θ = arccos(a·b / (||a|| * ||b||))
// =&amp;gt; θ = arccos(a·b) //当a和b按照单位向量算时
float angle = Mathf.Acos(Vector3.Dot(a.normalized, b.normalized)) * Mathf.Rad2Deg;

// 基于叉积计算，
// ||a × b|| = ||a|| ||b|| sinθ             
// =&amp;gt; θ = arcsin(||a × b|| / (||a|| * ||b||))
// =&amp;gt; θ = arcsin(||a × b||) //当a和b按照单位向量算时
// 下面公式中有个Distance的计算是因为||a × b||是有长度的
angle = Mathf.Asin(Vector3.Distance(Vector3.zero, Vector3.Cross(a.normalized, b.normalized))) * Mathf.Rad2Deg;

// 最简单计算方式
Vector3.Angle(a, b)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Sat, 12 Nov 2016 14:15:50 +0800</pubDate>
        <link>https://caihua.tech/2016/11/12/%E5%90%91%E9%87%8F%E5%A4%B9%E8%A7%92%E8%AE%A1%E7%AE%97/</link>
        <guid isPermaLink="true">https://caihua.tech/2016/11/12/%E5%90%91%E9%87%8F%E5%A4%B9%E8%A7%92%E8%AE%A1%E7%AE%97/</guid>
        
        <category>3D数学</category>
        
        
      </item>
    
      <item>
        <title>Deepoon的相关设置以及如何玩steam游戏</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;基本&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;保证Deepoon助手、显卡驱动是最新的。&lt;/li&gt;
  &lt;li&gt;安装Deepoon platform sdk。在platform sdk的安装过程中需要阅读其自带的文档，sdk path中不要带中文。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;dpnngetlasterror&quot;&gt;DpnnGetLastError的处理&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;目前发现在安装了steamVR的情况下会出现DpnuGetLastError错误，在启动状态下出现错误后，退出steamVR。然后重启游戏。&lt;/li&gt;
  &lt;li&gt;在setting→play中关闭VR support，这个东西在启动后会被steamVR开启（如果你的程序中用到了steamVR）。&lt;/li&gt;
  &lt;li&gt;按照上述两部则应该不会出现DpnnGetLastError错误，并且只能通过头盔来看游戏内容。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;steam&quot;&gt;玩steam&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;在steam的安装目录下放置xxx\Steam\steamapps\common\SteamVR\drivers\deepoon。如果没有放置这个驱动可能导致steam下无法设置VR房间。设置完成后应该是
&lt;img src=&quot;http://images2015.cnblogs.com/blog/23250/201610/23250-20161012092230578-1855749103.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;经过上面的设置就可以用大朋眼镜玩steam游戏了。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-1&quot;&gt;开发相关&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;目前发现如果用大朋眼镜可以玩steam，则在unity中是不需要使用DpnCameraRig的，而且也不需要开启大朋助手。&lt;/li&gt;
  &lt;li&gt;从这些表现来看大朋应该用的是Oculus的底层。&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Wed, 12 Oct 2016 21:21:12 +0800</pubDate>
        <link>https://caihua.tech/2016/10/12/Deepoon%E7%9A%84%E7%9B%B8%E5%85%B3%E8%AE%BE%E7%BD%AE%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E7%8E%A9steam%E6%B8%B8%E6%88%8F/</link>
        <guid isPermaLink="true">https://caihua.tech/2016/10/12/Deepoon%E7%9A%84%E7%9B%B8%E5%85%B3%E8%AE%BE%E7%BD%AE%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E7%8E%A9steam%E6%B8%B8%E6%88%8F/</guid>
        
        <category>VR</category>
        
        
      </item>
    
      <item>
        <title>LOD初探</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;概念&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;LOD全称是Level of Detail，也就是细节层级。&lt;/li&gt;
  &lt;li&gt;为什么会产生这个技术？根据官方教程的解释是因为在一个很大的场景中，需要进一步考虑性能问题。LOD就是一个很好的解决性能问题的方案，它根据物体与摄像机的距离来展示这个物体不同的mesh，从而使得物体较远是使用面数比较少的mesh，而距离近的时候使用面数多的mesh。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-1&quot;&gt;如何使用&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;LOD在unity中的使用极为简单，基本分为以下几个步骤&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;创建一个空GameObject，然后加上LOD Group组件。
&lt;img src=&quot;http://images2015.cnblogs.com/blog/23250/201610/23250-20161009232106898-784286333.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;LOD Group中选择某个LOD块会出现
&lt;img src=&quot;http://images2015.cnblogs.com/blog/23250/201610/23250-20161009233343045-133617437.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;拖动对象到&lt;code class=&quot;highlighter-rouge&quot;&gt;add&lt;/code&gt;按钮上后就设置了当前level下的模型。
&lt;img src=&quot;http://images2015.cnblogs.com/blog/23250/201610/23250-20161009233221336-502460804.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;依次设置完0、1、2的模型，需要注意LOD 0 表示摄像机最近距离显示，因此模型质量最高，数字越大距离摄像机越远，模型质量越低。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;最终效果
&lt;img src=&quot;http://images2015.cnblogs.com/blog/23250/201610/23250-20161009232136822-2074270500.gif&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我设置的是绿色cube在LOD 2，黄色在LOD 1,红色是0，因此从右下角的camera preview看到摄像机距离对象最远时显示的绿色，依次变为黄色和红色。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;几个参数的设置&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;在setting的quality中有LOD的两个参数&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://images2015.cnblogs.com/blog/23250/201610/23250-20161009234207377-1568794073.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Maximum LOD Level：最大LOD级别，表示游戏中使用的最高LOD级别。在该级别以上的模型不会被使用，并且在编译时忽略。（这将节省存储空间和内存空间）。&lt;/p&gt;

  &lt;p&gt;Bias LOD：LOD偏离 ，LOD级别基于物体在屏幕上的大小。当物体大小在两个LOD级别之间，可以选择使用低细节模型或高细节模型。数值取值范围为0-1，数值越接近0，越偏向于选择低细节模型。即是：如果该值小，那么摄像机离物体距离稍微有些变化，不同细节物体即会切换，该值大，那么摄像机需要与物体有很大的距离才会切换。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-3&quot;&gt;缺点&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;它的缺点是需要占用更多的内存，而且如果没有调整好距离的话，可能会造成模拟的突变。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果不想占用内存还有种办法是只设置一个LOD在group中，可以通过代码实现，这样只用一个模型即可，不过如果刷新不够快或者设置的不合适可能出现视野中突然多了个物体的情况。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 09 Oct 2016 23:47:35 +0800</pubDate>
        <link>https://caihua.tech/2016/10/09/LOD%E5%88%9D%E6%8E%A2/</link>
        <guid isPermaLink="true">https://caihua.tech/2016/10/09/LOD%E5%88%9D%E6%8E%A2/</guid>
        
        <category>Unity3D</category>
        
        
      </item>
    
      <item>
        <title>VR开发环境搭建</title>
        <description>&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;unity3d的安装&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;目前使用的Deepoon
1.安装大朋助手。
2.如果提示require DpnPlatform_x64.dll，则在大朋官网下载platform的sdk，并找到对应的平台的文件夹安装，有个bat文件可以安装。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;安装steam和steamVR。对于steamVR来说正常安装完会显示能识别头盔，但是可能提示未准备好，需要进行房间设置。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 09 Oct 2016 21:59:00 +0800</pubDate>
        <link>https://caihua.tech/2016/10/09/VR%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</link>
        <guid isPermaLink="true">https://caihua.tech/2016/10/09/VR%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</guid>
        
        <category>VR</category>
        
        <category>Unity3D</category>
        
        
      </item>
    
      <item>
        <title>Github Page爬坑指南</title>
        <description>&lt;h4 id=&quot;jekyll&quot;&gt;1.jekyll的使用&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;jekyll的核心命令就几个&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jekyll new blog // 选好文件夹位置
jekyll build    // 在_site文件夹下生成网站内容
jekyll serve    // 可以在本地生成一个服务查看生成网站的内容，IP:127.0.0.1:4000
   
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;模板，参考别人的模板进行了修改，&lt;a href=&quot;https://github.com/Huxpro/huxpro.github.io&quot;&gt;地址&lt;/a&gt;。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;github&quot;&gt;2.github上的设置&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;github上需要设置的反而是最少的，创建一个用户名下的repository，例如sam.github.io，然后直接将jekyll中_site下的文件提交到这个repository即可。如果代码没错就可以直接通过访问sam.github.io进入个人网站了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section&quot;&gt;3.个人域名绑定&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;首先在sam.github.io这个repository下添加一个名为CNAME的文件，内容为你自己的网站地址，比如sam.tech&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;去自己的域名管理中进行解析设置，以阿里云为例。从左侧进入&lt;code class=&quot;highlighter-rouge&quot;&gt;云解析 DNS&lt;/code&gt;，选择域名后点击解析。删除原来的几个默认生成的解析，然后进行如下设置&lt;img src=&quot;http://images2015.cnblogs.com/blog/23250/201610/23250-20161003173328629-236251795.jpg&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;记录值为&lt;code class=&quot;highlighter-rouge&quot;&gt;sam.github.io.&lt;/code&gt;，注意io后面有个点。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;经过上面两步如果你的域名和网站内容没有问题的话就可以通过域名访问了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;https&quot;&gt;4.https的问题&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;经过上面的几步已经可以正常访问网站了，但是会注意到在chrome中会提示网站不安全，因为不支持https。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;解决办法参考了&lt;a href=&quot;https://zhuanlan.zhihu.com/p/22667528&quot;&gt;这篇文章&lt;/a&gt;，在阿里云中通过&lt;code class=&quot;highlighter-rouge&quot;&gt;域名→管理&lt;/code&gt;然后设置新的nameservers即可。只不过一直提示&lt;code class=&quot;highlighter-rouge&quot;&gt;非万网DNS&lt;/code&gt;。
&lt;img src=&quot;http://images2015.cnblogs.com/blog/23250/201610/23250-20161003173334707-1998000533.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-1&quot;&gt;5.图片链接问题&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;目前生成出来的HTML代码中图片的路径是错误的，从网上也找了很多办法但是都不理想，咋这篇文章中使用的图片其实是我把图片上传到博客园，然后拿到URL后使用的。也就是说使用图片存储服务来实现，这样的好处就在于github page容量有限，如果将来图片多了会很麻烦，不如一开始就使用第三方来存储图片。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 03 Oct 2016 13:18:23 +0800</pubDate>
        <link>https://caihua.tech/2016/10/03/github-page%E7%88%AC%E5%9D%91%E6%8C%87%E5%8D%97/</link>
        <guid isPermaLink="true">https://caihua.tech/2016/10/03/github-page%E7%88%AC%E5%9D%91%E6%8C%87%E5%8D%97/</guid>
        
        <category>杂记</category>
        
        
      </item>
    
      <item>
        <title>解决JSONKit在macOS Sierra上crash的问题</title>
        <description>&lt;p&gt;按照如下方法修改代码即可
https://github.com/johnezang/JSONKit/pull/141/commits/ccc0565f0ae4a27371d18309ccb982a9f1f21b63&lt;/p&gt;

&lt;p&gt;懒得改的可以直接clone我修改过的
https://github.com/klkucan/JSONKit&lt;/p&gt;
</description>
        <pubDate>Thu, 22 Sep 2016 18:29:23 +0800</pubDate>
        <link>https://caihua.tech/2016/09/22/%E8%A7%A3%E5%86%B3JSONKit%E5%9C%A8macOS-Sierra%E4%B8%8Acrash%E7%9A%84%E9%97%AE%E9%A2%98/</link>
        <guid isPermaLink="true">https://caihua.tech/2016/09/22/%E8%A7%A3%E5%86%B3JSONKit%E5%9C%A8macOS-Sierra%E4%B8%8Acrash%E7%9A%84%E9%97%AE%E9%A2%98/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>iOS学习笔记-08杂</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;8.杂&lt;/h2&gt;

&lt;h4 id=&quot;section-1&quot;&gt;表达式&lt;/h4&gt;
&lt;p&gt;表达式，是由数字、算符、数字分组符号（括号）、自由变量和约束变量等以能求得数值的有意义排列方法所得的组合。如：算术表达式、逻辑表达式、关系表达式、赋值表达式、逗号表达式等等。&lt;/p&gt;
</description>
        <pubDate>Fri, 16 Sep 2016 03:32:23 +0800</pubDate>
        <link>https://caihua.tech/2016/09/16/08%E6%9D%82/</link>
        <guid isPermaLink="true">https://caihua.tech/2016/09/16/08%E6%9D%82/</guid>
        
        <category>iOS学习笔记</category>
        
        
      </item>
    
  </channel>
</rss>
