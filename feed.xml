<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>蔡华的博客</title>
    <description>Be publicly useful and privately happy.</description>
    <link>https://caihua.tech/</link>
    <atom:link href="https://caihua.tech/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sun, 19 Nov 2017 22:11:30 +0800</pubDate>
    <lastBuildDate>Sun, 19 Nov 2017 22:11:30 +0800</lastBuildDate>
    <generator>Jekyll v3.2.1</generator>
    
      <item>
        <title>PHP的OOP</title>
        <description>&lt;ul&gt;
  &lt;li&gt;在类中可以使用public（公有），protected（受保护）或 private（私有）来修饰属性和方法。如果不修饰默认是public。&lt;/li&gt;
  &lt;li&gt;类中用var定义变量，&lt;code class=&quot;highlighter-rouge&quot;&gt;var $name&lt;/code&gt;，使用方式&lt;code class=&quot;highlighter-rouge&quot;&gt;$this-&amp;gt;name&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;构造函数&lt;code class=&quot;highlighter-rouge&quot;&gt;function __construct()&lt;/code&gt;，析构函数&lt;code class=&quot;highlighter-rouge&quot;&gt;function __destruct()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;继承&lt;code class=&quot;highlighter-rouge&quot;&gt;class Child_Site extends Site&lt;/code&gt;，使用extends关键字&lt;/li&gt;
  &lt;li&gt;实例化类&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Login
{
    var $m_user;
    var $m_pw;

    function __construct($user, $pw)
    {
        $this-&amp;gt;m_user = $user;
        $this-&amp;gt;m_pw = $pw;
    }

    function Login()
    {
        echo $this-&amp;gt;m_user .'-'. $this-&amp;gt;m_user;
    }
}

$user = $_POST['user'];
$pw = $_POST['pw'];

$login = new Login($user, $pw);
$login-&amp;gt;Login();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;可以使用interface&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;?php

// 声明一个'iTemplate'接口
interface iTemplate
{
    public function setVariable($name, $var);
    public function getHtml($template);
}


// 实现接口
class Template implements iTemplate
{
    private $vars = array();
  
    public function setVariable($name, $var)
    {
        $this-&amp;gt;vars[$name] = $var;
    }
  
    public function getHtml($template)
    {
        foreach($this-&amp;gt;vars as $name =&amp;gt; $value) {
            $template = str_replace('{' . $name . '}', $value, $template);
        }
 
        return $template;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;常量&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;?php
class MyClass
{
    const constant = '常量值';

    function showConstant() {
        echo  self::constant . PHP_EOL;
    }
}

echo MyClass::constant . PHP_EOL;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;静态属性不能通过一个类已实例化的对象来访问（但静态方法可以）。&lt;/li&gt;
  &lt;li&gt;静态属性不可以由对象通过 -&amp;gt; 操作符来访问。调用方法是&lt;code class=&quot;highlighter-rouge&quot;&gt;::&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;抽象类与C#一样&lt;/li&gt;
  &lt;li&gt;Final 关键字，作用与C#的sealed一样。&lt;/li&gt;
  &lt;li&gt;子类中调用父类的方法&lt;code class=&quot;highlighter-rouge&quot;&gt;parent::Login();&lt;/code&gt;，与C#的&lt;code class=&quot;highlighter-rouge&quot;&gt;base.Login&lt;/code&gt;结构上一样。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 19 Nov 2017 22:00:09 +0800</pubDate>
        <link>https://caihua.tech/2017/11/19/PHP%E7%9A%84OOP/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/11/19/PHP%E7%9A%84OOP/</guid>
        
        <category>PHP</category>
        
        
      </item>
    
      <item>
        <title>每天一点UWA：第十六周</title>
        <description>&lt;h2 id=&quot;texture&quot;&gt;Texture&lt;/h2&gt;

&lt;h4 id=&quot;etcargb32&quot;&gt;如何处理ETC压缩完图片质量模糊和ARGB32内存占用太大这种关系？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;使用ETC压缩的图片尽量减少过渡，这是美术制作时需要注意的，很多情况下并不需要明显的过渡，只是需要半透明而已；&lt;/li&gt;
  &lt;li&gt;当然，有部分过渡色是必须的，这时候就要把相关小图整合到一张RGBA32的图片上；&lt;/li&gt;
  &lt;li&gt;在资源管理上入手。一般情况下，我们是允许部分资源使用RGBA32，但是要注意，及时卸载掉不使用的资源，以保证内存峰值在可控范围内。&lt;/li&gt;
  &lt;li&gt;果ETC压&amp;gt; 缩效果不好的，会使用RGBA32并降一个尺寸规格来压缩，这样虽然图片会模糊点，但是过渡还是平滑的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;astcandroidmalirgba32astc&quot;&gt;ASTC格式并不是所有机型都支持，在Android端只有配有高端Mali芯片的机器才支持，对于不支持的，引擎会将其解压成RGBA32进行处理，所以图片中的内存值过大，很可能是项目在不支持ASTC格式的设备上所看到的结果。&lt;/h4&gt;

&lt;h2 id=&quot;section&quot;&gt;工具&lt;/h2&gt;

&lt;h4 id=&quot;putgeometryjobfence&quot;&gt;PutGeometryJobFence开销较高&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;就目前我们所优化过的项目而言，推测PutGeometryJobFence是Unity项目的主线程在等子线程的一些网格计算操作完成，其在不同的模块中均有出现（UGUI模块、渲染模块、Mesh.Skin操作、Animator动画模块等等），出现的地方不同，其本身含义也并不相同，不能一概而论。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;transformsetposition&quot;&gt;Transform.set_position的开销很大&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Deep Profiler本身对于耗时的统计影响很大，通常在Deep Profiler下调用次数越多的函数，其耗时的统计就会越明显地偏高，因此，我们首先建议关闭Deep Profiler，同时用Profiler.BeginSample/EndSample将修改Position的代码包进来，再查看其耗时，相对会更加准确。&lt;/li&gt;
  &lt;li&gt;CanvasRenderer.OnTransformChanged过多，移动UI元素相比于移动其他的元素确实会有额外的开销。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;unity-profilercanvasrendersubbatchui&quot;&gt;Unity Profiler中的Canvas.RenderSubBatch是否属于UI上渲染的开销？和重建有关系吗？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;是UI模块（UGUI）的渲染开销，但是跟UI的重建并无太大关系，主要还是跟UI界面的渲染Draw Call相关。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;clear&quot;&gt;Clear的耗时过大&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2FTechSharing_65%2F7.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Clear操作一般是用来清除Camera的各种Render Buffer，当图像后处理使用的越多，则同一帧中开辟更多的Buffer的概率也越大，从而造成Clear的开销也较高。&lt;/li&gt;
  &lt;li&gt;项目中Clear耗时较高，且高耗时较为频繁，则建议先关闭图像后处理操作，来查看该情况是否有所好转。然后再逐步开启各个图像后处理操作，逐步定位造成Clear较高的耗时根源&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;模型&amp;amp;动画&lt;/h2&gt;
&lt;h4 id=&quot;uwa&quot;&gt;如何降低动画文件的浮点数精度？之前UWA给过思路，但具体怎么个执行方法？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;动画文件后处理可以做两件事，1）精度压缩，2）scale曲线剔除。比起用工具修改原始fbx文件，这样比较灵活。
实际测试，在开启Optimal压缩的情况下，加上这个后处理，能再节省40%左右。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 19 Nov 2017 01:04:30 +0800</pubDate>
        <link>https://caihua.tech/2017/11/19/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E5%8D%81%E5%85%AD%E5%91%A8/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/11/19/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E5%8D%81%E5%85%AD%E5%91%A8/</guid>
        
        <category>UWA</category>
        
        
      </item>
    
      <item>
        <title>每天一点UWA：卡通渲染笔记</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;描边的方法&lt;/h2&gt;
&lt;h4 id=&quot;section-1&quot;&gt;基于视角的勾边&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;PS：这个是最简单的绘制边界的做法。计算方式就是dot(viewDir, normal)。根据 三角函数的定义值越小说明视角与模型某个点的表面法线的夹角越大，夹角为90°时说明这个triangle是视角看不到的，也就是边界了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-2&quot;&gt;基于几何生成方法的描边&lt;/h4&gt;
&lt;h5 id=&quot;shell-method&quot;&gt;shell method&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;首先在绘制结束正常的模型后，将需要描边的物体改用正面剔除再绘制一遍，在VS中将顶点沿着法线方向膨胀一定距离，然后在FS中将模型用纯色输出。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;z-bias&quot;&gt;z-bias&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;也是绘制背面，但不膨胀，而是把背面顶点的Z值稍微向前偏移一点点，使得背面的些许部分显示出来形成描边效果。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-3&quot;&gt;基于图像处理的描边&lt;/h4&gt;

&lt;h5 id=&quot;section-4&quot;&gt;什么是“边缘”呢？&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;边缘就是在深度或者法线上不连续的位置。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-5&quot;&gt;做法：&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;需要将深度信息和法线信息以贴图的形式传入，运用边缘检测算法去寻找这些像素。&lt;/li&gt;
  &lt;li&gt;这类方法的优点是描边的线宽一致，缺点是需要额外的法线和深度信息，当然，由于近年来流行的延迟渲染框架，法线和深度本来就是G-Buffer的一部分，因此往往不需要额外绘制法线和深度的信息。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-6&quot;&gt;美式卡通中的做法&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;美式卡通中往往倾向于使用基于图像处理的描边方法来生成均匀一致的描边效果。在《英雄联盟》中小兵和英雄的勾边效果就是用Sobel算子对深度信息进行边缘检测来获得的。&lt;/li&gt;
  &lt;li&gt;当物体较多时在进行正常绘制的阶段用stencil buffer标记出需要描边的物体，然后用一个全屏的后处理，对stencil buffer标记的像素进行边缘检测，当然这样的话，就很难给每个物体单独指定描边颜色了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-7&quot;&gt;日式卡通中的做法&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;日式卡通中往往倾向于使用基于几何体生成的方法去描边，这类描边方法相较于另两类方法的好处在于线宽更容易为美术所控制。&lt;/li&gt;
  &lt;li&gt;在《GUILTY GEAR Xrd》中，角色的描边就是通过几何体生成的方法，结合了shell method和z-bias method，并引入了逐物体的顶点色来控制描边细节，同时也是为了保证描边粗细不会随着摄像机视距发生变化，具体来说，顶点色存储的信息包括：
    &lt;ul&gt;
      &lt;li&gt;R通道：控制toon shading的阈值，和描边无关，和着色有关，这个我们后面描述&lt;/li&gt;
      &lt;li&gt;G通道：控制顶点根据视距膨胀的强度（这个部分具体操作我也没有完全弄清楚，希望了解的朋友来补充）&lt;/li&gt;
      &lt;li&gt;B通道：控制描边的z-bias，越大则描边越不可见&lt;/li&gt;
      &lt;li&gt;A通道：控制描边的粗细&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-8&quot;&gt;着色&lt;/h2&gt;

&lt;h4 id=&quot;cel-shading&quot;&gt;Cel Shading&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;只考虑光线&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2Fsparkle_cartoonshading%2FGS1.png&quot; alt=&quot;image&quot; /&gt;
&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2Fsparkle_cartoonshading%2FGS2.png&quot; alt=&quot;image&quot; /&gt;
&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2Fsparkle_cartoonshading%2F10.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;同时考虑光线和视角&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2Fsparkle_cartoonshading%2FGS3.png&quot; alt=&quot;image&quot; /&gt;
&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2Fsparkle_cartoonshading%2FGS4.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2Fsparkle_cartoonshading%2F11.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;tone-based-shading&quot;&gt;Tone Based Shading&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Tone Based Shading的风格化是基于美术指定的色调插值，并且插值得到的色阶是连续的。首先需要由美术指定冷色调和暖色调，而最终模型的着色将根据法线和光照方向的夹角，在这两个色调的基础上进行插值，具体算法如下：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2Fsparkle_cartoonshading%2FGS5.png&quot; alt=&quot;image&quot; /&gt;
&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2Fsparkle_cartoonshading%2FGS25.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;其中，Kd仍是模型自身色彩贴图，Kblue，Kyellow和alpha，beta则均是自定义的参数。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2Fsparkle_cartoonshading%2F12.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;基于tone based shading绘制的球体&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;section-9&quot;&gt;日式卡通中的着色&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;以《GUILTY GEAR Xrd》为例，它也一定程度上包含了Cel Shading和Tone Based Shading的部分思想，将色阶离散成为“明暗”两个色调，并由美术指定冷暖色调的颜色：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2Fsparkle_cartoonshading%2FGS7.png&quot; alt=&quot;image&quot; /&gt;
&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2Fsparkle_cartoonshading%2FGS8.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;上述公式表示了这个卡通渲染的漫反射部分&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;threshold表示明暗交界的阈值，在游戏中通过顶点色的R通道来实现逐顶点的控制。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Kcool和Kwarm由美术逐物体地指定，Ksss是对模型次表面散射效果的模拟，对皮肤而言一般呈粉红色，通过美术绘制的SSS贴图来实现逐像素控制，并且只有暗部的像素才会受SSS贴图的影响。Kd是模型自身的颜色贴图。darkness表示了某个像素的明暗程度，用于确定色调的冷暖。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;美术绘制的AO贴图，来实现一些边角缝隙的暗部效果。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;高光的计算更简单一些：基本上与blinn-phong一样&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2Fsparkle_cartoonshading%2FGS10.png&quot; alt=&quot;image&quot; /&gt;
&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2Fsparkle_cartoonshading%2FGS11.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-10&quot;&gt;美式卡通中的着色&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Valve在其游戏《军团要塞2》将卡通渲染着色分为了view dependent term和view independent term。两部分的计算分别如下：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2Fsparkle_cartoonshading%2FGS12.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2Fsparkle_cartoonshading%2FGS13.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2Fsparkle_cartoonshading%2FGS14.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;PS：从公式中可以看到不依赖view的版本是l也就是光照向量，而依赖view的中是r，也就是反射计算。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://wikimedia.org/api/rest_v1/media/math/render/svg/d5acd56487631512ad0fc984bf3c11ce700589c4&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-11&quot;&gt;风格化高光和阴影&lt;/h2&gt;
&lt;h4 id=&quot;section-12&quot;&gt;可变形状的高光&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;从日式着色的高光公式看，改变形状的关键在于H向量。这个H就是半角向量，参考Blinn-Phong公式。具体做法有：
    &lt;ul&gt;
      &lt;li&gt;平移，改变高光的位置： &lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2Fsparkle_cartoonshading%2FGS17.png&quot; alt=&quot;image&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;有方向的缩放，沿着切线空间的某个轴缩放高光形状：&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2Fsparkle_cartoonshading%2FGS18.png&quot; alt=&quot;image&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;分割，将一块连续的高光切分成两块：&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2Fsparkle_cartoonshading%2FGS19.png&quot; alt=&quot;image&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;方块化，将趋于圆形的高光变成方形：&lt;/p&gt;

        &lt;p&gt;&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2Fsparkle_cartoonshading%2FGS20.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

        &lt;p&gt;&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2Fsparkle_cartoonshading%2FGS21.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

        &lt;p&gt;&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2Fsparkle_cartoonshading%2FGS22.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2Fsparkle_cartoonshading%2F16.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-13&quot;&gt;风格化阴影&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;类似于风格化的高光，风格化的阴影也是在标准的阴影计算流程之后，定义了一系列针对标准阴影的操作，通过这些操作，配合用户自定义的参数，便可以达到风格化阴影的效果，总的来说，共有四类操作：
    &lt;ul&gt;
      &lt;li&gt;膨胀/腐蚀（Inflation）：扩大或者缩小阴影范围，用参数i来控制&lt;/li&gt;
      &lt;li&gt;亮度（Brightness）：阴影区域的亮度，可以用于模拟半影区的效果，用参数b控制&lt;/li&gt;
      &lt;li&gt;柔度（Softness）：阴影边界处的柔和程度，用参数s控制&lt;/li&gt;
      &lt;li&gt;抽象度（Abstraction）：阴影形状的抽象程度，用参数alpha控制&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2Fsparkle_cartoonshading%2F17.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-14&quot;&gt;几种操作和相应的效果&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;整个风格化阴影的生成是基于图像空间的，从一个已经生成的精确阴影图开始。可以分成五个阶段：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;精确阴影的生成，由于是基于图像空间的，因此对精确阴影图的生成方法没有特别要求，可以是shadow volume，shadow map，ray tracing或者其他阴影生成技术，但必须要注意的是这里的阴影值一定是二值化的。&lt;/li&gt;
      &lt;li&gt;有向距离场的生成，基于图像空间的精确阴影，计算每个像素距离最近阴影边界的有向距离，这是文中算法的核心，也是后面风格化的基础，在文中给出了一种有向距离场的计算方法，当然也可以采用其他方案。&lt;/li&gt;
      &lt;li&gt;有向距离场的高斯模糊，这一步是抽象阴影生成的关键。&lt;/li&gt;
      &lt;li&gt;过滤，通过一个转移函数，将模糊后的有向距离场重新映射为阴影图。&lt;/li&gt;
      &lt;li&gt;使用过滤后的阴影进行光照计算。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2Fsparkle_cartoonshading%2F18.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;PS：如果是unity的话可能要做屏幕后处理，如果是延迟渲染的的话G-buffer不确定有没有阴影信息。而且移动平台也不推荐。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-15&quot;&gt;结束语&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;除了好好学习还能有啥好说的呢╮(╯▽╰)╭&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 14 Nov 2017 14:24:54 +0800</pubDate>
        <link>https://caihua.tech/2017/11/14/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E5%8D%A1%E9%80%9A%E6%B8%B2%E6%9F%93%E7%AC%94%E8%AE%B0/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/11/14/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E5%8D%A1%E9%80%9A%E6%B8%B2%E6%9F%93%E7%AC%94%E8%AE%B0/</guid>
        
        <category>UWA</category>
        
        
      </item>
    
      <item>
        <title>每天一点UWA：第十五周</title>
        <description>&lt;h2 id=&quot;assetbundle&quot;&gt;AssetBundle&lt;/h2&gt;
&lt;h4 id=&quot;unityprefabassetbundleassetbundleassetbundleobjectobjectobjectdestroyinstantiateobjectobjectdestroyloadassetbundle&quot;&gt;我们想请教一个Unity的普适性的资源管理问题。举个例子，我们现在的一个特效Prefab包含的贴图打成AssetBundle时没有单独拆分出来，就会存在一个问题，这个特效AssetBundle会存在重复加载的问题进而导致重复的特效贴图在内存中。（针对“重复加载”说明下：我们首先通过AssetBundle出来一个Object，这个Object会缓存一段时间，在这段缓存时间过后这个Object会被Destroy掉，而需要释放的特效是通过Instantiate这个Object出来的。当这个Object过了缓存时间被destroy掉后，下次需要释放相同的特效还是通过load同样的AssetBundle进行再实例化出来，这样内存中存在两份贴图了。）&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;一般是团队中自行做一些资源的引用计数来进行管理。频繁调用UnloadUnusedAssets是不可取的（该函数的主要作用是查找并卸载不再使用的资源。游戏场景越复杂、资源越多，该函数的开销越大，一般在300~2000 ms范围内），但可以调用UnloadAsset来释放资源。&lt;/li&gt;
  &lt;li&gt;PS:典型的释放prefab后没有释放对于的资源。确实应该用UnloadAsset，或者一开始这个图片资源就应该做成单独的AssetBundle。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;materialassetbundleassetbundleassetbundle&quot;&gt;美术做粒子的时候，粒子与粒子之间共用资源的情况很多，例如某几个粒子共用一个Material，某几个粒子共用一个贴图等，应该如何组织AssetBundle？要是对应到最细的那个程度，凡是共用过的资源都单独打一个AssetBundle，好像又会很琐碎，假如不那么做，粒子与粒子之间的AssetBundle又会有冗余。这方面有什么好的建议？&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;AssetBundle打包没有标准的方式，单就粒子系统而言，因为其个体本身比较小，并且在项目中经常大量出现，所以并不建议将粒子系统逐个打包，而是建议根据其出现频率进行打包，比如将同一段时间、同一出现场景等的粒子系统打包在一起。同时，由于粒子系统的Shader基本上都是Unity内置Shader，因此，尽可能将Shader进行依赖打包。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;gameplay&quot;&gt;Gameplay&lt;/h2&gt;
&lt;h4 id=&quot;optimize-game-objectsavatar&quot;&gt;我把骨骼文件的Optimize Game Objects”开启了，然后骨骼信息就没有了，那Avatar换装时候需要处理的骨骼信息怎么办？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;在开启“Optimize GameObject”选项后，因为Avatar信息消失，所以并不能通过原始的合并骨骼、合并Mesh的方法再来实现换装功能。对于开启“Optimize GameObject”选项的模型，Unity本身有另外一套更为方便的换装方式，即只要所换装模型的骨骼结点信息与Avatar自身骨骼信息可以匹配，那么直接将换装模型挂在Avatar模型下做为子节点即可，而不必再通过骨骼合并的方式来进行换装。&lt;/li&gt;
  &lt;li&gt;PS:mark一下，没看懂。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ui&quot;&gt;UI&lt;/h2&gt;
&lt;h4 id=&quot;mipmap&quot;&gt;关于Mipmap的设置&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;通过修改Texture的mipMapbias这个值可以改变使用的mipmap的层级。但是这个值目没有办法在全局设置，在导入图片的时候要用代码设置。&lt;/li&gt;
  &lt;li&gt;unit官方建议&lt;code class=&quot;highlighter-rouge&quot;&gt;Note that using large negative bias can reduce performance, so it’s not recommended to use more than -0.5 negative bias.&lt;/code&gt;，但是Mipmap的层级数的确是一个整数。mipMapbias是由Unity引擎定义的一个参数，按照Unity官网解释来看整数代表了比当前层级更低（级数更大，更模糊）的Mipmap，负数代表了比当前层级更高的Mipmap。“-0.5”具体是偏移多少层级目前也不是很清楚。&lt;/li&gt;
  &lt;li&gt;Trilinear应该是会比Bilinear效果好一些，但是也差强人意。原因是这样：传统的Mipmap（不采用Anisotropic Filtering）都是每层将u，v两个方向缩减一半，即：512x512的下一层是256x256。这就导致在两层交界处在不同层采样出来的纹理在u，v两个方向都被拉伸（或者叫变模糊）。Anisotropic Filtering的方式可以简单理解为在交界处只在某一个方向上被拉伸，另一个方向保持原有采样率（或者叫纹理分辨率），这样才能明显降低突变的模糊感。&lt;/li&gt;
  &lt;li&gt;使用Anisotropic Filtering不仅纹理内存占用会增高，而且采样率也增高（因为有一个方向的保持不变），因此它比传统的mipmap更耗时，耗时在于GPU端对纹理进行采样时增加了访存，在CPU端没有影响。虽然Anisotropic Filtering 耗时增加，但是相比于直接增加mipmap level（也就是设置-0.5的偏移），要达到相同的效果，Anisotropic Filtering的时间耗时还是相对更低的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;canvascanvasuguispriterenderer&quot;&gt;我在改血条，我原来是一个Canvas里放了所有血条，后来改成每个血条一个Canvas，再改成每个血条完全不用UGUI，直接用SpriteRenderer绘制，感觉性能越来越差了，怎么办呢？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;对于“所有血条放一个Canvas”和“一个血条放一个Canvas”做一个比较：
    &lt;ul&gt;
      &lt;li&gt;前者的开销主要在于网格的更新，在Unity5.2之后主要是在子线程中通过Timeline来查看。因此只看主线程的话，这种方法肯定是更高效的；&lt;/li&gt;
      &lt;li&gt;后者的开销主要在于DrawCall的数量（前者理论上能做到只用1个DrawCall，后者一个Canvas即一个DrawCall），开销被包含在了Camera.Render或者Canvas.RenderOverlays中。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;因此，在选择时，需要考虑的就是“网格更新”和“DrawCall”的权衡。&lt;/li&gt;
  &lt;li&gt;还是建议尽可能降低血条的顶点数，然后选择前者。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;模型&amp;amp;动画&lt;/h2&gt;
&lt;h4 id=&quot;generichumanoid&quot;&gt;优化动画精度时发现针对Generic效果明显，而Humanoid变化不大。&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;精度优化降内存（并非通过减少位数降低文本体积降内存），其实质是将曲线上过于接近0的数值（例如有效数字出现在小数点6位以后）直接归零，使部分曲线变为constant曲线来降低内存消耗。&lt;/li&gt;
  &lt;li&gt;在Generic中，大量曲线存在这样的数值，因而降低精度后，constant曲线增加，内存降低。&lt;/li&gt;
  &lt;li&gt;但在Humanoid中，动画信息被转化到Muscle空间后，muscle曲线上的数值很少约等于零，很难因为精度降低变为constant曲线，因此内存占用受精度降低的影响不大。&lt;/li&gt;
  &lt;li&gt;但归一化的Muscle空间本身就对动画信息进行了精简，自身内存占用相比Generic已经降低了不少，如果需要继续降低，可以尝试提高压缩选项下的Error值。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;animatoranimationclip&quot;&gt;Animator会把所有状态的AnimationClip加载到内存，有什么好的办法可以动态加载？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Animator Controller结构不需要改变，但动画需要变化。比如随着人物等级或技能升级，同种的攻击动作随着变化等。该种需求可以通过AnimatorOverrideController来进行完成，即按需加载新的AnimationClip，然后替换AnimatorOverrideController中相应的AnimationClip即可。目前，Unity的AnimatorOverriderController不仅可以进行单个替换，同时也可以ApplyOverrides成组替换；&lt;/li&gt;
  &lt;li&gt;Animator Controller结构需要改变，类似于Animation老版本动画的AddClip功能。这种需求需要替换AnimatorController，研发团队可以在动态加载AnimationClip的同时，动态加载相应的Animator Controller，然后进行替换即可。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;transformparentanimatorparentnull&quot;&gt;为什么Transform.设置Parent会触发Animator的初始化吗？Parent是等于null的。&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;把 Parent 设为null，相当于把这个 GameObject 变为根节点。如果在设置之前这个 GameObject 本身是激活状态，但其的父节点是未激活状态，那么设置之后，相当于把这个GameObject 激活。而激活GameObject 时就会触发 Animator.Initialize 等操作了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;物理&lt;/h2&gt;
&lt;h4 id=&quot;unity--profilerwarning&quot;&gt;在Unity 的 Profiler里，有些记录右边会有Warning的个数信息，请问这个是否影响性能，或者是否有必要修改呢？&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2FTechSharing_62%2F1.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;这种字符的出现很可能会导致后续的物理更新出现较大的性能开销，包含在Physics.Simulate/Processing中。&lt;/li&gt;
  &lt;li&gt;针对这个图是受限于Unity版本中的PhysX在移动静态碰撞体是开销较高的问题（虽然文档中说5.x下已经解决，但我们确实发现在5.x的项目中该项仍然存在）。&lt;/li&gt;
  &lt;li&gt;建议给需要移动的Collider加上RigidBody并勾选Is Kinematic复选框，从而将其变为动态碰撞体。对于不移动的物体，则直接将模型的Apply Root Motion选项进行关闭，从而直接省去Static Collider.Move的性能开销。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;性能综合&lt;/h2&gt;
&lt;h4 id=&quot;targetframerate30&quot;&gt;我们设置了TargetFrameRate为30，想避免过高的耗电和发热，请问这样做是合理的么？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;这种设置仅在帧率本身很好的情况下，才会起到减少耗电和发热的作用。但如果本身游戏已经较为卡顿，那么该设置方法意义不大。对于耗电和发热，研发团队需从CPU、GPU和IO入手，尽可能降低这三方面的负载压力。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;materialsetpassfast&quot;&gt;项目渲染中Material.SetPassFast的开销高&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Material.SetPassFast是Unity引擎在渲染过程中Material的轮循切换开销，一般在Unity5.0~Unity5.3版本中出现。它的开销主要分为两种：
    &lt;ul&gt;
      &lt;li&gt;Shader.CreateGPUProgram峰值开销：这种情况主要出现在Shader第一次渲染时。在Unity5.0以后，引擎为了避免Shader加载时过高的CPU峰值出现，已经将Shader.Parse和Shader.CreateGPUProgram两种操作分开执行，前者在Shader加载时，后者在Shader第一次渲染时。&lt;/li&gt;
      &lt;li&gt;渲染状态切换开销：这种情况是几乎每一帧都发生的，有渲染的地方就会有Material的切换。从问题图中可以看出，在运行的16000帧中，Material.SetPassFast一共被调用137万次。这里可以认为几乎全部是渲染时Material的切换操作。因此，该项较高的主要原因还是材质切换操作过多所致。所以，建议研发团队在报告中的详细材质页面查看是否有过多“冗余”的材质出现，如有则尽可能降低材质的使用冗余度。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-3&quot;&gt;渲染&lt;/h2&gt;
&lt;h4 id=&quot;shaderassetbundleshadershader-variantsshaderwarmupallshadersshadervariantcollectionwarmup&quot;&gt;将需要的Shader打到一个AssetBundle包中（包含一个关联了所有Shader的Shader Variants），分别用Shader.WarmupAllShaders和ShaderVariantCollection.WarmUp两种方式进行预加载，后者耗时更少。&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;根据官方的文档的描述，确实是ShaderVariantCollection的效率更高，详见：
https://docs.unity3d.com/Manual/OptimizingShaderLoadTime.html&lt;/li&gt;
  &lt;li&gt;因为在ShaderVariantCollection中，是可以给每个Shader添加指定的Keyword的，ShaderVariantCollection.WarmUp的调用只会对ShaderVariantCollection中指定的Keyword进行Warmup操作；而Shader.WarmupAllShaders则是对所有的Keyword全部进行Warmup操作（其中大多数很可能都不会用到）。&lt;/li&gt;
  &lt;li&gt;因此在Shader.WarmupAllShaders的文档中也提到，建议使用ShaderVariantCollection.Warmup来进行细粒度的Warmup操作，避免大量多余的Keyword被Warmup，造成严重的卡顿，大家可以参考下文：
https://docs.unity3d.com/ScriptReference/Shader.WarmupAllShaders.html&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;unity-56directional-modedirectional-specular&quot;&gt;在Unity 5.6版本中如何解决预渲染缺少高光的问题？该版本中光照预渲染Directional Mode选项中少了Directional Specular选项，渲染出来的效果场景缺少高光。&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;如果需要在使用Lightmap时渲染高光，替代方案是采用Mix Lights模式下的Shadow Mask以及Distance Shadow Mask选项。即将场景中的Directional Light改成Mix Lighting类型，并且在Lighting Mode选Shadow Mask或者Distance Shadow Mask。&lt;/li&gt;
  &lt;li&gt;其原理是：LIghtmap中仅仅存储indirect的光照，而direct光照是实时计算的，所以包括高光、阴影等都可以是实时的（阴影也可以是预计算好的）。这样做的好处是给Lightmap光照一定的灵活度，原来的Lightmap是完全静态的，现在是部分静态（direct的实时，indirect静态）。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;unity-5--shader-variant-collection-&quot;&gt;Unity 5 的 Shader Variant Collection 功能&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;经过测试，在较新的版本中（如Unity 5.5.3），将ShaderVariantCollection与Shader打包在相同的AssetBundle中后，其中会包含该Shader在ShaderVariantCollection中指定的Variant。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;shader-shader--shader-&quot;&gt;使用 Shader 变体之后，Shader 是否还能走资源更新？抑或 Shader 不推荐走资源更新？&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;使用 ShaderVariantCollection后依然可以进行资源更新（通过更新AssetBundle，来更新Shader的实现或者ShaderVariantCollection中包含的Variant）。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;shader--shader-always-include-&quot;&gt;Shader 变体和 Shader Always Include 的主要区别是什么？二者对内存和帧率影响如何？&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;ShaderVariantCollection与Always Included Shaders的区别主要在于打包时所包含的Variant。Always Included Shaders中的Shader，其所有的Variant都会被包含，好处是，理论上不会出现Variant丢失的情况；坏处是，会导致更大的发布包以及额外的内存占用，而影响最大的是手动进行Warmup时的耗时以及ShaderLab的内存占用。因此一般来说，对于Variant特别多的Shader（如Standard Shader），并不推荐放入Always Included Shaders中。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;unity-5-shader-bug&quot;&gt;在 Unity 5 较早的版本中，Shader 变体功能似乎有一些Bug，现在是否可靠？&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;目前即使是较新的版本，其可靠性我们也并不能确保，依然建议在使用前进行一些测试来验证。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;==PS: 需要关注的问题==&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 13 Nov 2017 09:22:09 +0800</pubDate>
        <link>https://caihua.tech/2017/11/13/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E5%8D%81%E4%BA%94%E5%91%A8/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/11/13/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E5%8D%81%E4%BA%94%E5%91%A8/</guid>
        
        <category>UWA</category>
        
        
      </item>
    
      <item>
        <title>每天一点UWA：动画重定向笔记</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;基本原理&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;动画重定向技术主要是针对骨骼动画的方案，由骨骼来描述动作信息，用蒙皮来表示模型网格与骨骼之间的关系，从而得到模型最终的样子。
&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2FAnimationRetargeting%2F2.png&quot; alt=&quot;image&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;PS：这张图很形象&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;动画就是每一帧为模型制作一个Pose（姿势），在每帧之间的姿势可以通过差值获得。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;最简单的情况：只有骨骼大小不一致的情况&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;此时因为骨骼在模型空间中具有一个对应的位置，因此以大人和小孩的骨骼为例，是没办法直接将大人的动画信息用在小孩的骨骼上的。&lt;/li&gt;
  &lt;li&gt;如何解决这个问题的呢？unity使用了一个参考姿势（通常情况下，会把T-Pose作为参考姿势）来计算不同大小骨骼之间的差值，然后应用到动画数据上。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;a1是A骨架的参考姿势，b1是B骨架的参考姿势，动画中某一帧的姿势是a2，我们想得到的结果是b2，我们认为，a2与参考姿势a1的差异应当和b2与其对应的参考姿势b1的差异相同，即：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;a2 - a1 = b2 - b1&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;我们可以得到计算过程为： b2 = a2 - a1 + b2 = a2 + (b1 - a1)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;参考姿势a1和b1都是提前得到的，因此可以进行预先计算好b1-a1的值。要知道这里的加法和减法要转换为每根骨骼的PRS计算，因此还是有不少CPU消耗的。下图给出了使用一个简单整数代替骨骼的PRS数据来模拟动画重定向的计算过程。
&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2FAnimationRetargeting%2F3.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;不同引擎的实现上可能不一样，文中提到了Havok的实现。&lt;/li&gt;
  &lt;li&gt;以上就解决了骨骼长度不一致的问题。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;真实的世界：骨骼名称、数量、父子关系不一致的情况&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;首先在如果项目中确定使用动画重定向，那么在模型制作时就需要约定好名称、数量和关系。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-3&quot;&gt;骨骼名称不一致&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;对于CS骨骼，由于在3DS Max中通常美术只会添加不同的前缀，因此可以通过去除前缀的方式进行模糊匹配来做骨骼映射；&lt;/li&gt;
  &lt;li&gt;Unity的做法细节不清楚，但是感觉会根据整个骨架的父子关系和结构来进行映射关系的计算；&lt;/li&gt;
  &lt;li&gt;而对于Bone骨骼，在没有预先定义好类似最大化骨骼这样规范的情况下，非常难通过程序来判断映射关系，可以提供可视化编辑的功能来让美术自己定义它们之间的映射关系。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-4&quot;&gt;骨骼数量不一致&lt;/h4&gt;

&lt;h5 id=&quot;cs&quot;&gt;在非CS骨骼或者不重要的部分存在多余的骨骼&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;如果动画文件的骨架中存在多余骨骼，通常的做法是把这些骨骼忽略掉，而如果目标骨架上存在多余的骨骼，即有些骨骼原始动画中并不存在，这其实没有办法为它生成动画，只需要保证其保留在原始姿势的local space当中，即让其跟着父骨骼移动。比如身上的飘带，如果原始动画中没有，在不使用布料系统等物理方案的情况下，只能让其按照参考姿势中的样子，“僵硬”地跟随角色移动。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-5&quot;&gt;在重要的位置存在骨骼不一致&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;多图，请直接看原文。解决的办法就是使用链式映射。&lt;/li&gt;
  &lt;li&gt;链式映射要做的就是将多根骨骼组成的骨链A和另外一个骨骼中多根骨骼组成的骨链B进行映射，做到整条B骨链的样子和A骨链的样子相近。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-6&quot;&gt;骨骼父子关系不一致&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;当两套骨骼的父子关系都不一致的情况下，其实很难得到正确的映射，简单的不一致可能可以容忍，但是可以想象，把一个人形骨骼的动画映射给四足动物甚至蜘蛛这样的八脚动物，是一件非常难做的事情。&lt;/li&gt;
  &lt;li&gt;也因为这样的原因，目前大范围应用的动画重定向，基本还是在人形骨骼上，当然，用相同的算法，把四足的战马动画映射到不同的体型的战马上也是可以的。基本的原则是骨架尽量具有更多的相似性，重定向的效果也就会更好。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;unity&quot;&gt;Unity中的重定向&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Unity引擎中动画重定向的实现不是一个直观的方法，而是封装在了Humanoid类型的动画系统里面，&lt;strong&gt;==也就是必须是人形的骨架、==使用Humanoid才可以使用它====&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;Unity没有像前文描述的基本原理那样去定义两套骨架之间的映射关系，而是自己在内部定义一套骨架模板，所有的Avatar骨骼都必须映射到这套模板上才可以由同一个Animator来驱动产生Retargeting之后的动画效果。&lt;/li&gt;
  &lt;li&gt;关于如何预览一个重定向之后的动画的效果，只能把模型放到Scene中，设置同一个Animator来观察。在动画文件的预览窗口，&lt;strong&gt;如果拖拽另外一个模型文件到其中，并不能预览到正确的效果。&lt;/strong&gt; PS：话说我以前都是这么干的。。&lt;/li&gt;
  &lt;li&gt;PS：具体操作过程参考原文或者unity文档吧，就是avatar设置那套流程。不过unity的avatar里面还能改变肌肉控制。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-7&quot;&gt;使用中的一些问题&lt;/h4&gt;
&lt;h5 id=&quot;humanoid&quot;&gt;角色的武器或者飘带在使用Humanoid类型的动画系统之后不会移动了，或者移动的位置有了很大的偏差。&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;这时候可以在动画文件的属性设置里，查看Mask下的Transform选项，里面可能存在没有被勾选的骨骼。目前的做法是把Transform下的所有骨骼对象都勾选上。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-8&quot;&gt;角色的武器在动作中出现了乱飘的情况，与手部无法紧密地绑定在一起&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;由于我们最初为了方便美术制作武器的动作，把其父骨骼设置给了盆骨这样一根相对稳定的骨骼，但是经过Retargeting计算之后，由于角色身材不同产生了一些偏差导致。最终我们还是把武器骨骼的父骨骼设置为手部的骨骼，才解决了这一问题。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-9&quot;&gt;某些角色在重定向之后的动画中表现为脚不贴地，和地面之间有缝隙，原始动画中没有&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;可能是重定向算法或者是参考姿势这两个因素导致&lt;/li&gt;
  &lt;li&gt;在avatar设置中，可以看看目标骨骼在T-POSS是否正常。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-10&quot;&gt;性能消耗&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;通过前面的原理分析可以看出，即使在有预计算的情况下，与普通的动画计算，Retargeting的过程还是有一定的CPU消耗的，但是这与通常会造成CPU瓶颈的蒙皮、渲染指令提交等相比，其实消耗并不算大。&lt;/li&gt;
  &lt;li&gt;Unity与Retargeting相关的还制作了肌肉控制的功能，Humanoid形式的动画系统相对于Generic形式的动画系统虽然有一部分额外的性能消耗，但是Unity内部做了比较好的优化，差别不是很大，因此可以放心使用。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-11&quot;&gt;补充&lt;/h2&gt;
&lt;h4 id=&quot;section-12&quot;&gt;一些概念&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;CAT和CS之前都是插件形式出现的&lt;/li&gt;
  &lt;li&gt;CS主要是用来创建两足动物的比如人类&lt;/li&gt;
  &lt;li&gt;CAT不但可以创建两足动物还能创建多足动物，这就是CAT相对于CS最大的优势了。&lt;/li&gt;
  &lt;li&gt;bones是3DMAX原始的骨骼系统，这个骨骼你需要自己手动创建才行，而CAT和CS可以自动生成&lt;/li&gt;
  &lt;li&gt;skin是蒙皮系统，就是用骨骼对模型进行蒙皮后模型和骨骼产生关联，这样模型就能跟着骨骼一起运动了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-13&quot;&gt;原文&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;https://blog.uwa4d.com/archives/AnimationRetargeting.html&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 08 Nov 2017 09:51:58 +0800</pubDate>
        <link>https://caihua.tech/2017/11/08/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E5%8A%A8%E7%94%BB%E9%87%8D%E5%AE%9A%E5%90%91%E7%AC%94%E8%AE%B0/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/11/08/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E5%8A%A8%E7%94%BB%E9%87%8D%E5%AE%9A%E5%90%91%E7%AC%94%E8%AE%B0/</guid>
        
        <category>UWA</category>
        
        
      </item>
    
      <item>
        <title>每天一点UWA：第十四周</title>
        <description>&lt;h2 id=&quot;assetbundle&quot;&gt;AssetBundle&lt;/h2&gt;
&lt;h4 id=&quot;assetbundleassetbundle&quot;&gt;AssetBundle划分过细的问题，比如每个资源都是AssetBundle。&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;加载IO次数过多，从而增大了硬件设备耗能和发热的压力；&lt;/li&gt;
  &lt;li&gt;Unity 5.3 ~ 5.5 版本中，Android平台上在不Unload的情况下，每个AssetBundle的加载，其每个文件的SerializedFile内存占用均为512KB（远高于其他平台），所以当内存中贮存了大量AssetBundle时，其SerializedFile的内存占用将会非常巨大。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;buildassetbundleoptionsdisablewritetypetree&quot;&gt;BuildAssetBundleOptions.DisableWriteTypeTree这个选项的实际用处是什么？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;在Unity 5.x版本中，AssetBundle在制作时会默认写入TypeTree信息，这样做的好处是可以保证AssetBundle文件的向下兼容性，即高版本可以支持以前低版本制作的AssetBundle文件。&lt;/li&gt;
  &lt;li&gt;所以，如果开启DisableWriteTypeTree选项，则可能造成AssetBundle对Unity版本的兼容问题，虽然关闭TypeTree会使Bundle更小，但我们一般都不建议研发团队在制作AssetBundle文件时开启该选项。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;assetbundlecscriptpublicassetbundlescriptassetbundlecsmd5&quot;&gt;我们项目做AssetBundle打包时，发现如果资源所依赖的C#Script的Public成员变量有变化时，用新代码加载旧的AssetBundle就会不兼容。有没有什么方法能判断这些Script在变化时是否需要重新打AssetBundle呢？目前我们使用.CS文件的MD5来判断是否需要重新打包，但其实这样应该有很多不必要的重复打包，对吗？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;该问题的本质原因是新代码的序列化信息变化所致。建议研发团队使用Unity 5的新的AssetBundle打包方式，默认情况下，Unity 5引擎会自动检测其脚本的序列化信息是否进行改变，从而自动进行增量打包。&lt;/li&gt;
  &lt;li&gt;PS: 虽然已经可以通过升级来解决，但是这个是个需要关注的点。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;assetbundle-1&quot;&gt;AssetBundle颗粒度问题&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;详见https://blog.uwa4d.com/archives/TechSharing_59.html 第一个问题&lt;/li&gt;
  &lt;li&gt;总结一下：
    &lt;ul&gt;
      &lt;li&gt;不要一个资源一个AssetBundle，因为Android上面一个serializedFile有512k,但是5.6后应该是32k。不过实际测试的情况是不一定是32K。WTF。。&lt;/li&gt;
      &lt;li&gt;对于AssetBundle小于1MB的限制在5.4后没意义，之前是因为www走webstream，会导致内存中占用AssetBundle大小4-5倍的空间。但是LZ4后基于其Chunk的加载特点，AB加载很快，且内存占用要比之前小很多。&lt;/li&gt;
      &lt;li&gt;仍旧需要注意的：&lt;/li&gt;
      &lt;li&gt;对于需要热更新的AB，也如问答中其他朋友的所言，要考虑实际情况控制AB的大小；- PS:可能是考虑网络下载的问题，以为过大的文件如果不做断点续传会是恶梦。&lt;/li&gt;
      &lt;li&gt;即便是LZ4的AB，其加载方式不同，加载效率也可能完全不一致。&lt;/li&gt;
      &lt;li&gt;对于AB的打包，尽可能把逻辑上同时出现（一个Prefab中非Share的Asset）、小而细碎的资源（Shader、Material、粒子系统等）尽可能打包在一起，并通过LoadAll来进行加载，因为这样会带来更好的加载效率。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;loadfromcacheordownloadversion&quot;&gt;使用LoadFromCacheOrDownload时如果用version参数，缓存的资源如何清除。&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;AssetBundle，其Version版本号变化时，新的解压Data是不会覆盖旧的解压Data的。清除旧的解压Data主要有三种方式：
    &lt;ul&gt;
      &lt;li&gt;设置缓存的过期日期，默认情况下是150天；&lt;/li&gt;
      &lt;li&gt;调用Caching.CleanCache来全部清空缓存；&lt;/li&gt;
      &lt;li&gt;当本地Cache已满时，Unity会从最早的AssetBundle来进行自动清理。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;wwwloadfromcacheordownloadsystemstring-url-int32-versionunity-4x500unityunity-5x-&quot;&gt;WWW.LoadFromCacheOrDownload(System.String url, Int32 version)这个接口加载资源，如果是Unity 4.x的版本，会有500个资源的数量限制，如果超过这个限制，Unity会删除之前缓存的每个资源，是这样吗？那在Unity 5.x 版本上是否还存在这样的问题呢？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;在Unity 4.x的版本中，如果通过LoadFromCacheOrDownload来加载AssetBundle，那么有两种情况需要考虑：
  -内存中加载的AssetBundle数量。在iOS平台上，通过该接口加载、同时存在于内存中的AssetBundle数量确实是有限的，接近300个，这是由于iOS上文件句柄数的限制导致。而该限制在Unity 5.0以后则被完善了，因为Unity 5引入了虚拟文件系统，所以不再有这个限制；在Android平台上，则没有这个限制，或者说数量限制值非常大，基本可以忽略。
    &lt;ul&gt;
      &lt;li&gt;本地Cache中缓存的AsseBundle数量。无论是iOS、Android还是PC版本，都没有500的数量限制，而是有一个硬盘占用大小限制。具体来说，在WebPlayer平台上，有50MB的缓存限制，而在其他平台上，则是4GB的缓存限制。所以只要硬盘占用大小不超过限定值即可。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;font&quot;&gt;Font&lt;/h2&gt;
&lt;h4 id=&quot;unity-534p6uguiatexttextdisableloada-managedstaticrefrences-font-textdisableafont&quot;&gt;我们在内存优化时发现一个问题，编辑器版本 Unity 5.3.4p6，使用UGUI，场景A中一个Text控件使用自定义字体资源，然后把该控件Text属性勾选为空（disable），再Load一个空场景，看场景A卸载后在内存中的残留，发现有一份引用是 ManagedStaticRefrences（）的 Font 内存。如果不是把Text属性disable，则场景A卸载后内存里不会再残留被引用的Font内存，请问可能是什么原因造成的呢？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;UWA对于该例子进行了检测，的确能够在 Editor 复现。查了下 UGUI 代码，能对 Font 产生引用的，主要是这个函数 FontUpdateTracker.TrackText(Text)，其中会把 t.font 引用起来；而对应的解引用的函数为 FontUpdateTracker.UntrackText。因此，如果出现了两者的调用不匹配，就有可能造成 font 的 ManagedStaticRefrences 引用。&lt;/li&gt;
  &lt;li&gt;进一步查看后，可以看到在定义了 UNITY_EDITOR 宏时，UI 元素会增加一个名为 OnValidate 的函数，Text 组件则在其中进行了 TrackText 的操作。
而最关键的是，该函数在 Text 组件以“未激活”的状态被实例化时同样会被触发，同时，如果这样的 Text 组件在后续没有被激活过就被销毁，其 OnDestroy 和 OnDisable 函数是不会被调用的，参见文档中的这句话：OnDestroy will only be called on game objects that have previously been active.
而 OnDisable 中才会调用 Untrack 解引用，所以造成了不匹配，导致了 font 的 ManagedStaticRefrences。&lt;/li&gt;
  &lt;li&gt;但是，OnValidate 函数只在 Editor 上才有，真机上不会发生上面说到的不匹配的情况。所以建议研发团队先在真机上测试下是否还有这种情况，如果确实没有，那么就忽略该问题即可。&lt;/li&gt;
  &lt;li&gt;PS:Mark&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;gameplay&quot;&gt;Gameplay&lt;/h2&gt;
&lt;h4 id=&quot;mask&quot;&gt;我想了解如何使用顶点色Mask控制明暗关系，才能达到类似崩坏琪亚娜效果？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;https://blog.uwa4d.com/archives/TechSharing_60.html 第五个问题，NB&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ui&quot;&gt;UI&lt;/h2&gt;
&lt;h4 id=&quot;nguihud600panel2drawcall&quot;&gt;我们游戏中用到NGUI的HUD，单位主要是一个进度条和一个倒计时文本(持续更新)，同屏数量达600左右，单位本身在持续移动。现已将这些设置为独立Panel，且只有2个DrawCall(进度条所在图集和文本)，但还是卡顿得很厉害，请问是否有优化的方法？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;简化元素的几何：进度条中的元素尽量避免Sliced 模式（改Simple）；倒计时部分如果使用了Outline或者Shadow，将其转为“图片字”；&lt;/li&gt;
  &lt;li&gt;降低更新频率：如倒计时按“秒”统一更新；进度条按1%甚至5%的间隔更新一次；移动速度较慢时可以尝试隔帧更新位置等；&lt;/li&gt;
  &lt;li&gt;拆分子UIPanel：尽可能将更新频率相同的UI元素放在一个UIPanel中，从而降低每次更新时涉及到的UI元素数量。具体的拆分数量，则可能要通过较多的测试来确定。需要说明的是，此处即使增加10到20个DrawCall，对渲染上的影响并不大。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;粒子&lt;/h2&gt;
&lt;h4 id=&quot;prefab100-200gameobjectgameobjectprefab&quot;&gt;我们项目中有大量的特效，一个特效Prefab可能包含100-200个GameObject，每个GameObject上都挂有一个粒子系统，但是实际上很多特效只有延时和坐标旋转之类的参数的区别。我看了Prefab文件后发现每个粒子系统分别记录了各自的信息，从而导致整体文件很大，内存占用也比较大。请问是否有优化的方法？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;如果开发的是一个手游项目，那么一个Prefab下含有100-200个粒子系统是非常不足取的，主要会造成以下几种问题：
    &lt;ul&gt;
      &lt;li&gt;同时播放100个以上的ParticleSystem，其ParticleSystem.Update本身的CPU占用会很高。下图为一款游戏在华为6Plus上的表现。可以看到Active Particle数量还没有达到100，其Update耗时就已经占到了5ms；&lt;/li&gt;
      &lt;li&gt;ParticleSystem.ScheduleGeometryJobs开销会很高。其耗时主要体现在渲染模块中的Culling阶段，与粒子系统的数量相关，场景中Active粒子系统的数量越多，其开销越高；&lt;/li&gt;
      &lt;li&gt;子线程中的渲染压力较大。Unity5.3版本以后，粒子系统的渲染虽然在主线程中占用很小，但并不意味它没有耗时，其耗时在渲染线程中，当渲染线程压力过大时，主线程同样会出现等待（Gfx.WaitForPresent），因此同样可能对帧率产生影响；&lt;/li&gt;
      &lt;li&gt;GPU的渲染压力较高。同屏中渲染的粒子系统越多，其屏幕每帧的填充率越高，从而更加容易造成设备的发热；&lt;/li&gt;
      &lt;li&gt;内存压力较高。如果一个Prefab上有100-200个粒子系统，并且如果场景中有10个以上这样的Prefab存在，那么其内存占用将在10~25MB内存区间内。就目前而言，粒子系统仍然是以Clone的形式存在，所以虽然粒子系统可能仅仅是某些参数不同，但其仍然是多个不同的粒子系统。因此，我们在UWA报告中会显示粒子系统在项目运行时的具体显示数量，以方便研发团队对粒子系统进行关注。如下图所示，一般来说，每帧中粒子系统的数量建议在400以下。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;模型&amp;amp;动画&lt;/h2&gt;
&lt;h4 id=&quot;fbxreadwrite-staticbatchingutilitycombinemesh&quot;&gt;网格模型FBX文件在不开启Read/Write选项时， 如果通过StaticBatchingUtility的CombineMesh来合批的话，内存会增加么？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;增加内存，主要表现在内存中CombinedMesh的增加以及一定量堆内存的增加。&lt;/li&gt;
  &lt;li&gt;该API使用的前提必须是网格Fbx模型开启Read/Write，如果不开启，则无法读到网格数据，进而不能完成网格的拼合操作。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-2&quot;&gt;如下图，请问这几个参数的单位是什么？&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog/TechSharing_58/2.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Rotation Error使用角度（degree）作为单位。Position和Scale是距离偏差的百分比（曲线调节前后的距离偏差与某距离值之比，取决于Unity内部实现），取值范围1~100，但实际可以高于100，并有作用。
我们建议研发团队在调节该误差时，将调节前后的动画效果进行对比，使文件体积压缩得尽量小，同时使动画效果在视觉上偏差不会太大。&lt;/li&gt;
  &lt;li&gt;PS:没找到，可能是动画导入的选项。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;resamplecurves&quot;&gt;如下图，这个ResampleCurves选项的作用，以及是否和对内存性能的影响？&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog/TechSharing_58/1.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;ResampleCurves选项是在Unity 5.3版本后加入的，在之前的版本中是隐藏并且默认勾选的。该选项会改变Unity动画数据的存储方式。&lt;/li&gt;
  &lt;li&gt;动画文件在导入到Unity之前，其关键帧的数据通常是以欧拉角（Euler format）的方式存储。在勾选该选项时导入，Unity会将欧拉角转换为四元数（Quaternion）表示，并且会生成逐帧的数据（不只是关键帧）。新生成的逐帧数据是为了解决四元数插值问题。关闭该选项会使动画文件保持欧拉角表示，但在应用于GameObject时仍会转换为四元数。&lt;/li&gt;
  &lt;li&gt;建议保持默认勾选该选项，只有当发现Unity中的动画播放效果与在动画编辑工具中的效果出现较大偏差时，尝试取消该选项，查看是否是该选项的原因导致动画偏差。我们在测试中发现该选项对运行性能影响并不明显。在内存方面，勾选该选项会使动画文件略微增加。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;scale&quot;&gt;动画提出scale&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;参见https://blog.uwa4d.com/archives/TechSharing_58.html第五个。&lt;/li&gt;
  &lt;li&gt;PS:很不错。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;animatorsprocessanimationsjobanimatorswritejobcpu&quot;&gt;动画模块中，Animators.ProcessAnimationsJob和Animators.WriteJob的CPU占用较高，这些与什么因素有关？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Animators.WriteJob受模型骨骼数目影响较大（受animation curves影响不明显），骨骼数目越多，该函数耗时越大。同时，开启Optimize GameObject选项能够降低该函数耗时。Animators.ProcessAnimationsJob 同样受骨骼数目影响较大，同时也受animation curves数目影响，二者数目越多，该函数耗时越大。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-3&quot;&gt;性能综合&lt;/h2&gt;
&lt;h4 id=&quot;cpugpugpuprofiler&quot;&gt;在整体的性能消耗上，CPU和GPU各占一半合理吗？如果不是，各占多少为好？还是说需要根据机型来看？其次，我如何知道游戏在手机上的GPU消耗？Profiler是看不到的，有工具推荐吗？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;首先，CPU和GPU是并行的，也就是CPU在运算的时候GPU也在运算，一帧的结束时间是两者中比较晚结束的那个。因此，一般我们在考虑这个问题的时候，经常会说是CPU bound还是GPU bound，也就是GPU在等CPU还是CPU在等GPU。&lt;/li&gt;
  &lt;li&gt;最理想的情况是两者都并行均衡，且都没有出现互相等待的情况。但在目前的大多数移动游戏中，都是CPU耗时为主要性能瓶颈。这也是为什么有多线程渲染的原因，多线程渲染就是利用CPU端的并行性，让CPU处理得更快，不拖后腿。&lt;/li&gt;
  &lt;li&gt;对于GPU的压力分析，可以尝试用Intel GPA，Mali或者高通出的针对自家芯片的工具。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;unityprefabgc-allocated&quot;&gt;为什么Unity里实例化一个Prefab会产生那么多GC Allocated?&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;这是一个特例，但是从里面可以总结出一个问题，就是在Instantiate一个对象时会发生或者&lt;strong&gt;可能发生&lt;/strong&gt;以下的事情
    &lt;ul&gt;
      &lt;li&gt;序列化和反序列化的处理，因为用prefab生成对象本身就是需要反序列化的。而直接clone一个对象可能还有先序列化在反序列化。&lt;/li&gt;
      &lt;li&gt;可能的资源的加载，比如prefab上用到的mesh、贴图等。&lt;/li&gt;
      &lt;li&gt;可能的shader编译，如果用了一个之前没有用过的shader就会实时的编译。&lt;/li&gt;
      &lt;li&gt;对象身上脚本的初始化。如果实例化一个prefab发现很占用时间要注意是不是脚本里面在awake或者start里面的功能太多了。&lt;/li&gt;
      &lt;li&gt;UI界面的Active和Deactive也会造成UI代码底层的一些相关OnEnable和OnDisable操作，同样会造成一定的堆内存分配。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-4&quot;&gt;渲染&lt;/h2&gt;
&lt;h4 id=&quot;unityskip&quot;&gt;Unity的材质的宏是有材质用到时才会被编译吗？还是说不手动Skip都会编译？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;在Unity中shader variant也包含两种类型，一种是通过 shader_feature 定义，一种是通过 multi_compile 定义。而只有通过 shader_feature 定义的 variant 在发布时会根据其使用情况来进行剥离。&lt;/li&gt;
  &lt;li&gt;具体可见Unity官方的文档：https://docs.unity3d.com/Manual/SL-MultipleProgramVariants.html&lt;/li&gt;
  &lt;li&gt;需要注意的是，放在Always Included Shaders中的Shader，其包含的所有 variant 都不会被剥离，因此对于Standard Shader这类包含了大量 shader_feature的Shader，不推荐将其放入。&lt;/li&gt;
  &lt;li&gt;PS:没有回答根本的问题：
    &lt;ul&gt;
      &lt;li&gt;Editor中：修改shader并保存时立即编译。
  Runtime下，无论哪个平台，都是在进入场景时加载shader object内容到内存，但是首次实际调用渲染时才编译，编译完成之后会cache下来。
  有两种优化方法：
  调用Shader.WarmupAllShaders()，自动编译该场景中用到的所有shader。该方法在Unity5中已经废弃。
  在项目设置的GraphicsSettings中，可以导出ShaderVariantCollection，并在Preloaded Shader中导入，这样的话就可以在载入场景时一并编译需要预加载的shader，这样的优化在移动平台上用得比较多。
  具体见&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;cpugfxwaitforpresent&quot;&gt;听说移动端开启多线程，把后期效果移动到渲染线程会节省后期的消耗。我测试了一下，虽然主线程中后期显示的CPU占用降低了，但是却多了Gfx.WaitForPresent的时间，最后两者相加基本还是一样的。那开启多线程这个功能，对后期到底有没有帮助呢？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;开启多线程渲染一般情况下会极大降低主线程的渲染耗时，但并不会降低其本身的总体计算量。因为这并不是底层算法或硬件上的提升，而是将部分计算从主线程搬到了子线程。所以，开启多线程的好处在于为主线程带来了大量空间来执行其他耗时模块（如代码逻辑等）。&lt;/li&gt;
  &lt;li&gt;但这并不意味着开启多线程渲染就“万事大吉”。如果渲染模块本身开销就很高，那么子线程一样会很耗时，更有可能出现主线程等待子线程的现象，也就是WaitForPresent开销较高的情况。所以，开启多线程是会降低主线程的渲染压力，但其帧率未必会大幅提升，还需研发团队自行在自己项目中进行尝试和比较。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 05 Nov 2017 10:07:00 +0800</pubDate>
        <link>https://caihua.tech/2017/11/05/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E5%8D%81%E5%9B%9B%E5%91%A8/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/11/05/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E5%8D%81%E5%9B%9B%E5%91%A8/</guid>
        
        <category>UWA</category>
        
        
      </item>
    
      <item>
        <title>浅析Timeline结构</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;结构&lt;/h2&gt;

&lt;table&gt;
   &lt;tr&gt;
      &lt;td&gt;PlayableDirector&lt;/td&gt;
      &lt;td colspan=&quot;6&quot; align=&quot;center&quot;&gt;Timeline&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td&gt;PlayableGraph&lt;/td&gt;
      &lt;td colspan=&quot;6&quot; align=&quot;center&quot;&gt;Graph&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td&gt;…&lt;/td&gt;
      &lt;td colspan=&quot;4&quot; align=&quot;center&quot;&gt;TrackGroup&lt;/td&gt;
      &lt;td&gt;TrackGroup&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td&gt;TrackAsset&lt;/td&gt;
      &lt;td&gt;AnimationTrack&lt;/td&gt;
      &lt;td&gt;PlayableTrack&lt;/td&gt;
      &lt;td&gt;CinemachineTrack&lt;/td&gt;
      &lt;td&gt;CustomTrack&lt;/td&gt;
      &lt;td&gt;…&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td&gt;…&lt;/td&gt;
      &lt;td&gt;TimelineClips&lt;/td&gt;
      &lt;td&gt;TimelineClips&lt;/td&gt;
      &lt;td&gt;TimelineClips&lt;/td&gt;
      &lt;td&gt;TimelineClips&lt;/td&gt;
      &lt;td&gt;…&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td&gt;PlayableAsset&lt;/td&gt;
      &lt;td&gt;AnimationClip (Motion)&lt;/td&gt;
      &lt;td&gt;CustomPlayableAsset&lt;/td&gt;
      &lt;td&gt;CinemachineShot&lt;/td&gt;
      &lt;td&gt;CustomClip&lt;/td&gt;
      &lt;td&gt;…&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td&gt;PlayableBehaviour&lt;/td&gt;
      &lt;td&gt;PlayableBehaviour&lt;/td&gt;
      &lt;td&gt;PlayableBehaviour&lt;/td&gt;
      &lt;td&gt;CinemachineShotPlayable&lt;/td&gt;
      &lt;td&gt;PlayableBehaviour&lt;/td&gt;
      &lt;td&gt;…&lt;/td&gt;
   &lt;/tr&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;从表中可以看出是一个树结构，在Timeline Editor中也是一目了然。核心的类就是最左边一列中列出的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;组件&lt;/h2&gt;
&lt;h3 id=&quot;timeline&quot;&gt;Timeline&lt;/h3&gt;
&lt;h5 id=&quot;timeline--playabledirector&quot;&gt;Timeline &amp;amp; PlayableDirector的关系&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;本质是个PlayableDirector，作用顾名思义。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;playablegraph--playabledirector&quot;&gt;PlayableGraph &amp;amp; PlayableDirector的关系&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;从测试情况看，一个PlayableDirector对应一个PlayableGraph&lt;/li&gt;
  &lt;li&gt;通过&lt;code class=&quot;highlighter-rouge&quot;&gt;PlayableDirector pd = graph.GetResolver() as PlayableDirector;&lt;/code&gt;可以反向得到PlayableDirector，在PlayableAsset中可能会比较有用。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;trackasset&quot;&gt;TrackAsset&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;TrackAsset从视觉上看就是Timeline Editor中左边preview中的一项，每个track可以约束它所影响的 GameObject的类型，也可以设置它上面clip的类型。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;从实际的操作上来看，PlayableTrack上可以放置任何继承自PlayableAsset的clip，但是其它的track上就必须放置约定类型的clip了。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;track&quot;&gt;如何自定义一个Track&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[TrackColor(1f, 1f, 0f)]
[TrackClipType(typeof(LightControlClip))]
[TrackBindingType(typeof(Light))]
public class LightControlTrack : TrackAsset {}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;从上面的代码看TrackBindingType定义了绑定的类型，TrackClipType定义了clip的类型。而TrackColor是定义了在Timeline Editor中最左边的那条很细的彩色线条。&lt;/li&gt;
  &lt;li&gt;经过测试，在自定义的TrackAsset中可以不实现CreateTrackMixer方法，但是如果要去override它，代码中不能用&lt;code class=&quot;highlighter-rouge&quot;&gt;return Playable.Create(graph);&lt;/code&gt;,而是用&lt;code class=&quot;highlighter-rouge&quot;&gt;return ScriptPlayable&amp;lt;CustomMixer&amp;gt;.Create(graph, inputCount);&lt;/code&gt;哪怕这个CustomMixer是个空类都可以，很坑爹。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;playableassetclip&quot;&gt;PlayableAsset（Clip）&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;要说PlayableAsset就离不开PlayableBehaviour。在旧版本的Timeline中BasePlayableBehaviour实现了PlayableAsset和PlayableBehaviour的功能。但是因为已经被舍弃了，因此想实现既可以放到track上，又能监控状态的对象需要用PlayableAsset配合PlayableBehaviour。做法为在自定义的PlayableAsset中写：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public override Playable CreatePlayable(PlayableGraph graph, GameObject go)
{
    return ScriptPlayable&amp;lt;CustomBehaviour&amp;gt;.Create(graph, template);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;playablebehaviour&quot;&gt;PlayableBehaviour&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;核心类，其定义了事件函数涵盖了自身的状态变化、graph的状态变化和PlayableDirector创建销毁时触发的事件。&lt;/li&gt;
  &lt;li&gt;PrepareFrame函数可以在每一帧对timeline中的元素进行访问和设置。可以说是在做自定义blend中不可缺失的功能。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;执行顺序&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;目前来看应该是：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;CreateTrackMixer-&amp;gt;CreatePlayable-&amp;gt;OnPlayableCreate-&amp;gt;OnGraphStart-&amp;gt;OnBehaviourPause-&amp;gt;OnBehaviourPlay-&amp;gt;OnGraphStop-&amp;gt;OnPlayableDestroy&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;这个顺序是一个clip的。当一个track上有多个clip时OnPlayableCreate、OnGraphStart、OnBehaviourPause会无序的出现，但是一定是在OnBehaviourPlay之前。&lt;/li&gt;
  &lt;li&gt;在真正的clip的执行期间，OnBehaviourPlay和OnBehaviourPause是按顺序执行的。&lt;/li&gt;
  &lt;li&gt;基本上可以判断当一个PlayableBehaviour准备好后，会先被pause。然后按照设计好的顺序执行，当开始执行时触发play，结束后再次触发pause。所以如果是要在一个clip结束后处理什么事情需要做一个判断，是否是第一次触发pause。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-3&quot;&gt;组件之间互相获取的方法&lt;/h2&gt;
&lt;h5 id=&quot;timelineplayabledirector&quot;&gt;Timeline(PlayableDirector)的获取方式&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;通过脚本中设置PlayableDirector类型变量获得。&lt;/li&gt;
  &lt;li&gt;如果是自定义的TrackAsset，则通过CreateTrackMixer方法的go参数获得。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public override Playable CreateTrackMixer(PlayableGraph graph, GameObject go, int inputCount)
{
    PlayableDirector playableDirector = go.GetComponent&amp;lt;PlayableDirector&amp;gt;();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;如果是自定义的PlayableAsset，则通过&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public override Playable CreatePlayable(PlayableGraph graph, GameObject go)
{
    var pd = graph.GetResolver() as PlayableDirector;
}        
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;PlayableBehaviour脚本中函数都是有playable参数，通过这个参数也可以获得&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public override void OnBehaviourPlay(Playable playable, FrameData info)
{
    PlayableDirector pd = playable.GetGraph&amp;lt;Playable&amp;gt;().GetResolver() as PlayableDirector;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h5 id=&quot;timelinetrackclipplayerbehaviour&quot;&gt;Timeline中获取track、clip和PlayerBehaviour&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;从上面的代码可以看到，获取director的过程比较符合最上面的那个表里的层级关系。但是从timeline获取其它的元素会比较困难。或者说比较不符合这个层级关系。我个人认为在API的设计上是有问题的。&lt;/li&gt;
  &lt;li&gt;那么要如何通过timeline获取这些元素呢？&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public PlayableDirector pd;
// Use this for initialization
void Start()
{
    var binding = pd.playableAsset.outputs;
    foreach (var item in binding)
    {
        switch (item.sourceObject.GetType().Name)
        {
            case &quot;AnimationTrack&quot;:
                {
                    var at = item.sourceObject as AnimationTrack;
                    foreach (TimelineClip clip in at.GetClips())
                    {
                        Debug.Log(clip.animationClip.name + &quot;\n&quot;);
                    }
                }
                break;
            case &quot;CinemachineTrack&quot;:
                var item2 = item.sourceObject as CinemachineTrack;
                foreach (TimelineClip clip in item2.GetClips())
                {
                    CinemachineShot cs = clip.asset as CinemachineShot;
                    Debug.Log(cs.VirtualCamera.Resolve(pd) + &quot;\n&quot;);
                }
                break;
            case &quot;PlayableTrack&quot;:
                var pt = item.sourceObject as PlayableTrack;
                foreach (TimelineClip clip in pt.GetClips())
                {
                    NewPlayableAsset cs = clip.asset as NewPlayableAsset;
                }
                break;
            case &quot;CustomTrack&quot;:
                var ct = item.sourceObject as CustomTrack;
                foreach (TimelineClip clip in ct.GetClips())
                {
                    CustomClip cs = clip.asset as CustomClip;
                    CustomBehaviour cb = cs.template;
                    cb.Foo();
                }
                break;
            default:
                break;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;从代码上看&lt;code class=&quot;highlighter-rouge&quot;&gt;pd.playableAsset.outputs&lt;/code&gt;获得了一个&lt;code class=&quot;highlighter-rouge&quot;&gt;IEnumerable&amp;lt;PlayableBinding&amp;gt;&lt;/code&gt;类型的集合。这个设计让人非常费解。然后遍历集合，得到&lt;code class=&quot;highlighter-rouge&quot;&gt;item.sourceObject&lt;/code&gt;，这个对象就是track了。然后可以根据不同的类型转换成不同的Track。然后就和表中的结构一致了，获得clip-&amp;gt;playableasset-&amp;gt;playablebehaviour。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-4&quot;&gt;获得场景对象&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;Timeline中获取对象在API设计上也不合理，在unity的通用做法是在代码中定义一个Public变量或者使用[SerializeField]标记一个private的变量，然后拖拽。又或者用过GameObject.Find来获取。但是对于策划和美术来说最多的还是拖拽。&lt;/li&gt;
  &lt;li&gt;Timeline相关的脚本中可以继续使用GameObject.Find。但是如果你想用拖拽的形式需要这样定义对象：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public ExposedReference&amp;lt;T&amp;gt; object;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;而当你想真正使用这个变量的值的时候需要用&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;object.Resolve (graph.GetResolver());
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;需要说明的是在Timeline的那些脚本类里面是可以用public定义变量的，在inspector面板上也可以显示出来，但是退拽无效。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;track-1&quot;&gt;获取Track绑定的对象&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;目前来看似乎只有用GameObject.Fine或者直接用属性值了。&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Thu, 02 Nov 2017 19:59:13 +0800</pubDate>
        <link>https://caihua.tech/2017/11/02/%E6%B5%85%E6%9E%90Timeline%E7%BB%93%E6%9E%84/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/11/02/%E6%B5%85%E6%9E%90Timeline%E7%BB%93%E6%9E%84/</guid>
        
        <category>Unity3D</category>
        
        
      </item>
    
      <item>
        <title>每天一点UWA：第十三周</title>
        <description>&lt;h2 id=&quot;gameplay&quot;&gt;Gameplay&lt;/h2&gt;
&lt;h4 id=&quot;layer&quot;&gt;求教一个屏幕后处理的问题。我们期望角色不受屏幕后处理影响，所以目前采用双相机的方案，根据Layer划分，但是这种情况下角色的影子也就没有办法投影到地表上，请问这种需求有什么好的实现方式？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;可以尝试根据地表模型的局部细节来动态生成接受阴影的网格（比如Fast Shadow Receiver插件），这样既可以保证地表模型进行屏幕后处理操作，同时也可以生成相关角色的动态阴影。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;texture&quot;&gt;Texture&lt;/h2&gt;
&lt;h4 id=&quot;uguiresource-resourcedrawcall&quot;&gt;UGUI用Resource来动态加载图片，有什么好的方法? 我的理解是：Resource目录下的图片都不能被打包成图集，而且会增加DrawCall和包大小。&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;需要打图集的Sprite确实不建议放置在Resources下，如果需要动态加载，并且不希望使用AssetBundle，则可以尝试把需要动态加载的Sprite统一引用到Prefab上进行管理（类似于NGUI的管理方式，一个图集对应一个Prefab），然后动态加载Prefab并查找其管理的Sprite即可。&lt;/li&gt;
  &lt;li&gt;另一种方式是，可以直接关闭Unity的Sprite Packer功能，通过第三方的工具来进行图集的打包，导入Unity时转为Multiple类型的Sprite资源，那么即使放在Resources文件夹下，也不会造成DrawCall无法合并的问题。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;resourcesunloadunusedassetsresourcesunloadassetmasset&quot;&gt;纹理图片通过文件流形式加载到内存，这样的资源还可以使用Resources.UnloadUnusedAssets()和Resources.UnloadAsset(m_Asset)进行资源卸载吗？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;如果是自己载入内存并初始化为Unity的Texture2D，则还是要重点查看Texture2D对象的创建方式。一般来说，会用new Texture2D的方式创建，并用LoadImage的接口将一块内存载入，那么这样就要用DestroyImmediate来销毁这个纹理对象了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ui&quot;&gt;UI&lt;/h2&gt;
&lt;h4 id=&quot;uguicanvascanvascanvasrendererpanel&quot;&gt;请问UGUI的重绘是针对于拥有Canvas组件的Canvas物件，还是针对于拥有CanvasRenderer组件的Panel物件？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;UGUI中，Canvas组件可以认为是容器，Image，Text等组件（都需要CanvasRenderer组件）可以认为是元素。在Unity5.2版本之前，在网格重建时，会以Canvas为单位，即一个Canvas中所有的元素最终都是合并到一个Mesh中的，而其中可以被合并渲染的元素则被合在同一个SubMesh中。&lt;/li&gt;
  &lt;li&gt;在Unity5.2版本之后由于引入了多线程的网格合并方式，据我们所知，目前并没有官方的原理解释。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;工具&lt;/h2&gt;
&lt;h4 id=&quot;animatorsdirtysceneobjects&quot;&gt;对于Animators.DirtySceneObjects这个参数，它是和哪些因素有关，以及如何优化？&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2FTechSharing%2052%2F5.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;该参数是更新场景中受Mecanim动画系统影响的每个GameObject的Transform，所以当这类的GameObject数量越多时，其CPU占用也会越高。对于它的优化方式，主要有如下两种：
    &lt;ul&gt;
      &lt;li&gt;如果是蒙皮网格物体，则可以开启“Optimize GameObject”选项来对其进行优化；&lt;/li&gt;
      &lt;li&gt;如果是非蒙皮网格（比如具有动画的UI界面、2D Sprite等），则只能建议研发团队尽可能减少同一时刻运动的GameObject数量（一般都不会太多），如果是被缓存的屏幕外的物体，则切记要在移出时关闭其Animator组件。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;prefabselect-dependenciesshader&quot;&gt;编辑器模式下，Prefab用Select Dependencies选项找依赖资源的时候，会把以前旧Shader引用的贴图也给关联上，怎么刷新这种引用关系？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;在切换Material所使用的Shader时，其上的纹理引用确实是不会自动清除的（除非被覆盖）。因此，我们的建议是，在编辑Material时，如果要切换Shader，那么在切换好之后，进行一次Reset的操作（如下图所示，该操作会重置所有使用中的属性，同时去掉未使用的属性），然后再开始编辑其属性。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2FTechSharing_54%2F2.png&quot; alt=&quot;请输入图片描述&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果希望在不改变当前使用属性的前提下，去掉未使用的属性，那么据我们所知，只能启用Editor的Force Text模式，打开对应的.mat文件进行手动去除。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;gc-allocaddcomponent-&quot;&gt;请问怎么优化下图这两者的GC Alloc？每次AddComponent 都会有这么多的开销。&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2FTechSharing_54%2F1.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;不可避免，只有减少AddComponent。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;物理&lt;/h2&gt;
&lt;h4 id=&quot;physicsprocessing&quot;&gt;请问Physics.Processing的占用过大一般是因为什么原因导致的？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;影响物理系统耗时的因素主要为Contacts数量（碰撞对数量）、Rigidbody API的使用情况和每帧的调用次数。
    &lt;ul&gt;
      &lt;li&gt;第一种情况是最为常见的引发物理模块耗时较大的原因，因此，我们在UWA性能报告中对其进行了详细的分析，如果你的报告中Contacts数量较高，切记要验证其合理性。&lt;/li&gt;
      &lt;li&gt;第二情况造成较大CPU开销的情况不多，不过如果你的项目是多角色游戏（比如MMO、MOBA、ARPG割草游戏等），那么你需要注意了。在我们优化过的一些项目中，通过Rigidbody API来移动GameObject位置（设置velocity、改变center等）确实会存在较高的性能开销。如果你的项目也有类似的做法，那么要时刻关注物理模块的开销了。&lt;/li&gt;
      &lt;li&gt;第三种情况同样也是目前引发物理模块耗时较高的原因。因为Unity引擎默认情况下，物理的更新频率是0.02s，即每20ms更新一次，所以，当你的项目比较卡时（开发过程中的项目在中低端设备上恐怕没几个是不卡的），物理模块会让你的项目更卡。举个例子，如果上一帧CPU耗时为100ms的话，那么物理模块会执行5次，从而进一步加大物理系统的耗时。这种情况下，物理模块的耗时是很有欺骗性的，你花了好长时间去研究物理的耗时，最后发现原来这个“锅”不是它的…所以，如果你的项目也遇到了这种情况，切记不要再上当了。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;性能综合&lt;/h2&gt;
&lt;h4 id=&quot;section-3&quot;&gt;5.0后批处理修改&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;从Unity 5.0开始，Static Batching的合批机制就已经出现了变化，不再进行索引数组的合批，因此并不会使得Draw Call降低，而是会降低Batches和SetPassCall，因此从图中来看，Static Batching 开启后的统计数据是没有问题的。也因此，UWA在统计时，使用的就是Batches的数值。具体的原因可见Unity官方在论坛中的回复：
https://forum.unity3d.com/threads/regression-feature-not-bug-static-dynamic-batching-combining-v-buffers-but-not-draw-calls.360143/&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;dynamic-batching&quot;&gt;尽量开启“Dynamic Batching”这个选项&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog/TechSharing_53/1.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;详见&lt;a href=&quot;https://blog.uwa4d.com/archives/TechSharing_53.html&quot;&gt;此处&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;gcalloc&quot;&gt;匿名函数造成GCAlloc&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;结论：当不使用外部变量的匿名函数时，编译器会把这个函数变成静态函数，在首次调用时初始化，之后就再也不会new新的对象。 当使用外部变量时，每次调用都会生成一个临时action变量，这个就是alloc的原因。&lt;/li&gt;
  &lt;li&gt;解决方案:&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public Action&amp;lt;int, int&amp;gt; pCall;
void Start()
{
  pCall = CallVariable;
  ... // 其他初始化代码
}
void FixedCall()
{
  table.Forecah(pCall);
}
void CallVariable(int k, int v)
{
  count = k + v;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.uwa4d.com/archives/Anonymous_heapmemory.html&quot;&gt;原文&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-4&quot;&gt;渲染&lt;/h2&gt;
&lt;h4 id=&quot;lightmapngameobjectprefablightmapnlightmaplightmap&quot;&gt;请教Lightmap相关的优化问题。我现在的场景中有N个GameObject共用一个Prefab，烘培Lightmap时，会生成出N个Lightmap贴图。有没有办法把这些生成的Lightmap合成一张？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;如果场景中某些物件在Lightmap纹理中占据的空间较大，但实际上并不需要较高的精度，那么可以选中该物体，并在Lighting面板的Object子面板中将其Scale in lightmap数值调低，从而可以降低其在Lightmap纹理中的空间，甚至减少Lightmap纹理的数量。&lt;/li&gt;
  &lt;li&gt;PS:为何会有N个lightmap？并没有回答能不能合并的问题。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;unityshaderifdef-endifpass&quot;&gt;Unity里的Shader能不能用关键字#ifdef #endif把整个pass包起来？&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;#ifdef&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;#endif&lt;/code&gt; 并不能写在Pass之外，如果有动态开关Pass的需求，可以通过Shader Lod来实现，即设置两个Level不同的SubShader分别包含1个和2个Pass，直接通过改变该Shader的局部Lod值，即可实现SubShader的切换。关于Shader Lod的细节，可见官方文档：
http://docs.unity3d.com/Manual/SL-ShaderLOD.html&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 30 Oct 2017 10:07:00 +0800</pubDate>
        <link>https://caihua.tech/2017/10/30/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E5%8D%81%E4%B8%89%E5%91%A8/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/10/30/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E5%8D%81%E4%B8%89%E5%91%A8/</guid>
        
        <category>UWA</category>
        
        
      </item>
    
      <item>
        <title>Shader合并与Variant</title>
        <description>&lt;h4 id=&quot;section&quot;&gt;前言&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;写这个的起因是因为看了唐建伟大佬在UWA上发表的文章&lt;a href=&quot;https://blog.uwa4d.com/archives/USparkle_Shader.html&quot;&gt;合并Shader系列_如何合并渲染状态&lt;/a&gt;。看完后受益良多，但是也对文中这样合并shader会不会产生shader的变种（shader variant）有所担心，因此在UWA的问答上提出了问题，最后唐建伟也做出了&lt;a href=&quot;https://answer.uwa4d.com/question/59dd6f350461bc6f45206ad5/%E3%80%8A%E5%90%88%E5%B9%B6Shader%E7%B3%BB%E5%88%97-%7C-%E5%A6%82%E4%BD%95%E5%90%88%E5%B9%B6%E6%B8%B2%E6%9F%93%E7%8A%B6%E6%80%81%E3%80%8B%E8%BF%99%E7%AF%87%E6%96%87%E7%AB%A0%E5%BC%95%E5%8F%91%E7%9A%84shader-variant%E9%97%AE%E9%A2%98&quot;&gt;回答&lt;/a&gt;，经过大佬授权在这里根据回答进行一些总结，想看原文的可以直接点击链接。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;sahder-variant&quot;&gt;Sahder Variant的概念&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;其实一个variant可以理解为一个具体的在GPU上执行的小程序，而一个Shader通常会编译出非常多的variant来应对不同的情况，比如单说雾效就有如下：没有雾效、有线性雾、有指数雾1、有指数雾2这样的4个variant(ps:这里只考虑雾效，其他条件一致)。至于原因嘛，有很多，粗略归纳一下是因为GPU需要更多的并行处理、逻辑单元少，因此Shader里面要尽可能规避各种判断、循环语句等等，最后本来可以通过逻辑判断来处理的雾效就需要编译成不同的执行程序来对应不同的情况(ps：这是一种高级优化，背后的原理很多很多，建议自行查询相关资料，查明前因后果，我懂的也不多)。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;shader-variant&quot;&gt;问题1:这样通过多参数来设置渲染状态不会造成shader variant吗？&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;在这篇文章中，我们只合并了渲染状态，渲染状态的合并不会导致Unity编译出更多的shader variant。
口说无凭，那么我们就先拿一个示例Shader来做测试，我选用了文章中的“ShaderCombine/01.ShaderCombineSimpleZTest”来做测试，Unity版本为 5.5.4p3，使用Unity的Shader Variant Collection来算取Variant数量，不管是否加入合并的代码，Variant的数量都是259，如下图所示：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://uwa-public.oss-cn-beijing.aliyuncs.com/answer/image/public/101228/1507705049102.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;即便是使用“ShaderCombine/02.ShaderCombineCommonState”来测试，Variant的数量也是是259，如下图所示&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://uwa-public.oss-cn-beijing.aliyuncs.com/answer/image/public/101228/1507705061601.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;从上面的图片可以看出，不管是否有渲染状态的参数在里面，Variant的数量都不会改变。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;shader-variant-1&quot;&gt;问题2：什么情况下在才会造成shader variant呢？&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;宏定义(Keyword)，“#pragma multi_compile XXX YYY ZZZ”，“#pragma multi_compile_xxx”，SubShader，Pass，Fallback及一些特殊不常用命令等的增减会造成variant的数量变化。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;至于一个Shader到底会生成多少variant呢？精确的计算方法，Unity并没有给出，但是我的归纳总结一下就是几组不同的编译宏的组合了，比如雾效、光照图、光源、阴影等等。另外还可以通过Unity的工具Shader Variant Collection来查看一个Shader到底有多少个variant，也可以在里面来自己组合和预编译自己想要的variant。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;variant&quot;&gt;福利：为什么修改渲染状态不会产生variant？&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;刚刚我们说了造成variant数量增加主要是需要生成不同的variant来应对不同的情况，那么不同的渲染状态是不是不同的情况呢？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;其实不是。生成不同的variant主要是为了消灭Shader内部的逻辑判断（ps：Shader的真正逻辑是CGPROGRAM…ENDCG中间的东西）。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;继续用雾效举例，先只考虑有雾效和没雾效，按一般的游戏逻辑写法，我们通常会在逻辑里用一个if判断来搞定，但是由于GPU的特殊性，这样的做法非常低效、不可取，那么就会使用Keyword这样的编译宏在编译的时候就分别编译为有雾效和没雾效的2个执行程序，也就是2个variant。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;现在说会渲染状态，看任何的Shader，我们都不会在CGPROGRAM…ENDCG里面有关于渲染状态的处理代码，当然不需要为不同的渲染状态编译不同的variant，也就不会造成variant的增加。（这部分可以参看Unity的渲染流水线，渲染一个物体需要非常多的步骤，我们写的Shader编译成的variant只在流水线中的两个可编程部分执行，而渲染状态是设置其他步骤的，与variant是完全隔离开、互不干扰。也可以说CGPROGRAM…ENDCG内的逻辑决定了variant的数量，CGPROGRAM…ENDCG外的是给Unity配置状态用的，不会引起Shader的逻辑变化，因此没变化）。
另附上一张简化版渲染流程图：
&lt;img src=&quot;https://uwa-public.oss-cn-beijing.aliyuncs.com/answer/image/public/101228/1507705163873.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Wed, 25 Oct 2017 00:02:11 +0800</pubDate>
        <link>https://caihua.tech/2017/10/25/Shader%E5%90%88%E5%B9%B6%E4%B8%8EVariant/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/10/25/Shader%E5%90%88%E5%B9%B6%E4%B8%8EVariant/</guid>
        
        <category>UWA</category>
        
        
      </item>
    
      <item>
        <title>每天一点UWA：第十二周</title>
        <description>&lt;h2 id=&quot;ui&quot;&gt;UI&lt;/h2&gt;
&lt;h4 id=&quot;ugui&quot;&gt;对于UGUI文字花屏问题，有什么推荐的解决方法吗？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;对于UGUI字体花屏的现象， 很有可能是字体的UV不准确导致。&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/yaukey/p/unity_ugui_font_texture_uv_wrong.html&quot;&gt;关于UGUI字体花屏和乱码&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;UGUI研究院之Text字体花屏（二十二）：http://www.xuanyusong.com/archives/4259&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;工具&lt;/h2&gt;
&lt;h4 id=&quot;deep-profilercolor--colorselftotalprofilerbeginsample0deep-profiler&quot;&gt;最近用Deep Profiler发现项目里有一个直接调用Color != Color的接口耗时很高，而且百分比也很高（不管是Self还是Total）。但是如果用Profiler.BeginSample显示时，其耗时又很低，百分比也很低几乎等于0。这样的情况下是Deep Profiler出问题了吗？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;针对上图具体例子来看，Deep Profiler中RoleRender_ChangeColor.get_running的CPU开销虽然较高，但其参考意义不大。因为不开Deep Profiler模式，此处开销是不会这么高的。&lt;/li&gt;
  &lt;li&gt;这是因为，图中的开销实际上是操作了200次循环且获取时间戳的开销，也就是说，当循环或者操作大量次数时，Deep Profiler模式中本身统计耗时操作的时间占比很大，所以此处反馈的时间其实并不是研发团队想看到的真正代码耗时。这也是为何很多团队反馈Deep Profiler统计不算准确的原因。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;粒子&lt;/h2&gt;
&lt;h4 id=&quot;section-2&quot;&gt;粒子系统里面使用到的模型，是不是读写开关必须要打开，否则会崩溃？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;这个问题在第六周的内容中有提到原因。在较新的版本上（例如4.7.2，5.3.5 等版本）进行了各种情况的测试后，尚未复现出这一现象。因此，我们建议研发团队可以尝试关闭 Readable选项。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-3&quot;&gt;模型&amp;amp;动画&lt;/h2&gt;
&lt;h4 id=&quot;skinnedmeshrenderermeshsharedmesh&quot;&gt;SkinnedMeshRenderer的Mesh是不是不能动态修改？属性里只开放了SharedMesh。&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;https://blog.uwa4d.com/archives/TechSharing_51.html  mark一下。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-4&quot;&gt;渲染&lt;/h2&gt;
&lt;h4 id=&quot;unitymaterialobjectmaterialbatching&quot;&gt;Unity中修改了Material的一个属性后，该Object就会单独实例化出一个Material，所以它就不能被动态Batching了，是这样吗？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;是的，所以我们在Material使用详情中对内存中驻留的Material进行了详细的检测和分析，如下图所示。
&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog/TechSharing_51/3.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;图中后缀为（Instance）的材质均为修改材质属性而生成的临时材质，对于这种情况，我们建议研发团队应严格将Instance材质数量控制在尽可能小（&amp;lt;10）的范围内，而对于过高数量的Instance材质，建议研发团队考虑是否可以通过动态更换Material的方式来代替修改材质属性的方式，从而来减少不必要的Instance材质，进而提升物体动态合批的几率。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;a2bsetactivefalse&quot;&gt;游戏中有一些静止的建筑，会和整个场景一起烘焙（包括了每个建筑在地表的阴影）。现在希望这些建筑是逐步开放的，比如玩家1级的时候只有建筑A开放，2级的时候建筑B开放，现在的问题是当建筑未开放时（SetActive(false)）地表的相关阴影还在。这种问题一般是怎么处理的？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;这种问题是因为研发团队将整个场景烘焙成一张Lightmap所致。如果地图中的建筑是固定的，且游戏中并没有动态改变方向光的需求（比如Time Of Day模拟），那么可以尝试以下方法来实现需求：&lt;/li&gt;
  &lt;li&gt;（1）如果建筑物是根据等级而批量出现的，那么可以尝试根据等级不同而烘焙相应建筑群的Lightmap，然后在游戏中根据需求动态替换Lightmap；&lt;/li&gt;
  &lt;li&gt;（2）如果是逐个出现且建筑之间相距较为紧密的话，那么建议尝试通过Dynamic Projector（Asset Store插件）或Shadow Map（Unity自带阴影）来进行处理，因为Lightmap方法已无法支持这种需求。同时，可配合Fast Shadow Receiver（Asset Store 插件）来尽可能降低上述实时阴影带来的性能开销。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 23 Oct 2017 09:02:00 +0800</pubDate>
        <link>https://caihua.tech/2017/10/23/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E5%8D%81%E4%BA%8C%E5%91%A8/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/10/23/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E5%8D%81%E4%BA%8C%E5%91%A8/</guid>
        
        <category>UWA</category>
        
        
      </item>
    
  </channel>
</rss>
