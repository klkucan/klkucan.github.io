<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>蔡华的博客</title>
    <description>Be publicly useful and privately happy.</description>
    <link>https://caihua.tech/</link>
    <atom:link href="https://caihua.tech/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sun, 27 Aug 2017 18:31:41 +0800</pubDate>
    <lastBuildDate>Sun, 27 Aug 2017 18:31:41 +0800</lastBuildDate>
    <generator>Jekyll v3.2.1</generator>
    
      <item>
        <title>每天一点UWA：第五周</title>
        <description>&lt;h2 id=&quot;assetbundle&quot;&gt;AssetBundle&lt;/h2&gt;
&lt;h4 id=&quot;shader&quot;&gt;shader加载&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;首先 Shader. WarmupAllShaders 并不影响 Shader 的加载，因为该函数的作用是将所有已加载的 Shader 都做一次快速渲染(渲染单个像素，GPU 在首次使用某一个 Shader 时会有额外开销，Warm 相当于是将这部分开销提前)。&lt;/li&gt;
  &lt;li&gt;可以通过AssetBundle.LoadAll等接口预加载 AssetBundle 中的 Shader。而对于 Always Included Shaders 中的 Shader 则可以通过 Shader. Find 来预加载。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;streamingassetpath--persistantdatapathloadassetbundle&quot;&gt;StreamingAssetPath 和 PersistantDataPath直接load非AssetBundle资源？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;可以但是只能用WWW这样的有限的API.&lt;/li&gt;
  &lt;li&gt;如果load MP3、JPG这样的非内部资源格式效率低，尤其是JPG还要软解码，效率更低。&lt;/li&gt;
  &lt;li&gt;还是推荐AssetBundle。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;unity-5x--fbx--mesh--animationclip--assetbundle-name&quot;&gt;在Unity 5.x 的打包机制下确实无法手动为 FBX 下的 Mesh 或 AnimationClip 单独资源设置 AssetBundle Name。&lt;/h4&gt;

&lt;h4 id=&quot;animatorfbxfbxfbxassetbundle&quot;&gt;如果Animator是直接引用了FBX里的动画文件，而不是复制了FBX的动画文件出来再引用，那么打包的时候不会把FBX打进AssetBundle。&lt;/h4&gt;

&lt;h4 id=&quot;resourcesunloadunusedassetsassetbundleloadassetbundleunloadfalse&quot;&gt;Resources.UnloadUnusedAssets同样可以卸载由AssetBundle.Load加载的资源，只是前提是其对应的AssetBundle已经调用Unload(false)，且并没有被引用。&lt;/h4&gt;

&lt;h3 id=&quot;assetbundle-1&quot;&gt;总结一下AssetBundle的加载和卸载&lt;/h3&gt;
&lt;h4 id=&quot;section&quot;&gt;加载&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;AssetBundle的各种创建函数可以从本地文件(LoadFromXXX)或者内存中将AssetBundle加载到一块内存区域（use from memory or unitywebrequest）或者只是建立一个序列化引用(use loadformfile)。&lt;/li&gt;
  &lt;li&gt;AssetBundle的各种load函数会将真正的asset从AssetBundle中加载出来到内存中。&lt;/li&gt;
  &lt;li&gt;instantiate函数创建GameObject实例&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-1&quot;&gt;卸载&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;AssetBundle的实例函数unload（false）会卸载内存中的AssetBundle（虽然函数的说明中是Unloads all assets in the bundle.），参数是true的话删除AssetBundle和用它创建的asset。&lt;/li&gt;
  &lt;li&gt;上面的函数针对的单个AssetBundle，而UnloadAllAssetBundles这个静态函数就是针对所有当前已经load的AssetBundle了。&lt;/li&gt;
  &lt;li&gt;对于一个具体的asset可以使用Resources.UnloadAsset来卸载，或者使用Resources.UnloadUnusedAssets将多有没有引用的asset卸载。前提就是调用过AssetBundle的Unload（不论参数是false还是true）。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;build&quot;&gt;Build&lt;/h2&gt;
&lt;h4 id=&quot;optimize-mesh-data&quot;&gt;Optimize Mesh Data选项&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;build时我们在player setting里面有这个选项，它只针对Build Player或者Bundle 时才生效的，所以提前做的AssetBundle是无效的。&lt;/li&gt;
  &lt;li&gt;模型导入时也有个Optimize Mesh选项，是调整面片排序的，和build时的是两回事。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ui&quot;&gt;UI&lt;/h2&gt;
&lt;h4 id=&quot;ugui-resourcesunloadunusedassets&quot;&gt;UGUI做的一个界面中有一个背景图片，关闭销毁这个界面后调用 Resources.UnloadUnusedAssets，图片还在内存中&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;在使用 Resources.Load 加载 UI 界面的情况下，即使“关闭销毁这个界面”后，Resources.UnloadUnusedAssets 确实还是无法卸载对应的图集的。因为此时该图集依然被 Resources.Load 加载出来的 Prefab 引用。&lt;/li&gt;
  &lt;li&gt;建议是手动调用 Resources.UnloadAssets 来手动释放图集（可以通过 Sprite.texture 来找到对应的图集），在重新实例化该 UI 界面时，图集也会自动进行 Reload 的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;模型&lt;/h2&gt;
&lt;h4 id=&quot;meshbaker-meshprefabfbxmodelgenerate-lightmap-uvs-&quot;&gt;MeshBaker 烘焙的Mesh可以保存到Prefab中，但是不能像FBX一样，设置Model导入设置中的Generate Lightmap UVs 等信息，请问有没有大招可以处理此情况？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;首先从理论上说，一个 Mesh 只能有一个 LightmapIndex 和 LightmapOffset 属性，这就决定了 Mesh 的合并必须在 Lightmap 的烘焙之前。&lt;/li&gt;
  &lt;li&gt;做Mesh合并时，需要注意到UV2对于一个Mesh而言，其所有三角面的UV区域都必须是互不重叠的，所以不能简单直接地合并。
考虑到合并前每一个Mesh的UV2区域都应该是在[0,1]x[0,1]的区间中，在合并时可以给每一个UV2区域做一个缩小和平移，从而可以把每个区间在互不重叠的情况下，放到同一个[0,1]x[0,1]的区间中。
在UV2也正确拼合后，重新进行Lightmap的烘焙即可得到正确的效果。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;batch&quot;&gt;关于静态batch&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;勾选Static的GameObject下的Mesh都会被合入CombineMesh（无论什么材质），且每个Mesh都作为SubMesh存在。&lt;/li&gt;
  &lt;li&gt;在Unity 5.3之前，对于渲染顺序相邻且材质相同的SubMesh则会动态将其索引数组拼合，从而合成一个Draw Call。&lt;/li&gt;
  &lt;li&gt;而Unity 5.3之后（还是在同材质，渲染顺序相邻的前提下）则不再拼合索引数组，因为在不切换材质时产生多个Draw Call的开销并不大，而这多个Draw Call会被统计为一个Batch。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;staticbatchingutilitycombinecombined-mesh&quot;&gt;如何删除StaticBatchingUtility.Combine会产生Combined Mesh的内存&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;通过某个使用了该Combined Mesh的MeshFilter来获取其引用（MeshFilter.sharedMesh），然后通过Destroy接口来将其卸载。因为Combined Mesh不属于真正的Assets（在Deep Memory中不属于Assets下，而是在Scene Memory下），所以不能用Resources.UnloadAsset来卸载。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-3&quot;&gt;内存&lt;/h2&gt;
&lt;h4 id=&quot;assetbundle-2&quot;&gt;AssetBundle内存占用问题&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;在webStream仍旧存在时（似乎是5.4之前），一个AssetBundle（1mb）解压到websream后如果是2mb，那么这个AssetBundle最终所占的内存就是2mb，因为webstream中已经包含了AssetBundle。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;assetbundle-3&quot;&gt;AssetBundle资源卸载&lt;/h4&gt;
&lt;p&gt;AssetBundle加载好以后立刻通过Instantiate实例化一个对象，然后通过Resources.UnloadAsset和Resources.UnloadUnusedAssets来进行卸载，如果无法卸载，则该资源一定被缓存了。&lt;/p&gt;

</description>
        <pubDate>Sun, 27 Aug 2017 18:27:46 +0800</pubDate>
        <link>https://caihua.tech/2017/08/27/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E4%BA%94%E5%91%A8/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/08/27/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E4%BA%94%E5%91%A8/</guid>
        
        <category>UWA</category>
        
        
      </item>
    
      <item>
        <title>bat学习</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;概念&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;批处理的本质，是一堆DOS和cmd命令按一定顺序排列而形成的集合。&lt;/li&gt;
  &lt;li&gt;熟悉DOS语法，然后按照正确的顺序来进行指令的运行。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-1&quot;&gt;系统教程&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;使用/?查看if的功能，使用与很多指令，&lt;code class=&quot;highlighter-rouge&quot;&gt;%&lt;/code&gt;似乎不行。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if /?
pause

--------------------------------------------

C:\Users\Administrator\Desktop&amp;gt;
执行批处理程序中的条件处理。

IF [NOT] ERRORLEVEL number command
IF [NOT] string1==string2 command
IF [NOT] EXIST filename command

  NOT               指定只有条件为 false 的情况下，Windows 才
                    应该执行该命令。

  ERRORLEVEL number 如果最后运行的程序返回一个等于或大于
                    指定数字的退出代码，指定条件为 true。

  string1==string2  如果指定的文字字符串匹配，指定条件为 true。

  EXIST filename    如果指定的文件名存在，指定条件为 true。

  command           如果符合条件，指定要执行的命令。如果指定的
                    条件为 FALSE，命令后可跟 ELSE 命令，该命令将
                    在 ELSE 关键字之后执行该命令。

ELSE 子句必须出现在同一行上的 IF 之后。例如:

    IF EXIST filename. (
请按任意键继续. . .
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;demo&quot;&gt;从一个demo中学习&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;这个demo的作用是用来更新游戏客户端的。一般来说我们的端游客户端会有一个launcher来启动真正的游戏，它还要负责来更新游戏。同时，它还要更新自己，以前WOW中的做法是有个专门的update.exe来做更新（不过现在是靠battle.net来更新了），我觉得bat文件一样可以做，因此写了这个demo。下面代码中TL代表launcher，TC代码client。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@echo on
cls

:: 当前程序所在目录
set LocalPath=%~dp0
:: TL更新包完全路径名,不带后缀，同时也是解压缩后的文件夹名称
set  TLZipFile=%~dp0TLUpgradeData\TL_%1
:: TL更新包解压路径
set  TLDecompressPath=%~dp0TLUpgradeData\

echo 执行更新，请稍后...

echo ----1.关闭客户端进程----
tasklist /nh|find /i &quot;TL.exe&quot;
if ERRORLEVEL 1 (echo TL客户端进程已经结束) else (taskkill /f /im TL.exe)
tasklist /nh|find /i &quot;TC.exe&quot;
if ERRORLEVEL 1 (echo TC客户端进程已经结束) else (taskkill /f /im TC.exe)

echo ----2.开始解压缩安装包----
if exist %TLZipFile%.zip   %LocalPath%7z x %TLZipFile%.zip -o%TLDecompressPath% -aoa

echo ----3.开始复制文件----
xcopy %TLZipFile%  %LocalPath% /e /f /k /y
:: xcopy switch说明：
:: /E           复制目录和子目录，包括空目录。
:: /F           复制时显示完整的源文件名和目标文件名。
:: /K           复制属性。一般的 Xcopy 会重置只读属性。
:: /Y           取消提示以确认要覆盖

echo ----4.删除临时文件----
del %TLZipFile%.zip
rmdir %TLZipFile% /s /q
:: 删除当文件夹和里面的所有文件，/s 表示包含子文件夹，/q 表示不需要确实提示 
pause

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-2&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;@&lt;/code&gt;&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;它的作用是让执行窗口中不显示它后面这一行的命令本身。行首有了它的话，这一行的命令就不显示了。首行的@echo off中，@的作用就是让脚本在执行时不显示后面的echo off部分。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-3&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;::&lt;/code&gt; -双冒号&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;类似注释符号&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-4&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&amp;gt;&lt;/code&gt;&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&lt;/code&gt;指示将内容写入某个文件&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&amp;gt;&lt;/code&gt;的作用，和&amp;gt;的相同，区别是把结果追加到前一行得出的结果的后面，类似写文件时的append。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;echo&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;echo&lt;/code&gt;的三个用法&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;命令显示与否的开关，有off和on两个选项。设置为off后，后续所有的命令都不会显示命令本身，只显示命令的结果。&lt;/li&gt;
  &lt;li&gt;类似于print，用于输出信息。&lt;/li&gt;
  &lt;li&gt;可以直接编辑文本文件。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;pause-&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;pause &lt;/code&gt;&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;就是字面意思&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;goto&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;goto&lt;/code&gt;&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;goto用于与其它语言是一样的，就是跳转到一个指定的标签&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:&lt;/code&gt;是定义一个标签&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;if&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;if&lt;/code&gt;&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@echo off

if &quot;%1&quot; == &quot;1&quot; goto goto1
if &quot;%1&quot; == &quot;2&quot; goto goto2

:goto1
echo 参数是goto1

:goto2
echo 参数是goto2
pause
exit
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;就是条件判断，只不过跟着不同的命令产生不同的功能&lt;/li&gt;
  &lt;li&gt;if exist判定存在&lt;/li&gt;
  &lt;li&gt;结果判断&lt;/li&gt;
  &lt;li&gt;if not 否定判定&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-5&quot;&gt;变量&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;使用set来进行变量设置，set还有几个switch。当变量的来源是输入内容时用&lt;code class=&quot;highlighter-rouge&quot;&gt;set /p&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;set variable=value&lt;/code&gt;注意这个语句中等号前后没有空格，我发现有空格的话变量赋值有问题。&lt;/li&gt;
  &lt;li&gt;使用变量时用&lt;code class=&quot;highlighter-rouge&quot;&gt;%variable%&lt;/code&gt;的形式，即两个百分号夹住变量名。&lt;/li&gt;
  &lt;li&gt;与传统的编程语言不同，bat中变量不能连接使用，比如下面这样是不行的。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;set a=1
set b=%a%2
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-6&quot;&gt;外部参数&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;%（0-9）来表示参数，其中%0代表自己，demo中只有一个参数是当前最新的版本号，用的是%1。&lt;/li&gt;
  &lt;li&gt;bat中参数有很多用法，具体不描述了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;cmd&quot;&gt;其它的cmd命令&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;demo中还是有tasklist、taskkill、del、rmdir这样的命令，这些就不一一解释了。其实这些全部都是cmd的命令，这样验证了开始时说的，其实bat就是顺序执行一些dos和cmd命令。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-7&quot;&gt;资源&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;这个demo的完整资源在GitHub的&lt;a href=&quot;https://github.com/klkucan/UpgradeByBat&quot;&gt;这个&lt;/a&gt;位置。&lt;/li&gt;
  &lt;li&gt;另外推荐一篇&lt;a href=&quot;http://www.cnblogs.com/s1ihome/archive/2009/01/15/batTutorial.html&quot;&gt;bat学习的文章&lt;/a&gt;，写的很不错。&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sun, 27 Aug 2017 18:22:24 +0800</pubDate>
        <link>https://caihua.tech/2017/08/27/bat%E5%AD%A6%E4%B9%A0/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/08/27/bat%E5%AD%A6%E4%B9%A0/</guid>
        
        <category>UWA</category>
        
        
      </item>
    
      <item>
        <title>每天一点UWA：加载模块深度解析</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;专题&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;因为UWA上会对一些技术进行系列的专题讲解，而且文章并不连续，如果按照每周的形式就会割裂这些内容，因此针对这样的情况统一写成专题形式。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;概述&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;载模块中最为耗时的性能开销可以归结为以下几类：资源加载、资源卸载、Object的实例化和代码的序列化等。&lt;/li&gt;
  &lt;li&gt;资源加载是加载模块中最为耗时的部分，其CPU开销在Unity引擎中主要体现在Loading.UpdatePreloading和Loading.ReadObject两项中。&lt;/li&gt;
  &lt;li&gt;Loading.UpdatePreloading，这一项仅在调用类似LoadLevel（Async）的接口处出现，主要负责卸载当前场景的资源，并且加载下一场景中的相关资源和序列化信息等。下一场景中，自身所拥有的GameObject和资源越多，其加载开销越大。&lt;/li&gt;
  &lt;li&gt;Loading.ReadObject，这一项记录的则是资源加载时的真正资源读取性能开销，基本上引擎的主流资源（纹理资源、网格资源、动画片段等等）读取均是通过该项来进行体现。可以说，这一项很大程度上决定了项目场景的切换效率。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;纹理篇&lt;/h2&gt;
&lt;h3 id=&quot;section-3&quot;&gt;只给出结论&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;同一的格式下（ETC1（Android）和PVRTC（iOS）、且关闭Mipmap功能），图片分辨率越大加载越慢，但是在Android上中（红米NOTE2）高（S6）端机在加载效率上差不多。&lt;/li&gt;
  &lt;li&gt;同一分辨率（1024x1024）上
  -不同格式（对于Android平台，使用ETC1、ETC2、RGBA16和RGBA32四种格式，对于iOS平台，使用PVRTC 4BPP、RGBA16和RGBA32三种格式）
    &lt;ul&gt;
      &lt;li&gt;所占的内容首先是有差异的（三组纹理的内存占用分别为1MB、1MB、4MB 和 8MB（Android平台）/1MB、4MB 和 8MB（iOS平台））。&lt;/li&gt;
      &lt;li&gt;加载效率上，ETC1、ETC2、RGBA16基本一致；PVRTC 4BPP、RGBA16基本一致。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;开启Mipmap功能会导致资源加载更为耗时，且设备性能越差，其加载效率影响越大。&lt;strong&gt;打破了Android上同一分辨率下ETC1、ETC2、RGBA16基本一致的情况，需要慎用。&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;PS：压缩后的文件大小，和解压缩的效率与纹理的内容相关，这是因为图片的压缩本质是用矩阵对图片数据进行变换，最终得到一个较小的数据。解压缩也是一样，数据的内容影响了反向计算的效率。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;uwa&quot;&gt;UWA给出的建议&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;严格控制RGBA32和ARGB32纹理的使用，在保证视觉效果的前提下，尽可能采用“够用就好”的原则，降低纹理资源的分辨率，以及使用硬件支持的纹理格式。&lt;/li&gt;
  &lt;li&gt;在硬件格式（ETC、PVRTC）无法满足视觉效果时，RGBA16格式是一种较为理想的折中选择，既可以增加视觉效果，又可以保持较低的加载耗时。&lt;/li&gt;
  &lt;li&gt;严格检查纹理资源的Mipmap功能，特别注意UI纹理的Mipmap是否开启。在UWA测评过的项目中，有不少项目的UI纹理均开启了Mipmap功能，不仅造成了内存占用上的浪费，同时也增加了不小的加载时间。&lt;/li&gt;
  &lt;li&gt;ETC2对于支持OpenGL ES3.0的Android移动设备来说，是一个很好的处理半透明的纹理格式。但是，如果你的游戏需要在大量OpenGL ES2.0的设备上进行运行，那么我们不建议使用ETC2格式纹理。因为不仅会造成大量的内存占用（ETC2转成RGBA32），同时也增加一定的加载时间。下图为测试2中所用的测试纹理在三星S3和S4设备上加载性能表现。可以看出，在OpenGL ES2.0设备上，ETC2格式纹理的加载要明显高于ETC1格式，且略高于RGBA16格式纹理。因此，建议研发团队在项目中谨慎使用ETC2格式纹理。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-4&quot;&gt;网格篇&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;总结一下：网格的加载效率的影响因素在于网格面数、顶点信息（tangent、color）数和read/write是否开启。&lt;/li&gt;
  &lt;li&gt;结论很简单，面数多、信息多、开启会造成内存的变大和加载的变慢。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-5&quot;&gt;建议&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;在保证视觉效果的前提下，尽可能采用“够用就好”的原则，即降低网格资源的顶点数量和面片数量；&lt;/li&gt;
  &lt;li&gt;研发团队对于顶点属性的使用需谨慎处理。通过以上分析可以看出，顶点属性越多，则内存占用越高，加载时间越长；&lt;/li&gt;
  &lt;li&gt;如果在项目运行过程中对网格资源数据不进行读写操作（比如Morphing动画等），那么建议将Read/Write功能关闭，既可以提升加载效率，又可以大幅度降低内存占用。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;shader&quot;&gt;Shader篇&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Shader资源的效率加载瓶颈并不在其自身大小的加载上，而是在Shader内容的解析上。&lt;/li&gt;
  &lt;li&gt;总结一下：，Mobile-Bumped Diffuse、Mobile-Diffuse、Mobile-VertexLit和Mobile-Particles Additive加载耗时依次减少，对于的normal版本也是一样。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;shader-1&quot;&gt;影响shader解析的因素&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;一般情况下，Shader加载的CPU耗时与其Keyword数量有关，Keyword数量越多，则加载开销也越大。&lt;a href=&quot;https://blog.uwa4d.com/archives/LoadingPerformance_Shader.html&quot;&gt;（具体数据看原文）&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Shader的Keyword数量是会随着场景设置的不同而变化的。在Unity 5.x中，Unity默认会根据场景设置、Shader Pass等来调整Shader的Keyword，比如如果存在Lightmap的使用，则会默认将对应的Keyword打开，而对于没有使用Fog的项目，则会直接将相关Keyword关闭。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-6&quot;&gt;如何提高解析速度&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;就是减少keyword数量。&lt;/li&gt;
  &lt;li&gt;首先可以使用skip variant来减少
&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/UWALab%2FLoadingPerformance%2FShader_SkipVariantsCode.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;其次去掉Fallback选项，因为文中认为目前不支持Mobile/Diffuse和Mobile/Bumped Diffuse的设备已经相当少，没有必要做这层保险了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-7&quot;&gt;避免重复解析&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;因为一个游戏内用到的shader的数量不会太多，如果shader打包到场景或者模型的AssetBundle中，那么在资源加载卸载的过程中会出现同一个shader多次加载解析的问题。因此建议shader单独打包。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;注意：对于Unity4.x版本，Shader的AssetBundle加载后只需LoadAll即可完成所有Shader的加载和解析，但对于Unity5.x版本，除执行LoadAllAssets操作外，还需要进行Shader.WarmupAllShaders操作，因为在Unity5.x版本中，Shader的解析和CreateGPUProgram操作是分离的。&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对于Unity 5.x版本且正在使用Resources.Load来加载资源的研发团队，可以尝试使用ShaderVariantCollection来对Shader进行Preload，同样也可以达到避免相同Shader重复加载的效果。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;注意：对于Unity5.x版本，如果可以通过AssetBundle来加载和解析Shader，则不建议通过ShaderVariantCollection来处理Shader的加载。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-8&quot;&gt;总结&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;综上所述，shader的处理就是减少keyword、对于简单的渲染去掉Fallback、尽量对shader进行单独打包。&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sun, 27 Aug 2017 18:20:55 +0800</pubDate>
        <link>https://caihua.tech/2017/08/27/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9D%97%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/08/27/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9D%97%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/</guid>
        
        <category>UWA</category>
        
        
      </item>
    
      <item>
        <title>每天一点UWA：第四周</title>
        <description>&lt;h2 id=&quot;assetbundle&quot;&gt;AssetBundle&lt;/h2&gt;
&lt;h4 id=&quot;resourcesunloadassetgameobjectcomponenttexturemeshprefabobjectcomponent&quot;&gt;Resources.UnloadAsset仅能释放非GameObject和Component的资源，比如Texture、Mesh等真正的资源。对于由Prefab加载出来的Object或Component，则不能通过该函数来进行释放。&lt;/h4&gt;

&lt;h4 id=&quot;resourceprefab-load&quot;&gt;用的是Resource的加载方式，并且已经预加载好了材质所在的Prefab ，但是为什么在第一次显示材质的时候还要Load这个材质？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;我的理解是prefab只是个资源GUID的合集，并不包含真正的资源。所以要使用真正的资源（mesh\texture等时要加载。）&lt;/li&gt;
  &lt;li&gt;通过 Resources 加载和通过 AssetBundle 加载是有所区别的。Resources.Load 和 Instantiate 操作都不会立刻加载其依赖的材质，因此在loadPrefab = Resources.Load之后，其依赖的材质（包括相关的 Shader 和纹理）实际并没有被加载到内存中，在实例化后也是一样，直到某个 Camera 需要对其进行渲染时（调用了 Material.SetPastFast），才发现该材质还没进内存，此时才开始进行加载。&lt;/li&gt;
  &lt;li&gt;因此，在使用 Resources 加载的情况下，如果希望提前加载该 Material 以及相关的 Shader 和纹理，可以尝试通过调用 Resources.Load 直接加载该材质和纹理，并通过 Shader.Find 来加载 Shader。也可以尝试通过 Player Settings 中的 Preload Shaders（配合 Graphics Settings 下的 Preloaded Shaders） 和 Preloaded Assets 来批量预加载。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;build&quot;&gt;Build&lt;/h2&gt;
&lt;h4 id=&quot;editoronly-tag&quot;&gt;EditorOnly tag&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;prefab打上EditorOnly tag，但是放到了Resources文件夹下一样会打包进入，因为理论上只对场景中的GameObject有效。- 不放到Resources文件夹下，然后在使用EditorOnly tag，打包时就会认为没有场景中的物件引用prefab，就不会打包了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;shader&quot;&gt;内置的shader怎么打包？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;通常有两种方式对内置的Shader进行打包：&lt;/li&gt;
  &lt;li&gt;将其添加到Graphics Settings中的Always Included Shaders 中，此时添加后的内置Shader就不会被打入AssetBundle包中；&lt;/li&gt;
  &lt;li&gt;在http://unity3d.com/cn/get-unity/download/archive下载内置的 Shader，将其导入项目，并替换成非内置的材质球，从而可以直接通过脚本来控制其打包的方式。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;gcmarkdependenciescpuresourcesunloadunusedassets-&quot;&gt;GC.MarkDependencies的CPU消耗有过高，虽然在退出战斗的时候调用了Resources.UnloadUnusedAssets(); 可是卡顿还是很明显&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;GC.MarkDependencies的消耗是由Resources.UnloadUnusedAssets引起的。该函数的主要作用是查找并卸载不再使用的资源。游戏场景越复杂、资源越多，该函数的开销越大，一般在300~2000 ms范围内。&lt;/li&gt;
  &lt;li&gt;对于该函数的优化，我们建议一方面控制场景中不必要的资源量，同时通过UnloadAsset来及时卸载不再使用的资源，以减少Resources.UnloadUnusedAssets的耗时压力。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;assetbundlemd5&quot;&gt;打包时候AssetBundle的md5总变化(被打包的东西没变)&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;对于Unity 4.x版本的AssetBundle文件，其md5值在某些情况下确实会前后不一致（哪怕是完全一样的内容进行打包）。对于该系列版本，仅能建议开发团队建立配置文件来对AssetBundle进行管理。&lt;/li&gt;
  &lt;li&gt;而对于Unity 5.x版本，则可以在打包时开启 AppendHashToAssetBundleName 选项，这样Unity引擎会在每个AssetBundle文件后生成一个唯一的HashID（显示地放在文件名后），开发团队可以通过该ID来判断对应的AssetBundle文件是否发生改变。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;cpu&quot;&gt;CPU&lt;/h2&gt;
&lt;h4 id=&quot;gameobjectinstantiate&quot;&gt;第一次执行GameObject.Instantiate一些资源的时候会卡&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Instantiate的卡顿与三部分开销相关：相关资源加载、脚本组件的序列化和构造函数的执行，并且绝大部分原因均是相关资源加载导致。所以，我们的建议如下：
    &lt;ul&gt;
      &lt;li&gt;通过 Profiler 查看 Instantiate 具体的CPU分配情况；&lt;/li&gt;
      &lt;li&gt;如果是资源加载导致的性能瓶颈，则一方面通过简化资源来缓解CPU耗时压力，另一方面通过 AssetBundle 依赖关系打包将资源预先加载，即将此处 Instantiate 的总体耗时拆分，平摊到之前帧进行执行（比如切换场景处等），从而让 Instantiate 实例化操作的局部耗时更加平滑；&lt;/li&gt;
      &lt;li&gt;如果是脚本组件序列化导致的性能瓶颈，则可尝试减少脚本中的序列化信息；
  -如果是构造函数的执行导致的性能瓶颈，一般只能在策略上进行规避，比如降低 Instantiate 的调用频率等。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ui&quot;&gt;UI&lt;/h2&gt;
&lt;h4 id=&quot;ui-1&quot;&gt;本周的UI有很多不错的技术知识&lt;/h4&gt;

&lt;h4 id=&quot;ngui&quot;&gt;能否对提升NGUI的渲染效率提供一些思路？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;开发团队可以从以下几点入手：
    &lt;ul&gt;
      &lt;li&gt;通常一个Panel会产生1个或多个Draw Call，以一个Panel为单位，Draw Call 的数量通常由当前 Panel 中使用的Atlas、Font的数量所决定。&lt;/li&gt;
      &lt;li&gt;要降低UI渲染时的 Draw Call数量则需要对 Atlas 的制作进行合理的规划，即在保证使用较少的 Atlas 的同时，还需要保证 Atlas之间不会存在交叉遮挡。&lt;/li&gt;
      &lt;li&gt;要注意UI Texture的使用，每个UITexture自身会占用一个Draw Call，同时如果其Depth值穿插在了其他来自相同Atlas的UISprite中，还会导致Draw Call的打断，造成不必要的额外Draw Call。&lt;/li&gt;
      &lt;li&gt;另外还可以借助Panel Tool和Draw Call Tool来对UI部分的Draw Call进行分析，前者可以显示每个UIPanel包含了多少个Draw Call，而后者可以显示每个Draw Call由哪些UIWidget组成。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;rebuild-batch-memory-profiler&quot;&gt;如何查看每次Rebuild Batch影响的顶点数， Memory Profiler是个办法但是不好定位。&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;5.2后开始使用Shared UI Mesh来存储UI Mesh，所以很难查看每次Rebuild的UI顶点数。可以尝试通过Frame Debugger工具对UI界面进行进一步的查看。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;uiuipanellateupdatecpusetactive&quot;&gt;通过移动位置来隐藏UI界面，会使得被隐藏的UIPanel继续执行更新（LateUpdate有持续开销），那么如果打开的界面比较多，CPU的持续开销是否就会超过一次SetActive所带来的开销？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;通过移动的方式“隐藏”的UI界面只适用于几个切换频率最高的界面&lt;/li&gt;
  &lt;li&gt;一般来说在没有UI元素变化的情况下，持续的 Update 开销是不太明显的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;uiuiui-setactivefalse-setactivetrue--gcalloc--batches--gc-alloc-&quot;&gt;游戏中出现UI界面重叠，该怎么处理较好？比如当前有一个全屏显示的UI界面，点其中一个按钮会再起一个全屏界面，并把第一个UI界面盖住。我现在的做法是把被覆盖的界面 SetActive(False)，但发现后续 SetActive(True) 的时候会有 GC.Alloc 产生。这种情况下，希望既降低 Batches 又降低 GC Alloc 的话，有什么推荐的方案吗？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;可以尝试通过添加一个 Layer 如 OutUI， 且在 Camera 的 Culling Mask 中将其取消勾选（即不渲染该 Layer）。从而在 UI 界面切换时，直接通过修改 Canvas 的 Layer 来实现“隐藏”。但需要注意事件的屏蔽，禁用动态的 UI 元素等等。
这种做法的优点在于切换时基本没有开销，也不会产生多余的 Draw Call，但缺点在于“隐藏时”依然还会有一定的持续开销（通常不太大），而其对应的 Mesh 也会始终存在于内存中（通常也不太大）。&lt;/li&gt;
  &lt;li&gt;PS：一个经典的场景，一个非常巧妙的答案。学到了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;uicanvasrecttransform&quot;&gt;在UI界面中，用Canvas还是用RectTransform做根节点更好？哪种方法效率更高？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;简单来说，因为一个Canvas下的所有UI元素都是合在一个Mesh中的，过大的Mesh在更新时开销很大，所以一般建议每个较复杂的UI界面，都自成一个Canvas(可以是子Canvas)，在UI界面很复杂时，甚至要划分更多的子Canvas。&lt;/li&gt;
  &lt;li&gt;同时还要注意动态元素和静态元素的分离，因为动态元素会导致Canvas的mesh的更新。最后，Canvas又不能细分的太多，因为会导致Draw Call的上升。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;PS：总结来说就是不分子Canvas会导致mesh过大，分的太多dc过高，在于平衡。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;filebytes512x512rgba322mb&quot;&gt;使用File类来读取图片的bytes流，512x512的RGBA32格式图片使用了2MB内存&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;首先正常的512x512的RGBA32图片的大小为4byte * 512 * 512 / 1024 / 1024 = 1MB，这个2MB是因为内存和显存各需要一份。file read的时候本身会产出一份，在向GPU发送的时候会备份一份，推测是这样。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;一般来说，比较建议通过AssetBundle来动态加载资源，而非通过bytes流来进行加载。如果你的项目正在使用这种方式来加载纹理，我们建议从策略上考虑将其更改。&lt;/li&gt;
  &lt;li&gt;在我们目前来看，通过bytes流来生成资源，绝大部分原因是想对其进行加密，从而让资源难于破解。但其实这种加密方式用处不大，因为据我们所知，现在有很多工具可以直接通过底层显卡层来直接查看各种纹理、Mesh资源，比如Mali Graphics Debugger、Qualcomn Profiler等。因此，如果是从加密的角度来通过bytes流生成资源，那么我们建议通过AssetBundle这种直接的方式进行加载。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;动画&lt;/h2&gt;
&lt;h4 id=&quot;cullcompletely&quot;&gt;CullCompletely&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;使用 CullCompletely 在开启 RootMotion 时是需要注意的，比如人物有一个巡逻动画是通过 RootMotion 制作的，那么在人物走出屏幕后，其动画就停止了，即不会再走回屏幕中。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;渲染&lt;/h2&gt;

&lt;h4 id=&quot;section-2&quot;&gt;场景中一个点光源，烘焙前暗，后亮是为何？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;简单来说，这就是实时的直接光照和全局光照的差别。
在渲染时前者只能处理光源和单个物件之间的直接光照，而后者在烘焙时是通过光线跟踪或者辐射度等复杂算法，计算出所有物体各个表面之间相互反射的光照信息，这也是烘焙Lightmap需要较久的时间的原因 。可以发现在全局光照下，即使是物体的背面也会因为其它表面的反射而被照亮，这在直接光线下就无法实现这样的效果。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;shader--vf-surface&quot;&gt;相同效果前提下，就性能而言，Shader 是用 V&amp;amp;F 还是Surface好？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;V&amp;amp;F，Surface生成的V&amp;amp;F比较庞杂，分支较多，如果不注意 #pragma surface 参数的选择，容易出现不必要的开销。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;baked-gi&quot;&gt;大面积的面片会导致baked GI时间过久，拆分大面积的面片对渲染性能也会有所提升&lt;/h4&gt;

&lt;h4 id=&quot;handheldplayfullscreenmovie&quot;&gt;Handheld.PlayFullScreenMovie&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;首先这天放在这里似乎不合适。&lt;/li&gt;
  &lt;li&gt;Android上PlayFullScreenMovie 的实现实际上是通过Android原生的接口直接播放的，播放过程中Unity也是停止更新的，因此这部分的内存理论上并不会记录在 Unity 中，同样也不影响mono。&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sun, 27 Aug 2017 18:19:29 +0800</pubDate>
        <link>https://caihua.tech/2017/08/27/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E5%9B%9B%E5%91%A8/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/08/27/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E5%9B%9B%E5%91%A8/</guid>
        
        <category>UWA</category>
        
        
      </item>
    
      <item>
        <title>Lua学习笔记：迭代和闭包</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;关系&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;迭代是一种遍历一种集合中所有元素的机制，在遍历的过程中需要在每次成功之间保持一些状态，比如当前变量的index等。而闭包的机制恰好很适合迭代，因为闭包是一种可以访问外部嵌套环境中的变量的函数，而这个变量可以用来保持状态。在lua中闭包结构通常由&lt;strong&gt;闭包函数本身&lt;/strong&gt;和一个&lt;strong&gt;创建该闭包函数的工厂函数&lt;/strong&gt;组成。&lt;/li&gt;
  &lt;li&gt;以下面代码为例，GetValue就是个工厂，它生产出一个闭包，这个闭包将状态保持在t和i这两个变量中。其实在我看来主要是i中。在循环中每次调用闭包（迭代器）都是在更新它的状态i。这段代码完美的展示了迭代器的概念，看完之后对于迭代的理解更近了一步。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;tt = {10,20,30}

function GetValue(t)
	local i =0
	return function ()
		i=i+1
		return t[i]
	end
end

iterator = GetValue(tt)

while true do
	local v = iterator()
	if v == nil then
		break
	end
	print(v)
end
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;for&quot;&gt;泛型for&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;泛型for在内部保存了3个值，分别是一个迭代器函数、一个恒定状态和一个控制变量。其形态如下，其中var-list是变量列表，exp-list表达式列表。var-list第一个原始就是控制变量，在循环中它不会是nil，如果是nil了循环就结束了。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for &amp;lt;var-list&amp;gt; in &amp;lt;exp-list&amp;gt; do
    &amp;lt;body&amp;gt;
end
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;迭代器是for中内部保存的，恒定状态应该是你需要循环的数据，比如一个table，控制变量是返回值变量列表的第一个变量，同时它也是用恒定状态和控制变量调用迭代器后得到的结果。假设迭代器函数是f，恒定状态是s，控制变量初始是a0，那么有&lt;code class=&quot;highlighter-rouge&quot;&gt;a1 = f(s,a0) a2 = f(s,a1)...&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;lua中将for的迭代器返回值固定为了3个，因此得到的是next\t\nil.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-1&quot;&gt;无状态迭代器&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;不保存任何状态的迭代器，可以在多个循环中使用同一个迭代器。例子：ipairs。准确说ipairs是个工厂，它生产了一个简单的迭代器。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;一个简单的迭代器&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;local function getNext(list, node)
	if not node then
		return list
	else
		return node.next
	end
end

function tra(list)
	return getNext,list,nil
end

list = nil
for line in io.lines() do
	list  = {val = line, next = list}
end

for node in list do
	print(tra(node.val))
end
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-2&quot;&gt;关于迭代的的一些理解&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;在lua中for迭代的迭代器其实主要是个生成器，它生成了iterator，然后依靠for来循环调用。注意生成迭代的函数的返回值必须是函数、恒定状态、控制变量这个顺序。&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Mon, 14 Aug 2017 22:57:15 +0800</pubDate>
        <link>https://caihua.tech/2017/08/14/Lua%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%BF%AD%E4%BB%A3%E5%92%8C%E9%97%AD%E5%8C%85/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/08/14/Lua%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%BF%AD%E4%BB%A3%E5%92%8C%E9%97%AD%E5%8C%85/</guid>
        
        <category>Lua</category>
        
        
      </item>
    
      <item>
        <title>Lua学习笔记：函数深入</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;闭包&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;lua中的函数都可以认为是闭包，只不过为了便于理解还是用了函数的概念。&lt;/li&gt;
  &lt;li&gt;lua中函数的返回值可以是匿名函数，也就是闭包。以下面的代码为例，提出一个概念：非局部的变量。在下面的代码中，匿名函数访问了一个变量i，它对于newCount来说是局部变量，对于匿名函数来说是既不是局部变量也不是全局变量，在lua中这个称谓&lt;em&gt;非局部的变量&lt;/em&gt;。&lt;/li&gt;
  &lt;li&gt;在lua中一个闭包指的是一个函数和该函数所需要访问的非局部的变量。lua会把它们看做是一个整体，因此在下面的代码中多次允许c1和c2，会发现变量i是在递增的。这是因为&lt;code class=&quot;highlighter-rouge&quot;&gt;c1 = newCount()&lt;/code&gt;这句代码相当于给c1赋值了一个闭包，它包含了i这个变量。因此多次执行相当于就是在反复执行一个对象，这样i就一直是原来那个i。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function newCount()
	local i =0
	return function ()
		i=i+1
		print(i)
	end
end

c1 = newCount()
print(c1())
print(c1())

c2 = newCount()
print(c2())
print(c2())
print(c1())

-- 结果
1
2
1
2
3
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-1&quot;&gt;利用闭包的沙盒&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;下面这段代码中，修改了math库的sin方法。类似的还可以用来处理一些不安全的代码，这样的方式类似沙盒，将不安全包装了起来。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;print(math.sin(45))

oldSin = math.sin
math.sin = function (x)
	return oldSin(x*math.pi/180)
end

print(math.sin(45))
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-2&quot;&gt;直接使用非全局函数做递归会报错&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;当你尝试调用下面的代码时，会提示&lt;code class=&quot;highlighter-rouge&quot;&gt;attempt to call global 'foo' (a nil value)
&lt;/code&gt;，很奇怪对吧，明明定义的foo是个local的，怎么会提示是global呢？这个是因为在调用foo(x-1)时，这个foo函数还没有定义完，因此表达式在尝试调用一个全局的函数foo，但是显然这个全局函数是不存在的。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;local foo = function (x)
	if x == 1 then
		return 1
	else return x*foo(x-1)
	end
end

print(foo(3))
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;正确的递归函数姿势，第二种&lt;code class=&quot;highlighter-rouge&quot;&gt;local function foo(x)&lt;/code&gt;其实是第一个方法的语法糖。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;local foo
foo = function (x)
	if x == 1 then
		return 1
	else return x*foo(x-1)
	end
end

print(foo(3))

-- 相当于
local function foo(x)
...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-3&quot;&gt;正确的尾调用&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;本质是为了不记录函数的返回位置，这样在栈中就可以无限的调用函数。在lua中只有&lt;code class=&quot;highlighter-rouge&quot;&gt;return  &amp;lt;func&amp;gt;(&amp;lt;args&amp;gt;)&lt;/code&gt;这样的形式才是尾调用。&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Mon, 14 Aug 2017 22:56:11 +0800</pubDate>
        <link>https://caihua.tech/2017/08/14/Lua%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%87%BD%E6%95%B0%E6%B7%B1%E5%85%A5/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/08/14/Lua%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%87%BD%E6%95%B0%E6%B7%B1%E5%85%A5/</guid>
        
        <category>Lua</category>
        
        
      </item>
    
      <item>
        <title>每天一点UWA：第三周</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;内存&lt;/h2&gt;
&lt;h4 id=&quot;section-1&quot;&gt;资源复用&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;如果一个prefab被简单的多复制几次，里面的mesh、Texture、AnimationClip、Material这些都是被复用的，在profile中可以看到。但是如果prefab从AssetBundle中获取，并且多次的加载、实例化、卸载可能造成内存泄漏，因为unload(false)并没有真正卸载内存中的已经实例化的prefab，再次load时PersistentManager会认为是一个新的对象。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;uiprofile&quot;&gt;UI在多次开关后出现profile中资源重复&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;刚进游戏时获取的图中出现的“重复”资源可能并不是冗余，因为 Atlas的一个 Group 中可能包含多张一样大小的Page（即纹理），而这几个Page在内存中的名字是一样的。&lt;/li&gt;
  &lt;li&gt;但是，如果同一UI界面多次开启后，内存中出现了更多同样的资源，则说明UI的管理方式存在一定问题。对于频繁使用的UI，我们建议在加载之后通过缓冲池对其进行缓存，后续使用时，直接通过缓冲池获取即可。而不要每次均通过AssetBundle进行加载，这种做法既会造成更大的CPU占用，同样会很大几率造成资源的冗余。&lt;/li&gt;
  &lt;li&gt;同时，如果多次开启的是不同UI界面，并且造成内存中同种资源的增加，则很有可能是UI在AssetBundle打包时形成了冗余（这种情况在目前的UGUI系统中较为常见）。对此，如果开发团队使用的是UGUI，那么我们的建议如下：
    &lt;ul&gt;
      &lt;li&gt;对于使用Unity 5.x的新AssetBundle打包系统，则打包时尽可能将同种Atlas的UI界面打成一个AssetBundle文件，否则将很有可能出现资源冗余的情况；&lt;/li&gt;
      &lt;li&gt;对于使用Unity 4.x的老AssetBundle打包系统，则可以将一个含有Atlas的Prefab（或其他Object）先打包，其他UI元素对其进行依赖即可。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;物理&lt;/h2&gt;
&lt;h4 id=&quot;rigidbody--capsulecollidercharactercontroller&quot;&gt;RigidBody + CapsuleCollider替换CharacterController&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;高效一些，因为 move 函数本身会进行较复杂的模拟运算。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;static-collidermove-expensive-delayed-cost&quot;&gt;Static Collider.Move (Expensive Delayed cost)警告&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Static Collider.Move (Expensive Delayed cost) 意味着场景中有静态碰撞体（不带有RigidBody的Collider）发生了移动，而该操作在Unity 4.x版本的PhysX 中会在后续的模拟中产生较高的开销，但在 5.x 中理论上开销并不明显。如果要消除该问题，只需定位到发生位移的Collider并挂上RigidBody 组件，打开其is kinematic 选项即可。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-3&quot;&gt;渲染&lt;/h2&gt;
&lt;h4 id=&quot;lightmap&quot;&gt;什么在影响lightmap尺寸&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;首先确认下Lightmap的类型，Single类型只生成一张，而Dual和Directional会生成两张。&lt;/li&gt;
  &lt;li&gt;其次，确认下当前的发布平台，Android下的Lightmap会比Standalone更小。因为不同平台采用的压缩格式不同。此外，Lightmapping中的Lock Atlas，Resolution，Padding等选项也会影响最后烘焙光照图的大小。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;lightmapmesh&quot;&gt;原先的Lightmap不再影响合并后的Mesh&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;总结一句就是不要讲使用了多个lightmap的mesh进行合并。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;bloom&quot;&gt;关于抗锯齿和BLOOM，有什么好的优化方案或者优秀插件推荐？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;通常在中低端的设备上，抗锯齿并没有比较高效的方案；而对于中高端的设备，可尝试直接使用 Unity 内置的 MSAA 功能，但也只推荐使用 2x。
关于Bloom效果，以下是适用于移动端，且评价较好的一款插件：BloomPro&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;assetbundle&quot;&gt;AssetBundle&lt;/h2&gt;
&lt;h4 id=&quot;xassetbundle-name&quot;&gt;5.x后设置好AssetBundle Name就可以实现依赖资源的独立打包&lt;/h4&gt;

&lt;h4 id=&quot;xassetbundle&quot;&gt;4.x时代不同版本之间的AssetBundle不能通用&lt;/h4&gt;

&lt;h4 id=&quot;unload&quot;&gt;unload顺序&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;在 Resources.UnloadUnusedAssets() 时，如果还没有进行AssetBunlde的Unload 操作，那么从AssetBunlde中加载的资源依然会因为被AssetBunlde引用而无法被卸载。&lt;/li&gt;
  &lt;li&gt;开发团队可以尝试 Destory 后做 AssetBunlde的Unload，最后进行 Resources.UnloadUnusedAssets()。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;assetbundlemanifestassetbundle&quot;&gt;生成AssetBundle的时候每个文件会多生成一个Manifest文件，这个文件也需要一起随着AssetBundle上传吗，在资源加载的时候具体怎么用呢？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;每个文件多生成的Manifest 文件是不需要上传的，其作用就是供开发人员查看AssetBundle 中的依赖关系等信息。&lt;/li&gt;
  &lt;li&gt;但除了每个文件多生成的 Manifest 以外，根目录下还会有一个与根目录同名的AssetBundle 以及 Manifest 文件，通过运行时加载这个AssetBundle，可以得到一个 AssetBundleManifest 对象，然后就可以通过这个对象得到AssetBundle直接的依赖关系。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;editorshader&quot;&gt;选择移动平台后，editor下shader显示错误&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;是Unity已知的一个问题，Android 和 iOS 的部分Shader在打包后，在Editor 下无法正常显示。 主要原因是在打包时，只会把对应平台的Shader预编译代码（如 gles ）打入包中，因此在 Editor 下会执行失败（通常 Editor 是 d3d 驱动）。 因此，目前只能尝试在Editor下重新指定Shader来绕过这个问题。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;texture&quot;&gt;Texture&lt;/h2&gt;
&lt;h4 id=&quot;iosastc&quot;&gt;ios上的ASTC格式&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;ASTC在 iOS 的高端机上是被支持的，因此理论上在 Editor 下不会强制把 ASTC 转为 RGBA32，建议尝试设置为 ASTC 后打包，从 Editor.log 中或者直接从包体大小上可以看出是否确实使用了ASTC。&lt;/li&gt;
  &lt;li&gt;一般来说，如果 RGBA16 的效果可以接受的话，建议使用 RGBA16，虽然打包时相对大一些，但是内存中相比 RGBA32 能够减半，但使用 ASTC 的话，虽然打包时比较小，但是在普通机型上会被处理成 RGBA32，导致过大的内存开销。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ui&quot;&gt;UI&lt;/h2&gt;
&lt;h4 id=&quot;shared-ui-mesh&quot;&gt;Shared UI Mesh&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Shared UI Mesh是在Unity 5.2 版本后UGUI系统维护的UI Mesh。在以前的版本中，UGUI会为每一个Canvas维护一个Mesh（名为BatchedMesh，其中再按材质分为不同的SubMesh）。而在Unity 5.2版本后，UGUI底层引入了多线程机制，而其Mesh的维护也发生了改变，目前Shared UI Mesh作为静态全局变量，由底层直接维护，其大小与当前场景中所有激活的UI元素所生成的网格数相关。&lt;/li&gt;
  &lt;li&gt;一般来说当界面上UI元素较多，或者文字较多时该值都会较高，在使用UI/Effect/shadow和UI/Effect/Outline时需要注意该值，因为这两个Effect会明显增加文字所带来的网格数。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;build&quot;&gt;Build&lt;/h2&gt;
&lt;h4 id=&quot;section-4&quot;&gt;打包注意&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;打包的时候Resources文件夹下所有的内容都会被打入resources.assets，要想包体小就删除不要的资源。而且Resources目录下所以资源启动时参与persistentmanager的初始化，内容多了会卡。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;static&quot;&gt;static选项&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;如果在Editor中进行勾选，则会在项目中生成一个较大的VBO，Runtime时通过该VBO来进行渲染，优点是有效减少了Draw Call，缺点是增大了发布游戏包的体积。&lt;/li&gt;
  &lt;li&gt;如果在Runtime通过脚本来进行Batching，则相当于把拼合的时间由Editor中搬到了Runtime，所以加载时间（一般在场景加载时执行Batching）会稍有增加，但游戏包的体积将相应减少。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-5&quot;&gt;动画&lt;/h2&gt;
&lt;h4 id=&quot;optimize-gameobject&quot;&gt;Optimize GameObject&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;在选择Optimize GameObjects后，可在Extra Transforms中加入你想挂载特效的骨骼结点，这样该骨骼结点将不会进行优化处理，即其Transfrom将不会消失。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-6&quot;&gt;工具&lt;/h2&gt;
&lt;h4 id=&quot;waitfortargetfps&quot;&gt;WaitForTargetFPS&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;该参数一般出现在CPU开销过低，且通过设定了目标帧率的情况下（Application.targetFrameRate）。当上一帧低于目标帧率时，将会在本帧产生一个WaitForTargetFPS的空闲等待耗时，以维持目标帧率。&lt;/li&gt;
  &lt;li&gt;该项在Unity引擎的主循环中其实是最早执行的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;gfxwaitforpresent--graphicspresentandsync&quot;&gt;Gfx.WaitForPresent &amp;amp; Graphics.PresentAndSync&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;这两个参数在Profiler中经常出现CPU占用较高的情况，其实是CPU和GPU之间的垂直同步（VSync）导致的，之所以会有两种参数，主要是与项目是否开启多线程渲染有关。当项目开启多线程渲染时，你看到的则是Gfx.WaitForPresent；当项目未开启多线程渲染时，看到的则是Graphics.PresentAndSync。&lt;/li&gt;
  &lt;li&gt;Gfx.WaitForPresent其真实的意思应该是为了在渲染子线程（Rendering Thread）中进行Present，当前主线程（MainThread）需要等待的时间。&lt;/li&gt;
  &lt;li&gt;最后，如何优化并降低这两个参数的CPU占用呢？ 那就是，忽略Gfx.WaitForPresent 和 Graphics.PresentAndSync这两个参数，优化其他你能优化的一切！WTF！&lt;/li&gt;
  &lt;li&gt;PS：这篇内容相当不错，建议看&lt;a href=&quot;https://blog.uwa4d.com/archives/presentandsync.html&quot;&gt;原文&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;editorassetdatabase&quot;&gt;editor下出现AssetDatabase内存过高可以无视&lt;/h4&gt;

&lt;h4 id=&quot;canvassendwillrendercanvases&quot;&gt;Canvas.SendWillRenderCanvases&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Canvas.SendWillRenderCanvases为UGUI中非常重要的接口，经常会出现较高的性能开销。当Canvas中的UI元素出现了长、宽或Alpha变化时，UGUI会更新其所在Canvas中所有UI元素的Transform、状态等等。Canvas中UI Mesh顶点较多的话，则该项将会出现较高的CPU开销。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;loadingupdatepreloading&quot;&gt;Loading.UpdatePreloading&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Loading.UpdatePreloading为Unity引擎的主要加载函数。场景中的资源加载（包括Texture、Mesh、Shader、AnimationClip等）和相关序列化操作均在其中体现。因此，如果该值开销较高，建议研发团队对资源进行进一步的优化和控制。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-7&quot;&gt;脚本&lt;/h2&gt;
&lt;h4 id=&quot;gameobjectgameobject&quot;&gt;如果脚本引用了GameObject，那转换场景的时候脚本和GameObject都没了，还会产生堆内存的吗？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;如果脚本是MonoBehaviour，而且在切换场景后所挂的Game Object被释放了，那么这个脚本对象所引用的堆内存就会在GC的时候被释放。 但有一种例外，如果是通过Static变量引用的堆内存，那么依然是释放不掉的，除非手动解开引用，比如变量置Null，数组Clear等等。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-8&quot;&gt;粒子&lt;/h2&gt;
&lt;h4 id=&quot;section-9&quot;&gt;粒子动态合并&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;del&gt;粒子系统的Draw Call动态拼合与半透明物体的动态拼合机制相当（粒子基本都是半透明材质）。而对半透明物体，由于其渲染顺序的限制（必须从后向前渲染，以保证渲染结果的正确性），动态拼合只能对渲染顺序相邻且材质相同的物体有效。而在决定半透明物体的渲染顺序时，Unity首先会按Shader中的RenderQueue进行排序；其次（相同RenderQueue时），会根据每个半透明物件到屏幕的距离，距离大的优先渲染。&lt;/del&gt;&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;因此，需要尽可能地将相同材质的粒子系统放在比较接近的深度下，才能更多地使动态拼合生效。但通常由于相机的运动、粒子系统的分散分布等原因造成粒子系统之间的穿插，能够动态拼合的数量往往都是很少的。&lt;/del&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;目前粒子系统已经不再进行 Draw Call 的拼合，因为在新版本5.3 中已通过多线程进行更新，暂时无法支持拼合，但性能已经得到提升。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Mon, 14 Aug 2017 22:54:29 +0800</pubDate>
        <link>https://caihua.tech/2017/08/14/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E4%B8%89%E5%91%A8/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/08/14/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E4%B8%89%E5%91%A8/</guid>
        
        <category>UWA</category>
        
        
      </item>
    
      <item>
        <title>每天一点UWA：第二周</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;内存&lt;/h2&gt;

&lt;h3 id=&quot;section-1&quot;&gt;概述&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;内存的开销无外乎以下三大部分：1.资源内存占用；2.引擎模块自身内存占用；3.托管堆内存占用。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-2&quot;&gt;资源内存&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;大头在纹理，其次在网格、动画片段和音频。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-3&quot;&gt;纹理&lt;/h4&gt;

&lt;h5 id=&quot;section-4&quot;&gt;从格式解决内存占用问题&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;选择正确的格式，比如Android上是ETC，ios的PVRTC，PC上DXT。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-5&quot;&gt;不同格式可能出现的问题：&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;因为ETC、PVRTC都是有损压缩因此可能出现色阶问题，如果用RGB32这样的格式虽然能解决问题但是内存占用太大。好的办法是在做纹理的时候减少色差范围，必要做出高对比度的阶梯式的图。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;比如，同样一张1024x1024的纹理，如果不开启Mipmap，并且为PVRTC格式，则其内存占用为512KB，而如果转换为RGBA32位，则很可能占用达到4MB。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;OpenGL ES2的设备只支持ETC1，但是ETC1不支持alpha通道。解决办法是将透明图分成两张，一个RGB24的保存RGB通道，一个alpha8的保存A通道，然后在使用时使用定制的shader去分别读取两个纹理图。&lt;/li&gt;
  &lt;li&gt;PS：OpenGL ES 3.0支持ETC2甚至ASTC，都是很好的支持透明通道的压缩格式。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-6&quot;&gt;选择合适的纹理设置&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;能512解决的事情别用1024&lt;/li&gt;
  &lt;li&gt;选择性的使用mipmap，对于UI这样的纹理使用完全没有必要用mipmap。&lt;/li&gt;
  &lt;li&gt;Read &amp;amp; Write选项会使得纹理的内存使用量增加一倍。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-7&quot;&gt;网格&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;mesh中顶点信息可以进行相关的优化，比如Normal、Color和Tangent这些数据要按照需要来做，不用的就不要做。而且顶点信息超多900还不能动态批处理。不需要就计算发现的时候就可以不用tangent数据了，有贴图的话color数据也不需要。&lt;/li&gt;
  &lt;li&gt;Color数据和Normal数据主要为3DMax、Maya等建模软件导出时设置所生成，而Tangent一般为导入引擎时生成。&lt;/li&gt;
  &lt;li&gt;如果项目对Mesh进行Draw Call Batching操作的话，那么将很有可能进一步增大总体内存的占用。比如，100个Mesh进行拼合，其中99个Mesh均没有Color、Tangent等属性，剩下一个则包含有Color、Normal和Tangent属性，那么Mesh拼合后，CombinedMesh中将为每个Mesh来添加上此三个顶点属性，进而造成很大的内存开销。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-8&quot;&gt;引擎模块自身占用内存&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;引擎自身中存在内存开销的部分纷繁复杂，可以说是由巨量的“微小”内存所累积起来的，比如GameObject及其各种Component（最大量的Component应该算是Transform了）、ParticleSystem、MonoScript以及各种各样的模块Manager（SceneManager、CanvasManager、PersistentManager等)…&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;一般情况下，上面所指出的引擎各组成部分的内存开销均比较小，真正占据较大内存开销的是这两处：WebStream 和 SerializedFile。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;PS：5.4以后没有webStream的概念了，不过还是要考虑WWW和LoadFromMemory中会保存AssetBundle原始数据的问题，参见&lt;a href=&quot;https://docs.unity3d.com/550/Documentation/Manual/AssetBundleCompression.html&quot;&gt;Asset Bundle Compression&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;AssetBundle所占的内存也需要考虑，尽可能做到按需加载，用完后及时的清理。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;mono&quot;&gt;托管堆内存占用/无效的Mono堆内存开销&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Mono的堆内存一旦分配，就不会返还给系统。这意味着Mono的堆内存是只升不降的。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-9&quot;&gt;不必要的堆内存分配主要来自于以下几个方面：&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;高频率地 New Class/Container/Array等。不要再update占用的函数中实例化对象。&lt;/li&gt;
  &lt;li&gt;Log输出，需要适当的减少log，只保留最关键的。&lt;/li&gt;
  &lt;li&gt;UIPanel.LateUpdate。这是NGUI中CPU和堆内存开销最大的函数,是由UI网格的重建造成。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-10&quot;&gt;一些推荐的办法&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;不要一次加载一个过大的资源，比如配置文件、纹理图等。这样会造成一次性申请过多的内存，但是还不回去了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-11&quot;&gt;内存泄漏&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;首先通过工具发现场景切换开始和结束时内存使用没有一致，这个现象不能说明内存就一定有泄漏。比如资源加载后常驻内存以备后续使用、Mono堆内存的只升不降等等，这些均可造成内存无法完全回落。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-12&quot;&gt;检查资源的使用情况，特别是纹理、网格等资源的使用&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;这段主要介绍了如何使用UWA的工具对纹理和网格进行检查，查看是否出现资源的内存泄漏。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;profilerwebstreamserializedfile&quot;&gt;通过Profiler来检测WebStream或SerializedFile的使用情况&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;直接通过Profiler Memory中的Take Sample来对其进行检测，通过直接查看WebStream或SerializedFile中的AssetBundle名称，即可判断是否存在“泄露”情况。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-13&quot;&gt;资源冗余&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;是指在某一时刻内存中存在两份甚至多份同样的资源。导致这种情况的出现主要有两种原因：&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;assetbundle&quot;&gt;AssetBundle打包机制出现问题&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;显而易见，对于公用资源需要进行合理的划分打包。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-14&quot;&gt;资源的实例化所致&lt;/h5&gt;

&lt;blockquote&gt;
  &lt;p&gt;在Unity引擎中，当我们修改了一些特定GameObject的资源属性时，引擎会为该GameObject自动实例化一份资源供其使用，比如Material、Mesh等。以Material为例，我们在研发时经常会有这样的做法：在角色被攻击时，改变其Material中的属性来得到特定的受击效果。这种做法则会导致引擎为特定的GameObject重新实例化一个Material，后缀会加上（instance）字样。其本身没有特别大的问题，但是当有改变Material属性需求的GameObject越来越多时（比如ARPG、MMORPG、MOBA等游戏类型），其内存中的冗余数量则会大量增长。虽然Material的内存占用不大，但是过多的冗余资源却为Resources.UnloadUnusedAssets API的调用效率增加了相当大的压力。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;上面描述的material的问题是个常见的问题。如果是直接改变还好说，会产生一个material instance，但是如果是在一段时间内线性的改变某个属性，那么后果很难说。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;建议&lt;/p&gt;
    &lt;blockquote&gt;
      &lt;p&gt;一般情况下，资源属性的改变情况都是固定的，并非随机出现。比如，假设GameObject受到攻击时，其Material属性改变随攻击类型的不同而有三种不同的参数设置。那么，对于这种需求，我们建议你直接制作三种不同的Material，在Runtime情况下通过代码直接替换对应GameObject的Material，而非改变其Material的属性。这样，你会发现，成百上千的instance Material在内存中消失了，取而代之的，则是这三个不同的Material资源。其中的益处，对于能够阅读到这里的你来说，应该已经不需要我多说了。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-15&quot;&gt;粒子&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Navmesh是不支持动态加载的目前的，办法是将多个场景做成prefab，然后用LoadLevelAdditive的方式加载，去拼接。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;assetbundle-1&quot;&gt;AssetBundle&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;本周第一篇关于AssetBundle的文章可以说有点陈旧了，在5.3以后解决了一些功能，比如AssetBundle.LoadFromFile加载LZMA文件的失败的问题。&lt;/li&gt;
  &lt;li&gt;还有就是在5.4以后已经没有webstream的概念了。&lt;/li&gt;
  &lt;li&gt;最后开始使用UnityWebRequest&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;lightmapsnapshotassetlightmap&quot;&gt;热更新打包时LightmapSnapshot.asset无法导出，导致场景丢失lightmap&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;LightmapSnapshot.asset是editor模式下的无法打包。解决办法是整个scene打包，lightmap信息会打包进去。或者在运行时调用Lightmapsettings.Lightmaps来设置，但是5.x后lightmap信息不会保存在prefab中，因此需要重设Prefab的Lightmap信息（Lightmapindex和Lightmapscaleoffset）。&lt;/li&gt;
  &lt;li&gt;还有一种可能是因为打包场景的时候shader会根据当前场景的使用情况来打包，如果打包是在一个空场景中那么bundle中的shader会失去lightmap和fog的支持。这个&lt;/li&gt;
  &lt;li&gt;PS: 这个问题在5.5.2中也存在，而且打包的时候是按照场景打包的，但是是不是shader丢失确实需要测试。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;prefab&quot;&gt;prefab打包&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;如果有一个Prefab，它的Dependencies都在Resources文件夹中，那么，当我在AssetBundle打包时，只打包这个Prefab（不指定BuildAssetBundleOptions.CompleteAssets和BuildAssetBundleOptionsCollectDependencies）是不能正确实例化的，因为AssetBundle中的资源和Resource文件夹下资源是不会建立依赖关系的（脚本除外，因为开启BuildAssetBundleOptionsCollectDependencies 时，脚本依然不会打包到AssetBundle中）。所以会出现Mesh、Material等的丢失。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;assetbundle-2&quot;&gt;卸载依赖AssetBundle的问题&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;比如prefabA和prefabB依赖于AtlasC，那么分别打包的话首先肯定是要先加载AtlasC的AssetBundle的。&lt;/li&gt;
  &lt;li&gt;但是如果先从AtlasC的AssetBundle中load了AtlasC，然后unload这个AssetBundle，此后加载或实例化A和B时，引擎将无法自动将C绑定给A和B进行使用。这个需要注意。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-16&quot;&gt;纹理格式&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;目前来讲，并不存在一个所有GPU平台都支持硬件解压的压缩格式。&lt;/li&gt;
  &lt;li&gt;ETC1 和 PVRTC 分别是Android和iOS上我们最推荐的格式。 但对于透明纹理，ETC1不支持，而 PVRTC 则可能有较大失真，因此更推荐使用 RGBA 16。&lt;/li&gt;
  &lt;li&gt;一般来说建议直接使用 Unity 默认的压缩格式（即选择 Compressed 即可，不需要做特殊设置），Unity 会做如下处理：
    &lt;ul&gt;
      &lt;li&gt;Android 上不带Alpha通道的图片采用 ETC1，带Alpha通道的图片采用True Color中的RGB16，TrueColor中的 RGBA16 会&amp;gt;比 RGBA32 更节省空间，但图像的显示质量会差一些；&lt;/li&gt;
      &lt;li&gt;iOS 上使用 PVRTC，但PVRTC格式要求纹理的长宽相等，且都是2的幂次（即POT，在ImportSettings中可以将NPOT的纹理自动转换成POT）。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;同时，我们不建议直接使用 RGBA32 格式的纹理，因为它占用了很大的内存。一般建议使用 RGBA16 和 ETC 格式的纹理来进行加载。 如果转换到 RGBA16 格式时出现了类似“色阶”的颜色问题，则建议尽可能避免大量的过渡色使用。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-17&quot;&gt;工具&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;unity的分析工具中的Reserved Total 和 Used Total为Unity引擎在内存方面的总体分配量和总体使用量。 一般来说，引擎在分配内存时并不是向操作系统 “即拿即用”，而是首先获取一定量的连续内存，然后供自己内部使用，待空余内存不够时，引擎才会向系统再次申请一定量的连续内存进行使用。&lt;/li&gt;
  &lt;li&gt;Overhead：
    &lt;ul&gt;
      &lt;li&gt;Overhead的计算方法是：Profiler当前帧统计的总耗时时间减去所有已知选项的累加时间，即引擎当前还无法识别模块的耗时时间。&lt;/li&gt;
      &lt;li&gt;Overhead数值理论上是趋向于0的，但是由于目前市面上的硬件设备、系统框架过于丰富，所以引擎可能无法识别所有模块的CPU开销。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Unity Profiler反馈的则是引擎的真实物理使用内存，有时内存使用数值比原生的分析工具小是正常的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Profiler中ManagedHeap.UsedSize是项目逻辑代码在运行时申请的堆内存， 
ManagedHeap.UsedSize过大，一方面可能会影响一次GC的耗时；另一方面也可能反映出脚本中不合理的GC Alloc。该选项只能通过优化代码来进行降低。 优化方法一般如下：
    &lt;ul&gt;
      &lt;li&gt;尽可能地复用变量，减少new的次数；&lt;/li&gt;
      &lt;li&gt;使用StringBuilder代替String连接，使用for代替foreach；&lt;/li&gt;
      &lt;li&gt;对于局部变量或非常驻变量，尽可能使用Struct来代替Class。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;本周读到的所有关于内存监控的部分都提到了一个概念就是Profiler所监控到的数据和Android上的PSS或者ios上检测到的会不一致，这                                                   个是因为Unity Profiler反馈的是引擎的真实分配的物理内存，而PSS中记录的则包括系统的部分缓存。一般情况下，Android或iOS并不会及时将所有App卸载数据进行清理，为了保证下次使用时的流畅性，OS会将部分数据放入到缓存，待自身内存不足时，OS Kernel会启动类似LowMemoryKiller的机制来查询缓存甚至杀死一些进程来释放内存。因此，并不能通过一两次的PSS内存没有完全回落来说明内存泄露问题。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Reserved GFX 中的内存，主要是纹理和网格资源。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-18&quot;&gt;渲染&lt;/h2&gt;
&lt;h4 id=&quot;lightmappcandroid&quot;&gt;Lightmap在PC上显示正常，但是转到Android平台上存在色差，颜色普遍偏暗的问题&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Unity烘焙的Lightmap是32bit的HDR图，而移动设备通常不支持HDR图(32bit per channel)，会按照LDR图(8bit per channel)的形式进行处理，因此会出现色偏问题。因此需要如下的处理：
    &lt;ul&gt;
      &lt;li&gt;在移动平台下使用Mobile/Diffuse材质，可载入Standard Assets(Mobile) package获得。&lt;/li&gt;
      &lt;li&gt;如果要获得更合适的效果，需要自行修改Lightmap的DecodeLightmap函数，该函数可在Unity\Editor\Data\CGIncludes\UnityCG.cginc文件中找到。需要说明的是，这种方法也不能达到与PC端完全一致的效果。&lt;/li&gt;
      &lt;li&gt;如果需要PC和移动平台的显示效果一致，可以用图像编辑软体修改Lightmap為LDR格式，例如PNG(8bit per channel)。&lt;/li&gt;
      &lt;li&gt;为了避免类似问题，请不要使用过于强烈的Light进行烘焙，因為Light的强度(Intensity)越高，色偏问题会越严重。若有阴影丢失时，可以尝试检查一下模型的Lightmapindex、Lightmapscaleoffset、UV2等影响Lightmap采样的一些参数。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;另一种可能是存在过曝现象，可以尝试将playersettings -&amp;gt; use direct3d 11关闭，看问题是否解决。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;lightmap&quot;&gt;lightmap动态加载&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Lightmap的动态加载，需要通过脚本将烘焙时每个物件的Lightmapindex和Lightmapscaleoffset记录下，并在运行时动态加载后设置回去的方式来实现。因为目前Lightmapindex和Lightmapscaleoffset信息是和场景绑定在一起，储存在Lightmapsnap.assets 中，发布时也是放在场景信息中，因此不会记录在Prefab 上。&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Mon, 07 Aug 2017 22:17:31 +0800</pubDate>
        <link>https://caihua.tech/2017/08/07/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E4%BA%8C%E5%91%A8/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/08/07/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E4%BA%8C%E5%91%A8/</guid>
        
        <category>UWA</category>
        
        
      </item>
    
      <item>
        <title>Lua学习笔记：高级概念</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;高级概念&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;这部分中会记录一些lua语言中的高级概念和技术。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-1&quot;&gt;模块&lt;/h3&gt;

&lt;h4 id=&quot;section-2&quot;&gt;概念&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;从我的理解看，模块更像是一个类。但是因为lua中没有类的概念，模块的实现是依赖于table。&lt;/li&gt;
  &lt;li&gt;一些公共或者私有的变量+函数组成了模块的主体，最后一个return module完成了基本的构造。其实这个return就是返回了这个table。&lt;/li&gt;
  &lt;li&gt;具体实现看教程&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-3&quot;&gt;使用&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-- 创建一个叫Class的模块
Class = {}

Class.Name = &quot;name&quot;

Class.Grades =
{
  &quot;Grade1&quot;,
  &quot;Grade2&quot;,
  &quot;Grade3&quot;
}

temp = &quot;a&quot;
local temp2 = &quot;b&quot;
Class.temp3 = &quot;c&quot;

function Class.FindGrade(key)
   return Class.Grades[key]
end

return Class
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-- temp = &quot;local temp1&quot;

-- 导入模块
require(&quot;Class&quot;)

-- temp = &quot;local temp1&quot;

print(temp)
print(Class.temp2)
print(Class.temp3)

-- 调用模块函数
print(Class.FindGrade(1))

-- 结果
a
nil
c
Grade1-abc
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;分析一下模块的变量，从例子中可以总结，模块中的以模块名+&lt;code class=&quot;highlighter-rouge&quot;&gt;.&lt;/code&gt;形成的变量（Class.temp3）是全局变量，而且即使在模块内部调用用也要用模块名+&lt;code class=&quot;highlighter-rouge&quot;&gt;.&lt;/code&gt;的形式使用。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;没有加模块名的变量其实也是全局变量，外部代码也可以直接访问。注意代码中在require的前后分别定义了一个和模块中名字相同的变量，这里有一个很有意思的事情，就是如果是之前定义的，那么在print时是模块中的值，如果在之后定义那么就是本地定义的值。这说明require这种过程实际上等于在本地定义了一些变量。所以最终输出的值可以按照后定义的输出。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;显示标记为local的变量是本地变量，在模块内部使用是没有问题的，但是外部代码无法访问。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-4&quot;&gt;加载机制&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;基本上遵循C的加载机制，也就是先找同一目录下的文件，然后会找全局变量中path里面定义的文件。&lt;/li&gt;
  &lt;li&gt;通常我们在编写代码的时候肯定是会有物理的文件夹结构的，此时如果我们不去改package.path的值，那么可以在引用时加速文件夹名字，比如我把class和student放到了Module文件夹下，那么代码中写&lt;code class=&quot;highlighter-rouge&quot;&gt;require(&quot;Module/Class&quot;)&lt;/code&gt;即可正常调用。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-5&quot;&gt;协程&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;首先是真的多线程，并非unity的那种主线程内部的线程。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;require(&quot;MyCoroutine&quot;)
cor1 = MyCoroutine.CreatCor()
print(cor1)
for i = 1,  10 do
	MyCoroutine.RunCor(cor1)
end


cor2 = MyCoroutine.CreatCor()
print(cor2)
for i = 1,  10 do
	MyCoroutine.RunCor(cor2)
end

-- 结果
thread: 0089D628
1
2
3
running
thread: 0089D628
4
5
6
7
8
9
10
thread: 00897D60
1
2
3
running
thread: 00897D60
4
5
6
7
8
9
10

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;用法比较繁琐，但是可以明确的控制协程的执行步骤。有点类似python。&lt;/li&gt;
  &lt;li&gt;建议直接看教程。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;metatable&quot;&gt;元表（MetaTable）&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;metatable更像是lua为table提供的依赖倒置的接口&lt;/strong&gt;，以&lt;code class=&quot;highlighter-rouge&quot;&gt;__index&lt;/code&gt;这个函数为例，本身如果lua提供了固定的函数，那么我们在取值时候只能遵从lua的规定。但是现在提供了一个&lt;code class=&quot;highlighter-rouge&quot;&gt;__index&lt;/code&gt;，你可以自定义这个&lt;code class=&quot;highlighter-rouge&quot;&gt;__index&lt;/code&gt;的行为，而lua在运行期间遇到了需要用到&lt;code class=&quot;highlighter-rouge&quot;&gt;__index&lt;/code&gt;的时候就会按照你所规定的准则行事了。这个思维是很好的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;下面是&lt;code class=&quot;highlighter-rouge&quot;&gt;__index&lt;/code&gt;的用法，metatable。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Lua查找一个表元素时的规则，其实就是如下3个步骤:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;1.在表中查找，如果找到，返回该元素，找不到则继续&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;2.判断该表是否有元表，如果没有元表，返回nil，有元表则继续。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;3.判断元表有没有__index方法，如果__index方法为nil，则返回nil；如果__index方法是一个表，则重复1、2、3；如果__index方法是一个函数，则返回该函数的返回值。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;代码示例：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mt = {}

mt.__index =
function (t,key)
	if key == &quot;key3&quot; then
		return 5
	elseif key == &quot;key4&quot;  then
		return 6
	else
		return 0
	end
	
end

mt.__newindex =
function (t,key,value)
	t.key = value
end

mt.__tostring = function (t)
	local tempTable = {}
	local index = 0
	for i,v in pairs(t) do
		index = index + 1
		tempTable[index] = v
		print(i..&quot;/&quot;..v)
	end
	return '{' .. table.concat(tempTable, ', ') .. '}'
end

-- 一旦定义了__metatable，就代表getmetatable只能得到这个函数的值，
-- 而不能再次赋值,否则会报错“cannot change a protected metatable”
mt.__metatable = &quot;不能看啊不能看&quot;


local t = {1, 2, 3, key1 = 3,key2 = 4}
setmetatable(t, mt)
print(t)

print(getmetatable(t))

print(t[&quot;key4&quot;])


mt2 = {}

-- 下面的代码会报错
--setmetatable(t,mt2)


&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;这个东西有个好处，如果我写的key不存在，那么我是可以自定义它的行为的。我可以返回一个数值，也可以执行一段代码。但是一般来说还是提前预置好数据比较好。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;PS：元表本身是一个table，如果按照table就是类这个概念来看的话，元表对应了类类型，而实际的使用中它也是起了这样的作用。元表中以&lt;code class=&quot;highlighter-rouge&quot;&gt;__&lt;/code&gt;开头的方法们算是它保留的方法，我们可以给一个元表定义这些方法实际是一个什么样的行为。比如&lt;code class=&quot;highlighter-rouge&quot;&gt;__tostring&lt;/code&gt;方法，我们可以在一个元表中重新定义它的实现，有点像C#中override ToString方法。&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-6&quot;&gt;面向对象&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;lua的oop是基于table的，table中可以设置全局或局部的变量、方法等。&lt;/li&gt;
  &lt;li&gt;继承通过子类调用父类的构造函数（其实lua没有构造函数一说，只是我们人为的在代码中创造出来了一个创建对象的函数）来创建，然后在扩展，从而实现了继承。&lt;/li&gt;
  &lt;li&gt;从本质上说，lua的继承和C的继承是一样的，依赖的是table嵌套table，而C中是结构体嵌套结构体。&lt;/li&gt;
  &lt;li&gt;具体看下链接里教程的例子吧。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-7&quot;&gt;一些体会&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;其实只要学过一个脚本语言，lua就不算陌生，还算是上手比较快。&lt;/li&gt;
  &lt;li&gt;所有语言的核心在api的使用，所以熟悉标准库是关键。&lt;/li&gt;
  &lt;li&gt;lua与C/C++的交互也是大头，不过目前暂时不用就先不学了，等后续学了再填坑。&lt;/li&gt;
  &lt;li&gt;多写，多写，多写。&lt;/li&gt;
  &lt;li&gt;一个学习lua编程的方法是看WOW的插件源码。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-8&quot;&gt;调试&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;因为用的是LuaStudio，在调试的过程中也遇到了很多的问题。首先正常的自己写的代码都可以require成功，os\io\math这样的库也都没有问题，但是用到socket库的时候怎么都无法require。最后发现在LuaStudio中必须这样设置才行&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://imglf1.nosdn.127.net/img/Nld0N0tacnNuUG45bFJFdFZwNEVuU216QnRPaEtaaHcwTFU3MW1PS2tuUWl2cWkwZE1EWC9RPT0.png?imageView&amp;amp;thumbnail=500x0&amp;amp;quality=96&amp;amp;stripmeta=0&amp;amp;type=jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-9&quot;&gt;参考&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/booirror/article/details/7881820&quot;&gt;table参考&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.runoob.com/lua/lua-tutorial.html&quot;&gt;lua教程&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/klkucan/LuaStudy&quot;&gt;我在学习中写的所有代码&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.jb51.net/list/list_245_3.htm&quot;&gt;脚本之家-lua&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Mon, 07 Aug 2017 22:10:24 +0800</pubDate>
        <link>https://caihua.tech/2017/08/07/Lua%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%AB%98%E7%BA%A7%E6%A6%82%E5%BF%B5/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/08/07/Lua%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%AB%98%E7%BA%A7%E6%A6%82%E5%BF%B5/</guid>
        
        <category>Lua</category>
        
        
      </item>
    
      <item>
        <title>每天一点UWA：第一周</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;初衷&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;首先&lt;a href=&quot;https://www.uwa4d.com&quot;&gt;UWA&lt;/a&gt;一直以来都是一个我很喜欢的网站，因为他们在unity的优化方面是非常专业的，而且他们对于技术的分享也是毫不吝啬的。在他们的网站上有很多的技术文章，很久以来都想系统的阅读一遍，但是一直没有去做。这周开始下定决心要从第一篇开始，把UWA所有的技术分享文章读完，这个系列的文章会对每周读到的技术做一个总结，但是因为文章涉及的方向比较杂，因此会简单的用技术进行一个分类。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;cpu&quot;&gt;CPU方面的优化（很有用）&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;就目前的Unity移动游戏而言，CPU方面的性能开销主要可归结为两大类：引擎模块性能开销和自身代码性能开销。其中，引擎模块中又可细致划分为渲染模块、动画模块、物理模块、UI模块、粒子系统、加载模块和GC调用等等。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-1&quot;&gt;渲染模块&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;减少draw call。减少dc的核心办法在unity里面就是减少材质球。因为如果多个物体共用一个材质球（共同的贴图和shader）那么对于一次draw call来说就是传递顶点数多少的问题。&lt;/li&gt;
  &lt;li&gt;顶点数的多少引出了另一个问题，传输渲染数据的总线带宽。当大量GameObject满足批处理条件时（900个数据值），unity会合并mesh，但是一个超大的mesh数据传输起来也有瓶颈。因此关于draw call的优化不能是无脑的，需要平衡dc次数和总线带宽。&lt;/li&gt;
  &lt;li&gt;简化资源&lt;/li&gt;
  &lt;li&gt;渲染模块在CPU方面的优化方法还有很多，比如LOD、Occlusion Culling和Culling Distance等等&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;ui&quot;&gt;UI模块&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;文中以NGUI为例进行了函数的分析，但是UGUI应该也有借鉴的意义。&lt;/li&gt;
  &lt;li&gt;在NGUI的优化方面，UIPanel.LateUpdate为性能优化的重中之重，它是NGUI中CPU开销最大的函数，没有之一。对于UIPanel.LateUpdate的优化，主要着眼于UIPanel的布局，其原则如下：
    &lt;ul&gt;
      &lt;li&gt;尽可能将动态UI元素和静态UI元素分离到不同的UIPanel中（UI的重建以UIPanel为单位），从而尽可能将因为变动的UI元素引起的重构控制在较小的范围内；&lt;/li&gt;
      &lt;li&gt;尽可能让动态UI元素按照同步性进行划分，即运动频率不同的UI元素尽可能分离放在不同的UIPanel中；&lt;/li&gt;
      &lt;li&gt;控制同一个UIPanel中动态UI元素的数量，数量越多，所创建的Mesh越大，从而使得重构的开销显著增加。比如，战斗过程中的HUD运动血条可能会出现较多，此时，建议研发团队将运动血条分离成不同的UIPanel，每组UIPanel下5~10个动态UI为宜。这种做法，其本质是从概率上尽可能降低单帧中UIPanel的重建开销。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;PS：结合之前关于UI优化的文章，UI优化的核心在于拆分UI元素。始终不变的归为一类，动态变化的归为一类。对于UGUI来说就是拆分Canvas。&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;PS2：关于UI重建的说明。UI其实是一些3D的quad，这一下就能够理解为什么存在UI的减少drawcall了，这个和模型的减dc完全一个原理。多个UI在一个Canvas下就存在多个UI的mesh合并问题（批处理），但是像血条这样的UI一般用的是progress，它的原理就是默认模式下改变quad的顶点数据来实现进度大小的改变，fxxx模式下是顶点和UV一起变，只要改变了顶点位置，那么mesh必要每次dc的时候都要重新计算。和它一起的那些不变的UI的计算是浪费的。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-2&quot;&gt;加载模块&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;目前加载模块性能开销主要在场景切换，分为前一场景的场景卸载和下一场景的场景加载。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;场景卸载：主要是Destroy和Resources.UnloadUnusedAssets两个函数，前者的消耗多少主要取决于事件函数中代码的功能多少。后者耗时开销主要取决于场景中Asset和Object的数量，数量越多，则耗时越慢。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;场景加载：主要是资源加载和Instantiate实例化。
    &lt;ul&gt;
      &lt;li&gt;资源加载几乎占据了整个加载过程的90%时间以上，其加载效率主要取决于资源的加载方式（Resource.Load或AssetBundle加载）、加载量（纹理、网格、材质等资源数据的大小）和资源格式（纹理格式、音频格式等）等等。不同的加载方式、不同的资源格式，其加载效率可谓千差万别。&lt;/li&gt;
      &lt;li&gt;在场景加载过程中，往往伴随着大量的Instantiate实例化操作，比如UI界面实例化、角色/怪物实例化、场景建筑实例化等等。在Instantiate实例化时，引擎底层会查看其相关的资源是否已经被加载，如果没有，则会先加载其相关资源，再进行实例化，这其实是大家遇到的大多数“Instantiate耗时问题”的根本原因，这也是为什么我们在之前的AssetBundle文章中所提倡的资源依赖关系打包并进行预加载，从而来缓解Instantiate实例化时的压力。&lt;/li&gt;
      &lt;li&gt;另一方面，Instantiate实例化的性能开销还体现在脚本代码的序列化上，如果脚本中需要序列化的信息很多，则Instantiate实例化时的时间亦会很长。最直接的例子就是NGUI，其代码中存在很多SerializedField标识，从而在实例化时带来了较多的代码序列化开销。因此，在大家为代码增加序列化信息时，这一点是需要大家时刻关注的。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;以上是游戏项目中性能开销最大的三个模块，当然，游戏类型的不同、设计的不同，其他模块仍然会有较大的CPU占用。比如，ARPG游戏中的动画系统和物理系统，音乐休闲类游戏中的音频系统和粒子系统等。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;PS：关于场景加载在之前的文章中也有讲到，尤其是AssetBundle系列文章中。根据unity对资源的管理方式，Resources文件夹里面的asset会全部加载到PersistentManager，当然这个过程只是建立InstanceID的过程，但是仍旧消耗了时间。&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;代码效率&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;一图胜千言
&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2Foptimzation_cpu%2FDoc1_09.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;assetbundle&quot;&gt;AssetBundle&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;4.x的内容就不考虑写出来了。&lt;/li&gt;
  &lt;li&gt;AssetBundle5.x怎么制作我在之前的一个blog中写过,可以说5.x极大的简化了AssetBundle的打包流程。&lt;/li&gt;
  &lt;li&gt;不考虑5.3前的情况，之后的版本建议使用LZ4打包，因为是按需解压加载的。&lt;/li&gt;
  &lt;li&gt;新增的AppendHashToAssetBundleName选项很不错，可以在生成AssetBundle时加入hash值，便于判定是否有更新，AssetBundleBrowser中支持。&lt;/li&gt;
  &lt;li&gt;几个注意的点：
    &lt;ul&gt;
      &lt;li&gt;新机制打包无法指定Assetbundle.mainAsset，因此无法再通过mainAsset来直接获取资源。&lt;/li&gt;
      &lt;li&gt;开启DisableWriteTypeTree可能造成AssetBundle对Unity版本的兼容问题，但会使Bundle更小，同时也会略微提高加载速度。&lt;/li&gt;
      &lt;li&gt;abName可通过脚本进行设置和清除，也可以通过构造一个AssetBundleBuild数组来打包。&lt;/li&gt;
      &lt;li&gt;Prefab之间不会建立依赖，即如果Prefab-A和Prefab-B引用了同一张纹理，而他们设置了不同的abName，而共享的纹理并未设置abName，那么Prefab-A和Prefab-B可视为分别打包，各自Bundle中都包含共享的纹理。因此在使用UGUI，开启Sprite Packer时，由于Atlas无法标记abName，在设置UI界面Prefab的abName时就需要注意这个问题。&lt;/li&gt;
      &lt;li&gt;5.x中加入了Shader stripping功能,在打包时，默认情况下会根据当前场景的Lightmap及Fog设置对资源中的Shader进行代码剥离。这意味着，如果在一个空场景下进行打包，则Bundle中的Shader会失去对Lightmap和Fog的支持，从而出现运行时Lightmap和Fog丢失的情况.而通过将Edit-&amp;gt;Project Settings-&amp;gt;Graphics下shader Stripping中的modes改为Manual，并勾选相应的mode即可避免这一问题。&lt;/li&gt;
      &lt;li&gt;Shader被打包到不同AssetBundle中了，WarmupAllShaders仅能对当前内存中的Shader进行warm up。后续如果又有Shader加载进来，则仍然会出现CreateGPUProgram操作。&lt;/li&gt;
      &lt;li&gt;PS:这一条在2017中发现custom选项中是全选的。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-4&quot;&gt;纹理&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;对于图片如果可以的话，建议直接将其制作成POT（ power of two，即图片的size是2次幂，这个也是unity建议的）图片，而非进行二次转换。ToLarger确实可以将纹理拉伸成POT纹理，但如果是UI界面（开启Pixel Perfect）的话，可能显示时会有较大视觉损失。&lt;/li&gt;
  &lt;li&gt;Texture占用内存总是双倍：出现这种情况的原因有两种：一种是在真机运行时开启了Read&amp;amp;Write。另一种可能是Unity的Bug，目前的Unity 5.2.3 release note如下 ：
(735644) - OpenGL: Fixed texture memory usage reporting in profiler, was twice the actual size for most textures.&lt;/li&gt;
  &lt;li&gt;纹理Atlas是合成一张2048（尺寸）的纹理还是四张1024的纹理在其他设置一致的情况下，这两种方式无论在加载还是渲染方面其实并没有实质上的差别。在我们接触到的大多数案例中，纹理资源方面的问题除了尺寸外，&lt;strong&gt;纹理格式、Mipmap设置和Read&amp;amp;Write功能&lt;/strong&gt;同样是需要研发团队时刻关注的。&lt;/li&gt;
  &lt;li&gt;PS:看来纹理的Read&amp;amp;Write选项很重要&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;unity&quot;&gt;unity的工具&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Overhead：
    &lt;ul&gt;
      &lt;li&gt;Overhead的计算方法是：Profiler当前帧统计的总耗时时间减去所有已知选项的累加时间，即引擎当前还无法识别模块的耗时时间。&lt;/li&gt;
      &lt;li&gt;Overhead数值理论上是趋向于0的，但是由于目前市面上的硬件设备、系统框架过于丰富，所以引擎可能无法识别所有模块的CPU开销。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;unity的分析工具中的Reserved Total 和 Used Total为Unity引擎在内存方面的总体分配量和总体使用量。 一般来说，引擎在分配内存时并不是向操作系统 “即拿即用”，而是首先获取一定量的连续内存，然后供自己内部使用，待空余内存不够时，引擎才会向系统再次申请一定量的连续内存进行使用。&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sat, 29 Jul 2017 23:18:54 +0800</pubDate>
        <link>https://caihua.tech/2017/07/29/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E4%B8%80%E5%91%A8/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/07/29/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E4%B8%80%E5%91%A8/</guid>
        
        <category>UWA</category>
        
        
      </item>
    
  </channel>
</rss>
