<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>蔡华的博客</title>
    <description>Be publicly useful and privately happy.</description>
    <link>https://caihua.tech/</link>
    <atom:link href="https://caihua.tech/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Wed, 07 Jun 2017 22:33:51 +0800</pubDate>
    <lastBuildDate>Wed, 07 Jun 2017 22:33:51 +0800</lastBuildDate>
    <generator>Jekyll v3.2.1</generator>
    
      <item>
        <title>写点东西，证明我还在更新</title>
        <description>&lt;h4 id=&quot;section&quot;&gt;最近的一些情况&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;很久没有更新博客了，从4月份开始为了项目赶进度开始了996模式，实在没有什么时间写东西。这个是公司也是我自己做的第一个VR旅游项目，可以说从零开始吧，毕竟与游戏开发不一样，期间学到了多东西，也走了不少的弯路。&lt;/li&gt;
  &lt;li&gt;在项目期间很神奇的看了一大半冯乐乐写的《Shader入门精要》，在这给这本书打打广告，这是一本很适合入门的Shader书籍，而且紧密的结合了Unity5。对于我这样想要编写shader的人来说是很好的入门。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-1&quot;&gt;后续的计划&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;本来今年的计划是搞定AssetBundle和热更新，然后看完《游戏编程模式》这本书。之前的blog中也陆续写了一些读书笔记，其实在写AssetBundle的最后一篇时的最后一个link指向了AssetBundle的一个官方实践教程，是必须读的文章。我基本已经看完了，后续会写读书笔记，现在年纪大了不写点东西感觉自己记不住了。XD&lt;/li&gt;
  &lt;li&gt;另外就是上面提到的项目完成后会写一点总结。&lt;/li&gt;
  &lt;li&gt;还有就是上半年最大的收获，学会了写unity shader。以前一些特效总要找特效的同事做，而且有时候用了一些特效发现很影响性能但是不知为何，在学了shader之后很多事情知道是怎么回事了，虽然PBR这样的shader还是不能完全写出来，但是基本的写法和理论都已经知道了，遇到问题的时候不会再一脸懵逼。这算是上半年最大的收获吧。当然，读书笔记必不可少，等我刷第二遍书的时候会开始写。&lt;/li&gt;
  &lt;li&gt;下半年的项目计划已经出来了，做一个VR教育的产品，涉及到AssetBundle和热更新，好吧真是太巧了，刚好在项目中要好好学学热更新了。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 04 Jun 2017 21:44:23 +0800</pubDate>
        <link>https://caihua.tech/2017/06/04/%E5%86%99%E7%82%B9%E4%B8%9C%E8%A5%BF-%E8%AF%81%E6%98%8E%E6%88%91%E8%BF%98%E5%9C%A8%E6%9B%B4%E6%96%B0/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/06/04/%E5%86%99%E7%82%B9%E4%B8%9C%E8%A5%BF-%E8%AF%81%E6%98%8E%E6%88%91%E8%BF%98%E5%9C%A8%E6%9B%B4%E6%96%B0/</guid>
        
        <category>杂记</category>
        
        
      </item>
    
      <item>
        <title>AssetBundle学习笔记：4、AssetBundle的下载与asset的加载</title>
        <description>&lt;h2 id=&quot;assetbundle&quot;&gt;AssetBundle的下载&lt;/h2&gt;
&lt;h4 id=&quot;assetbundle-1&quot;&gt;下载AssetBundle&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;首先需要理解的是这个下载就是指的从网络下载。因此只有WWW和 WWW.LoadFromCacheOrDownload两个方法。&lt;/li&gt;
  &lt;li&gt;www是不带缓存的，而后者是带缓存的。&lt;/li&gt;
  &lt;li&gt;LoadFromCacheOrDownload的version参数，如果缓存中不存在，或者version低于指定的版本就会重新下载，否则直接从缓存拿数据。&lt;strong&gt;缓存数据应该是始终在磁盘上的，而5.3以后缓存文件也压缩为LZ4(好像是可配置的)，所以读取cache的数据很可能与LoadFromFile是等效的。&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;如果多个AssetBundle使用WWW.LoadFromCacheOrDownload下载，每帧只能完成一个。&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.unity3d.com/ScriptReference/WWW.LoadFromCacheOrDownload.html&quot;&gt;LoadFromCacheOrDownload&lt;/a&gt;中如果发现缓存文件夹已经满了，会优先删除最近没有使用的cache，但是如果磁盘本身就满了或者说cache folder已经满了（这个东西是有容量限制的）那么会把AssetBundle数据直接按照stream的形式放到内存，这个和new WWW的做法完全一样。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;assetbundle-2&quot;&gt;生成AssetBundle&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;当访问&lt;code class=&quot;highlighter-rouge&quot;&gt; .assetBundle&lt;/code&gt;属性时，会从下载的数据中提取并生产AssetBundle对象。此时就可以加载AssetBundle中的asset了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section&quot;&gt;其它&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;后面在editor中加载asset的demo中API已经过时，可以用&lt;code class=&quot;highlighter-rouge&quot;&gt;AssetDatabase.LoadAssetAtPath&lt;/code&gt;代替。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;asset&quot;&gt;Asset加载&lt;/h2&gt;

&lt;h3 id=&quot;assetbundleapi&quot;&gt;AssetBundle加载API概述&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;具体表格可以参考&lt;a href=&quot;https://docs.unity3d.com/Manual/AssetBundleCompression.html&quot;&gt;原文&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;www&quot;&gt;WWW&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;在使用WWW时需要及时释放，因为它会在内存（WebStream）中保留下载的文件的大小。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;loadfromcacheordownload&quot;&gt;LoadFromCacheOrDownload&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;LoadFromCacheOrDownload没有什么额外的内存使用（其实应该有序列化文件（SerializedFile）的内存使用，而且如果prefab过多，有可能SerializedFile比WebStream还大，&lt;a href=&quot;http://blog.uwa4d.com/archives/ABTheory.html&quot;&gt;来源&lt;/a&gt;）&lt;/li&gt;
  &lt;li&gt;从表中可以看到在性能上也只有读磁盘的操作，然而LoadFromCacheOrDownload本质上是个网络操作，因此它会产生一些例如CRC检测的操作，所以unity的建议是如果是本地的AssetBundle不要用这个函数加载。&lt;/li&gt;
  &lt;li&gt;如果是加载缓存行为与 LoadFromFile一致，但是按照上面的说法看应该有差异吧。&lt;/li&gt;
  &lt;li&gt;补充：关于SerializedFile在4.7上每个的大小并不一定。&lt;code class=&quot;highlighter-rouge&quot;&gt;在5.3-5.5期间Unity引擎目前的做法，为了保证Android端apk解压速度而保证的两个256KB的buffer，在pc上只有7KB&lt;/code&gt;。而到了5.6会改为2x8KB。但是经过测试这个不是必然的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;loadfrommemory-async&quot;&gt;LoadFromMemory (Async)&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;LoadFromMemory (Async)，不推荐使用，因为它的操作几乎都是在内存中完成的。加载AssetBundle需要占用大概AB size两倍的内存，一个API创建的内容还有就是参数里面的数据内存。如果是load一个asset会在内存中出现三个asset的拷贝，一个是托管代码字节数组，一个是 AssetBundle 的本地内存，第三个是在 GPU 或者系统内存中的资产本身。（第一个是参数、一个是AssetBundle本身、一个是Load函数产生的对象内存）。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;loadfromfileasync&quot;&gt;LoadFromFile(Async)&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;LoadFromFile(Async)，&lt;strong&gt;++不能加载LZMA（特么的你敢信）。而且在Android上5.3和之前的unity无法加载StreamingAssets中的AssetBundle。++&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;移动端上：当使用AssetBundle.LoadFromFile加载LZ4格式的文件时，其实不会将问价加载到内容，而是加载AssetBundle的Header。&lt;/li&gt;
  &lt;li&gt;Editor下会将AssetBundle加载到内容，因此在Profiler中会出现峰值，不用担心。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;webrequest&quot;&gt;WebRequest&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.unity3d.com/Manual/UnityWebRequest-HLAPI.html&quot;&gt;WebRequest&lt;/a&gt;。
 (also supports caching)，这个东西算是WWW的替代品，很好用，回头写个总结。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-1&quot;&gt;其它&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;使用WWW, WebRequest下载AssetBundle时，还有一个8x64KB的缓冲池buff来保存socket中的数据。so，这也是内存啊。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-2&quot;&gt;从压缩格式角度看:&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;不压缩没啥优势，除了访问速度快。其实如果是不考虑内存或者磁盘的占用问题，倒是可以用这个。&lt;/li&gt;
  &lt;li&gt;LZ4，从文档看unity应该用的是&lt;a href=&quot;http://www.findbestopensource.com/product/lz4hc&quot;&gt;LZ4HC&lt;/a&gt;，一个LZ4的高压缩版本。由于unity从5.3以后缓存也可以压缩了，而且这个算法是基于块的，所以在综合性上比较好。&lt;/li&gt;
  &lt;li&gt;LZMA，必须先解压在压缩，如果不是因为网络传输需要节省流量，不建议使用。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-3&quot;&gt;加载二进制数据&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;按照建议应该将原始的二进制文件保存为后缀为&lt;code class=&quot;highlighter-rouge&quot;&gt;.bytes&lt;/code&gt;的文件，unity会视这个后缀的文件为TextAsset，作为一个TextAsset文件然后打包到AssetBundle。加载的时候也是一样，从AssetBundle中按照TextAsset类型得到asset，然后TextAsset.bytes属性得到byte数组。
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;string url = &quot;http://www.mywebsite.com/mygame/assetbundles/assetbundle1.unity3d&quot;;
IEnumerator Start () {
  while (!Caching.ready)
      yield return null;

  // Start a download of the given URL
  WWW www = WWW.LoadFromCacheOrDownload (url, 1);

  // Wait for download to complete
  yield return www;

  // Load and retrieve the AssetBundle
  AssetBundle bundle = www.assetBundle;

  // Load the TextAsset object
  TextAsset txt = bundle.Load(&quot;myBinaryAsText&quot;, typeof(TextAsset)) as TextAsset;

  // Retrieve the binary data as an array of bytes
  byte[] bytes = txt.bytes;
}
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-4&quot;&gt;对于加密资源的处理&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;三个套路：
    &lt;ul&gt;
      &lt;li&gt;加密自己的原始数据，然后改后缀为.byte，按照上面说的二进制的套路走。客户端拿到二进制数据后进行解密。&lt;/li&gt;
      &lt;li&gt;加密AssetBundle，后缀名不限。用WWW的形式拿到数据后解密，然后用AssetBundle.CreateFromMemory生成AssetBundle。&lt;/li&gt;
      &lt;li&gt;一个普通的AssetBundle中包含一个加密的AssetBundle（蛋疼不？）。需要经历获取TextAsset-&amp;gt;拿到二进制数据-&amp;gt;解密二进制数据-&amp;gt;生成未加密AssetBundle-&amp;gt;加载AssetBundle中的asset。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;script-asset&quot;&gt;Script Asset的处理&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;script-&amp;gt;assembly(pre-compiled)-&amp;gt;TextAsset-&amp;gt;AssetBundle-&amp;gt;TextAsset-&amp;gt;byte[]-&amp;gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var assembly = System.Reflection.Assembly.Load(txt.bytes);
var type = assembly.GetType(&quot;MyClassDerivedFromMonoBehaviour&quot;);

// Instantiate a GameObject and add a component with the loaded class
GameObject go = new GameObject();
go.AddComponent(type);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;assetassetbundle&quot;&gt;卸载asset或者说AssetBundle&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;AssetBundle.Unload方法是目前AssetBundle唯一能够使用的方法，与Resources.UnloadAsset比起来缺乏灵活性。&lt;/li&gt;
  &lt;li&gt;参数是个bool，传递false&lt;code class=&quot;highlighter-rouge&quot;&gt;unload the compressed data from memory&lt;/code&gt;，按照第二部分的说明，什么是压缩的数据，那就是LZ4的数据，也就是AssetBundle。如果传递true，那么已经load出来的asset也会被清理。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-5&quot;&gt;一些策略&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;一个AssetBundle对象在同一时刻只能存在一份，所以当反复使用www下载并调用www.assetBundle时会报错&lt;code class=&quot;highlighter-rouge&quot;&gt; Cannot load cached AssetBundle. A file of the same name is already loaded from another AssetBundle&lt;/code&gt;。这个时候要么自己unload要么就代码控制只保留一个对象。unity的建议是尽快删除不用的AssetBundle。&lt;/li&gt;
  &lt;li&gt;unity5之前bundle在unload之前如果有load，需要等到load结束才会执行unload。so，可能会卡线程。&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.unity3d.com/560/Documentation/Manual/keepingtrackofloadedassetbundles.html&quot;&gt;文中&lt;/a&gt;有一个完整的解决方案。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;assetbundleseek&quot;&gt;优化AssetBundle的磁盘寻道(Seek)&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;unity序列化数据是为使得数据在读取时是线性的，减少寻道的次数。因为HDDs的硬盘比SSD慢很多。&lt;/li&gt;
  &lt;li&gt;一个场景的数据按照对象类型进行排序，在场景加载时，场景中的asset先按顺序加载，然后画面中的对象才加载。（完全可以理解，场景中摆放的多是prefab，肯定要先加载prefab所需要的资源。）而Scene AssetBundle也是这个顺序。&lt;/li&gt;
  &lt;li&gt;一个来自non-Scene AssetBundles中的asset在序列化上是和Scene AssetBundles一样的，但是加载方式取决于调用的API。LoadAllAssets这样的API会采用线性的方式加载所有的资源。但是如果是LoadAsset会随机读取的形式加载。&lt;/li&gt;
  &lt;li&gt;DeterministicAssetBundles不破坏线性读取和类型排序，但是保留对象位置在一个特点的范围(没看懂)。&lt;/li&gt;
  &lt;li&gt;LZ4不影响线性读取，但是会影响读取的颗粒度。（想来是因为按需加载，所以。。。）&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-6&quot;&gt;一些需要注意的行为&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;一些异步加载API会打破线性读取的模式，即使是读取场景。&lt;/li&gt;
  &lt;li&gt;因为有依赖的存在，所即使AssetBundle.LoadAllAssets这样的API也不能保证是线性读取的。因为可能出现依赖的资源在别的AssetBundle中，所以最好是将所有依赖的资源都读取出来放好了，这样可以使用最小的寻道次数。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-7&quot;&gt;参考&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/huxiao-tee/p/4660352.html&quot;&gt;MMAP&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/lodypig/article/details/51879702&quot;&gt;一些内存测试数据&lt;/a&gt;。第二个测试结果符合unity使用MMAP的结论。&lt;/li&gt;
  &lt;li&gt;一些不错的文章
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;http://minhhh.github.io/posts/unity-asset-bundle&quot;&gt;简单好理解&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;http://blog.shuiguzi.com/2016/12/15/GuideToABAndRes/&quot;&gt;震惊！男人看了会沉默，女人看了会流泪，不看不是中国人之事实的真相系列。&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 04 Apr 2017 12:06:27 +0800</pubDate>
        <link>https://caihua.tech/2017/04/04/AssetBundle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4-AssetBundle%E7%9A%84%E4%B8%8B%E8%BD%BD%E4%B8%8Easset%E7%9A%84%E5%8A%A0%E8%BD%BD/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/04/04/AssetBundle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4-AssetBundle%E7%9A%84%E4%B8%8B%E8%BD%BD%E4%B8%8Easset%E7%9A%84%E5%8A%A0%E8%BD%BD/</guid>
        
        <category>AssetBundle学习笔记</category>
        
        
      </item>
    
      <item>
        <title>AssetBundle学习笔记：3、AssetBundle内部结构</title>
        <description>&lt;h4 id=&quot;section&quot;&gt;本质&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;AssetBundle在本质上是一些被分组保存在一个序列化文件中的对象。被部署为一个数据文件，这些文件按照普通包和场景包的不同，在结构上有些差别。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;normal-assetbundle-structure&quot;&gt;Normal AssetBundle structure&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://docs.unity3d.com/550/Documentation/uploads/Main/AssetBundleStructureNormal.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;对于第一个块中的main serialized file应该是可以通过AssetBundle.mainAsset获取的，而谁是mainAsset呢？在build的时候第一个放置进去的资源就是mainAsset，所以可以采用将AssetBundle中所有的资源的名称写入一个文件，然后文件作为mainAsset来使用。&lt;a href=&quot;https://docs.unity3d.com/560/Documentation/ScriptReference/BuildPipeline.BuildAssetBundles.html&quot;&gt;具体代码参考引用的第二部分&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;streamed-scene-assetbundle-structure&quot;&gt;Streamed scene AssetBundle structure&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://docs.unity3d.com/550/Documentation/uploads/Main/AssetBundleStructureStreamedScene.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;虽然结构不同，但是是一样的压缩方式。&lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;assetbundle-compression&quot;&gt;AssetBundle compression&lt;/h4&gt;
    &lt;p&gt;&lt;img src=&quot;https://docs.unity3d.com/550/Documentation/uploads/Main/AssetBundleArchiveFileSystem.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;LZ4（ chunk-based compression）将原始数据分隔后独立压缩，在解压的时候是随机读取的开销很小。而LZMA(stream-based compression)提供了高压缩比，但是解压时必须按照顺序读取。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;总结:这篇的内容基本都是图，从normal bundle和scene bundle中可以看到些不同。它们都有一个主序列化文件，然后是&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Tue, 04 Apr 2017 12:04:45 +0800</pubDate>
        <link>https://caihua.tech/2017/04/04/AssetBundle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-AssetBundle%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/04/04/AssetBundle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-AssetBundle%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84/</guid>
        
        <category>AssetBundle学习笔记</category>
        
        
      </item>
    
      <item>
        <title>AssetBundle学习笔记：2、压缩</title>
        <description>&lt;h4 id=&quot;section&quot;&gt;格式&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;谈压缩就要谈到格式，unity目前在制作AssetBundle时默认就是压缩的，当然也可以设置为不压缩，但是显然不科学尤其是在移动端的开发上。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;LZMA：这个是一个序列化数据文件流，也是AssetBundle的默认压缩格式。LZMA提供最佳的压缩比，但是在使用的时候需要完全解压后才能使用，因此加载时需要的事件比较多。&lt;/li&gt;
  &lt;li&gt;LZ4：5.3以后才加入的一种压缩格式，被unity自己大量使用。这是一种基于块的压缩方式，当一个对象从LZ4压缩的AssetBundle中加载时，会按照需要解压部分的块。这样的好处在于快速的加载对象，后面会提到一个最佳实践。当然，按照这个原理，你也可以想象如果一个LZ4AssetBundle中只包含了一个GameObject，那么也不存在什么按需加载了。当使用AssetBundle.LoadFromFile加载LZ4格式的文件时，其实不会将问价加载到内容，而是加载AssetBundle的Header。&lt;/li&gt;
  &lt;li&gt;AssetBundle也可以选择不压缩，这样体积最大但是加载最快。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;assetbundle&quot;&gt;缓冲被压缩的AssetBundle&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;WWW.LoadFromCacheOrDownload方法下载并缓冲AssetBundle到磁盘，5.3以后缓冲的文件可以是LZ4格式的压缩文件了，这直接导致了一个很2的事情。就是当你下载了LZMA格式的AssetBundle后，每当你通过socket下载到足够的数据后，unity就在后台悄悄的解压然后重新压缩为LZ4格式的文件直到下载结束，这个压缩发生在下载流（download streaming）中。当用到缓冲中的数据时，就会按照解压LZ4的套路走了。也就是按需按块解压。&lt;/li&gt;
  &lt;li&gt;缓冲压缩是默认的，然后可以通过 Caching.compressionEnabled属性来控制。会影响到包缓冲到磁盘和保存在内存中。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-1&quot;&gt;指导方针，满满的干货&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;如果是将AssetBundle打包到游戏中，也就是AssetBundle跟着安装包走的话，推荐LZ4+AssetBundle.LoadFromFileAsync，既有压缩省空间，又有最快的加载性能可能性，给你读取内存buff的快感。&lt;/li&gt;
  &lt;li&gt;如果是网络下载可下载内容（DLC），则使用LZMA+LoadFromCacheOrDownload/WebRequest，这样可以获得最好的压缩比。缓存到本地后使用AssetBundle.LoadFromFile加载。这里需要注意，如果是一些需要持久化的内容，是需要实实在在的保存到本地的，否则进程结束后内存中的cache会清除。&lt;/li&gt;
  &lt;li&gt;如果是加密的AssetBundle，则使用LZ4+LoadFromMemoryAsync。其实也可以理解，毕竟需要加载到内容后进行解密。而且这个差不多是LoadFromMemory[Async]唯一的使用场景。&lt;/li&gt;
  &lt;li&gt;当使用自定义压缩时，请使用不压缩来创建AssetBundle，然后自己解压后使用AssetBundle.LoadFromFileAsync来加载。&lt;/li&gt;
  &lt;li&gt;为了节约内存，如果是不含prefab的AssetBundle，比如是texture的。最好用LoadFromCacheOrDownload，前提是通过网络获取，因为只有少量的序列化文件在内存。如果是保护prefab比较多的，用new WWW可能占用的内存会比序列化文件的都少。&lt;/li&gt;
  &lt;li&gt;总之，AssetBundle的使用需要进行灵活的应用。&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Mon, 20 Mar 2017 18:00:00 +0800</pubDate>
        <link>https://caihua.tech/2017/03/20/AssetBundle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2-%E5%8E%8B%E7%BC%A9/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/03/20/AssetBundle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2-%E5%8E%8B%E7%BC%A9/</guid>
        
        <category>AssetBundle学习笔记</category>
        
        
      </item>
    
      <item>
        <title>我所了解的法线贴图</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;两篇文章&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;本文大多数内容来自这两篇文章，看完后基本明白了法线贴图的种种细节。&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;http://www.66acg.com/m/?post=468&quot;&gt;凹凸映射&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/flytrace/p/3387748.html&quot;&gt;写给笨人的法线贴图原理&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;一些基本的概念&lt;/h2&gt;

&lt;h4 id=&quot;section-2&quot;&gt;1.法线贴图的定义&lt;/h4&gt;

&lt;p&gt;顾名思义，法线贴图保存的是法线的信息贴图。&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;2.用来干什么&lt;/h4&gt;
&lt;p&gt;用来进行凹凸映射。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;凹凸映射的目的是使用一张纹理来修改模型表面的法线，以便为模型提供更多的细节。这种方法不会真的改变模型的顶点位置，只是让模型看起来好像是“凹凸不平”的，但可以从模型的轮廓处看出“破绽”。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;有两种主要的方法可以用来进行凹凸映射：一种方法是使用一张高度纹理(height map)来模拟表面位移(displacement)，然后得到一个修改后的法线值，这种方法也被称为高度映射(height mapping);另一种方法则是使用一张法线纹理(normal map)来直接存储表面法线，这种方法又被称为法线映射(normal mapping)。尽管我们常常将凹凸映射和法线映射当成是相同的技术，但要知道它们之间的不同。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;section-4&quot;&gt;3.种类&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;世界空间下的法线纹理&lt;/li&gt;
  &lt;li&gt;模型空间下的法线纹理&lt;/li&gt;
  &lt;li&gt;切线空间下的法线纹理&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-5&quot;&gt;对比不同的法线贴图&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;首先按照不同的坐标系得到了不同类型的法线贴图。模型顶点的法线根据所处坐标系的不同，在成图后表现也是不同的。以模型法线贴图和切线法线贴图为例：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://www.66acg.com/content/uploadfile/201609/8e0f1474641756.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图 左边: 模型空间下的法线纹理   右边: 切线空间下的法线纹理&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;不同的颜色是因为法线作为一个Vector3类型的需要转换到2D的颜色，而通常来说我们可以把颜色的RGB看成一个坐标系，这样法线就对应了一个RGB颜色。但是法线的范围是[-1,1]，而颜色是没有负值的，因此有以下的转换过程。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;法线纹理存储的是表面的法线方向。由于法线方向的分量范围在[-1, 1]，而像素的分量范围为[0, 1]，因此我们需要做一个映射，通常使用的映射就是： 
pixel=(normal + 1) / 2 
这就要求，我们在Shader中对法线纹理进行纹理采样后，还需要对结果进行一次反映射的过程，以得到原先的法线方向。反映射的过程实际就是使用上面映射函数的逆函数： 
normal=pixel × 2 - 1&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;world-space-normal-map&quot;&gt;1.world space normal map&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;一旦从贴图里解压出来后,就可以直接用了,效率很高.但是有个缺点,这个world space normal 是固定了,如果物体没有保持原来的方向和位置,那原来生成的normal map就作废了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;世界坐标下的顶点的法线是现成的，因此好用。不过如果进入模型在U3D里面进行了位置或者方向的转换，那么在没有转换矩阵的情况下，法线信息就是错误的，也就无法使用了。进一步思考如果场景中存在大量的静态模型，可以考虑用这个。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;object-space-normal-map&quot;&gt;2.object space normal map&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;对于模型顶点自带的法线，它们是定义在模型空间中的，因此一种直接的想法就是将修改后的模型空间中的表面法线存储在一张纹理中，这种纹理被称为模型空间的法线纹理(object-space normal map)。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;对象空间的法线贴图，这个贴图中记录的法线信息是基于模型空间的，因此数值是相对的，这样模型在场景中是可以位移和旋转的，只要在计算的时候乘上对应的矩阵即可。而且从上面的图里可以看到贴图是彩色的，因为模型上的顶点法线在这个空间中是朝各个方向的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对象空间的法线贴图比起世界空间的在使用了已经有了很大的进步，不过它仍旧有自己的局限性，就是这样的贴图还是依赖于模型本身。从其定义也可以看出来，它也是一种“绝对位置”。如果模型发生了形变，则这个贴图的信息就是错误的。从目前来看，我只能想到模型在场景中存在动画这个问题。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;tangent-space-normal-map&quot;&gt;3.tangent space normal map&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;对于模型的每一个顶点，它都有一个属于自己的切线空间，这个切线空间的原点就是该顶点本身，而z轴是顶点的法线方向(n),x轴是顶点的切线方向(t)，而y轴可由法线和切线叉积而得，也被称为副切线(bitangent, b)或副法线。这种纹理被称为是切线空间的法线纹理(tangent-space normal map)。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;定义很好理解，从本质上讲切线空间的法线贴图解决了模型变形的问题。因为在另一个模型上的顶点的切线空间坐标系里面，法线贴图中的信息是可以使用的，它不依赖于模型本身、也不依赖于模型所处的坐标系。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-6&quot;&gt;4.切线空间下的法线贴图如何生成&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;以3DMAX为例，法线贴图需要高模和低模配合，具体过程不说了，网上大把的视频。&lt;/li&gt;
  &lt;li&gt;重点是法线贴图的生成需要高模和低模，因为没有高模就不知道法线方向,没有低模,就不知道高模上某点的法线对应于低模上哪个点。&lt;/li&gt;
  &lt;li&gt;下面才是重点，因为多个高模的面使用了同一个低模的面，因此在生成法线贴图时，高模不能使用自己的tangent space，而是使用低模的tangent space。这样一些高模上的点的法线与低模面上的法线出现了不一致，你可以想象低模上的某个面上的法线指向一个方向，但是对应了几个高模的点，可能一些点的法线与低模面的法线方向一样，那么很好，完美融入低模的切线空间，颜色呈现出淡蓝色。但是其它那些和低模面法线不一致的点的法线就产生了夹角，就造成了在切线法线贴图上那些不是[0.5,0.5,1]色值的点。
    &lt;blockquote&gt;
      &lt;p&gt;低模上的这个tangent space，也必须与高模上的坐标系tangent space。因为低模上的一个面,可能对应了高模上的几个面(精度高)，按照新方法每个面都有一个局部坐标系，那对于低模上的每个面，高模因为存在好几个面，就会出现好几个局部坐标系，这肯定是不行的。所以高模所用的tangent space，就是低模上的。生成法线贴图，必定会确认高模上哪些面都对应低模上的哪个面，然后高模上的这几个面的法线，都会转换为低模这个面上所构建的tangent space的坐标。这样，当低模变形时，即三角面变化时，它的tangent space也会跟着变化，保存在贴图里的法线乘以低模这个面的tangent space到外部坐标系的转换矩阵即可得到外部坐标。顺便再提一点，高模保存的这个法线，是高模上object space里的法线。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;对于上述的内容，这张图做了很好的诠释。
&lt;img src=&quot;http://images.cnitblog.com/blog/278594/201310/26011616-6fe1f456a1b94c408c883ab302c59f99.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-7&quot;&gt;如何将高模的法线贴图用在低模上&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;对于object space normal map，低模的object space坐标系与高模中的object space坐标系是重合的。所以不需要构建,所以低模上某点才能直接用高模的法线替换自己的法线。&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Thu, 16 Mar 2017 15:20:05 +0800</pubDate>
        <link>https://caihua.tech/2017/03/16/%E6%88%91%E6%89%80%E4%BA%86%E8%A7%A3%E7%9A%84%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/03/16/%E6%88%91%E6%89%80%E4%BA%86%E8%A7%A3%E7%9A%84%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE/</guid>
        
        <category>Unity3D</category>
        
        
      </item>
    
      <item>
        <title>游戏设计模式读书笔记：原型模式</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;原型模式&lt;/h2&gt;
&lt;h4 id=&quot;section-1&quot;&gt;定义&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F&quot;&gt;定义&lt;/a&gt;：原型模式是创建型模式的一种,其特点在于通过“复制”一个已经存在的实例来返回新的实例,而不是新建实例。被复制的实例就是我们所称的“原型”，这个原型是可定制的。
原型模式多用于创建复杂的或者耗时的实例，因为这种情况下，复制一个已经存在的实例使程序运行更高效；或者创建值相等，只是命名不一样的同类数据。&lt;/li&gt;
  &lt;li&gt;看图
&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/thumb/1/14/Prototype_UML.svg/678px-Prototype_UML.svg.png&quot; alt=&quot;image&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;模式的理解&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;当需要快速并且尽可能少的占用内存的情况下，创建一个新的对象可以采用这个模式。前提是浅拷贝，因为深拷贝就是创建一个新的对象。&lt;/li&gt;
  &lt;li&gt;如果在必须是深拷贝，那么这个模式只是在使用上有便利，或者说代码上更优雅而已。&lt;/li&gt;
  &lt;li&gt;在扩展一个基础类型时，可以使用原型模式。但是C#中如果是结构体还好说，如果是个类完全可以用继承。&lt;/li&gt;
  &lt;li&gt;根据定义这个不是新建一个实例，那么本质上是浅拷贝。至于到底是深拷贝还是浅拷贝我认为可以根据自己的需要去做。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;unity&quot;&gt;Unity中的实现&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;其实在C#中已经实现了ICloneable接口，直接继承接口，然后实现方法即可。而且.net还提供了MemberwiseClone方法，直接实现了浅拷贝。&lt;/li&gt;
  &lt;li&gt;要做深拷贝就是new一个对象返回即可。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-3&quot;&gt;吐槽&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;这个文章不知所谓。作者自己都不喜欢这个模式。或者说他用这个模式的方向应该不是这个模式原本希望人们使用的方式吧。&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Thu, 16 Mar 2017 15:20:05 +0800</pubDate>
        <link>https://caihua.tech/2017/03/16/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/03/16/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</guid>
        
        <category>游戏设计模式读书笔记</category>
        
        
      </item>
    
      <item>
        <title>AssetBundle学习笔记：1、概述和创建</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;前言&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;打算彻底搞清楚AssetBundle的原理和使用，目前计划刷完官方文档和最佳实践系列文章，而且笔记中的内容会大量是官方文档的内容。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;概述&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;AssetBundle可以包含任意unity能识别的类型文件，甚至是一个场景。如果想包含自定义的二进制文件，需要文件后缀名是.bytes，unity会将这样的文件导入为TextAsset。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;ab&quot;&gt;AB流程&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://docs.unity3d.com/550/Documentation/uploads/Main/AssetBundlesBuildPlusUpload.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Editor编辑，场景中使用。&lt;/li&gt;
  &lt;li&gt;上传AB到服务器，其实这个不是必须的，也可以放到本地，后面会讲到这种case下怎么做才是最高效的。程序会按需加载AB，然后每个AB中的asset各自处理。其实就是在AssetBundle中按照需要加载不同的资源。&lt;/li&gt;
  &lt;li&gt;下载AB到本地，方法也非常多，各有优劣，后面会说。&lt;/li&gt;
  &lt;li&gt;从AssetBundle中加载GameObject，这个有一个AssetBundle→asset→GameObject的过程。而AB之前还可能有www。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-2&quot;&gt;友情提示&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;你必须看&lt;a href=&quot;http://unity3d.com/learn/tutorials/topics/best-practices/guide-assetbundles-and-resources&quot;&gt;这个&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;assetbundle&quot;&gt;创建AssetBundle&lt;/h2&gt;

&lt;h4 id=&quot;assetbundle-1&quot;&gt;设置AssetBundle&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;定义AssetBundle名称，在一个资源的最下方会有一个AssetBundle的设置。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://docs.unity3d.com/550/Documentation/uploads/Main/AssetBundleInspectorNewBundle.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;点击New按钮可以创建新包，并给它命名。下图的例子中资源被添加到一个名为environment/desert的AssetBundle中，这里面可能包含了之前已经放置的资源。另外在AssetBundle命名时unity会当名称转为小写。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://docs.unity3d.com/550/Documentation/uploads/Main/AssetBundleEditor.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果创建了一些AssetBundle，但是没有放置任何的资源通过Remove Unused Names选项可以删除定义的名字。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;从上述的说明感觉这个new出来的是一个空文件夹识，在设置资源时这个文件夹的名字作为了标识来使用。而Remove Unused Names按钮就是一键删除空文件夹。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;assetbundle-2&quot;&gt;代码生成AssetBundle&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;这里有一段代码。代码很简单，而且没有很多容错机制。而且说实话这个代码很粗暴，所有被标记（就是上面说的设置）了AssetBundle的资源：prefab、scene文件等都会被无脑的build进指定的AssetBundle中。&lt;/li&gt;
  &lt;li&gt;```
using UnityEditor;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;public class CreateAssetBundles
{
    [MenuItem (“Assets/Build AssetBundles”)]
    static void BuildAllAssetBundles ()
    {
        BuildPipeline.BuildAssetBundles (“Assets/AssetBundles”, BuildAssetBundleOptions.None, BuildTarget.StandaloneOSXUniversal);
    }
}&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- 同时生成的manifest文件包含一下内容：
    - [CRC](https://zh.wikipedia.org/wiki/%E5%BE%AA%E7%92%B0%E5%86%97%E9%A4%98%E6%A0%A1%E9%A9%97)
    - AssetFileHash：AssetBundle中所有asset文件的hash，一个单独的hash。只用来做增量build时的检查。
    - TypeTreeHash：AssetBundle中所有类型的hash，只用来做增量build时的检查。
    - ClassTypes： AssetBundle中包含的所有类类型，这些数据用来得到一个新的单独的hash当typetree做增量build检测。
    - Asset names.所有在AssetBundle中的asset的名称。
    - Dependent AssetBundle names. AssetBundle所依赖的其它AssetBundle的名字
    - 这个manifest文件只是用来做增量build的，非运行时必须。
    
- 放一个自己的测试数据

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;ManifestFileVersion: 0
CRC: 1763426742
Hashes:
  AssetFileHash:
    serializedVersion: 2
    Hash: eed209af1be31231fa135faaff2ab7b6
  TypeTreeHash:
    serializedVersion: 2
    Hash: 31d6cfe0d16ae931b73c59d7e0c089c0
HashAppended: 0
ClassTypes: []
Assets:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Assets/Test.unity
Dependencies:&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;E:/CodeDemo/New Unity Project 2/Assets/AssetBundles/sphere
```&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;还有两个文件生成，文件名就是打包目的地文件夹的名字，比如上面的代码就在AssetBundles文件夹下生成，名字是AssetBundles，一个是没有后缀的一个是以manifest为后缀，打开manifest文件可以看到下面的内容，可以看出来是这个目录下AssetBundle的信息。&lt;strong&gt;&lt;em&gt;其实它只包含两个  信息，一个是所有的AssetBundle名字和它们的依赖。&lt;/em&gt;&lt;/strong&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ManifestFileVersion: 0
CRC: 4270654667
AssetBundleManifest:
AssetBundleInfos:
  Info_0:
    Name: cube
    Dependencies: {}
  Info_1:
    Name: scene
    Dependencies: {}
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;做了个小测试，添加了两个新的AssetBundle，名字也不一样，每次添加这个文件的内容跟着变，并且CRC也在变。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ManifestFileVersion: 0
CRC: 2591254959
AssetBundleManifest:
  AssetBundleInfos:
    Info_0:
      Name: cube
      Dependencies: {}
    Info_1:
      Name: scene
      Dependencies:
        Dependency_0: sphere
        Dependency_1: capsule
    Info_2:
      Name: sphere
      Dependencies: {}
    Info_3:
      Name: capsule
      Dependencies: {}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;继续小测试，把Capsule的AssetBundle从capsule改为sphere。果然只是简单记录了下目录中的AssetBundle信息。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ManifestFileVersion: 0
CRC: 3856405611
AssetBundleManifest:
  AssetBundleInfos:
    Info_0:
      Name: cube
      Dependencies: {}
    Info_1:
      Name: scene
      Dependencies:
        Dependency_0: sphere
    Info_2:
      Name: sphere
      Dependencies: {}
      
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;再次小测试，在UI的AssetBundle设定中第一栏设定了多层次的名称结果如下。而且从文件夹结构上看one和two都是两个文件夹，而在two里面则是一个名为xx.three的文件。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ManifestFileVersion: 0
CRC: 2167406161
AssetBundleManifest:
  AssetBundleInfos:
    Info_0:
      Name: scene
      Dependencies:
        Dependency_0: sphere
    Info_1:
      Name: sphere
      Dependencies: {}
    Info_2:
      Name: one/two/xx.three
      Dependencies: {} 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;shadershader-stripping&quot;&gt;shader剥离（Shader stripping）&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;如果AssetBundle中包含shader，unity编辑器会根据当前场景和光照贴图的设置来决定使用哪种Lightmap modes。这还意味着你在打包的时候需要将打开着一个配置的场景。我的理解是因为需要根据当前场景来作为因素来做某个事情，所以这个场景需要时打开的。&lt;/li&gt;
  &lt;li&gt;也可以指定一个场景用来计算光照贴图模式，这个在用命令行buildbundle时是必须的。
&lt;img src=&quot;https://docs.unity3d.com/550/Documentation/uploads/Main/AssetBundleShaderStripping.png&quot; alt=&quot;image&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-3&quot;&gt;引擎代码剥离&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;代码剥离这个事情是将没有在任何场景（特指Build Settings &amp;gt; Scene list中的场景）中使用的代码移除，减少了包的大小。不过只能用在iOS、Android和webGL。选择IL2CPP的是时候是默认打开的。而且顾名思义，只剥离引擎代码，你自己的代码不会被剥离。
&lt;img src=&quot;https://docs.unity3d.com/550/Documentation/uploads/Main/BuildingAssetBundles-enginecodestripping.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果一个引擎代码在build的时候被剥离了，但是在运行时又被请求使用，那么就会报错，因为被剥离的代码无法再被访问。如何避免这个错呢？把player（此处我认为不是玩家的意思，而是引擎）可能用到的AssetBundle列出来，放置到一个manifest文件中，代码剥离系统使用这个文件中列出来的AssetBundle (along with the Scenes in the build)来确定哪些code需要保留。当一些平台或build不支持代码剥离，又或者没有勾选剥离时assetBundleManifestPath属性是被忽略的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;从代码角度来看就是&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;using UnityEngine;

using UnityEditor;

namespace AssetBundles

{

    public class BuildScript

    {

        public static void BuildPlayer()

        {

            BuildPlayerOptions buildPlayerOptions = new BuildPlayerOptions();   

            // example hard-coded platform manifest path

            buildPlayerOptions.assetBundleManifestPath = &quot;AssetBundles/iOS/iOS.manifest&quot;;

            // build the Player ensuring engine code is included for 

            // AssetBundles in the manifest.

            BuildPipeline.BuildPlayer(buildPlayerOptions);

        }

    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-4&quot;&gt;几个小工具代码&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;列出所有在build process中产生的AssetBundle的名称&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;using UnityEditor;
using UnityEngine;

public class GetAssetBundleNames
{
    [MenuItem (&quot;Assets/Get AssetBundle names&quot;)]
    static void GetNames ()
    {
        var names = AssetDatabase.GetAllAssetBundleNames();
        foreach (var name in names)
            Debug.Log (&quot;AssetBundle: &quot; + name);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;一个asset发生改变时的监听，讲道理这个函数从说明到函数名都看着真么不协调。&lt;em&gt;从函数名看感觉是AssetBundle名字变化，但是说明又是AssetBundle中一个asset发生变化。&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;using UnityEngine;
using UnityEditor;

public class MyPostprocessor : AssetPostprocessor {

    void OnPostprocessAssetbundleNameChanged ( string path,
            string previous, string next) {
        Debug.Log(&quot;AB: &quot; + path + &quot; old: &quot; + previous + &quot; new: &quot; + next);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;assetbundle-3&quot;&gt;AssetBundle变体&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;这个玩意有什么意义呢？&lt;/li&gt;
  &lt;li&gt;下图中在后一个label中填入一个名字，就可以形成变体。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://docs.unity3d.com/550/Documentation/uploads/Main/AssetBundle50Editor.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;从文档上看可以同一批asset创建不同的变体，而且在这些变体AssetBundle中asset有意义的内部ID。需要注意这样的变体AssetBundle的全名是由AssetBundle name + the variant name组成的，如果你创建了一个名为MyAssets.hd的AssetBundle，那它只是一个普通的AssetBundle而不是变体的。而且 “MyAssets”+“hd”和“MyAssets.hd”+”“不能同时存在因为它们具有相同的全称。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-5&quot;&gt;脚本建议&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;妈蛋总算快完了。&lt;/li&gt;
  &lt;li&gt;呵呵，我不打算写了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;typetrees&quot;&gt;Typetrees&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;默认写到AssetBundle中，但是metro除外，因为不同的序列化方案。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-6&quot;&gt;一些实验&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;以熊作为测试，如果将bear文件夹下的所有asset打包，会出现明显的依赖。而且贴图的AssetBundle大小比prefab本身要大。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ManifestFileVersion: 0
CRC: 519453993
AssetBundleManifest:
  AssetBundleInfos:
    Info_0:
      Name: xiong.assetbundle
      Dependencies:
        Dependency_0: baixiong.assetbundle
        Dependency_1: baixiongyachi.assetbundle
        Dependency_2: xiong@run.assetbundle
        Dependency_3: xiong@stand.assetbundle
    Info_1:
      Name: baixiong.assetbundle
      Dependencies: {}
    Info_2:
      Name: baixiongyachi.assetbundle
      Dependencies: {}
    Info_3:
      Name: xiong@run.assetbundle
      Dependencies: {}
    Info_4:
      Name: xiong@stand.assetbundle
      Dependencies: {}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;如果只是打包xiong这个prefab，会产生一个100多K的xiaong的AssetBundle。可以正常使用。&lt;/li&gt;
  &lt;li&gt;但是如果做一个xiong2，其实就是xiong的复制体的话。会发现运行的时候avatar、mesh、shader等都是双份的。这个就是不把依赖单独打包的坏处了。&lt;/li&gt;
  &lt;li&gt;对于shader的双份问题可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;Editor-&amp;gt;Project Settings-&amp;gt;Graphics-&amp;gt;Always Included Shaders&lt;/code&gt;添加你用的shader，这样就不会出现了。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 14 Mar 2017 11:40:00 +0800</pubDate>
        <link>https://caihua.tech/2017/03/14/AssetBundle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1-%E6%A6%82%E8%BF%B0%E5%92%8C%E5%88%9B%E5%BB%BA/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/03/14/AssetBundle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1-%E6%A6%82%E8%BF%B0%E5%92%8C%E5%88%9B%E5%BB%BA/</guid>
        
        <category>AssetBundle学习笔记</category>
        
        
      </item>
    
      <item>
        <title>SendMessage测试</title>
        <description>&lt;ul&gt;
  &lt;li&gt;5.5.2中没有了以前那种参数是对象的SendMessage方法，WTF.&lt;/li&gt;
  &lt;li&gt;obj.SendMessage(“Foo”, 1, SendMessageOptions.DontRequireReceiver);如果设置了DontRequireReceiver，那么找不到Foo方法不会报错，如果没有写这个参数默认是RequireReceiver，则报错。&lt;/li&gt;
  &lt;li&gt;如果Foo的参数不对，会提示&lt;code class=&quot;highlighter-rouge&quot;&gt;MissingMethodException: The best match for method Foo has some invalid parameter.&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    public void Foo(string s)
    {
        Debug.Log(s);
    }

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;如果Foo是没有参数的，SendMessage有参数也没关系。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;总之最好指定的函数是存在的，参数是匹配的。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Wed, 08 Mar 2017 15:34:13 +0800</pubDate>
        <link>https://caihua.tech/2017/03/08/SendMessage%E6%B5%8B%E8%AF%95/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/03/08/SendMessage%E6%B5%8B%E8%AF%95/</guid>
        
        <category>Unity3D</category>
        
        
      </item>
    
      <item>
        <title>关于AssetBundle解压的讨论结果</title>
        <description>&lt;ul&gt;
  &lt;li&gt;一切的起源在于&lt;a href=&quot;《http://blog.uwa4d.com/archives/ABTheory.html》&quot;&gt;这篇文章&lt;/a&gt;，在文中对AssetBundle的加载进行了详细的描述，但是疑问也由此而生。以下是我在UWA讨论群的提问：
    &lt;blockquote&gt;
      &lt;p&gt;在讲WWW的时候有这样一段话【解压后的内容，通常为原Bundle文件的4~5倍大小，纹理资源比例可能更大】，在我理解就是www这样的方式获取到的资源（压缩形式的）会被解压缩，并放置到webstream中。而在【AssetBundle加载进阶】部分的【前者劣势】部分，又有【每次加载都涉及到解压操作】，请问这个【加载】指的是什么？是www.assetBundle还是AssetBundle.Load？还有【解压缩】是指的什么？不是在WWW的时候已经解压缩了吗？&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;张鑫大神是这样回答的
    &lt;blockquote&gt;
      &lt;p&gt;是这样的，我们所说的AssetBundle【加载】指的是New WWW（或其他加载AB的API）和www.assetbundle的统称，而真正的【解压】过程，是在New WWW进行的。同时，需要说明的是，这个是5.3版本之前Unity对于AssetBundle的处理方式，5.3版本后，由于Unity新增了LZ4压缩方式，所以如果AssetBundle在制作时已经是LZ4格式的，那么在加载时就已经不会在进行解压了。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;身为一个程序猿一定要弄清楚才行，所以有了另一个疑问
    &lt;blockquote&gt;
      &lt;p&gt;那么【每次加载都涉及到解压操作】是不是可以这样理解：对于new WWW实际是解压到webstream。而如果是用的LoadFromCacheOrDownload，那么资源是在磁盘的，所以在调用www.assetbundle时才做解压。或者正如你说的只要是加载AB的API，都会有一个解压过程。那么有个问题，如果使用直接获取AssetBundle的那些API，解压过程是怎样的呢？CreateFromFile是在调用assetbundle.load的时候从磁盘解压，CreateFromMemory是直接解压到webstream？还有个问题，对于WebStream来说，同一个www对象多次调用www.assetbundle方法时，得到了栈上的多个变量，但是这些变量都指向同一个WebStream中的对象吗？&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;其实在这里我犯了一个错误，就是对于资源最终放到磁盘上的AB来说在调用LoadFromCacheOrDownload和LoadFromFile（5.3之前是CreateFromFile）方法的过程中就已经解压缩了，LoadFromCacheOrDownload是上面文章中说明了我自己看漏了，但是LoadFromFile是有一个演进的过程的。
    &lt;blockquote&gt;
      &lt;p&gt;在5.3之前，如果需要解压，都在四个API（New WWW、CreateFromFile、LoadFromMemory、LoadFromCache等）中进行，而不是在后面执行&lt;/p&gt;

      &lt;p&gt;CreateFromFile在4.x的API，只能加载非压缩的AB，而在5.0以后，对应的是LoadFromFile，5.3之后可以加载任何压缩格式的AB了&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;至此可以总结一点就是&lt;strong&gt;&lt;em&gt;解压缩发生在New WWW、CreateFromFile、LoadFromMemory、LoadFromCache函数调用过程中&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;至于张鑫大神提到的LZ4不要解压缩这个事情，从&lt;a href=&quot;https://docs.unity3d.com/Manual/AssetBundleCompression.html&quot;&gt;文档&lt;/a&gt;上看LZ4还是需要解压缩的，只不过是基于块的，也就是说当你从LZ4文件中加载一个object的时候，只会解压缩这个object对应的压缩块，这个当然效率就高了很多。但是这句我甚是不解，如果一个LZ4文件压缩了一个很大的对象且只有这个对象，解压的时候难道不要时间？？在群里问完大神在来补充吧。
    &lt;blockquote&gt;
      &lt;p&gt;This occurs on-the-fly, meaning there are no wait times for the entire bundle to be decompressed before use.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;em&gt;第二天的更新&lt;/em&gt;：&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;看了文档也和群里讨论了一下，应该还是我理解上有误。所谓&lt;code class=&quot;highlighter-rouge&quot;&gt;5.3版本后，由于Unity新增了LZ4压缩方式，所以如果AssetBundle在制作时已经是LZ4格式的，那么在加载时就已经不会在进行解压了。&lt;/code&gt;的前提是在AB的基础上的，5.3以后的AB压缩格式3种：LZMA、LZ4和不压缩（Uncompressed Format，原文如此），LZMA是默认的AB压缩格式，unity在使用socket下载LZMA格式的文件时，一边下载，一边解压，并且一边压缩为LZ4。和大家讨论了下认为应该是考虑到传输的流量成本、节约内存和磁盘的空间，所以解压后再压缩为LZ4。一是因为LZMA压缩比高，适合传输，但是解压后会占用内容和磁盘空间比较大，而且是整体解压并且过程较慢，不适合用时在解压。所以解压后使用LZ4压缩一下节约空间，而且LZ4前面也说了是按需逐块解压的速度比较快，因此适合已经是内存中或者本地的解压。从这个角度说，如果直接AB压成LZ4就可以直接在需要的时候解压了，没有了解压再压缩的过程。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;最后还是要刷&lt;a href=&quot;https://unity3d.com/cn/learn/tutorials/topics/best-practices/guide-assetbundles-and-resources?playlist=30089&quot;&gt;这个&lt;/a&gt;才行。&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sun, 05 Mar 2017 23:15:13 +0800</pubDate>
        <link>https://caihua.tech/2017/03/05/%E5%85%B3%E4%BA%8EAssetBundle%E8%A7%A3%E5%8E%8B%E7%9A%84%E8%AE%A8%E8%AE%BA%E7%BB%93%E6%9E%9C/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/03/05/%E5%85%B3%E4%BA%8EAssetBundle%E8%A7%A3%E5%8E%8B%E7%9A%84%E8%AE%A8%E8%AE%BA%E7%BB%93%E6%9E%9C/</guid>
        
        <category>Unity3D</category>
        
        
      </item>
    
      <item>
        <title>游戏设计模式读书笔记：双缓冲</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;第三篇：序列模型&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;双缓冲模式算是书中第三篇：序列模型中的一个，它与游戏循环和更新方法组成了第三篇。后两者可以说是在我做Unity中最常用到的，而且也是游戏引擎本身已经实现了的。谨以&lt;a href=&quot;http://gpp.tkchu.me/sequencing-patterns.html&quot;&gt;下文&lt;/a&gt;来说明下序列模型部分的重要性。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;电子游戏之所有有趣，很大程度上归功于它们会将我们带到别的地方。 几分钟后（或者，诚实点，可能会更长），我们活在一个虚拟的世界。 创造那样的世界是游戏程序员至上的欢愉。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;大多数游戏世界都有的特性是时间——虚构世界以其特定的节奏运行。 作为世界的架构师，我们必须发明时间，制造推动游戏时间运作的齿轮。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;这本篇的模式是建构这些的工具。 游戏循环是时钟的中心轴。 对象通过更新方法来聆听时钟的滴答声。 我们可以用双缓冲模式存储快照来隐藏计算机的顺序执行，这样看起来世界可以进行同步更新。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section-1&quot;&gt;双缓冲&lt;/h2&gt;
&lt;h4 id=&quot;section-2&quot;&gt;一个典型的例子&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;这个例子非常经典，就是渲染时候的双缓冲。只有当一帧的色值数据完全计算出来后，才能在屏幕上展示出来，如果在计算的同时就开始渲染，那么屏幕只会出现一部分的色彩。所以我们在屏幕看到的色彩值其实往往是GPU算出的上一帧的数据。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-3&quot;&gt;使用场景&lt;/h4&gt;
&lt;blockquote&gt;
  &lt;p&gt;我们需要维护一些被逐步改变着的状态量。&lt;/p&gt;

  &lt;p&gt;同个状态可能会在其被修改的同时被访问到。&lt;/p&gt;

  &lt;p&gt;我们希望避免访问状态的代码能看到具体的工作过程。&lt;/p&gt;

  &lt;p&gt;我们希望能够读取状态但不希望等到写入操作的完成。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;section-4&quot;&gt;我对双缓冲的理解&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;说白了，双缓冲是为了维护完整性。它展示给外界的永远是一个完整的，已经准备好被使用的内容。在其内部，有一个缓冲是用于写入数据的，写入的过程可能是缓慢的，但是没关系，另一个缓冲已经做好了被使用的准备，外界读取的是这个已经写好的缓冲。&lt;/li&gt;
  &lt;li&gt;当写入完成时，两个缓冲互换，刚刚写完的这个缓冲变为准备被读取的一个，而被读取的缓冲开始作为写入缓冲使用。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-5&quot;&gt;设计决策&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;缓冲区如何交互？
    &lt;ul&gt;
      &lt;li&gt;在文中作者使用的是C++，因此交换只不过是一个指针重定向的过程。&lt;/li&gt;
      &lt;li&gt;如果不能指针重定向，就要考虑数据拷贝了。&lt;/li&gt;
      &lt;li&gt;C#中一个集合对象表现出来的也是一个指针（引用），可以直接做重定向。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;缓冲的粒度
    &lt;ul&gt;
      &lt;li&gt;书中提到两个粒度，一个是缓冲区是单个整体，也就是渲染的时候一个图像的内容就在一个缓冲区中。&lt;/li&gt;
      &lt;li&gt;另一种情况就是多个对象中都存在一个缓冲数据。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sat, 25 Feb 2017 16:43:13 +0800</pubDate>
        <link>https://caihua.tech/2017/02/25/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%8F%8C%E7%BC%93%E5%86%B2/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/02/25/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%8F%8C%E7%BC%93%E5%86%B2/</guid>
        
        <category>游戏设计模式读书笔记</category>
        
        
      </item>
    
  </channel>
</rss>
