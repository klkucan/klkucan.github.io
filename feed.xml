<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>蔡华的博客</title>
    <description>Be publicly useful and privately happy.</description>
    <link>https://caihua.tech/</link>
    <atom:link href="https://caihua.tech/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Fri, 10 Nov 2017 00:01:44 +0800</pubDate>
    <lastBuildDate>Fri, 10 Nov 2017 00:01:44 +0800</lastBuildDate>
    <generator>Jekyll v3.2.1</generator>
    
      <item>
        <title>每天一点UWA：动画重定向笔记</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;基本原理&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;动画重定向技术主要是针对骨骼动画的方案，由骨骼来描述动作信息，用蒙皮来表示模型网格与骨骼之间的关系，从而得到模型最终的样子。
&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2FAnimationRetargeting%2F2.png&quot; alt=&quot;image&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;PS：这张图很形象&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;动画就是每一帧为模型制作一个Pose（姿势），在每帧之间的姿势可以通过差值获得。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;最简单的情况：只有骨骼大小不一致的情况&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;此时因为骨骼在模型空间中具有一个对应的位置，因此以大人和小孩的骨骼为例，是没办法直接将大人的动画信息用在小孩的骨骼上的。&lt;/li&gt;
  &lt;li&gt;如何解决这个问题的呢？unity使用了一个参考姿势（通常情况下，会把T-Pose作为参考姿势）来计算不同大小骨骼之间的差值，然后应用到动画数据上。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;a1是A骨架的参考姿势，b1是B骨架的参考姿势，动画中某一帧的姿势是a2，我们想得到的结果是b2，我们认为，a2与参考姿势a1的差异应当和b2与其对应的参考姿势b1的差异相同，即：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;a2 - a1 = b2 - b1&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;我们可以得到计算过程为： b2 = a2 - a1 + b2 = a2 + (b1 - a1)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;参考姿势a1和b1都是提前得到的，因此可以进行预先计算好b1-a1的值。要知道这里的加法和减法要转换为每根骨骼的PRS计算，因此还是有不少CPU消耗的。下图给出了使用一个简单整数代替骨骼的PRS数据来模拟动画重定向的计算过程。
&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2FAnimationRetargeting%2F3.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;不同引擎的实现上可能不一样，文中提到了Havok的实现。&lt;/li&gt;
  &lt;li&gt;以上就解决了骨骼长度不一致的问题。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;真实的世界：骨骼名称、数量、父子关系不一致的情况&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;首先在如果项目中确定使用动画重定向，那么在模型制作时就需要约定好名称、数量和关系。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-3&quot;&gt;骨骼名称不一致&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;对于CS骨骼，由于在3DS Max中通常美术只会添加不同的前缀，因此可以通过去除前缀的方式进行模糊匹配来做骨骼映射；&lt;/li&gt;
  &lt;li&gt;Unity的做法细节不清楚，但是感觉会根据整个骨架的父子关系和结构来进行映射关系的计算；&lt;/li&gt;
  &lt;li&gt;而对于Bone骨骼，在没有预先定义好类似最大化骨骼这样规范的情况下，非常难通过程序来判断映射关系，可以提供可视化编辑的功能来让美术自己定义它们之间的映射关系。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-4&quot;&gt;骨骼数量不一致&lt;/h4&gt;

&lt;h5 id=&quot;cs&quot;&gt;在非CS骨骼或者不重要的部分存在多余的骨骼&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;如果动画文件的骨架中存在多余骨骼，通常的做法是把这些骨骼忽略掉，而如果目标骨架上存在多余的骨骼，即有些骨骼原始动画中并不存在，这其实没有办法为它生成动画，只需要保证其保留在原始姿势的local space当中，即让其跟着父骨骼移动。比如身上的飘带，如果原始动画中没有，在不使用布料系统等物理方案的情况下，只能让其按照参考姿势中的样子，“僵硬”地跟随角色移动。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-5&quot;&gt;在重要的位置存在骨骼不一致&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;多图，请直接看原文。解决的办法就是使用链式映射。&lt;/li&gt;
  &lt;li&gt;链式映射要做的就是将多根骨骼组成的骨链A和另外一个骨骼中多根骨骼组成的骨链B进行映射，做到整条B骨链的样子和A骨链的样子相近。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-6&quot;&gt;骨骼父子关系不一致&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;当两套骨骼的父子关系都不一致的情况下，其实很难得到正确的映射，简单的不一致可能可以容忍，但是可以想象，把一个人形骨骼的动画映射给四足动物甚至蜘蛛这样的八脚动物，是一件非常难做的事情。&lt;/li&gt;
  &lt;li&gt;也因为这样的原因，目前大范围应用的动画重定向，基本还是在人形骨骼上，当然，用相同的算法，把四足的战马动画映射到不同的体型的战马上也是可以的。基本的原则是骨架尽量具有更多的相似性，重定向的效果也就会更好。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;unity&quot;&gt;Unity中的重定向&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Unity引擎中动画重定向的实现不是一个直观的方法，而是封装在了Humanoid类型的动画系统里面，&lt;strong&gt;==也就是必须是人形的骨架、==使用Humanoid才可以使用它====&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;Unity没有像前文描述的基本原理那样去定义两套骨架之间的映射关系，而是自己在内部定义一套骨架模板，所有的Avatar骨骼都必须映射到这套模板上才可以由同一个Animator来驱动产生Retargeting之后的动画效果。&lt;/li&gt;
  &lt;li&gt;关于如何预览一个重定向之后的动画的效果，只能把模型放到Scene中，设置同一个Animator来观察。在动画文件的预览窗口，&lt;strong&gt;如果拖拽另外一个模型文件到其中，并不能预览到正确的效果。&lt;/strong&gt; PS：话说我以前都是这么干的。。&lt;/li&gt;
  &lt;li&gt;PS：具体操作过程参考原文或者unity文档吧，就是avatar设置那套流程。不过unity的avatar里面还能改变肌肉控制。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-7&quot;&gt;使用中的一些问题&lt;/h4&gt;
&lt;h5 id=&quot;humanoid&quot;&gt;角色的武器或者飘带在使用Humanoid类型的动画系统之后不会移动了，或者移动的位置有了很大的偏差。&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;这时候可以在动画文件的属性设置里，查看Mask下的Transform选项，里面可能存在没有被勾选的骨骼。目前的做法是把Transform下的所有骨骼对象都勾选上。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-8&quot;&gt;角色的武器在动作中出现了乱飘的情况，与手部无法紧密地绑定在一起&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;由于我们最初为了方便美术制作武器的动作，把其父骨骼设置给了盆骨这样一根相对稳定的骨骼，但是经过Retargeting计算之后，由于角色身材不同产生了一些偏差导致。最终我们还是把武器骨骼的父骨骼设置为手部的骨骼，才解决了这一问题。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-9&quot;&gt;某些角色在重定向之后的动画中表现为脚不贴地，和地面之间有缝隙，原始动画中没有&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;可能是重定向算法或者是参考姿势这两个因素导致&lt;/li&gt;
  &lt;li&gt;在avatar设置中，可以看看目标骨骼在T-POSS是否正常。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-10&quot;&gt;性能消耗&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;通过前面的原理分析可以看出，即使在有预计算的情况下，与普通的动画计算，Retargeting的过程还是有一定的CPU消耗的，但是这与通常会造成CPU瓶颈的蒙皮、渲染指令提交等相比，其实消耗并不算大。&lt;/li&gt;
  &lt;li&gt;Unity与Retargeting相关的还制作了肌肉控制的功能，Humanoid形式的动画系统相对于Generic形式的动画系统虽然有一部分额外的性能消耗，但是Unity内部做了比较好的优化，差别不是很大，因此可以放心使用。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-11&quot;&gt;补充&lt;/h2&gt;
&lt;h4 id=&quot;section-12&quot;&gt;一些概念&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;CAT和CS之前都是插件形式出现的&lt;/li&gt;
  &lt;li&gt;CS主要是用来创建两足动物的比如人类&lt;/li&gt;
  &lt;li&gt;CAT不但可以创建两足动物还能创建多足动物，这就是CAT相对于CS最大的优势了。&lt;/li&gt;
  &lt;li&gt;bones是3DMAX原始的骨骼系统，这个骨骼你需要自己手动创建才行，而CAT和CS可以自动生成&lt;/li&gt;
  &lt;li&gt;skin是蒙皮系统，就是用骨骼对模型进行蒙皮后模型和骨骼产生关联，这样模型就能跟着骨骼一起运动了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-13&quot;&gt;原文&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;https://blog.uwa4d.com/archives/AnimationRetargeting.html&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 08 Nov 2017 09:51:58 +0800</pubDate>
        <link>https://caihua.tech/2017/11/08/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E5%8A%A8%E7%94%BB%E9%87%8D%E5%AE%9A%E5%90%91%E7%AC%94%E8%AE%B0/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/11/08/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E5%8A%A8%E7%94%BB%E9%87%8D%E5%AE%9A%E5%90%91%E7%AC%94%E8%AE%B0/</guid>
        
        <category>UWA</category>
        
        
      </item>
    
      <item>
        <title>每天一点UWA：第十四周</title>
        <description>&lt;h2 id=&quot;assetbundle&quot;&gt;AssetBundle&lt;/h2&gt;
&lt;h4 id=&quot;assetbundleassetbundle&quot;&gt;AssetBundle划分过细的问题，比如每个资源都是AssetBundle。&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;加载IO次数过多，从而增大了硬件设备耗能和发热的压力；&lt;/li&gt;
  &lt;li&gt;Unity 5.3 ~ 5.5 版本中，Android平台上在不Unload的情况下，每个AssetBundle的加载，其每个文件的SerializedFile内存占用均为512KB（远高于其他平台），所以当内存中贮存了大量AssetBundle时，其SerializedFile的内存占用将会非常巨大。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;buildassetbundleoptionsdisablewritetypetree&quot;&gt;BuildAssetBundleOptions.DisableWriteTypeTree这个选项的实际用处是什么？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;在Unity 5.x版本中，AssetBundle在制作时会默认写入TypeTree信息，这样做的好处是可以保证AssetBundle文件的向下兼容性，即高版本可以支持以前低版本制作的AssetBundle文件。&lt;/li&gt;
  &lt;li&gt;所以，如果开启DisableWriteTypeTree选项，则可能造成AssetBundle对Unity版本的兼容问题，虽然关闭TypeTree会使Bundle更小，但我们一般都不建议研发团队在制作AssetBundle文件时开启该选项。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;assetbundlecscriptpublicassetbundlescriptassetbundlecsmd5&quot;&gt;我们项目做AssetBundle打包时，发现如果资源所依赖的C#Script的Public成员变量有变化时，用新代码加载旧的AssetBundle就会不兼容。有没有什么方法能判断这些Script在变化时是否需要重新打AssetBundle呢？目前我们使用.CS文件的MD5来判断是否需要重新打包，但其实这样应该有很多不必要的重复打包，对吗？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;该问题的本质原因是新代码的序列化信息变化所致。建议研发团队使用Unity 5的新的AssetBundle打包方式，默认情况下，Unity 5引擎会自动检测其脚本的序列化信息是否进行改变，从而自动进行增量打包。&lt;/li&gt;
  &lt;li&gt;PS: 虽然已经可以通过升级来解决，但是这个是个需要关注的点。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;assetbundle-1&quot;&gt;AssetBundle颗粒度问题&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;详见https://blog.uwa4d.com/archives/TechSharing_59.html 第一个问题&lt;/li&gt;
  &lt;li&gt;总结一下：
    &lt;ul&gt;
      &lt;li&gt;不要一个资源一个AssetBundle，因为Android上面一个serializedFile有512k,但是5.6后应该是32k。不过实际测试的情况是不一定是32K。WTF。。&lt;/li&gt;
      &lt;li&gt;对于AssetBundle小于1MB的限制在5.4后没意义，之前是因为www走webstream，会导致内存中占用AssetBundle大小4-5倍的空间。但是LZ4后基于其Chunk的加载特点，AB加载很快，且内存占用要比之前小很多。&lt;/li&gt;
      &lt;li&gt;仍旧需要注意的：&lt;/li&gt;
      &lt;li&gt;对于需要热更新的AB，也如问答中其他朋友的所言，要考虑实际情况控制AB的大小；- PS:可能是考虑网络下载的问题，以为过大的文件如果不做断点续传会是恶梦。&lt;/li&gt;
      &lt;li&gt;即便是LZ4的AB，其加载方式不同，加载效率也可能完全不一致。&lt;/li&gt;
      &lt;li&gt;对于AB的打包，尽可能把逻辑上同时出现（一个Prefab中非Share的Asset）、小而细碎的资源（Shader、Material、粒子系统等）尽可能打包在一起，并通过LoadAll来进行加载，因为这样会带来更好的加载效率。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;loadfromcacheordownloadversion&quot;&gt;使用LoadFromCacheOrDownload时如果用version参数，缓存的资源如何清除。&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;AssetBundle，其Version版本号变化时，新的解压Data是不会覆盖旧的解压Data的。清除旧的解压Data主要有三种方式：
    &lt;ul&gt;
      &lt;li&gt;设置缓存的过期日期，默认情况下是150天；&lt;/li&gt;
      &lt;li&gt;调用Caching.CleanCache来全部清空缓存；&lt;/li&gt;
      &lt;li&gt;当本地Cache已满时，Unity会从最早的AssetBundle来进行自动清理。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;wwwloadfromcacheordownloadsystemstring-url-int32-versionunity-4x500unityunity-5x-&quot;&gt;WWW.LoadFromCacheOrDownload(System.String url, Int32 version)这个接口加载资源，如果是Unity 4.x的版本，会有500个资源的数量限制，如果超过这个限制，Unity会删除之前缓存的每个资源，是这样吗？那在Unity 5.x 版本上是否还存在这样的问题呢？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;在Unity 4.x的版本中，如果通过LoadFromCacheOrDownload来加载AssetBundle，那么有两种情况需要考虑：
  -内存中加载的AssetBundle数量。在iOS平台上，通过该接口加载、同时存在于内存中的AssetBundle数量确实是有限的，接近300个，这是由于iOS上文件句柄数的限制导致。而该限制在Unity 5.0以后则被完善了，因为Unity 5引入了虚拟文件系统，所以不再有这个限制；在Android平台上，则没有这个限制，或者说数量限制值非常大，基本可以忽略。
    &lt;ul&gt;
      &lt;li&gt;本地Cache中缓存的AsseBundle数量。无论是iOS、Android还是PC版本，都没有500的数量限制，而是有一个硬盘占用大小限制。具体来说，在WebPlayer平台上，有50MB的缓存限制，而在其他平台上，则是4GB的缓存限制。所以只要硬盘占用大小不超过限定值即可。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;font&quot;&gt;Font&lt;/h2&gt;
&lt;h4 id=&quot;unity-534p6uguiatexttextdisableloada-managedstaticrefrences-font-textdisableafont&quot;&gt;我们在内存优化时发现一个问题，编辑器版本 Unity 5.3.4p6，使用UGUI，场景A中一个Text控件使用自定义字体资源，然后把该控件Text属性勾选为空（disable），再Load一个空场景，看场景A卸载后在内存中的残留，发现有一份引用是 ManagedStaticRefrences（）的 Font 内存。如果不是把Text属性disable，则场景A卸载后内存里不会再残留被引用的Font内存，请问可能是什么原因造成的呢？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;UWA对于该例子进行了检测，的确能够在 Editor 复现。查了下 UGUI 代码，能对 Font 产生引用的，主要是这个函数 FontUpdateTracker.TrackText(Text)，其中会把 t.font 引用起来；而对应的解引用的函数为 FontUpdateTracker.UntrackText。因此，如果出现了两者的调用不匹配，就有可能造成 font 的 ManagedStaticRefrences 引用。&lt;/li&gt;
  &lt;li&gt;进一步查看后，可以看到在定义了 UNITY_EDITOR 宏时，UI 元素会增加一个名为 OnValidate 的函数，Text 组件则在其中进行了 TrackText 的操作。
而最关键的是，该函数在 Text 组件以“未激活”的状态被实例化时同样会被触发，同时，如果这样的 Text 组件在后续没有被激活过就被销毁，其 OnDestroy 和 OnDisable 函数是不会被调用的，参见文档中的这句话：OnDestroy will only be called on game objects that have previously been active.
而 OnDisable 中才会调用 Untrack 解引用，所以造成了不匹配，导致了 font 的 ManagedStaticRefrences。&lt;/li&gt;
  &lt;li&gt;但是，OnValidate 函数只在 Editor 上才有，真机上不会发生上面说到的不匹配的情况。所以建议研发团队先在真机上测试下是否还有这种情况，如果确实没有，那么就忽略该问题即可。&lt;/li&gt;
  &lt;li&gt;PS:Mark&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;gameplay&quot;&gt;Gameplay&lt;/h2&gt;
&lt;h4 id=&quot;mask&quot;&gt;我想了解如何使用顶点色Mask控制明暗关系，才能达到类似崩坏琪亚娜效果？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;https://blog.uwa4d.com/archives/TechSharing_60.html 第五个问题，NB&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ui&quot;&gt;UI&lt;/h2&gt;
&lt;h4 id=&quot;nguihud600panel2drawcall&quot;&gt;我们游戏中用到NGUI的HUD，单位主要是一个进度条和一个倒计时文本(持续更新)，同屏数量达600左右，单位本身在持续移动。现已将这些设置为独立Panel，且只有2个DrawCall(进度条所在图集和文本)，但还是卡顿得很厉害，请问是否有优化的方法？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;简化元素的几何：进度条中的元素尽量避免Sliced 模式（改Simple）；倒计时部分如果使用了Outline或者Shadow，将其转为“图片字”；&lt;/li&gt;
  &lt;li&gt;降低更新频率：如倒计时按“秒”统一更新；进度条按1%甚至5%的间隔更新一次；移动速度较慢时可以尝试隔帧更新位置等；&lt;/li&gt;
  &lt;li&gt;拆分子UIPanel：尽可能将更新频率相同的UI元素放在一个UIPanel中，从而降低每次更新时涉及到的UI元素数量。具体的拆分数量，则可能要通过较多的测试来确定。需要说明的是，此处即使增加10到20个DrawCall，对渲染上的影响并不大。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;粒子&lt;/h2&gt;
&lt;h4 id=&quot;prefab100-200gameobjectgameobjectprefab&quot;&gt;我们项目中有大量的特效，一个特效Prefab可能包含100-200个GameObject，每个GameObject上都挂有一个粒子系统，但是实际上很多特效只有延时和坐标旋转之类的参数的区别。我看了Prefab文件后发现每个粒子系统分别记录了各自的信息，从而导致整体文件很大，内存占用也比较大。请问是否有优化的方法？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;如果开发的是一个手游项目，那么一个Prefab下含有100-200个粒子系统是非常不足取的，主要会造成以下几种问题：
    &lt;ul&gt;
      &lt;li&gt;同时播放100个以上的ParticleSystem，其ParticleSystem.Update本身的CPU占用会很高。下图为一款游戏在华为6Plus上的表现。可以看到Active Particle数量还没有达到100，其Update耗时就已经占到了5ms；&lt;/li&gt;
      &lt;li&gt;ParticleSystem.ScheduleGeometryJobs开销会很高。其耗时主要体现在渲染模块中的Culling阶段，与粒子系统的数量相关，场景中Active粒子系统的数量越多，其开销越高；&lt;/li&gt;
      &lt;li&gt;子线程中的渲染压力较大。Unity5.3版本以后，粒子系统的渲染虽然在主线程中占用很小，但并不意味它没有耗时，其耗时在渲染线程中，当渲染线程压力过大时，主线程同样会出现等待（Gfx.WaitForPresent），因此同样可能对帧率产生影响；&lt;/li&gt;
      &lt;li&gt;GPU的渲染压力较高。同屏中渲染的粒子系统越多，其屏幕每帧的填充率越高，从而更加容易造成设备的发热；&lt;/li&gt;
      &lt;li&gt;内存压力较高。如果一个Prefab上有100-200个粒子系统，并且如果场景中有10个以上这样的Prefab存在，那么其内存占用将在10~25MB内存区间内。就目前而言，粒子系统仍然是以Clone的形式存在，所以虽然粒子系统可能仅仅是某些参数不同，但其仍然是多个不同的粒子系统。因此，我们在UWA报告中会显示粒子系统在项目运行时的具体显示数量，以方便研发团队对粒子系统进行关注。如下图所示，一般来说，每帧中粒子系统的数量建议在400以下。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;模型&amp;amp;动画&lt;/h2&gt;
&lt;h4 id=&quot;fbxreadwrite-staticbatchingutilitycombinemesh&quot;&gt;网格模型FBX文件在不开启Read/Write选项时， 如果通过StaticBatchingUtility的CombineMesh来合批的话，内存会增加么？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;增加内存，主要表现在内存中CombinedMesh的增加以及一定量堆内存的增加。&lt;/li&gt;
  &lt;li&gt;该API使用的前提必须是网格Fbx模型开启Read/Write，如果不开启，则无法读到网格数据，进而不能完成网格的拼合操作。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-2&quot;&gt;如下图，请问这几个参数的单位是什么？&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog/TechSharing_58/2.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Rotation Error使用角度（degree）作为单位。Position和Scale是距离偏差的百分比（曲线调节前后的距离偏差与某距离值之比，取决于Unity内部实现），取值范围1~100，但实际可以高于100，并有作用。
我们建议研发团队在调节该误差时，将调节前后的动画效果进行对比，使文件体积压缩得尽量小，同时使动画效果在视觉上偏差不会太大。&lt;/li&gt;
  &lt;li&gt;PS:没找到，可能是动画导入的选项。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;resamplecurves&quot;&gt;如下图，这个ResampleCurves选项的作用，以及是否和对内存性能的影响？&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog/TechSharing_58/1.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;ResampleCurves选项是在Unity 5.3版本后加入的，在之前的版本中是隐藏并且默认勾选的。该选项会改变Unity动画数据的存储方式。&lt;/li&gt;
  &lt;li&gt;动画文件在导入到Unity之前，其关键帧的数据通常是以欧拉角（Euler format）的方式存储。在勾选该选项时导入，Unity会将欧拉角转换为四元数（Quaternion）表示，并且会生成逐帧的数据（不只是关键帧）。新生成的逐帧数据是为了解决四元数插值问题。关闭该选项会使动画文件保持欧拉角表示，但在应用于GameObject时仍会转换为四元数。&lt;/li&gt;
  &lt;li&gt;建议保持默认勾选该选项，只有当发现Unity中的动画播放效果与在动画编辑工具中的效果出现较大偏差时，尝试取消该选项，查看是否是该选项的原因导致动画偏差。我们在测试中发现该选项对运行性能影响并不明显。在内存方面，勾选该选项会使动画文件略微增加。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;scale&quot;&gt;动画提出scale&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;参见https://blog.uwa4d.com/archives/TechSharing_58.html第五个。&lt;/li&gt;
  &lt;li&gt;PS:很不错。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;animatorsprocessanimationsjobanimatorswritejobcpu&quot;&gt;动画模块中，Animators.ProcessAnimationsJob和Animators.WriteJob的CPU占用较高，这些与什么因素有关？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Animators.WriteJob受模型骨骼数目影响较大（受animation curves影响不明显），骨骼数目越多，该函数耗时越大。同时，开启Optimize GameObject选项能够降低该函数耗时。Animators.ProcessAnimationsJob 同样受骨骼数目影响较大，同时也受animation curves数目影响，二者数目越多，该函数耗时越大。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-3&quot;&gt;性能综合&lt;/h2&gt;
&lt;h4 id=&quot;cpugpugpuprofiler&quot;&gt;在整体的性能消耗上，CPU和GPU各占一半合理吗？如果不是，各占多少为好？还是说需要根据机型来看？其次，我如何知道游戏在手机上的GPU消耗？Profiler是看不到的，有工具推荐吗？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;首先，CPU和GPU是并行的，也就是CPU在运算的时候GPU也在运算，一帧的结束时间是两者中比较晚结束的那个。因此，一般我们在考虑这个问题的时候，经常会说是CPU bound还是GPU bound，也就是GPU在等CPU还是CPU在等GPU。&lt;/li&gt;
  &lt;li&gt;最理想的情况是两者都并行均衡，且都没有出现互相等待的情况。但在目前的大多数移动游戏中，都是CPU耗时为主要性能瓶颈。这也是为什么有多线程渲染的原因，多线程渲染就是利用CPU端的并行性，让CPU处理得更快，不拖后腿。&lt;/li&gt;
  &lt;li&gt;对于GPU的压力分析，可以尝试用Intel GPA，Mali或者高通出的针对自家芯片的工具。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;unityprefabgc-allocated&quot;&gt;为什么Unity里实例化一个Prefab会产生那么多GC Allocated?&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;这是一个特例，但是从里面可以总结出一个问题，就是在Instantiate一个对象时会发生或者&lt;strong&gt;可能发生&lt;/strong&gt;以下的事情
    &lt;ul&gt;
      &lt;li&gt;序列化和反序列化的处理，因为用prefab生成对象本身就是需要反序列化的。而直接clone一个对象可能还有先序列化在反序列化。&lt;/li&gt;
      &lt;li&gt;可能的资源的加载，比如prefab上用到的mesh、贴图等。&lt;/li&gt;
      &lt;li&gt;可能的shader编译，如果用了一个之前没有用过的shader就会实时的编译。&lt;/li&gt;
      &lt;li&gt;对象身上脚本的初始化。如果实例化一个prefab发现很占用时间要注意是不是脚本里面在awake或者start里面的功能太多了。&lt;/li&gt;
      &lt;li&gt;UI界面的Active和Deactive也会造成UI代码底层的一些相关OnEnable和OnDisable操作，同样会造成一定的堆内存分配。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-4&quot;&gt;渲染&lt;/h2&gt;
&lt;h4 id=&quot;unityskip&quot;&gt;Unity的材质的宏是有材质用到时才会被编译吗？还是说不手动Skip都会编译？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;在Unity中shader variant也包含两种类型，一种是通过 shader_feature 定义，一种是通过 multi_compile 定义。而只有通过 shader_feature 定义的 variant 在发布时会根据其使用情况来进行剥离。&lt;/li&gt;
  &lt;li&gt;具体可见Unity官方的文档：https://docs.unity3d.com/Manual/SL-MultipleProgramVariants.html&lt;/li&gt;
  &lt;li&gt;需要注意的是，放在Always Included Shaders中的Shader，其包含的所有 variant 都不会被剥离，因此对于Standard Shader这类包含了大量 shader_feature的Shader，不推荐将其放入。&lt;/li&gt;
  &lt;li&gt;PS:没有回答根本的问题：
    &lt;ul&gt;
      &lt;li&gt;Editor中：修改shader并保存时立即编译。
  Runtime下，无论哪个平台，都是在进入场景时加载shader object内容到内存，但是首次实际调用渲染时才编译，编译完成之后会cache下来。
  有两种优化方法：
  调用Shader.WarmupAllShaders()，自动编译该场景中用到的所有shader。该方法在Unity5中已经废弃。
  在项目设置的GraphicsSettings中，可以导出ShaderVariantCollection，并在Preloaded Shader中导入，这样的话就可以在载入场景时一并编译需要预加载的shader，这样的优化在移动平台上用得比较多。
  具体见&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;cpugfxwaitforpresent&quot;&gt;听说移动端开启多线程，把后期效果移动到渲染线程会节省后期的消耗。我测试了一下，虽然主线程中后期显示的CPU占用降低了，但是却多了Gfx.WaitForPresent的时间，最后两者相加基本还是一样的。那开启多线程这个功能，对后期到底有没有帮助呢？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;开启多线程渲染一般情况下会极大降低主线程的渲染耗时，但并不会降低其本身的总体计算量。因为这并不是底层算法或硬件上的提升，而是将部分计算从主线程搬到了子线程。所以，开启多线程的好处在于为主线程带来了大量空间来执行其他耗时模块（如代码逻辑等）。&lt;/li&gt;
  &lt;li&gt;但这并不意味着开启多线程渲染就“万事大吉”。如果渲染模块本身开销就很高，那么子线程一样会很耗时，更有可能出现主线程等待子线程的现象，也就是WaitForPresent开销较高的情况。所以，开启多线程是会降低主线程的渲染压力，但其帧率未必会大幅提升，还需研发团队自行在自己项目中进行尝试和比较。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 05 Nov 2017 10:07:00 +0800</pubDate>
        <link>https://caihua.tech/2017/11/05/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E5%8D%81%E5%9B%9B%E5%91%A8/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/11/05/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E5%8D%81%E5%9B%9B%E5%91%A8/</guid>
        
        <category>UWA</category>
        
        
      </item>
    
      <item>
        <title>浅析Timeline结构</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;结构&lt;/h2&gt;

&lt;table&gt;
   &lt;tr&gt;
      &lt;td&gt;PlayableDirector&lt;/td&gt;
      &lt;td colspan=&quot;6&quot; align=&quot;center&quot;&gt;Timeline&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td&gt;PlayableGraph&lt;/td&gt;
      &lt;td colspan=&quot;6&quot; align=&quot;center&quot;&gt;Graph&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td&gt;…&lt;/td&gt;
      &lt;td colspan=&quot;4&quot; align=&quot;center&quot;&gt;TrackGroup&lt;/td&gt;
      &lt;td&gt;TrackGroup&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td&gt;TrackAsset&lt;/td&gt;
      &lt;td&gt;AnimationTrack&lt;/td&gt;
      &lt;td&gt;PlayableTrack&lt;/td&gt;
      &lt;td&gt;CinemachineTrack&lt;/td&gt;
      &lt;td&gt;CustomTrack&lt;/td&gt;
      &lt;td&gt;…&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td&gt;…&lt;/td&gt;
      &lt;td&gt;TimelineClips&lt;/td&gt;
      &lt;td&gt;TimelineClips&lt;/td&gt;
      &lt;td&gt;TimelineClips&lt;/td&gt;
      &lt;td&gt;TimelineClips&lt;/td&gt;
      &lt;td&gt;…&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td&gt;PlayableAsset&lt;/td&gt;
      &lt;td&gt;AnimationClip (Motion)&lt;/td&gt;
      &lt;td&gt;CustomPlayableAsset&lt;/td&gt;
      &lt;td&gt;CinemachineShot&lt;/td&gt;
      &lt;td&gt;CustomClip&lt;/td&gt;
      &lt;td&gt;…&lt;/td&gt;
   &lt;/tr&gt;
   &lt;tr&gt;
      &lt;td&gt;PlayableBehaviour&lt;/td&gt;
      &lt;td&gt;PlayableBehaviour&lt;/td&gt;
      &lt;td&gt;PlayableBehaviour&lt;/td&gt;
      &lt;td&gt;CinemachineShotPlayable&lt;/td&gt;
      &lt;td&gt;PlayableBehaviour&lt;/td&gt;
      &lt;td&gt;…&lt;/td&gt;
   &lt;/tr&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;从表中可以看出是一个树结构，在Timeline Editor中也是一目了然。核心的类就是最左边一列中列出的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;组件&lt;/h2&gt;
&lt;h3 id=&quot;timeline&quot;&gt;Timeline&lt;/h3&gt;
&lt;h5 id=&quot;timeline--playabledirector&quot;&gt;Timeline &amp;amp; PlayableDirector的关系&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;本质是个PlayableDirector，作用顾名思义。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;playablegraph--playabledirector&quot;&gt;PlayableGraph &amp;amp; PlayableDirector的关系&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;从测试情况看，一个PlayableDirector对应一个PlayableGraph&lt;/li&gt;
  &lt;li&gt;通过&lt;code class=&quot;highlighter-rouge&quot;&gt;PlayableDirector pd = graph.GetResolver() as PlayableDirector;&lt;/code&gt;可以反向得到PlayableDirector，在PlayableAsset中可能会比较有用。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;trackasset&quot;&gt;TrackAsset&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;TrackAsset从视觉上看就是Timeline Editor中左边preview中的一项，每个track可以约束它所影响的 GameObject的类型，也可以设置它上面clip的类型。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;从实际的操作上来看，PlayableTrack上可以放置任何继承自PlayableAsset的clip，但是其它的track上就必须放置约定类型的clip了。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;track&quot;&gt;如何自定义一个Track&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[TrackColor(1f, 1f, 0f)]
[TrackClipType(typeof(LightControlClip))]
[TrackBindingType(typeof(Light))]
public class LightControlTrack : TrackAsset {}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;从上面的代码看TrackBindingType定义了绑定的类型，TrackClipType定义了clip的类型。而TrackColor是定义了在Timeline Editor中最左边的那条很细的彩色线条。&lt;/li&gt;
  &lt;li&gt;经过测试，在自定义的TrackAsset中可以不实现CreateTrackMixer方法，但是如果要去override它，代码中不能用&lt;code class=&quot;highlighter-rouge&quot;&gt;return Playable.Create(graph);&lt;/code&gt;,而是用&lt;code class=&quot;highlighter-rouge&quot;&gt;return ScriptPlayable&amp;lt;CustomMixer&amp;gt;.Create(graph, inputCount);&lt;/code&gt;哪怕这个CustomMixer是个空类都可以，很坑爹。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;playableassetclip&quot;&gt;PlayableAsset（Clip）&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;要说PlayableAsset就离不开PlayableBehaviour。在旧版本的Timeline中BasePlayableBehaviour实现了PlayableAsset和PlayableBehaviour的功能。但是因为已经被舍弃了，因此想实现既可以放到track上，又能监控状态的对象需要用PlayableAsset配合PlayableBehaviour。做法为在自定义的PlayableAsset中写：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public override Playable CreatePlayable(PlayableGraph graph, GameObject go)
{
    return ScriptPlayable&amp;lt;CustomBehaviour&amp;gt;.Create(graph, template);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;playablebehaviour&quot;&gt;PlayableBehaviour&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;核心类，其定义了事件函数涵盖了自身的状态变化、graph的状态变化和PlayableDirector创建销毁时触发的事件。&lt;/li&gt;
  &lt;li&gt;PrepareFrame函数可以在每一帧对timeline中的元素进行访问和设置。可以说是在做自定义blend中不可缺失的功能。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;执行顺序&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;目前来看应该是：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;CreateTrackMixer-&amp;gt;CreatePlayable-&amp;gt;OnPlayableCreate-&amp;gt;OnGraphStart-&amp;gt;OnBehaviourPause-&amp;gt;OnBehaviourPlay-&amp;gt;OnGraphStop-&amp;gt;OnPlayableDestroy&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;这个顺序是一个clip的。当一个track上有多个clip时OnPlayableCreate、OnGraphStart、OnBehaviourPause会无序的出现，但是一定是在OnBehaviourPlay之前。&lt;/li&gt;
  &lt;li&gt;在真正的clip的执行期间，OnBehaviourPlay和OnBehaviourPause是按顺序执行的。&lt;/li&gt;
  &lt;li&gt;基本上可以判断当一个PlayableBehaviour准备好后，会先被pause。然后按照设计好的顺序执行，当开始执行时触发play，结束后再次触发pause。所以如果是要在一个clip结束后处理什么事情需要做一个判断，是否是第一次触发pause。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-3&quot;&gt;组件之间互相获取的方法&lt;/h2&gt;
&lt;h5 id=&quot;timelineplayabledirector&quot;&gt;Timeline(PlayableDirector)的获取方式&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;通过脚本中设置PlayableDirector类型变量获得。&lt;/li&gt;
  &lt;li&gt;如果是自定义的TrackAsset，则通过CreateTrackMixer方法的go参数获得。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public override Playable CreateTrackMixer(PlayableGraph graph, GameObject go, int inputCount)
{
    PlayableDirector playableDirector = go.GetComponent&amp;lt;PlayableDirector&amp;gt;();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;如果是自定义的PlayableAsset，则通过&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public override Playable CreatePlayable(PlayableGraph graph, GameObject go)
{
    var pd = graph.GetResolver() as PlayableDirector;
}        
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;PlayableBehaviour脚本中函数都是有playable参数，通过这个参数也可以获得&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public override void OnBehaviourPlay(Playable playable, FrameData info)
{
    PlayableDirector pd = playable.GetGraph&amp;lt;Playable&amp;gt;().GetResolver() as PlayableDirector;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h5 id=&quot;timelinetrackclipplayerbehaviour&quot;&gt;Timeline中获取track、clip和PlayerBehaviour&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;从上面的代码可以看到，获取director的过程比较符合最上面的那个表里的层级关系。但是从timeline获取其它的元素会比较困难。或者说比较不符合这个层级关系。我个人认为在API的设计上是有问题的。&lt;/li&gt;
  &lt;li&gt;那么要如何通过timeline获取这些元素呢？&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public PlayableDirector pd;
// Use this for initialization
void Start()
{
    var binding = pd.playableAsset.outputs;
    foreach (var item in binding)
    {
        switch (item.sourceObject.GetType().Name)
        {
            case &quot;AnimationTrack&quot;:
                {
                    var at = item.sourceObject as AnimationTrack;
                    foreach (TimelineClip clip in at.GetClips())
                    {
                        Debug.Log(clip.animationClip.name + &quot;\n&quot;);
                    }
                }
                break;
            case &quot;CinemachineTrack&quot;:
                var item2 = item.sourceObject as CinemachineTrack;
                foreach (TimelineClip clip in item2.GetClips())
                {
                    CinemachineShot cs = clip.asset as CinemachineShot;
                    Debug.Log(cs.VirtualCamera.Resolve(pd) + &quot;\n&quot;);
                }
                break;
            case &quot;PlayableTrack&quot;:
                var pt = item.sourceObject as PlayableTrack;
                foreach (TimelineClip clip in pt.GetClips())
                {
                    NewPlayableAsset cs = clip.asset as NewPlayableAsset;
                }
                break;
            case &quot;CustomTrack&quot;:
                var ct = item.sourceObject as CustomTrack;
                foreach (TimelineClip clip in ct.GetClips())
                {
                    CustomClip cs = clip.asset as CustomClip;
                    CustomBehaviour cb = cs.template;
                    cb.Foo();
                }
                break;
            default:
                break;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;从代码上看&lt;code class=&quot;highlighter-rouge&quot;&gt;pd.playableAsset.outputs&lt;/code&gt;获得了一个&lt;code class=&quot;highlighter-rouge&quot;&gt;IEnumerable&amp;lt;PlayableBinding&amp;gt;&lt;/code&gt;类型的集合。这个设计让人非常费解。然后遍历集合，得到&lt;code class=&quot;highlighter-rouge&quot;&gt;item.sourceObject&lt;/code&gt;，这个对象就是track了。然后可以根据不同的类型转换成不同的Track。然后就和表中的结构一致了，获得clip-&amp;gt;playableasset-&amp;gt;playablebehaviour。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-4&quot;&gt;获得场景对象&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;Timeline中获取对象在API设计上也不合理，在unity的通用做法是在代码中定义一个Public变量或者使用[SerializeField]标记一个private的变量，然后拖拽。又或者用过GameObject.Find来获取。但是对于策划和美术来说最多的还是拖拽。&lt;/li&gt;
  &lt;li&gt;Timeline相关的脚本中可以继续使用GameObject.Find。但是如果你想用拖拽的形式需要这样定义对象：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public ExposedReference&amp;lt;T&amp;gt; object;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;而当你想真正使用这个变量的值的时候需要用&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;object.Resolve (graph.GetResolver());
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;需要说明的是在Timeline的那些脚本类里面是可以用public定义变量的，在inspector面板上也可以显示出来，但是退拽无效。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;track-1&quot;&gt;获取Track绑定的对象&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;目前来看似乎只有用GameObject.Fine或者直接用属性值了。&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Thu, 02 Nov 2017 19:59:13 +0800</pubDate>
        <link>https://caihua.tech/2017/11/02/%E6%B5%85%E6%9E%90Timeline%E7%BB%93%E6%9E%84/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/11/02/%E6%B5%85%E6%9E%90Timeline%E7%BB%93%E6%9E%84/</guid>
        
        <category>Unity3D</category>
        
        
      </item>
    
      <item>
        <title>每天一点UWA：第十三周</title>
        <description>&lt;h2 id=&quot;gameplay&quot;&gt;Gameplay&lt;/h2&gt;
&lt;h4 id=&quot;layer&quot;&gt;求教一个屏幕后处理的问题。我们期望角色不受屏幕后处理影响，所以目前采用双相机的方案，根据Layer划分，但是这种情况下角色的影子也就没有办法投影到地表上，请问这种需求有什么好的实现方式？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;可以尝试根据地表模型的局部细节来动态生成接受阴影的网格（比如Fast Shadow Receiver插件），这样既可以保证地表模型进行屏幕后处理操作，同时也可以生成相关角色的动态阴影。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;texture&quot;&gt;Texture&lt;/h2&gt;
&lt;h4 id=&quot;uguiresource-resourcedrawcall&quot;&gt;UGUI用Resource来动态加载图片，有什么好的方法? 我的理解是：Resource目录下的图片都不能被打包成图集，而且会增加DrawCall和包大小。&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;需要打图集的Sprite确实不建议放置在Resources下，如果需要动态加载，并且不希望使用AssetBundle，则可以尝试把需要动态加载的Sprite统一引用到Prefab上进行管理（类似于NGUI的管理方式，一个图集对应一个Prefab），然后动态加载Prefab并查找其管理的Sprite即可。&lt;/li&gt;
  &lt;li&gt;另一种方式是，可以直接关闭Unity的Sprite Packer功能，通过第三方的工具来进行图集的打包，导入Unity时转为Multiple类型的Sprite资源，那么即使放在Resources文件夹下，也不会造成DrawCall无法合并的问题。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;resourcesunloadunusedassetsresourcesunloadassetmasset&quot;&gt;纹理图片通过文件流形式加载到内存，这样的资源还可以使用Resources.UnloadUnusedAssets()和Resources.UnloadAsset(m_Asset)进行资源卸载吗？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;如果是自己载入内存并初始化为Unity的Texture2D，则还是要重点查看Texture2D对象的创建方式。一般来说，会用new Texture2D的方式创建，并用LoadImage的接口将一块内存载入，那么这样就要用DestroyImmediate来销毁这个纹理对象了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ui&quot;&gt;UI&lt;/h2&gt;
&lt;h4 id=&quot;uguicanvascanvascanvasrendererpanel&quot;&gt;请问UGUI的重绘是针对于拥有Canvas组件的Canvas物件，还是针对于拥有CanvasRenderer组件的Panel物件？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;UGUI中，Canvas组件可以认为是容器，Image，Text等组件（都需要CanvasRenderer组件）可以认为是元素。在Unity5.2版本之前，在网格重建时，会以Canvas为单位，即一个Canvas中所有的元素最终都是合并到一个Mesh中的，而其中可以被合并渲染的元素则被合在同一个SubMesh中。&lt;/li&gt;
  &lt;li&gt;在Unity5.2版本之后由于引入了多线程的网格合并方式，据我们所知，目前并没有官方的原理解释。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;工具&lt;/h2&gt;
&lt;h4 id=&quot;animatorsdirtysceneobjects&quot;&gt;对于Animators.DirtySceneObjects这个参数，它是和哪些因素有关，以及如何优化？&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2FTechSharing%2052%2F5.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;该参数是更新场景中受Mecanim动画系统影响的每个GameObject的Transform，所以当这类的GameObject数量越多时，其CPU占用也会越高。对于它的优化方式，主要有如下两种：
    &lt;ul&gt;
      &lt;li&gt;如果是蒙皮网格物体，则可以开启“Optimize GameObject”选项来对其进行优化；&lt;/li&gt;
      &lt;li&gt;如果是非蒙皮网格（比如具有动画的UI界面、2D Sprite等），则只能建议研发团队尽可能减少同一时刻运动的GameObject数量（一般都不会太多），如果是被缓存的屏幕外的物体，则切记要在移出时关闭其Animator组件。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;prefabselect-dependenciesshader&quot;&gt;编辑器模式下，Prefab用Select Dependencies选项找依赖资源的时候，会把以前旧Shader引用的贴图也给关联上，怎么刷新这种引用关系？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;在切换Material所使用的Shader时，其上的纹理引用确实是不会自动清除的（除非被覆盖）。因此，我们的建议是，在编辑Material时，如果要切换Shader，那么在切换好之后，进行一次Reset的操作（如下图所示，该操作会重置所有使用中的属性，同时去掉未使用的属性），然后再开始编辑其属性。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2FTechSharing_54%2F2.png&quot; alt=&quot;请输入图片描述&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果希望在不改变当前使用属性的前提下，去掉未使用的属性，那么据我们所知，只能启用Editor的Force Text模式，打开对应的.mat文件进行手动去除。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;gc-allocaddcomponent-&quot;&gt;请问怎么优化下图这两者的GC Alloc？每次AddComponent 都会有这么多的开销。&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2FTechSharing_54%2F1.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;不可避免，只有减少AddComponent。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;物理&lt;/h2&gt;
&lt;h4 id=&quot;physicsprocessing&quot;&gt;请问Physics.Processing的占用过大一般是因为什么原因导致的？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;影响物理系统耗时的因素主要为Contacts数量（碰撞对数量）、Rigidbody API的使用情况和每帧的调用次数。
    &lt;ul&gt;
      &lt;li&gt;第一种情况是最为常见的引发物理模块耗时较大的原因，因此，我们在UWA性能报告中对其进行了详细的分析，如果你的报告中Contacts数量较高，切记要验证其合理性。&lt;/li&gt;
      &lt;li&gt;第二情况造成较大CPU开销的情况不多，不过如果你的项目是多角色游戏（比如MMO、MOBA、ARPG割草游戏等），那么你需要注意了。在我们优化过的一些项目中，通过Rigidbody API来移动GameObject位置（设置velocity、改变center等）确实会存在较高的性能开销。如果你的项目也有类似的做法，那么要时刻关注物理模块的开销了。&lt;/li&gt;
      &lt;li&gt;第三种情况同样也是目前引发物理模块耗时较高的原因。因为Unity引擎默认情况下，物理的更新频率是0.02s，即每20ms更新一次，所以，当你的项目比较卡时（开发过程中的项目在中低端设备上恐怕没几个是不卡的），物理模块会让你的项目更卡。举个例子，如果上一帧CPU耗时为100ms的话，那么物理模块会执行5次，从而进一步加大物理系统的耗时。这种情况下，物理模块的耗时是很有欺骗性的，你花了好长时间去研究物理的耗时，最后发现原来这个“锅”不是它的…所以，如果你的项目也遇到了这种情况，切记不要再上当了。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;性能综合&lt;/h2&gt;
&lt;h4 id=&quot;section-3&quot;&gt;5.0后批处理修改&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;从Unity 5.0开始，Static Batching的合批机制就已经出现了变化，不再进行索引数组的合批，因此并不会使得Draw Call降低，而是会降低Batches和SetPassCall，因此从图中来看，Static Batching 开启后的统计数据是没有问题的。也因此，UWA在统计时，使用的就是Batches的数值。具体的原因可见Unity官方在论坛中的回复：
https://forum.unity3d.com/threads/regression-feature-not-bug-static-dynamic-batching-combining-v-buffers-but-not-draw-calls.360143/&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;dynamic-batching&quot;&gt;尽量开启“Dynamic Batching”这个选项&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog/TechSharing_53/1.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;详见&lt;a href=&quot;https://blog.uwa4d.com/archives/TechSharing_53.html&quot;&gt;此处&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;gcalloc&quot;&gt;匿名函数造成GCAlloc&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;结论：当不使用外部变量的匿名函数时，编译器会把这个函数变成静态函数，在首次调用时初始化，之后就再也不会new新的对象。 当使用外部变量时，每次调用都会生成一个临时action变量，这个就是alloc的原因。&lt;/li&gt;
  &lt;li&gt;解决方案:&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public Action&amp;lt;int, int&amp;gt; pCall;
void Start()
{
  pCall = CallVariable;
  ... // 其他初始化代码
}
void FixedCall()
{
  table.Forecah(pCall);
}
void CallVariable(int k, int v)
{
  count = k + v;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.uwa4d.com/archives/Anonymous_heapmemory.html&quot;&gt;原文&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-4&quot;&gt;渲染&lt;/h2&gt;
&lt;h4 id=&quot;lightmapngameobjectprefablightmapnlightmaplightmap&quot;&gt;请教Lightmap相关的优化问题。我现在的场景中有N个GameObject共用一个Prefab，烘培Lightmap时，会生成出N个Lightmap贴图。有没有办法把这些生成的Lightmap合成一张？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;如果场景中某些物件在Lightmap纹理中占据的空间较大，但实际上并不需要较高的精度，那么可以选中该物体，并在Lighting面板的Object子面板中将其Scale in lightmap数值调低，从而可以降低其在Lightmap纹理中的空间，甚至减少Lightmap纹理的数量。&lt;/li&gt;
  &lt;li&gt;PS:为何会有N个lightmap？并没有回答能不能合并的问题。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;unityshaderifdef-endifpass&quot;&gt;Unity里的Shader能不能用关键字#ifdef #endif把整个pass包起来？&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;#ifdef&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;#endif&lt;/code&gt; 并不能写在Pass之外，如果有动态开关Pass的需求，可以通过Shader Lod来实现，即设置两个Level不同的SubShader分别包含1个和2个Pass，直接通过改变该Shader的局部Lod值，即可实现SubShader的切换。关于Shader Lod的细节，可见官方文档：
http://docs.unity3d.com/Manual/SL-ShaderLOD.html&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 30 Oct 2017 10:07:00 +0800</pubDate>
        <link>https://caihua.tech/2017/10/30/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E5%8D%81%E4%B8%89%E5%91%A8/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/10/30/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E5%8D%81%E4%B8%89%E5%91%A8/</guid>
        
        <category>UWA</category>
        
        
      </item>
    
      <item>
        <title>Shader合并与Variant</title>
        <description>&lt;h4 id=&quot;section&quot;&gt;前言&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;写这个的起因是因为看了唐建伟大佬在UWA上发表的文章&lt;a href=&quot;https://blog.uwa4d.com/archives/USparkle_Shader.html&quot;&gt;合并Shader系列_如何合并渲染状态&lt;/a&gt;。看完后受益良多，但是也对文中这样合并shader会不会产生shader的变种（shader variant）有所担心，因此在UWA的问答上提出了问题，最后唐建伟也做出了&lt;a href=&quot;https://answer.uwa4d.com/question/59dd6f350461bc6f45206ad5/%E3%80%8A%E5%90%88%E5%B9%B6Shader%E7%B3%BB%E5%88%97-%7C-%E5%A6%82%E4%BD%95%E5%90%88%E5%B9%B6%E6%B8%B2%E6%9F%93%E7%8A%B6%E6%80%81%E3%80%8B%E8%BF%99%E7%AF%87%E6%96%87%E7%AB%A0%E5%BC%95%E5%8F%91%E7%9A%84shader-variant%E9%97%AE%E9%A2%98&quot;&gt;回答&lt;/a&gt;，经过大佬授权在这里根据回答进行一些总结，想看原文的可以直接点击链接。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;sahder-variant&quot;&gt;Sahder Variant的概念&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;其实一个variant可以理解为一个具体的在GPU上执行的小程序，而一个Shader通常会编译出非常多的variant来应对不同的情况，比如单说雾效就有如下：没有雾效、有线性雾、有指数雾1、有指数雾2这样的4个variant(ps:这里只考虑雾效，其他条件一致)。至于原因嘛，有很多，粗略归纳一下是因为GPU需要更多的并行处理、逻辑单元少，因此Shader里面要尽可能规避各种判断、循环语句等等，最后本来可以通过逻辑判断来处理的雾效就需要编译成不同的执行程序来对应不同的情况(ps：这是一种高级优化，背后的原理很多很多，建议自行查询相关资料，查明前因后果，我懂的也不多)。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;shader-variant&quot;&gt;问题1:这样通过多参数来设置渲染状态不会造成shader variant吗？&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;在这篇文章中，我们只合并了渲染状态，渲染状态的合并不会导致Unity编译出更多的shader variant。
口说无凭，那么我们就先拿一个示例Shader来做测试，我选用了文章中的“ShaderCombine/01.ShaderCombineSimpleZTest”来做测试，Unity版本为 5.5.4p3，使用Unity的Shader Variant Collection来算取Variant数量，不管是否加入合并的代码，Variant的数量都是259，如下图所示：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://uwa-public.oss-cn-beijing.aliyuncs.com/answer/image/public/101228/1507705049102.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;即便是使用“ShaderCombine/02.ShaderCombineCommonState”来测试，Variant的数量也是是259，如下图所示&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://uwa-public.oss-cn-beijing.aliyuncs.com/answer/image/public/101228/1507705061601.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;从上面的图片可以看出，不管是否有渲染状态的参数在里面，Variant的数量都不会改变。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;shader-variant-1&quot;&gt;问题2：什么情况下在才会造成shader variant呢？&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;宏定义(Keyword)，“#pragma multi_compile XXX YYY ZZZ”，“#pragma multi_compile_xxx”，SubShader，Pass，Fallback及一些特殊不常用命令等的增减会造成variant的数量变化。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;至于一个Shader到底会生成多少variant呢？精确的计算方法，Unity并没有给出，但是我的归纳总结一下就是几组不同的编译宏的组合了，比如雾效、光照图、光源、阴影等等。另外还可以通过Unity的工具Shader Variant Collection来查看一个Shader到底有多少个variant，也可以在里面来自己组合和预编译自己想要的variant。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;variant&quot;&gt;福利：为什么修改渲染状态不会产生variant？&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;刚刚我们说了造成variant数量增加主要是需要生成不同的variant来应对不同的情况，那么不同的渲染状态是不是不同的情况呢？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;其实不是。生成不同的variant主要是为了消灭Shader内部的逻辑判断（ps：Shader的真正逻辑是CGPROGRAM…ENDCG中间的东西）。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;继续用雾效举例，先只考虑有雾效和没雾效，按一般的游戏逻辑写法，我们通常会在逻辑里用一个if判断来搞定，但是由于GPU的特殊性，这样的做法非常低效、不可取，那么就会使用Keyword这样的编译宏在编译的时候就分别编译为有雾效和没雾效的2个执行程序，也就是2个variant。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;现在说会渲染状态，看任何的Shader，我们都不会在CGPROGRAM…ENDCG里面有关于渲染状态的处理代码，当然不需要为不同的渲染状态编译不同的variant，也就不会造成variant的增加。（这部分可以参看Unity的渲染流水线，渲染一个物体需要非常多的步骤，我们写的Shader编译成的variant只在流水线中的两个可编程部分执行，而渲染状态是设置其他步骤的，与variant是完全隔离开、互不干扰。也可以说CGPROGRAM…ENDCG内的逻辑决定了variant的数量，CGPROGRAM…ENDCG外的是给Unity配置状态用的，不会引起Shader的逻辑变化，因此没变化）。
另附上一张简化版渲染流程图：
&lt;img src=&quot;https://uwa-public.oss-cn-beijing.aliyuncs.com/answer/image/public/101228/1507705163873.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Wed, 25 Oct 2017 00:02:11 +0800</pubDate>
        <link>https://caihua.tech/2017/10/25/Shader%E5%90%88%E5%B9%B6%E4%B8%8EVariant/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/10/25/Shader%E5%90%88%E5%B9%B6%E4%B8%8EVariant/</guid>
        
        <category>UWA</category>
        
        
      </item>
    
      <item>
        <title>每天一点UWA：第十二周</title>
        <description>&lt;h2 id=&quot;ui&quot;&gt;UI&lt;/h2&gt;
&lt;h4 id=&quot;ugui&quot;&gt;对于UGUI文字花屏问题，有什么推荐的解决方法吗？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;对于UGUI字体花屏的现象， 很有可能是字体的UV不准确导致。&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/yaukey/p/unity_ugui_font_texture_uv_wrong.html&quot;&gt;关于UGUI字体花屏和乱码&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;UGUI研究院之Text字体花屏（二十二）：http://www.xuanyusong.com/archives/4259&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;工具&lt;/h2&gt;
&lt;h4 id=&quot;deep-profilercolor--colorselftotalprofilerbeginsample0deep-profiler&quot;&gt;最近用Deep Profiler发现项目里有一个直接调用Color != Color的接口耗时很高，而且百分比也很高（不管是Self还是Total）。但是如果用Profiler.BeginSample显示时，其耗时又很低，百分比也很低几乎等于0。这样的情况下是Deep Profiler出问题了吗？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;针对上图具体例子来看，Deep Profiler中RoleRender_ChangeColor.get_running的CPU开销虽然较高，但其参考意义不大。因为不开Deep Profiler模式，此处开销是不会这么高的。&lt;/li&gt;
  &lt;li&gt;这是因为，图中的开销实际上是操作了200次循环且获取时间戳的开销，也就是说，当循环或者操作大量次数时，Deep Profiler模式中本身统计耗时操作的时间占比很大，所以此处反馈的时间其实并不是研发团队想看到的真正代码耗时。这也是为何很多团队反馈Deep Profiler统计不算准确的原因。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;粒子&lt;/h2&gt;
&lt;h4 id=&quot;section-2&quot;&gt;粒子系统里面使用到的模型，是不是读写开关必须要打开，否则会崩溃？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;这个问题在第六周的内容中有提到原因。在较新的版本上（例如4.7.2，5.3.5 等版本）进行了各种情况的测试后，尚未复现出这一现象。因此，我们建议研发团队可以尝试关闭 Readable选项。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-3&quot;&gt;模型&amp;amp;动画&lt;/h2&gt;
&lt;h4 id=&quot;skinnedmeshrenderermeshsharedmesh&quot;&gt;SkinnedMeshRenderer的Mesh是不是不能动态修改？属性里只开放了SharedMesh。&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;https://blog.uwa4d.com/archives/TechSharing_51.html  mark一下。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-4&quot;&gt;渲染&lt;/h2&gt;
&lt;h4 id=&quot;unitymaterialobjectmaterialbatching&quot;&gt;Unity中修改了Material的一个属性后，该Object就会单独实例化出一个Material，所以它就不能被动态Batching了，是这样吗？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;是的，所以我们在Material使用详情中对内存中驻留的Material进行了详细的检测和分析，如下图所示。
&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog/TechSharing_51/3.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;图中后缀为（Instance）的材质均为修改材质属性而生成的临时材质，对于这种情况，我们建议研发团队应严格将Instance材质数量控制在尽可能小（&amp;lt;10）的范围内，而对于过高数量的Instance材质，建议研发团队考虑是否可以通过动态更换Material的方式来代替修改材质属性的方式，从而来减少不必要的Instance材质，进而提升物体动态合批的几率。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;a2bsetactivefalse&quot;&gt;游戏中有一些静止的建筑，会和整个场景一起烘焙（包括了每个建筑在地表的阴影）。现在希望这些建筑是逐步开放的，比如玩家1级的时候只有建筑A开放，2级的时候建筑B开放，现在的问题是当建筑未开放时（SetActive(false)）地表的相关阴影还在。这种问题一般是怎么处理的？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;这种问题是因为研发团队将整个场景烘焙成一张Lightmap所致。如果地图中的建筑是固定的，且游戏中并没有动态改变方向光的需求（比如Time Of Day模拟），那么可以尝试以下方法来实现需求：&lt;/li&gt;
  &lt;li&gt;（1）如果建筑物是根据等级而批量出现的，那么可以尝试根据等级不同而烘焙相应建筑群的Lightmap，然后在游戏中根据需求动态替换Lightmap；&lt;/li&gt;
  &lt;li&gt;（2）如果是逐个出现且建筑之间相距较为紧密的话，那么建议尝试通过Dynamic Projector（Asset Store插件）或Shadow Map（Unity自带阴影）来进行处理，因为Lightmap方法已无法支持这种需求。同时，可配合Fast Shadow Receiver（Asset Store 插件）来尽可能降低上述实时阴影带来的性能开销。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 23 Oct 2017 09:02:00 +0800</pubDate>
        <link>https://caihua.tech/2017/10/23/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E5%8D%81%E4%BA%8C%E5%91%A8/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/10/23/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E5%8D%81%E4%BA%8C%E5%91%A8/</guid>
        
        <category>UWA</category>
        
        
      </item>
    
      <item>
        <title>LuaFramework&amp;PureMVC</title>
        <description>&lt;h4 id=&quot;luaframeworkhttpsgithubcomjarjinluaframeworkuguigithubtoluatoluapuremvcpuremvc&quot;&gt;&lt;a href=&quot;https://github.com/jarjin/LuaFramework_UGUI&quot;&gt;LuaFramework&lt;/a&gt;是GitHub上一个基于tolua的人更新案例，里面除了tolua的功能外还使用了PureMVC的部分功能。这个文章是对代码中PureMVC部分的一些理解。&lt;/h4&gt;

&lt;h2 id=&quot;puremvc&quot;&gt;PureMVC&lt;/h2&gt;
&lt;h3 id=&quot;structure&quot;&gt;Structure&lt;/h3&gt;
&lt;h4 id=&quot;modelproxy&quot;&gt;Model&amp;amp;Proxy&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Model保存对Proxy对象的引用，Proxy负责操作数据模型，与远程服务通信存取数据。这样保证了Model层的可移植性。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;viewmediator&quot;&gt;View&amp;amp;Mediator&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;View保存对Mediator对象的引用。&lt;/li&gt;
  &lt;li&gt;由Mediator对象来操作具体的视图组件（View Component，例如Flex的DataGrid组件），包括：添加事件监听器，发送或接收Notification ，直接改变视图组件的状态。&lt;/li&gt;
  &lt;li&gt;这样做实现了把视图和控制它的逻辑分离开来。&lt;/li&gt;
  &lt;li&gt;在LuaFramework的初始代码中只有个APPView，在其中的&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;controllercommand&quot;&gt;Controller&amp;amp;Command&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Controller保存所有Command的映射。Command类是无状态的，只在需要时才被创建。&lt;/li&gt;
  &lt;li&gt;Command可以获取Proxy对象并与之交互，发送Notification，执行其他的Command。经常用于复杂的或系统范围的操作，如应用程序的“启动”和“关闭”。应用程序的业务逻辑应该在这里实现。&lt;/li&gt;
  &lt;li&gt;Controller会注册侦听每一个Notification，当被通知到时，Controller会实例化一个该Notification对应的Command类的对象。最后，将Notification作为参数传递给execute方法。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;facade&quot;&gt;Facade&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Façade类应用单例模式，它负责初始化核心层（Model，View和Controller），并能访问它们的Public方法。&lt;/li&gt;
  &lt;li&gt;在实际的应用中，只需继承Façade类创建一个具体的Façade类就可以实现整个MVC模式，并不需要在代码中导入编写Model，View和Controller类。&lt;/li&gt;
  &lt;li&gt;Proxy、Mediator和Command就可以通过创建的Façade类来相互访问通信。&lt;/li&gt;
  &lt;li&gt;Facade保存了Command与Notification之间的映射。当Notification（通知）被发出时，对应的Command（命令）就会自动地由Controller执行。Command实现复杂的交互，降低View和Model之间的耦合性。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;observernotification&quot;&gt;Observer&amp;amp;Notification&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;使用一个简单的观察者模式实现。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;puremvc-in-luaframework&quot;&gt;PureMVC in LuaFramework&lt;/h2&gt;
&lt;h5 id=&quot;noteluaframeworkmodelproxymediator&quot;&gt;NOTE：在LuaFramework的初始代码中是没有model、proxy、mediator这些内容的。&lt;/h5&gt;
&lt;h4 id=&quot;view&quot;&gt;View&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;view部分也只存在一个AppView对象，它监听了一个MessageList，如果需要监听自己的事件可以在messagelist继续添加。从目前情况看，一个AppView基本可以满足所有UI事件的需要。&lt;/li&gt;
  &lt;li&gt;如果需要多个view的时候，在每个view中可以通过RegisterMessage方法来注册多个事件。&lt;/li&gt;
  &lt;li&gt;view的父类Base负责view的notification和command的映射。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;controller&quot;&gt;Controller&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;LuaFramework中Controller是一个singleton的，在一次性command的基础上加入了一个m_viewCmdMap用于处理由view负责处理的事件。&lt;/li&gt;
  &lt;li&gt;上面提到PureMvc中Command类是无状态的，只在需要时才被创建。所以在command的注册上LuaFramework采用的是名字+类型，因为有了类型就可以动态生成对象。&lt;/li&gt;
  &lt;li&gt;具体来说在LuaFramework的初始代码中注册了socketcommand，当facade send某个message时会调用这个command，采用的就是生成一个socketcommand对象，然后执行它的execute方法。这个方法调用了lua的network对象的OnSocket方法。&lt;/li&gt;
  &lt;li&gt;在command的注册上分为一次性的和view的&lt;/li&gt;
  &lt;li&gt;在command的执行上，在Controller的ExecuteCommand方法中可以看到，先从m_commandMap中查询是否有类型，如果有就实例化并执行execute方法。如果没有就在m_viewCmdMa中找，所有订阅了特定消息的view都会被执行OnMessage方法。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;facade-1&quot;&gt;Facade&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;AppFacade是其子对象。&lt;/li&gt;
  &lt;li&gt;在LuaFramework中facade不但负责将notification和command关联，而且负责管理Manager实例。本质一个字典，如果add的时候没有动静就是&lt;/li&gt;
  &lt;li&gt;facade父类负责将一次性的notification和command关联起来。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;observernotification-1&quot;&gt;Observer&amp;amp;Notification&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;m_viewCmdMap是多播，而m_commandMap是单播。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;总结&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;基本上在LuaFramework中的PureMvc只是使用了一部分功能，主要功能在于消息的注册发布和manager的管理。&lt;/li&gt;
  &lt;li&gt;在使用过程中，因为这个框架本身是要使用lua的，所以在源码中lua的部分在解耦上主要依赖event库来实现订阅发布。在C#部分反而不是很能体现MVC架构的优势。&lt;/li&gt;
  &lt;li&gt;在我自己的项目中为了最大化的使用热更新，所以很多逻辑都是写在lua中的，其实可以考虑在lua中实现一套PureMVC，但是这个语言在实现上应该不简单。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 16 Oct 2017 09:54:07 +0800</pubDate>
        <link>https://caihua.tech/2017/10/16/LuaFramework&PureMVC/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/10/16/LuaFramework&PureMVC/</guid>
        
        <category>Lua</category>
        
        
      </item>
    
      <item>
        <title>每天一点UWA：第十一周</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;字体&lt;/h2&gt;
&lt;h3 id=&quot;section-1&quot;&gt;优化字体资源&lt;/h3&gt;

&lt;h4 id=&quot;section-2&quot;&gt;方向：内存和数量峰值&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;主要是因为在字体资源的使用过程中采用了不同的方式。比如一开始的UI没有考虑使用AssetBundle，从而直接从Resources或者其它文件夹加载了字体资源。而后面的UI又依赖了AssetBundle中的字体，虽然也没有主动load，但是因为unity在load asset的时候会自动加载（有待验证）所以导致字体资源又被加载一次。从而峰值数量会不止一个。&lt;/li&gt;
  &lt;li&gt;内存:很多情况下我们对于一个字体库中的字体只是用了个别的，但是却加载了整个字体库。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2FSparkle_Font%2F1.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;优化方案&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;字库裁切
    &lt;ul&gt;
      &lt;li&gt;针对不同字体的应用场景，设计有效精简的裁切字库。&lt;/li&gt;
      &lt;li&gt;需要注意同一个字体资源在AssetBundle内外可能都会有依赖，如果依赖不能避免，那么就要各自设计裁切字库。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;工具：FontSubsetGUI
&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2FSparkle_Font%2F3.png&quot; alt=&quot;image&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-4&quot;&gt;结果&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2FSparkle_Font%2F4.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;ui&quot;&gt;UI&lt;/h2&gt;
&lt;h4 id=&quot;maskablegraphicenable-imagegcsetactivegc&quot;&gt;什么情况下会触发MaskableGraphic.Enable() ？现在我得到的结论是只要用到了Image组件，然后禁用启用带有这个组件的物体，都会触发进而产生GC。大家都怎么显示隐藏图片这种需求的，SetActive这种方式容易产生GC。&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;在UGUI中，Image组件并没有重写其父类的OnEnable函数，所以在激活时会出现MaskableGraphic.OnEnable。其中出现堆内存开销的话，通常是因为其父类函数Graphic.OnEnable中，UGUI在进行全局容器的Add等类似的操作时，遇到了扩容等产生堆内存的操作。&lt;/li&gt;
  &lt;li&gt;总之，在UGUI中，UI元素的激活和禁用所导致的堆内存分配，通常是不会持续出现的，其实不需要特别地处理。但对于其CPU开销，在UI元素数量较大时，依然是可观的，所以我们依然建议，对于激活禁用操作较为频繁的UI元素，可以尝试通过移出屏幕，缩放为0等方式来避免SetActive的调用。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;uwauiui-panelscrollviewitemitempanel&quot;&gt;UWA建议“将较多的动态UI元素分组放在不同的UI Panel中”，那么请问如果是ScrollView里面多个item的话，是否意味着每个Item都加一个Panel会更好一些？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;“动态元素”其实是相对的。在 ScrollView 中，一般情况下，如背包，其中的Item在滑动过程中是相对静止的，因此这种情况下只需要将这些Item放在一个UIPanel中即可。&lt;/li&gt;
  &lt;li&gt;但在类似于聊天界面中，存在一些UI元素是有持续的动画的，那么就需要考虑对这类元素进行特殊处理，可以尝试将这部分有动画的UI放在独立的UIPanel中，或者在个数不多的情况下，各自变为一个UIPanel等。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;uipanelsprite-renderernguispriteuipanel&quot;&gt;如果我在UIPanel下面放的是Sprite Renderer而不是NGUI的Sprite，是否会引起整个UIPanel的重绘？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;在NGUI中使用Unity2D的Sprite有两种情况，一种是直接使用Unity2D的SpriteRenderer组件，这种情况下，NGUI和Unity2D之间是互不影响的，只是在深度的设置上相对会比较麻烦一些。&lt;/li&gt;
  &lt;li&gt;另一种是使用NGUI的UI2DSprite组件，而该组件是NGUI对Unity2D的SpriteRenderer组件上进行封装的，方便使其深度与其他UI元素进行穿插，因此其行为和其他的UI元素一致，在某些情况下是有可能引起UIPanel的重绘。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-5&quot;&gt;模型&amp;amp;动画&lt;/h2&gt;
&lt;h4 id=&quot;abab&quot;&gt;有一个带位移动画A，有位置有旋转的变化，需要播完这个动画后切换到一个原地的动画B。现在我发现动画A没播放就会切换到B了，导致一些位移数据并没有作用到模型上，这种情况怎么处理？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Mecanim动画系统提供了“Apply Root Motion”功能来满足两个动画文件顶点位移不一致的切换的需求。&lt;strong&gt;当开启“Apply Root Motion”功能后，角色的GameObject位置会随着动画的更新而更新&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;因此，问题中的A切到B后，GameObject的位移将不会改变。建议该研发团队检测GameObject Animator组件的“Apply Root Motion”功能是否开启。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-6&quot;&gt;删除模型上动画的缩放&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;http://answers.unity3d.com/questions/668672/removing-scale-curves-from-animation.html&quot;&gt;link&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;防止将来翻不出去了&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void Apply(GameObject g)
     {
         List&amp;lt;AnimationClip&amp;gt; animationClipList = new List&amp;lt;AnimationClip&amp;gt;(AnimationUtility.GetAnimationClips(g));
         if (animationClipList.Count == 0) {
             AnimationClip[] objectList = UnityEngine.Object.FindObjectsOfType (typeof(AnimationClip)) as AnimationClip[];
             animationClipList.AddRange(objectList);
         }
 
         int count = 0;
 
         foreach (AnimationClip theAnimation in animationClipList)
         {
             foreach (AnimationClipCurveData theCurve in AnimationUtility.GetAllCurves(theAnimation))
             {
                 string name = theCurve.propertyName.ToLower();
                 if (name.Contains(&quot;scale&quot;))
                 {
                     for (int i = theCurve.curve.keys.Length - 1; i &amp;gt;= 0; i--) {
                         theCurve.curve.RemoveKey(i);
                     }
                     string propertyName = theCurve.propertyName;
                     // we can't delete &quot;*.x&quot;, e.g. m_LocalScale.x - but only &quot;*&quot;, e.g. m_LocalScale
                     if (propertyName.IndexOf(&quot;.&quot;) &amp;gt; 0) {
                         propertyName = propertyName.Substring(0, propertyName.IndexOf(&quot;.&quot;));
                     }
                     Debug.Log(string.Format(&quot;Fixing: {0} - {1}&quot;, theCurve.path, propertyName));
                     theAnimation.SetCurve(theCurve.path, theCurve.type, propertyName, null);
                     count++;
                 }
             } 
         }
 
         int checkCount = 0;
         foreach (AnimationClip theAnimation in animationClipList)
         {
             foreach (AnimationClipCurveData theCurve in AnimationUtility.GetAllCurves(theAnimation))
             {
                 string name = theCurve.propertyName.ToLower();
                 if (name.Contains(&quot;scale&quot;))
                 {
                     checkCount++;
                 }
             } 
         }
 
         if (count &amp;gt; 0)
         {
             Debug.Log(&quot;Total number of removed curves is &quot; + count + &quot;. GO name: &quot; + g.name);
             Debug.Log(&quot;Number of remaining scale curves is &quot; + checkCount);
         }
     }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-7&quot;&gt;渲染&lt;/h2&gt;
&lt;h4 id=&quot;section-8&quot;&gt;物体的动态合批条件和是否是透明物体没什么关系吧？比如粒子系统的物体一般都是透明的，是不是也可以合批？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;动态合批并不限制物体是否为半透明或不透明物体。&lt;/li&gt;
  &lt;li&gt;合批的首要要求是Material一致，其本身是半透明Material还是不透明Material均没有限制。&lt;/li&gt;
  &lt;li&gt;粒子系统同样是可以合批的，只要其材质一致，深度较为接近且中间没有其他材质的物体阻隔，那么Unity引擎将会将其进行合批。&lt;/li&gt;
  &lt;li&gt;查看Unity引擎的官方文档：https://docs.unity3d.com/Manual/DrawCallBatching.html&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 16 Oct 2017 09:47:00 +0800</pubDate>
        <link>https://caihua.tech/2017/10/16/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E5%8D%81%E4%B8%80%E5%91%A8/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/10/16/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E5%8D%81%E4%B8%80%E5%91%A8/</guid>
        
        <category>UWA</category>
        
        
      </item>
    
      <item>
        <title>Xlua摘要</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;加载机制&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;xlua在加载lua文件时会使用多个loader，LuaEnv的构造函数中有这么一段代码:&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;AddSearcher(StaticLuaCallbacks.LoadBuiltinLib, 2); // just after the preload searcher
AddSearcher(StaticLuaCallbacks.LoadFromCustomLoaders, 3);
#if !XLUA_GENERAL
AddSearcher(StaticLuaCallbacks.LoadFromResource, 4);
AddSearcher(StaticLuaCallbacks.LoadFromStreamingAssetsPath, -1);
#endif
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;从这段代码可以看出xlua主要的4个加载器分别是内置的lua的&lt;code class=&quot;highlighter-rouge&quot;&gt;LoadBuiltinLib&lt;/code&gt;，已经lua可能存在的两个目录，一个是Resources、另一个是StreamingAssets，通常来说我们也很有可能会把lua代码放到这两个里面。尤其是当用lua做热更新的时候，StreamingAssets是一个很好的选择。&lt;/li&gt;
  &lt;li&gt;当LuaEnv遇到一个&lt;code class=&quot;highlighter-rouge&quot;&gt;require&lt;/code&gt;的时候，就开始从这四个文件夹找&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;luac&quot;&gt;lua调用C#代码&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;unity中C#类分为两种，一种是继承了MonoBehaviour的，一种是一般的C#类。这两种都可以在lua中调用，但是调用方式不同。但是都需要给&lt;code class=&quot;highlighter-rouge&quot;&gt;LuaCallCSharp&lt;/code&gt;这个attribute。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对于一般的C#类型，可以使用这样的方式&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;local testClass = CS.Test
local test = testClass()
test.foo()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;对于继承MonoBehaviour的类是不能用上述方法的，因为在实例化的时候会报错。xlua在生wrap的时候没有考虑是否继承自mono，继承自mono的类不能用new，所以会报错。只能用下面的方法，注意第一个是已经在某个游戏对象上挂了脚本的情况，第二个是用lua动态添加脚本。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;self:GetComponent(&quot;MainUI&quot;):LoadScene(&quot;class1/class1&quot;)	

-- 或者

local mainui = self.gameObject:AddComponent(typeof(CS.MainUI))
mainui:LoadScene(&quot;class1/class1&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;需要注意一下对于静态方法是用&lt;code class=&quot;highlighter-rouge&quot;&gt;.&lt;/code&gt;，非静态是用&lt;code class=&quot;highlighter-rouge&quot;&gt;:&lt;/code&gt;，其实也可以用&lt;code class=&quot;highlighter-rouge&quot;&gt;.&lt;/code&gt;但是需要在函数定义的时候带自己self参数。对于unity中的一些函数这里尤为重要，比如&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-- 因为Find是静态方法所以用.
local cubes = GameObject.Find(&quot;Cubes&quot;)
-- 而Transform.Find其实是依赖于一个具体的GameObject的所以要用:
cube1 = cubes.transform:Find(&quot;Cube1&quot;).gameObject
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;luac-1&quot;&gt;lua与C#代码结合&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;如果想使用xlua的LuaBehaviour这个脚本，需要注意的是不能用加载器加载lua代码，而是dostring，否则不能使用self、注入的对象。但是awake方法是可以用的。需要注意要使用GetInPath，get方法我没成功过。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; // 用对象名字作为加载脚本的查询名字
 string luaname = GameRoot.Instance.GlobleUtil.NameDeleteClone(gameObject.name);

 // 直接用byte[] dostring
 AssetBundle bundle = AssetBundle.LoadFromFile(&quot;Assets/StreamingAssets/main/lua&quot;);
 TextAsset lua = bundle.LoadAsset(&quot;MainUI.lua&quot;, typeof(TextAsset)) as TextAsset;
 luaEnv.DoString(lua.bytes, luaname, scriptEnv);

 // 用 custom loader加载 但是无法使用self，也无法获取luaAwake这类的方法
 //luaEnv.DoString(&quot;require  '&quot; + luaname + &quot;'&quot;, luaname, scriptEnv);

 Action luaAwake = scriptEnv.GetInPath&amp;lt;Action&amp;gt;(&quot;MainUI.awake&quot;);
 luaStart = scriptEnv.GetInPath&amp;lt;Action&amp;gt;(&quot;MainUI.start&quot;);
 luaUpdate = scriptEnv.GetInPath&amp;lt;Action&amp;gt;(&quot;MainUI.update&quot;);
 luaOnDestroy = scriptEnv.GetInPath&amp;lt;Action&amp;gt;(&quot;MainUI.ondestroy&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;refout&quot;&gt;关于ref和out修饰符&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;一开始我测试的时候是本以为lua调用ref传入的参数，也会返回出修改的结果，但出乎我的意料，并没能修改，经过作者提示，lua是通过返回值返回的ref参数，如果函数本身就有返回值，那么最后一个参数是返回的ref或者out参数，如果是一个没有返回值的函数（C#中），在lua中同样可以让它给变量赋值，赋的值就是ref的结果。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 05 Oct 2017 14:28:20 +0800</pubDate>
        <link>https://caihua.tech/2017/10/05/Xlua%E6%91%98%E8%A6%81/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/10/05/Xlua%E6%91%98%E8%A6%81/</guid>
        
        <category>Lua</category>
        
        
      </item>
    
      <item>
        <title>每天一点UWA：第十周</title>
        <description>&lt;h2 id=&quot;assetbundle&quot;&gt;AssetBundle&lt;/h2&gt;
&lt;h4 id=&quot;assetbundle-1&quot;&gt;AssetBundle中的脚本&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;首先，需要说明的是，脚本本身的内容是不会被打包到AssetBundle文件中的，AssetBundle文件储存的仅是脚本的索引信息。因此，即便有多个AssetBundle中都存在UIAtlas这一脚本索引，对堆内存也几乎是不产生影响的，且不会产生冗余问题。&lt;/li&gt;
  &lt;li&gt;其次，脚本被当做资源且会产生依赖这一现象，仅在Unity 4.x版本中出现，而在Unity 5.0以后，脚本之间将不会产生依赖关系。因此，如果你目前还在使用Unity 4.x版本进行开发，那么依赖关系打包时确实需要注意这个问题，即依次Push A和B进行打包时，如果AssetBundle之间存在相同脚本，那么B会对A的脚本产生依赖。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;wwwassetbundlewebstreamassetbundlewwwdisposewebstream&quot;&gt;如果我用WWW加载了一个AssetBundle，创建了一块WebStream内存。这时候我用另一个东西保存这个AssetBundle的引用，然后用WWW给Dispose了，那么这块WebStream内存会释放掉么？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;如果仅是www.dispose，但是AssetBundle引用依然保留的话，那么WebStream是不会释放的。WebStream存在两个引用，一个是www对象，一个是加载出来的AssetBundle。仅这两个引用全部消除时，WebStream才会被Unity引擎回收，具体说明可见之前的技术文章：Unity AssetBundle内存管理机制详解。&lt;/li&gt;
  &lt;li&gt;5.4之后似乎没有webstream的概念了。因为很多方法现在都是直接从disk读取，或者先保存在读取。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;unloadunusedassetsinstantiateresoucesunloadassetgameobject-&quot;&gt;我发现如果不调用UnloadUnUsedAssets这个函数，则无法销毁通过Instantiate实例化出来的材质（包括纹理）。如果我尝试用Resouces.UnloadAsset来卸载挂在GameObject上的实例化材质, 则会闪退，请问这种情况该如何解决呢？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;如果想要直接销毁通过Instantiate实例化出来的材质、纹理等资源，则只能使用DestroyImmediate来进行销毁。研发团队可以参考NGUI中UI Draw Call组件里对动态材质的处理，来加深对动态创建以及销毁的理解。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;脚本&lt;/h2&gt;
&lt;h4 id=&quot;section-1&quot;&gt;关于字符串驻留导致的内存占用&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;https://blog.uwa4d.com/archives/USparkle_String-interning.html&lt;/li&gt;
  &lt;li&gt;https://gist.github.com/klkucan/6c51468ca6f92933356477745f0a50e0&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;androidassetbundleloadfromfileapplicationstreamingassetspathassetbundle&quot;&gt;Android用AssetBundle.LoadFromFile读取Application.streamingAssetsPath目录下的AssetBundle文件，用什么样的地址？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Unity 5.3之前，直接使用 Application.streamingAssetsPath 作为目录路径。&lt;/li&gt;
  &lt;li&gt;Unity 5.3之后，通过新增的LoadFromFile接口加载AssetBundle时，则需要改为 Application.dataPath+”!assets。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;nguiuieventlisteneronpressuibuttonpressuibuttonpressbuttonuibuttonnormaluieventlisteneronpresspress&quot;&gt;准确说这个不是一个优化的问题：NGUI的UIEventListener中的OnPress与UIButton的Press状态不能对应上。具体情况是我点击某个按钮并且按住不放，UIButton处于Press状态，然后移出了Button的范围，UIButton的状态变回了Normal，而UIEventListener中的OnPress并没有监听到，必须松开点击才能监听到。它们的Press状态切换有什么不一样呢？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;理论上UIButton的OnPress和UIEventListener的OnPress是在相同时间点触发的，即手指按下和手指抬起这两个时间点上。&lt;/li&gt;
  &lt;li&gt;而手指在按住状态下移开按钮时， UIButton的状态会变为Normal，这是因为其响应了OnHover的消息。因此如果要模拟UIButton的行为，至少要配合使用OnPress和OnHover两个消息。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;模型&amp;amp;动画&lt;/h2&gt;
&lt;h4 id=&quot;meshuv3uv4uvuv2&quot;&gt;求教Mesh导入后这里的uv3和uv4是怎么回事？有的模型只有uv和uv2，有的有四套。&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;如果在模型导入时就存在 uv2，uv3，uv4，那么这是因为在建模软件中添加了这些顶点属性。一般来说uv3和uv4的使用较为少见，通常是用来配合特殊的Shader实现特殊的效果。而uv2通常被用于Lightmap，uv2可以在建模软件中添加，也可以在Unity中通过Generate Lightmap UVs的选项来生成。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-3&quot;&gt;物理&lt;/h2&gt;
&lt;h4 id=&quot;section-4&quot;&gt;伤害检测、还有靠近采集物品时触发可以采集的提示箭头等，我们都使用了碰撞，请问如果不使用碰撞，可以用什么方法代替呢？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;使用Trigger也是较为合理的做法，如果想替代，可尝试根据距离、动画运行的时间点来进行判断。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-5&quot;&gt;性能综合&lt;/h2&gt;
&lt;h4 id=&quot;prefab&quot;&gt;prefab加载时依赖图片何时加载&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;首先说明一下，如果AssetBundle B和AssetBundle A产生依赖，那么在仅仅加载AssetBunde B中的Prefab B_prefab时，其本身开销仅为B_prefab的加载开销，对于AssetBundle A中的依赖资源并无影响。&lt;/li&gt;
  &lt;li&gt;但是在实例化B_prefab时，Unity引擎会去检查AssetBundle A中的依赖资源是否已经被加载好，如果没有加载好，则先加载AssetBundle A中相关资源，然后再实例化B_prefab。这其实就是大家经常遇到的初次实例化一个技能、角色时出现卡顿的主要原因。&lt;/li&gt;
  &lt;li&gt;因此，如果大家想加快B_prefab的实例化效率，那么对于其依赖关系AssetBundle A中的相关资源，可提前进行预加载，从而减少B_prefab实例化时的相关资源加载时间。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;unloadunusedassetsgc&quot;&gt;手动调用UnloadUnusedAssets+GC的问题&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;通过LoadLevel等API来切换场景时，Unity会自动触发Resources.UnloadUnusedAssets的操作，但在切换完成后再次调用Resources.UnloadUnusedAssets来确保卸载完全的做法也是较为常见的。但是在其它时间点不要调用。&lt;/li&gt;
  &lt;li&gt;对于大场景的MMO类型的游戏，因为切换场景的频率较低，也可以考虑每隔几分钟来手动触发一次Resources.UnloadUnusedAssets来降低内存。而GC的话，则不建议手动调用，即使是在切换场景时。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;resources&quot;&gt;Resources目录下的所有内容都会加载到内存里吗？如果里面东西多，是不是会导致占用内存过高？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;不会，Resources.Load也是即用即加载，但就目前我们统计的结果来看，Resources文件下的资源越多，其生成的ResourceManager内存占用也越大。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;font-texture-&quot;&gt;Font Texture 资源是如何生成的，因为我发现好像有重复的出现，如何优化呢？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;这是Unity为动态字体自动产生的纹理，一般来说不用特别关注。即使重复出现，里面的内容一般也是不一样的（内容即屏幕上显示的文字）。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;meshunitygpumeshcreatevbomeshdrawvbo&quot;&gt;重建的Mesh，Unity引擎会将其重新传入GPU端进行渲染，这部分开销主要体现在Mesh.CreateVBO和Mesh.DrawVBO中。&lt;/h4&gt;

&lt;h4 id=&quot;fk--statemachine-&quot;&gt;FK &amp;amp; Statemachine 状态机占用时间比较高，是否有优化的方法呢？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;影响该项的因素较多，一般为：
    &lt;ul&gt;
      &lt;li&gt;是否开启Optimize GameObjects选项，如果没有，建议开启；&lt;/li&gt;
      &lt;li&gt;场景中Active的GameObject（使用并开启了Animator组件的）是否较多，数量越多，则该项目开销越高；&lt;/li&gt;
      &lt;li&gt;GameObject的骨骼数越多、AnimationClip的采样次数越多，则该项开销也越高。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;因此，建议研发团队可从以上三种情况入手来优化FK &amp;amp; Statemachine的开销。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;prefabresourcesunloadassetxxxprefabprefab--destroy--resoucesunloadunused&quot;&gt;对Prefab资源的卸载、预览英雄模块、需要卸载英雄角色的资源、动画和材质都可以通过Resources.UnloadAsset(xxx)来顶点清除，而Prefab不行，Prefab 只能用 Destroy + Resouces.UnloadUnused()卸载吗？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Prefab如果想要单独卸载，只能使用DestroyImmediate来实现。同时，考虑到Prefab本身已经是很小的一个壳了，对内存的影响非常小，一般情况下是在切换场景的时候一起释放的。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 05 Oct 2017 14:25:20 +0800</pubDate>
        <link>https://caihua.tech/2017/10/05/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E5%8D%81%E5%91%A8/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/10/05/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E5%8D%81%E5%91%A8/</guid>
        
        <category>UWA</category>
        
        
      </item>
    
  </channel>
</rss>
