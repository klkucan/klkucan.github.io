<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>蔡华的博客</title>
    <description>Be publicly useful and privately happy.</description>
    <link>https://caihua.tech/</link>
    <atom:link href="https://caihua.tech/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sat, 17 Mar 2018 09:27:58 +0800</pubDate>
    <lastBuildDate>Sat, 17 Mar 2018 09:27:58 +0800</lastBuildDate>
    <generator>Jekyll v3.2.1</generator>
    
      <item>
        <title>七周七并发模式：Actor</title>
        <description>&lt;h4 id=&quot;actor&quot;&gt;什么是Actor&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;在本书提到的观点中，认为Actor是一个线程或者进程。在这个线程或者进程中执行了一段代码（函数)，这个代码可以包含状态（数据）也可以不包含。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;所谓Actor模型是Sequential Processes和Functions transforming data values两者的结合，可以理解为是综合了过程式计算和函数式计算的一个计算模型。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;一个Actor会把接收到的消息映射为三个部分，传给其他Actor的消息，一个新的行为（用来处理下一个消息），和创造一些新的Actors。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;actor-1&quot;&gt;为什么会出现Actor&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;在本书的第二章谈到了线程和锁，其中提到了这个并发模式存在的一些问题，比如竞争共享资源所导致的阻塞、多重锁导致的死锁等问题。&lt;/li&gt;
  &lt;li&gt;Actor正是为了解决这些问题而产生的。从定义看actor就是多线程，只不过它避免了对于共享资源的并发调用。一个actor只使用自己的资源，而不是直接使用共享资源，它作用单一，顺序执行。不同的Actor之间使用message来传递数据。&lt;/li&gt;
  &lt;li&gt;PS：这里实际上并不存在真的不使用锁。只要存在多个actor共同访问一个数据对象就存在锁的问题，只不过可能无需开发者自己去写相关的代码。因此书中在提到actor缺点时也提到了可能出现死锁的问题。&lt;/li&gt;
  &lt;li&gt;PS2：在书中最后使用Actor来统计wiki的例子里，实际上是将wiki的页面进行拆分，然后不同的page用不同的Actor开统计。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section&quot;&gt;消息和信箱&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;因为actor模型没有提供直接回复消息的机制，所以将发送进程的标识符包含在消息中。通过这个机制，消息的接收者可以回复消息。&lt;/li&gt;
  &lt;li&gt;异步地发送消息是用actor模型编程的重要特性之一。消息并不是直接发送到一个actor，而是发送到一个信箱（mailbox）。&lt;/li&gt;
  &lt;li&gt;每个Actor都有一个信箱&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-1&quot;&gt;分布式&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;与其说Actor是为了并发，不如说Actor是为了分布式。&lt;/li&gt;
  &lt;li&gt;书中使用Elixir语言进行了demo的编写。在不同的设备或者操作系统中（这里可以是一个设备上有多个不同的虚拟机，也就是逻辑意义上的一个主机），不同的Actor可以进行通信，可以协作来处理一些数据。整个过程是异步的，每个Actor因为都看上去是无状态的，或者说即使有状态也是内部的。所以每个Actor的运行并不会影响其它Actor。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;actor-2&quot;&gt;Actor的实现&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;这个是我比较郁闷的地方，因为书中使用了Elixir这个我完全不熟悉的语言，因此我对于代码也是看个大概，具体某些语法和函数为什么这么写也是一知半解。&lt;/li&gt;
  &lt;li&gt;但是从demo code来看，也是创建纤程（这个概念个人认为和golang里面的应该是一样的）来实现actor，而一个actor本质就是一个module，里面包含了一些函数用于处理逻辑，收发消息。&lt;/li&gt;
  &lt;li&gt;对于Actor可以使用缓存机制来统一进行管理。这样的好处还有可以控制错误的处理。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;actor-3&quot;&gt;Actor的错误处理&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;书中对于Actor的错误处理有这样一个观点：任其崩溃。&lt;/li&gt;
  &lt;li&gt;这个观点得益于Actor的独立性，在一个Actor出现异常后，以为它对于某些消息的处理是失败的，因此消息队列或者信箱可以将没有处理的消息交给其它的Actor来处理。&lt;/li&gt;
  &lt;li&gt;出现异常的Actor什么我们可以不做任何的处理。&lt;/li&gt;
  &lt;li&gt;不过如果出现Actor一启动就崩溃了，那么也不能无限制的创建新的Actor。因此书中提到了Actor创建频率的问题，过高的时候就要考虑错误的问题了。&lt;/li&gt;
  &lt;li&gt;对于Actor的错误处理建议的做法是创建一个错误处理内核，这就有一个要求了：&lt;strong&gt;&lt;em&gt;那么该系统正确运行的前提是其错误处理内核必须正确运行&lt;/em&gt;&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;如何保证错误处理内核正确运行呢？这需要内核是&lt;code class=&quot;highlighter-rouge&quot;&gt;顶层的管理者&lt;/code&gt;，书中是使用actor的缓存来实现的。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://c1.staticflickr.com/1/791/39040480120_d12837240a_z.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;同时在错误处理时还要保证消息的必达性：
    &lt;ul&gt;
      &lt;li&gt;没有异常发生，消息一定能被送达并被处理&lt;/li&gt;
      &lt;li&gt;如果某个环节出现异常，异常一定会通知到使用者（假设使用者已经连接到或正在管理发生异常的进程）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;actor-4&quot;&gt;Actor的优势和缺点&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;从前面的讲述来看，其优点是：
    &lt;ul&gt;
      &lt;li&gt;消息的传输和封装性很好&lt;/li&gt;
      &lt;li&gt;容错能力比较好&lt;/li&gt;
      &lt;li&gt;天然支持分布式。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;而缺点是：
    &lt;ul&gt;
      &lt;li&gt;同样有死锁问题&lt;/li&gt;
      &lt;li&gt;信箱溢出（这个可能是指的actor如果处理不够及时，mailbox可能会数据量过大)&lt;/li&gt;
      &lt;li&gt;actor本身没有直接提供并发，需要通过并发技术来构造并发方案。&lt;/li&gt;
      &lt;li&gt;由于多个actor并不共享状态，仅通过消息传递来进行交流，所以不太适合实施细粒度的并行。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-2&quot;&gt;吐槽&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;这本书是好书，不过其使用的编程语言确实比较丰富，导致我看代码时很痛苦。&lt;/li&gt;
  &lt;li&gt;像是OTP部分完全是依赖于某个编程语言来写的，对于其真正的机制我觉得描述的不够清楚。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-3&quot;&gt;参考&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.zhihu.com/question/37792465/answer/73537924&quot;&gt;为什么我觉得 Actor很难用？&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.zhihu.com/question/266384753&quot;&gt;如果理解并行计算中的参与者模式（Actor Model）？&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;PS：在这里说下C#的进程间通信实现，可以通过pipe来实现。可以参考：https://gist.github.com/klkucan/b76c85c77fdfcde51aa4eeb1c6f7cd0b&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Thu, 15 Mar 2018 22:47:43 +0800</pubDate>
        <link>https://caihua.tech/2018/03/15/%E4%B8%83%E5%91%A8%E4%B8%83%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B-Actor/</link>
        <guid isPermaLink="true">https://caihua.tech/2018/03/15/%E4%B8%83%E5%91%A8%E4%B8%83%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B-Actor/</guid>
        
        <category>并发模型</category>
        
        
      </item>
    
      <item>
        <title>使用整体性学习方法来提高学习效率</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;前言&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;这篇文章可以说是一篇读书笔记，内容来自《如何高效学习：1年完成MIT4年33门课程的整体性学习法》这本书。&lt;/li&gt;
  &lt;li&gt;实际上看到书名的时候我的第一反应这是本讲费曼技巧的书，因为在很多年前我看到过一篇&lt;a href=&quot;https://kb.cnblogs.com/page/162480/&quot;&gt;文章&lt;/a&gt;，标题和这个非常类似，直到我重新翻出来后发现文中所讲的那个人正是这本书的作者。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-1&quot;&gt;书的内容&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;在这里我不打算过多的写书中的内容，只是简单的把一些核心的内容列出来。实际上如果没有时间看书，我觉得看上面链接中的那篇文章是一样的。因为这本书的观点比较简单，大部分内容是来证明这些观点，并且列出了一些如何实践的方法。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-2&quot;&gt;结构、模型和高速公路&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;这本书虽然叫做如何高效学习，但实际上主要讲的是整体性学习方法。作者一上来先讲了三个主要的观点：结构、模型和高速公路。&lt;/li&gt;
  &lt;li&gt;结构：理解是结构高度发达完善的结果，结构是学习新知识时与其它知识建立联系。&lt;/li&gt;
  &lt;li&gt;模型：
    &lt;ul&gt;
      &lt;li&gt;简化的结构、结构的快照&lt;/li&gt;
      &lt;li&gt;模型的目的是压缩信息&lt;/li&gt;
      &lt;li&gt;核心概念联系在一起创建模型&lt;/li&gt;
      &lt;li&gt;模型是逐渐调整和更新的&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;高速公路：结构之间的联系&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;实际上这三点是整体性学习的核心内容或者说是最终形态。在我的理解中所谓的整体性学习更像是用类比的方式来快速对新知识进行学习，而在类比的过程中对于已有的知识需要一个结构或者模型，在这个基础上通过联想、类比等方法来进行学习。不同的知识之间是有相似性或者本身就是有联系的，这就是高速公路。&lt;/li&gt;
  &lt;li&gt;以学习编程语言为例，我们知道目前的编程语言会分成不同的范式，比如有面向对象的、面向过程的、函数式的、命令式的等等。现代的编程语言往往包含了多个范式，以C#为例它是面向对象的，也是命令式和函数式都有的。在学会了C#之后，对于java这样的编程的语言在学习上会很快，因为他们几乎在编程范式是一样的，在语法上的差异和API的时候在使用的过程中再慢慢熟悉即可。但是在赋值、条件判断、循环、多线程、文件操作、lambda等等上都非常的接近，这样就可以通过类比的当时来快速的学习。&lt;/li&gt;
  &lt;li&gt;对于lua、python或者JavaScript这样的脚本语言来说，其在赋值、条件判断、循环这些基本操作上也是一样的，再加上函数式编程的范式使得学习起来也会有一种熟悉的感觉。这也是为啥工作了几年的人在学习一门新的编程语言时会比较快，因为会有一种熟悉感、进而进行类比的学习。快速掌握共同点、重点学习不同点和API就可以很快的掌握。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-3&quot;&gt;五个信息类型&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;书中列出了五种信息类型，也是知识类型。分别是：
    &lt;ul&gt;
      &lt;li&gt;随意信息&lt;/li&gt;
      &lt;li&gt;观点信息&lt;/li&gt;
      &lt;li&gt;过程信息&lt;/li&gt;
      &lt;li&gt;具体信息&lt;/li&gt;
      &lt;li&gt;抽象信息&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;其中随意信息是最难以记忆的，因为它们往往是一些事实，比如历史中的事件的时间，这些东西往往就是枯燥的记忆内容，没有什么很好的类比方式。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-4&quot;&gt;学习的顺序&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;文中还列出了一个学习的顺序，实际上就是一种知识的学习过程：
    &lt;ul&gt;
      &lt;li&gt;获取：快速阅读和笔记法&lt;/li&gt;
      &lt;li&gt;理解：使用内在化、类比、比喻等技巧。所谓内在化更像是观想法，也就是把知识具现化。&lt;/li&gt;
      &lt;li&gt;拓展：同上&lt;/li&gt;
      &lt;li&gt;纠错&lt;/li&gt;
      &lt;li&gt;应用&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;这个没什么特别的地方，基本上就是一个获取知识的过程。实际上，这本书中很多的内容对于天朝读了十几年书的人来说都是没什么新意。&lt;/li&gt;
  &lt;li&gt;书中用了很大的篇幅来描述着5个过程，比如获取就介绍了快速阅读和笔记法。在这里快速阅读推荐指读法，也就是用手指的移动来带动阅读，这样可以让人的注意力集中在手指所在的地方。而笔记法，推荐使用康奈尔笔记法或者与其接近的黄金三分法来做笔记。&lt;/li&gt;
  &lt;li&gt;对于理解和拓展，就是内在化、图表法等。&lt;/li&gt;
  &lt;li&gt;对于随意信息的记忆推荐联想法、信息压缩技术。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-5&quot;&gt;真正的干货 - 费曼技巧&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;费曼技巧的过程：
    &lt;ul&gt;
      &lt;li&gt;选择要学习的概念&lt;/li&gt;
      &lt;li&gt;设想你是老师，正在试图教会一名新生这个知识点&lt;/li&gt;
      &lt;li&gt;当你感到疑惑时，回过头来，重新阅读参考材料、听讲座或找老师解答，直到你觉得搞懂了为止，然后把解释记到纸上。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;总结来说就是小学老师告诉我们的，如果你能给你的同学讲明白一个知识点你就是真的懂了这个知识点。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-6&quot;&gt;我所总结出来的学习方法&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;在学习一个新的知识点的时候尽可能的联系已经学过的知识，通过知识的连接和类比来快速掌握知识。&lt;/li&gt;
  &lt;li&gt;实际上费曼技巧是很实用而且也比较容易实施的方法，费曼技巧的根本理论在于找出自己没有真正掌握的知识，从而查漏补缺。&lt;/li&gt;
  &lt;li&gt;使用思维导图来做联想、类比和内在化。书中很多方法都提到了联想、内在化、图表法等，在我看来都可以总结为思维导图。思维导图的制作本身就是一个查漏补缺和思维拓展的过程。&lt;/li&gt;
  &lt;li&gt;使用方格笔记和黄金三分法，这个技巧也是有人专门写过书的，个人认为还是很有用的。&lt;/li&gt;
  &lt;li&gt;最后这本书的笔记可以看&lt;a href=&quot;https://www.flickr.com/photos/142765619@N07/40075301272/in/dateposted-public/&quot;&gt;这里&lt;/a&gt;
&lt;img src=&quot;https://c1.staticflickr.com/5/4602/40075301272_eb0642788d_b.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 18 Feb 2018 01:49:43 +0800</pubDate>
        <link>https://caihua.tech/2018/02/18/%E4%BD%BF%E7%94%A8%E6%95%B4%E4%BD%93%E6%80%A7%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E6%9D%A5%E6%8F%90%E9%AB%98%E5%AD%A6%E4%B9%A0%E6%95%88%E7%8E%87/</link>
        <guid isPermaLink="true">https://caihua.tech/2018/02/18/%E4%BD%BF%E7%94%A8%E6%95%B4%E4%BD%93%E6%80%A7%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E6%9D%A5%E6%8F%90%E9%AB%98%E5%AD%A6%E4%B9%A0%E6%95%88%E7%8E%87/</guid>
        
        <category>杂记</category>
        
        
      </item>
    
      <item>
        <title>七周七并发模型：函数式编程</title>
        <description>&lt;h4 id=&quot;section&quot;&gt;概念&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;命令式编程的代码由一系列改变全局状态的语句构成，而函数式编程则是将计算过程抽象成表达式求值。&lt;/li&gt;
  &lt;li&gt;这些表达式由纯数学函数构成，而这些数学函数是第一类对象（我们可以像操作数值一样操作第一类对象）并且没有副作用。由于没有副作用，函数式编程可以更容易做到线程安全，因此特别适合于并发编程。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-1&quot;&gt;为什么在并发和并行问题时会用到函数式编程&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;有关锁的一些规则，都是针对于线程之间共享的可变的数据——换个说法就是共享可变状态。而对于不变的数据，多线程不使用锁就可以安全地进行访问。&lt;/li&gt;
  &lt;li&gt;这就是为什么在解决并发和并行问题时函数式编程会如此引人注目——它没有可变状态，所以不会遇到由共享可变状态带来的种种问题。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;纯粹的函数式语言中，函数都具有引用透明性——在任何调用函数的地方，都可以用函数运行的结果来替换函数的调用，而不会对程序产生副作用。这个特性也使得可以任意安排多个计算过程的求值顺序，包括让它们并行&lt;em&gt;。&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;所有函数（至少是理论上）都可以同时执行。这种执行方式被称为数据流式编程（dataflow programming）。&lt;/li&gt;
  &lt;li&gt;PS：其实本书在第三章函数式编程部分的前两天中的内容，在我看来更多的是利用语言或者运行时本书的并发能力。后续会专门写个文章总结下C#中对应的并发功能。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-2&quot;&gt;写在2018.2.8的第一版总结&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;函数式编程确实是个大话题，在七周七并发模式看到第三章的时候我卡到了函数式编程这里。然后看完了《函数式编程思维》这本书，《C#函数式程序设计》还在路上，我想这是一次很不错的机会，让我好好的学习下。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-3&quot;&gt;参考&lt;/h2&gt;

&lt;h4 id=&quot;c&quot;&gt;从C#的角度看看&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Map、Reduce、Filter分别对应了C# linq中的三个函数&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Map = Select | Enumerable.Range(1, 10).Select(x =&amp;gt; x + 2);
Reduce = Aggregate | Enumerable.Range(1, 10).Aggregate(0, (acc, x) =&amp;gt; acc + x);
Filter = Where | Enumerable.Range(1, 10).Where(x =&amp;gt; x % 2 == 0);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;Map从下面函数式编程部分的含义看就是接收一个函数，作用于范畴中每一个值，使得范畴从A变成B。&lt;/li&gt;
  &lt;li&gt;Filter就是过滤，在我理解里面其实也就是一个传递给map的函数，这里的map是函子中的map。&lt;/li&gt;
  &lt;li&gt;Reduce，正如下图说的，它是个折叠的作用。要我说就是sum的过程。只不过也许并不是真的对数值进行累加，而是可以做其它的处理。总之细细体会下面图片中的文字吧。&lt;/li&gt;
  &lt;li&gt;PS:折叠这个词用的好。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;httpswwwzhihucomquestion28292740&quot;&gt;来自知乎的一个&lt;a href=&quot;https://www.zhihu.com/question/28292740&quot;&gt;回答&lt;/a&gt;&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;结论：函数式编程会把数据的结构外显，而命令式则把执行过程外显。
或者这样说：你在读函数式代码时，经常会想不清楚执行过程；而你在读命令式代码时，会经常搞不清楚当前对象有哪些属性。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-4&quot;&gt;函数式编程思维&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://c1.staticflickr.com/5/4669/40374586841_18f607ea60.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;函数式编程&lt;/h3&gt;
&lt;h4 id=&quot;section-6&quot;&gt;原文&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2017/02/fp-tutorial.html&quot;&gt;函数式编程入门教程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-7&quot;&gt;范畴&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;彼此之间存在某种关系的概念、事物、对象等等，都构成”范畴”。随便什么东西，只要能找出它们之间的关系，就能定义一个”范畴”。&lt;/li&gt;
  &lt;li&gt;范畴的数学模型：
    &lt;ul&gt;
      &lt;li&gt;所有成员是一个集合&lt;/li&gt;
      &lt;li&gt;变形关系是函数&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-8&quot;&gt;容器&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;可以把”范畴”想象成是一个容器，里面包含两样东西。
    &lt;ul&gt;
      &lt;li&gt;值（value）&lt;/li&gt;
      &lt;li&gt;值的变形关系，也就是函数。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-9&quot;&gt;范畴论与函数式编程的关系&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;范畴论使用函数，表达范畴之间的关系。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;本质上，函数式编程只是范畴论的运算方法，跟数理逻辑、微积分、行列式是同一类东西，都是数学方法，只是碰巧它能用来写程序。&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;为什么函数式编程要求函数必须是纯的，不能有副作用？因为它是一种数学运算，原始目的就是求值，不做其他事情，否则就无法满足函数运算法则了。&lt;/li&gt;
  &lt;li&gt;总之，在函数式编程中，&lt;strong&gt;函数就是一个管道（pipe）。这头进去一个值，那头就会出来一个新的值，没有其他作用。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-10&quot;&gt;函子&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;函子是函数式编程里面最重要的数据类型，也是基本的运算单位和功能单位。&lt;/li&gt;
  &lt;li&gt;++&lt;strong&gt;它首先是一种范畴，也就是说，是一个容器，包含了值和变形关系&lt;/strong&gt;++。&lt;strong&gt;比较特殊的是，它的变形关系可以依次作用于每一个值，将当前容器变形成另一个容器。&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;一般约定，函子的标志就是容器具有map方法。该方法将容器里面的每一个值，映射到另一个容器。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;函数式编程里面的运算，都是通过函子完成，即运算不直接针对值，而是针对这个值的容器—-函子。函子本身具有对外接口（map方法），各种函数就是运算符，通过接口接入容器，引发容器里面的值的变形。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;PS:实际上函子通过map方法接收函数来实现转换。而所有的计算本质还是这个函数对函子中的值的计算&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-11&quot;&gt;常见的函子&lt;/h4&gt;

&lt;h5 id=&quot;of&quot;&gt;of&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;new一个函子&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;maybe&quot;&gt;Maybe&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;Maybe 函子就是为了解决内部值为null而设计的。简单说，它的map方法里面设置了空值检查。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;either&quot;&gt;Either&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;条件运算if…else是最常见的运算之一，函数式编程里面，使用 Either 函子表达。&lt;/li&gt;
  &lt;li&gt;Either 函子内部有两个值：左值（Left）和右值（Right）。右值是正常情况下使用的值，左值是右值不存在时使用的默认值。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;ap&quot;&gt;ap&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;函子B内部的函数，可以使用函子A内部的值进行运算。这时就需要用到 ap 函子。&lt;/li&gt;
  &lt;li&gt;ap 是 applicative（应用）的缩写。凡是部署了ap方法的函子，就是 ap 函子。&lt;/li&gt;
  &lt;li&gt;ap是为了解决一个函子使用另一个函子的值的问题。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;monad&quot;&gt;Monad&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;Monad 函子的作用是，总是返回一个单层的函子。&lt;/li&gt;
  &lt;li&gt;它有一个flatMap方法，与map方法作用相同，唯一的区别是如果生成了一个嵌套函子，它会取出后者内部的值，保证返回的永远是一个单层的容器，不会出现嵌套的情况。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Monad 函子的重要应用，就是实现 I/O （输入输出）操作。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;举例说明：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Monad extends Functor {
  join() {
    return this.val;
  }
  flatMap(f) {
    return this.map(f).join();
  }
}

// 具体事例

var fs = require('fs');

var readFile = function(filename) {
  return new IO(function() {
    return fs.readFileSync(filename, 'utf-8');
  });
};

var print = function(x) {
  return new IO(function() {
    console.log(x);
    return x;
  });
}

readFile('./user.txt')
.flatMap(print)

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;上面第一段代码中如果f函数返回一个函子，map本身也是返回函子。这样就的造成了this.map(f)是函子的嵌套。&lt;/li&gt;
  &lt;li&gt;从事例的角度看，&lt;code class=&quot;highlighter-rouge&quot;&gt;readFile('./user.txt')&lt;/code&gt;本身是返回了一个函子IO，其中的值为函数&lt;code class=&quot;highlighter-rouge&quot;&gt;function() { return fs.readFileSync(filename, 'utf-8');}&lt;/code&gt;（注意：函子的值可以是函数，而且因为这里的new实际就是上面的of，所以里面的参数应该是值），它其实是从文件中读取到的数据。而&lt;code class=&quot;highlighter-rouge&quot;&gt;.flatMap(print)&lt;/code&gt;根据上面的描述&lt;code class=&quot;highlighter-rouge&quot;&gt;它会取出后者内部的值，保证返回的永远是一个单层的容器，不会出现嵌套的情况。&lt;/code&gt;
。它取出的就是第一个IO函子中的值（函数），然后在将这个值作为参数传递到print函数中。只有就形成了函数链。&lt;/li&gt;
  &lt;li&gt;PS：以上只是我的理解，这篇文章的评论区有很多质疑，但是因为我确实对这个不了解，所以就按照原文的理解来解释了。&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Thu, 08 Feb 2018 20:52:19 +0800</pubDate>
        <link>https://caihua.tech/2018/02/08/%E4%B8%83%E5%91%A8%E4%B8%83%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</link>
        <guid isPermaLink="true">https://caihua.tech/2018/02/08/%E4%B8%83%E5%91%A8%E4%B8%83%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</guid>
        
        <category>并发模型</category>
        
        
      </item>
    
      <item>
        <title>七周七并发模型：线程与锁</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;为何使用多线程和锁&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;为了能够并行的计算一些东西&lt;/li&gt;
  &lt;li&gt;因为在多线程下，如果要修改同一个对象是值会出现竞态条件（即代码行为取决于各操作的时序）。它的表现可能是值的不对，甚至某些时候这个值的前半段是一个线程修改的，后半段是另一个线程修改的。因为这个对象可能不是原子的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;锁，或者说是并行控制的进化&lt;/h2&gt;

&lt;h3 id=&quot;section-2&quot;&gt;第一阶段：锁与同步方法&lt;/h3&gt;

&lt;h4 id=&quot;section-3&quot;&gt;基础的锁&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;从代码层面看就是一个lock函数&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-4&quot;&gt;同步方法&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;在java或者C#中可以通过attribute来让方法同步执行，但是这个的效率是很低的。&lt;/li&gt;
  &lt;li&gt;同时还引出了另外一个问题，当同时使用多个锁的时候不但效率会进一步降低，而且容易产生死锁。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-5&quot;&gt;基础锁带来的问题&lt;/h4&gt;

&lt;h5 id=&quot;section-6&quot;&gt;死锁&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;当出现多个锁的时候，因为执行顺的问题，导致多个对象都持有一个锁，同时在等待其他人释放锁。例子就是哲学家进餐问题。&lt;/li&gt;
  &lt;li&gt;哲学家进餐问题的解决方法就是:
    &lt;blockquote&gt;
      &lt;p&gt;一个线程想使用多把锁时，就需要考虑死锁的可能。幸运的是，有一个简单的规则可以避开死锁——总是按照一个全局的固定的顺序获取多把锁。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-7&quot;&gt;外星方法问题&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;所谓外星方法指的是在锁的block中调用了一个外部的方法，但是这个方法中可能会要求获得当前锁的权限，但是因为这个锁正在被使用，导致了代码出现死锁。&lt;/li&gt;
  &lt;li&gt;解决方案：
    &lt;ul&gt;
      &lt;li&gt;唯一的解决思路是避免持有锁时调用外星方法；&lt;/li&gt;
      &lt;li&gt;一种方法是在遍历之前对listeners进行保护性复制（defensive copy），再针对这份副本进行遍历；&lt;/li&gt;
      &lt;li&gt;PS：但是我的理解是这个情况只有当数据是并发read时，如果是并发的write想来就有问题了。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-8&quot;&gt;第二阶段： 进击的锁&lt;/h3&gt;
&lt;h4 id=&quot;section-9&quot;&gt;中断死锁&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;死锁问题是很让人沮丧的，而且也是很多时候都会遇到的。在我们的C#代码中使用lock来做锁，如果遇到死锁，我们是没有办法终止这个被锁的线程的。但是好在还有办法可以结束锁，在java中就是书中说的&lt;code class=&quot;highlighter-rouge&quot;&gt;ReentrantLock &lt;/code&gt;，对应的在C#中是&lt;code class=&quot;highlighter-rouge&quot;&gt;Monitor&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;PS：java的部分可以看下&lt;a href=&quot;http://blog.csdn.net/lipeng_bigdata/article/details/52154637&quot;&gt;这篇文章&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;PS2：两个类的功能基本是一致的，都包含了超时的功能。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-10&quot;&gt;问题是否得到了解决？&lt;/h4&gt;
&lt;blockquote&gt;
  &lt;p&gt;虽然tryLock()方案避免了无尽地死锁，但这并不是一个足够好的方案。首先，这个方案并不能避免死锁——它只是提供了从死锁中恢复的手段。其次，这个方案会受到活锁现象的影响——如果所有死锁线程同时超时，它们极有可能再次陷入死锁。虽然死锁没有永远持续下去，但对资源的争夺状况却没有得到任何改善。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;有一些方法可以减小活锁的几率。比如为每个线程设置不同的超时时间，来减少所有线程同时超时的几率。但通过设置超时来处理死锁不能说是一个好的方案——以后我们还可以做得更好。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;section-11&quot;&gt;条件变量&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;C#中的Monitor有wait、Pulse和PulseAll，对应了ReentrantLock的&lt;code class=&quot;highlighter-rouge&quot;&gt;reachSixCondition&lt;/code&gt;对应。用法参考&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.threading.monitor.pulse.aspx&quot;&gt;这里&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;该方法可以显著调高并发度&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-12&quot;&gt;原子变量&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;C#中可以使用Interlocked.Increment来做计算，这个是原子性的。在计数类的场景比较实用。&lt;/li&gt;
  &lt;li&gt;这个是为了解决基础锁使用过程中对于数据的操作比较繁琐的问题。比如对于计数类的变量，需要保证其get\set都有锁的保护，这样写的方法就比较多了。&lt;/li&gt;
  &lt;li&gt;原子变量是无锁（lock-free）非阻塞（non-blocking）算法的基础，这种算法可以不用锁和阻塞来达到同步的目的。无锁的代码比起有锁的代码更为复杂。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-13&quot;&gt;第三阶段：终极形态&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;书中以一个大数据的单词解析为例。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-14&quot;&gt;线程池&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;好处就是可以节约线程数，因此往往不能无限制的使用多线程。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;影响线程池最优大小的因素有很多，例如硬件的性能、线程任务是CPU密集型还是IO密集型、是否有其他任务在同时运行。还有很多其他原因也会产生影响。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;话虽如此，但也存在经验法则：对于CPU密集型的任务，线程池大小应接近于可用核数；对于IO密集型的任务，线程池可以设置得更大些。
当然，最佳的方法是建立一个真实环境下的压力测试来衡量性能&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;section-15&quot;&gt;解决方案的进化&lt;/h4&gt;

&lt;h5 id=&quot;section-16&quot;&gt;生产者消费者模式&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;将数据的解析与计算分割为生产者与消费者。从而分析出性能的瓶颈在消费者（统计单词量）这边。&lt;/li&gt;
  &lt;li&gt;使用多线程分别进行生产和消费。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;关键在于生产者和消费者可能不会（几乎肯定不会）保持相同的速度。比如，当生产者的速度快于消费者的速度时，队列会越来越大。Wikipedia的dump差不多有40 GiB，很容易就让队列大小超过内存容量。
相比之下，阻塞队列只允许生产者的速度在一定程度上超过消费者的速度，但不会超过很多。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&quot;section-17&quot;&gt;消费者端的并发执行&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;将解析出来的数据放入到一个HashMap中&lt;/li&gt;
  &lt;li&gt;在计算上，使用多线程来对HashMap进行统计，但是真正的计算方法本身采样lock。&lt;/li&gt;
  &lt;li&gt;问题是从结果统计看并没有提高效率。其原因为：&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;答案是因为过度竞争——过多的线程尝试同时使用一个共享资源。在我们的程序中，消费者花费大量时间等待被其他消费者锁住的counts，它们的等待时间比实际运算时间还要长，最终导致惨烈的性能下降。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&quot;concurrenthashmap&quot;&gt;使用ConcurrentHashMap来解决共享资源的并发访问&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;C#中对应的是&lt;code class=&quot;highlighter-rouge&quot;&gt;ConcurrentDictionary&amp;lt;TKey, TValue&amp;gt;.AddOrUpdate Method (TKey, TValue, Func&amp;lt;TKey, TValue, TValue&amp;gt;)&lt;/code&gt;。也就是并发集合，依赖于内置的并发集合来提高并发的访问。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;concurrenthashmap-1&quot;&gt;使用多个ConcurrentHashMap&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;使用ConcurrentHashMap并没有完全的释放多核的威力。&lt;/li&gt;
  &lt;li&gt;对原来的数据进一步拆分，进而分配给不同的线程来统计，极大的利用了多核。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-18&quot;&gt;优缺点&lt;/h2&gt;
&lt;h4 id=&quot;section-19&quot;&gt;优点&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;线程与锁模型的最大优点是其适用面很广。它是其他许多技术的基础，适用于解决很多类型的问题。同时，线程与锁模型更接近于“本质”——近似于对硬件工作方式的形式化——正确使用时，其效率很高。这也意味着它能够解决从小到大不同粒度的问题。&lt;/li&gt;
  &lt;li&gt;另外，这个模型可以被轻松地集成到大多数编程语言中。语言设计者们可以轻易让一门指令式语言或面向对象语言支持线程与锁模型。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-20&quot;&gt;缺点&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;线程与锁模型没有为并行提供直接的支持。&lt;/li&gt;
  &lt;li&gt;线程与锁模型仅支持共享内存模型。如果要支持分布式内存模型（无论是地理分布型或者容错型），就需要寻求其他技术的帮助。这也意味着线程与锁模型不适用于单个系统无力解决的问题。&lt;/li&gt;
  &lt;li&gt;多线程的难点不在于难以编程，而在于难以测试。&lt;/li&gt;
  &lt;li&gt;我们要全程保证所有对象的同步都是正确的、必须按照顺序来获取多把锁、持有锁时不调用外星方法。&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Wed, 17 Jan 2018 00:01:05 +0800</pubDate>
        <link>https://caihua.tech/2018/01/17/%E4%B8%83%E5%91%A8%E4%B8%83%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B-%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%94%81/</link>
        <guid isPermaLink="true">https://caihua.tech/2018/01/17/%E4%B8%83%E5%91%A8%E4%B8%83%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B-%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%94%81/</guid>
        
        <category>并发模型</category>
        
        
      </item>
    
      <item>
        <title>侯捷C++学习笔记：对象的创建和销毁</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;概述&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;本文会记录CPP中对象的创建和销毁的过程中的细节&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;big-three&quot;&gt;big three函数&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;拷贝构造函数&lt;/li&gt;
  &lt;li&gt;拷贝赋值函数&lt;/li&gt;
  &lt;li&gt;析构函数&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-1&quot;&gt;用途：这三个函数是在类中包含了指针的情况下使用的。&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;当有一个成员变量是一个指针时，就有了给这个变量赋值的问题。如果这个赋值需要深拷贝，那么就需要申请内存空间。这样在析构函数中就需要对指针进行delete。&lt;/li&gt;
  &lt;li&gt;这个成员变量可以是在对象构造函数中被赋值的，比如是个拷贝构造函数。也可以是在拷贝赋值函数中被赋值的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;对象创建&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Complex c1(1,2)&lt;/code&gt;这样的形式还是&lt;code class=&quot;highlighter-rouge&quot;&gt;Complex* c2 = new Complex(1,2)&lt;/code&gt;这样的形式，都可以创建对象。&lt;/li&gt;
  &lt;li&gt;构造函数不能直接被指针调用&lt;code class=&quot;highlighter-rouge&quot;&gt;p-&amp;gt;P::P()&lt;/code&gt;，这样写在某些编译器下可以通过编译但是某些不行。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;new&quot;&gt;new做了什么&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://c1.staticflickr.com/5/4670/40329065372_ff712bf4f9_b.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;生命周期&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;对于c1这样在栈上的，生命周期就是C1的作用域。&lt;/li&gt;
  &lt;li&gt;对于C2这样指针的，生命周期也看C2的生命周期，比如C2是个函数的局部变量，那么在函数结束时因为要调用&lt;code class=&quot;highlighter-rouge&quot;&gt;delete c2&lt;/code&gt;，此时对象也就被销毁了。&lt;/li&gt;
  &lt;li&gt;如果一个c3是static的，那么按照C里面的约定这个变量的生命周期就是进程的生命周期，不管这个C3是全局还是局部。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-4&quot;&gt;对象在内存中是什么样的布局&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://c1.staticflickr.com/5/4613/39477530815_26b8a6f5c4_b.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;section-5&quot;&gt;看图说话&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;图是VC中的内存布局，一个对象的大小必须是16字节的倍数。&lt;/li&gt;
  &lt;li&gt;灰色部分是debug模式下才有的，用于debug。&lt;/li&gt;
  &lt;li&gt;Release模式下一个对象包含上下hook共4*2=8个字节，对象本身的字节数（complex那个例子下就是实部和虚部共2个double，即4*2=8字节）。如果不够16的倍数就会出现墨绿色部分的pad，也就是填补内存。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-6&quot;&gt;对象的销毁&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;生成的对象c1和c2都会在作用域结束后销毁。如果是c1那么它这个对象本身就在栈上保存，因此销毁后全部内存就释放掉了。但是指针的形式，因为对象是在堆上的，如果c2指针被销毁了，那么堆上这块内存就无法找到并销毁了（直到进程结束），造成了内存泄漏。&lt;/li&gt;
  &lt;li&gt;因此对于指针形式的c2，在其使用完成后就可以直接调用&lt;code class=&quot;highlighter-rouge&quot;&gt;delete c2&lt;/code&gt;来实现销毁。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-7&quot;&gt;析构函数&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;如果一个对象中动态的分配了内存，那么需要在析构函数找那个对分配的内存进行删除。&lt;/li&gt;
  &lt;li&gt;如果不显式的去写析构函数编译器应该会生成一个，如果我没有记错的话。&lt;/li&gt;
  &lt;li&gt;上面的c1中如果是在栈上的，那么变量离开作用域后会自动销毁并调用析构函数。&lt;/li&gt;
  &lt;li&gt;构造函数执行两个步骤，第一个执行&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;delete&quot;&gt;delete做了什么&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://c1.staticflickr.com/5/4664/25502410297_0d908862e7_b.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-8&quot;&gt;数组删除&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;如果动态生产了数组内存，则在析构函数或者当需要删除对象时需要用&lt;code class=&quot;highlighter-rouge&quot;&gt;delete[]&lt;/code&gt;。在这个过程中具体干了什么呢？&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://c1.staticflickr.com/5/4710/40329065432_911ca4b950_b.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;上面也说了，delete会先执行析构函数，其实对于一个对象来说，由于上下hook的存在因此析构函数可以完美的删除这个对象所占用的内存。所以图中左右两个delete都可以删除p所指向的数组，但是因为数组中是string的指针， 所以删除数组后string指针对指向的string对象本身并没有删除。而这个string对象本身其实就是char[]。这才是不用delete[]造成内存泄漏的本质。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 16 Jan 2018 23:49:53 +0800</pubDate>
        <link>https://caihua.tech/2018/01/16/%E4%BE%AF%E6%8D%B7C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E9%94%80%E6%AF%81/</link>
        <guid isPermaLink="true">https://caihua.tech/2018/01/16/%E4%BE%AF%E6%8D%B7C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E9%94%80%E6%AF%81/</guid>
        
        <category>CPP</category>
        
        
      </item>
    
      <item>
        <title>侯捷C++学习笔记：Object Model</title>
        <description>&lt;h4 id=&quot;composition--delegate--inherit-&quot;&gt;composition &amp;amp; delegate &amp;amp; inherit 的构造和析构顺序&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;如果有以下代码：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class A
{
public：
    A();
    ~A();
    Foo();
}

class B
{
public：
    B();
    ~B();
}

class C:A
{
public：
    C();
    ~C();
private:
    B* b;
}

main()
{
    C c;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;在前面面向对象中讲过，B和C组成了composition &amp;amp; delegate，而A和C是继承关系。&lt;/li&gt;
  &lt;li&gt;那么在内存使用的顺序上会先调用A的构造函数，然后调用B的构造函数。最后调用C的构造函数。&lt;/li&gt;
  &lt;li&gt;在析构时的顺序是：先调用C的析构，在调用B的，最后调用A的。&lt;/li&gt;
  &lt;li&gt;其顺序可以从代码层面这样的解释&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;C::C() ：A(), B() { // c在构造函数中要做的事情}

C::~C()
{
    // c的析构
    ~B();
    ~C();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;vptr--vtbl&quot;&gt;vptr &amp;amp; vtbl&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;在C++中函数分为虚函数和非虚函数，对于非虚函数来说调用的时候编译器会编译为&lt;code class=&quot;highlighter-rouge&quot;&gt;call(method address)&lt;/code&gt;的形式，也就是说函数的地址是已知的，即使是继承下来的函数，等于也是调用了父类的函数的地址。这个被称为静态绑定。&lt;/li&gt;
  &lt;li&gt;但是对于虚函数，因为有override的情况，所以C++中采用了虚机制，也可以说是动态绑定。&lt;/li&gt;
  &lt;li&gt;虚机制的基础是虚指针和虚表。虚指针是对象中的一个指向虚表的指针，虚表是一个对象中所有的虚函数地址表。&lt;/li&gt;
  &lt;li&gt;与C#方法列表进行比对： C#中方法列表包含了所有函数的地址，而C++的虚表中只是虚函数的。因为不知道子对象是否会override父类虚函数，所以这个虚表里面的函数可能指向了父类的虚函数，也可能指向了子类的虚函数，还有可能是子类override的虚函数。&lt;/li&gt;
  &lt;li&gt;什么时候C++会使用动态绑定呢？
    &lt;ul&gt;
      &lt;li&gt;调用方法的对象是一个指针&lt;/li&gt;
      &lt;li&gt;对象使用时是up cast，也就是协变。&lt;/li&gt;
      &lt;li&gt;调用的是虚函数&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;本质：从下面的代码看*(p-&amp;gt;vptr)是虚指针指向的虚表，虚表中其实是函数地址的数组，调用某个函数就是去数组的值，然后传递参数。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;( *(p-&amp;gt;vptr) [n] )(...)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;PS：对于栈上的对象的方法调用，就不考虑虚机制。下面例子中B继承自A，AB中均有虚函数vFunc的情况下，结果是调用了A的虚函数，因为a不是指针。如果a是指针，那么走虚机制，应该执行的是B的vFunc。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;B b;

A a = (A)b;

a.vFunc();

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Tue, 09 Jan 2018 23:48:28 +0800</pubDate>
        <link>https://caihua.tech/2018/01/09/%E4%BE%AF%E6%8D%B7C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Object-Model/</link>
        <guid isPermaLink="true">https://caihua.tech/2018/01/09/%E4%BE%AF%E6%8D%B7C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Object-Model/</guid>
        
        <category>CPP</category>
        
        
      </item>
    
      <item>
        <title>侯捷C++学习笔记：Reference</title>
        <description>&lt;h4 id=&quot;section&quot;&gt;本质&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;通过指针实现，所以本质就是指针&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-1&quot;&gt;意义&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;是某个变量的代表，因此下面的代码中，x的值为5。在给x赋值后i和x都是6。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int i = 5;

int&amp;amp; x = i;

x = 6;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-2&quot;&gt;编译器的一些做法&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;以一下代码为例，如果有一个变量b是a的引用，那么有&lt;code class=&quot;highlighter-rouge&quot;&gt;sizeof(a) == sizeof(b)&lt;/code&gt;而且&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;a == &amp;amp;b&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;上面也说了引用是个指针，在32位系统中sizeof指针应该是4个byte。但是因为b是a的引用，它代表了a，所以代码中&lt;code class=&quot;highlighter-rouge&quot;&gt;sizeof(b)&lt;/code&gt;是16byte。而且a和b取地址得到的值也是一样的，虽然我们知道这个在内存中肯定是不一样的。只不过编译器做了这些的处理。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typedef struct A {int a, b, c, d};

A a;
A&amp;amp; b = a;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;reference&quot;&gt;reference的常用方式&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;主要用于参数的修饰，很少用来声明变量。&lt;/li&gt;
  &lt;li&gt;参考以下的代码，在使用上引用传递在写法上和值传递是一样的，当然本质不同。但是从代码的优雅性上引用会比指针的参数形式好。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void Func1 (Cls a)
void Func2 (Cls&amp;amp; a)
void Func3 (Cls* a)

...

Cls obj;

Func1(obj);
Func2(obj);
Func3(&amp;amp;obj);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;需要注意以下两个函数不能同时定义，因为在调用上会出现歧义。但是const修饰符可以实现重载。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void Func (Cls a)
void Func (Cls&amp;amp; a)

......

Cls obj;
Func(obj);

......

void Func (Cls a) const
void Func (Cls&amp;amp; a)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Sun, 07 Jan 2018 23:45:30 +0800</pubDate>
        <link>https://caihua.tech/2018/01/07/%E4%BE%AF%E6%8D%B7C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Reference/</link>
        <guid isPermaLink="true">https://caihua.tech/2018/01/07/%E4%BE%AF%E6%8D%B7C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Reference/</guid>
        
        <category>CPP</category>
        
        
      </item>
    
      <item>
        <title>侯捷C++学习笔记：偏特化</title>
        <description>&lt;h4 id=&quot;section&quot;&gt;什么是偏特化&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;泛化（泛型）的反义&lt;/li&gt;
  &lt;li&gt;分为个数的偏特化和范围的偏特化&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-1&quot;&gt;数量偏特化&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;举个例子，如果有如下class的定义，第一个class的就是泛型的，而第二个class，也是两个参数，但是第一个参数是个确定类型的，第二个是泛型的。这样就叫个人的偏特化。这固定类型的位置必须是从左至右的，不能跳着写。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;template&amp;lt;typename T, typename U&amp;gt;
class vector {}


template&amp;lt;typename U&amp;gt;
class vector&amp;lt;bool, U&amp;gt; {}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-2&quot;&gt;范围偏特化&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;说白了进一步约束泛型的类型。这个和C#中泛型的where约束有点像。&lt;/li&gt;
  &lt;li&gt;对于下面的例子来说，第一个C约束几乎没有，但是第二个就约束为指针类型了。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;template&amp;lt;typename T&amp;gt;
class C {}


template&amp;lt;typename U&amp;gt;
class C&amp;lt;U*&amp;gt; {}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Tue, 02 Jan 2018 23:45:30 +0800</pubDate>
        <link>https://caihua.tech/2018/01/02/%E4%BE%AF%E6%8D%B7C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%81%8F%E7%89%B9%E5%8C%96/</link>
        <guid isPermaLink="true">https://caihua.tech/2018/01/02/%E4%BE%AF%E6%8D%B7C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%81%8F%E7%89%B9%E5%8C%96/</guid>
        
        <category>CPP</category>
        
        
      </item>
    
      <item>
        <title>侯捷C++学习笔记：类型转换</title>
        <description>&lt;h4 id=&quot;section&quot;&gt;自己转换为别的类型&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;做法：使用&lt;code class=&quot;highlighter-rouge&quot;&gt;operator&lt;/code&gt;关键字，无需返回值，函数名称就是返回值。如有需要加上const修饰。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Class A
{
Public:
    A(int arg1, int arg2) 
     : x(arg1), y(arg2) {}
    
    operator double() const
    {
        return (double)(x/y);
    }
    
private:
    int x;
    int y;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;non-explicit-one-argument-ctor&quot;&gt;non-explicit-one-argument ctor&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;本质是编译器将别的对象转化为我们定义的对象&lt;/li&gt;
  &lt;li&gt;要求的自定义构造函数比较特殊&lt;/li&gt;
  &lt;li&gt;在实例代码中编译器会把4装换为A，然后执行+ 操作。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Class A
{
Public:
    A(int arg1, int arg2) 
     : x(arg1), y(arg2) {}
    
    A operator +(const A&amp;amp; a) 
    {
        return A(....);
    }
    
private:
    int x;
    int y;
}

A a(2,3);
double d = a + 4;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-1&quot;&gt;编译器有时会不清楚&lt;/h4&gt;

&lt;p&gt;-下面的代码中a+4时编译器发现可以用double操作，也可以用+操作，在这样的情况下编译器会不知道如何选择进而报错。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Class A
{
Public:
    A(int arg1, int arg2) 
     : x(arg1), y(arg2) {}
    
    A operator +(const A&amp;amp; a) 
    {
        return A(....);
    }
    
    operator double() const
    {
        return (double)(x/y);
    }
    
private:
    int x;
    int y;
}

A a(2,3);
double d = a + 4;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;explicit-one-argument-ctor&quot;&gt;explicit-one-argument ctor&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;explicit关键字几乎都是用到构造函数前面的，告诉编译器不要随便的把别的类型转换为我自定的类型。&lt;/li&gt;
  &lt;li&gt;下面的例子中，编译器不会再把4转成A，因此这个表达式是错误的。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Class A
{
Public:
    explicit A(int arg1, int arg2) 
     : x(arg1), y(arg2) {}
    
    A operator +(const A&amp;amp; a) 
    {
        return A(....);
    }
    
private:
    int x;
    int y;
}

A a(2,3);
double d = a + 4;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Tue, 02 Jan 2018 23:44:24 +0800</pubDate>
        <link>https://caihua.tech/2018/01/02/%E4%BE%AF%E6%8D%B7C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</link>
        <guid isPermaLink="true">https://caihua.tech/2018/01/02/%E4%BE%AF%E6%8D%B7C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</guid>
        
        <category>CPP</category>
        
        
      </item>
    
      <item>
        <title>侯捷C++学习笔记：面向对象</title>
        <description>&lt;h4 id=&quot;composition&quot;&gt;Composition&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;组合&lt;/li&gt;
  &lt;li&gt;其实就是一个类（Container）中包含了另一个类的实例（Component），注意是实例。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;delegate&quot;&gt;delegate&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;组合的一种&lt;/li&gt;
  &lt;li&gt;但是包含的是一个类的引用(reference)。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section&quot;&gt;组合的使用&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;用这样的方式可以做出adapter模式，比如A功能很多但是如果只要暴露出一部分，可以用B来包含A，然后只在B中定义一些方法，这些方法都是直接调用A的即可。&lt;/li&gt;
  &lt;li&gt;还可以引申出面向接口编程。比如A中要调用某一类的功能，但是这些功能可以由B\C\D来提供，或者说不通的条件下使用不通的提供者，那么我们就可以为这些功能定义一个接口，然后让BCD实现接口，A中只要是一个对接口类型的引用即可。&lt;/li&gt;
  &lt;li&gt;PS：目前我看到C++里面的接口是用虚函数实现的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;no-virtualvirtual&quot;&gt;no-virtual&amp;amp;virtual&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;C++的函数使用virtual关键字标记为虚函数。&lt;/li&gt;
  &lt;li&gt;虚函数分为纯虚函数和虚函数，区别就是虚函数是有实现的，哪怕只是个空的函数体&lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;&lt;/code&gt;。但是纯虚函数是没有实现的，定义方式为&lt;code class=&quot;highlighter-rouge&quot;&gt;virtual void Foo() = 0&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;虚函数不要求子对象一定实现override，但是纯虚函数要求一定实现。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 02 Jan 2018 23:42:45 +0800</pubDate>
        <link>https://caihua.tech/2018/01/02/%E4%BE%AF%E6%8D%B7C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</link>
        <guid isPermaLink="true">https://caihua.tech/2018/01/02/%E4%BE%AF%E6%8D%B7C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</guid>
        
        <category>CPP</category>
        
        
      </item>
    
  </channel>
</rss>
