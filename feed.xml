<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>笛音夏扇</title>
    <description>Be publicly useful and privately happy.</description>
    <link>https://caihua.tech/</link>
    <atom:link href="https://caihua.tech/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Mon, 20 Mar 2017 22:11:58 +0800</pubDate>
    <lastBuildDate>Mon, 20 Mar 2017 22:11:58 +0800</lastBuildDate>
    <generator>Jekyll v3.2.1</generator>
    
      <item>
        <title>AssetBundle学习笔记：2、压缩</title>
        <description>&lt;h4 id=&quot;section&quot;&gt;格式&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;谈压缩就要谈到格式，unity目前在制作AssetBundle时默认就是压缩的，当然也可以设置为不压缩，但是显然不科学尤其是在移动端的开发上。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;LZMA：这个是一个序列化数据文件流，也是AssetBundle的默认压缩格式。LZMA提供最佳的压缩比，但是在使用的时候需要完全解压后才能使用，因此加载时需要的事件比较多。&lt;/li&gt;
  &lt;li&gt;LZ4：5.3以后才加入的一种压缩格式，被unity自己大量使用。这是一种基于块的压缩方式，当一个对象从LZ4压缩的AssetBundle中加载时，会按照需要解压部分的块。这样的好处在于快速的加载对象，后面会提到一个最佳实践。当然，按照这个原理，你也可以想象如果一个LZ4AssetBundle中只包含了一个GameObject，那么也不存在什么按需加载了。&lt;/li&gt;
  &lt;li&gt;AssetBundle也可以选择不压缩，这样体积最大但是加载最快。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;assetbundle&quot;&gt;缓冲被压缩的AssetBundle&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;WWW.LoadFromCacheOrDownload方法下载并缓冲AssetBundle到磁盘，5.3以后缓冲的文件可以是LZ4格式的压缩文件了，这直接导致了一个很2的事情。就是当你下载了LZMA格式的AssetBundle后，每当你通过socket下载到足够的数据后，unity就在后台悄悄的解压然后重新压缩为LZ4格式的文件直到下载结束，这个压缩发生在下载流（download streaming）中。当用到缓冲中的数据时，就会按照解压LZ4的套路走了。也就是按需按块解压。&lt;/li&gt;
  &lt;li&gt;缓冲压缩是默认的，然后可以通过 Caching.compressionEnabled属性来控制。会影响到包缓冲到磁盘和保存在内存中。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;assetbundleapi&quot;&gt;AssetBundle加载API概述&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;具体表格可以参考&lt;a href=&quot;https://docs.unity3d.com/Manual/AssetBundleCompression.html&quot;&gt;原文&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;对这个表格总结以下，从API的角度看：
    &lt;ul&gt;
      &lt;li&gt;在使用WWW时需要及时释放，因为它会在内存（WebStream）中保留下载的文件的大小。&lt;/li&gt;
      &lt;li&gt;LoadFromCacheOrDownload没有什么额外的内存使用（其实应该有序列化文件（SerializedFile）的内存使用，而且如果prefab过多，有可能SerializedFile比WebStream还大，&lt;a href=&quot;http://blog.uwa4d.com/archives/ABTheory.html&quot;&gt;来源&lt;/a&gt;）。而且从表中可以看到在性能上也只有读磁盘的操作，然而LoadFromCacheOrDownload本质上是个网络操作，因此它会产生一些例如CRC检测的操作，所以unity的建议是如果是本地的AssetBundle不要用这个函数加载。&lt;/li&gt;
      &lt;li&gt;LoadFromMemory (Async)，不推荐使用。后面会说使用场景。&lt;/li&gt;
      &lt;li&gt;LoadFromFile(Async)，so beautiful。&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://docs.unity3d.com/Manual/UnityWebRequest-HLAPI.html&quot;&gt;WebRequest&lt;/a&gt;。
 (also supports caching)，这个东西算是WWW的替代品，很好用，回头写个总结。&lt;/li&gt;
      &lt;li&gt;使用WWW, WebRequest下载AssetBundle时，还有一个8x64KB的缓冲池buff来保存socket中的数据。so，这也是内存啊。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;从压缩格式角度看:
    &lt;ul&gt;
      &lt;li&gt;不压缩没啥优势，除了访问速度快。其实如果是不考虑内存或者磁盘的占用问题，倒是可以用这个。&lt;/li&gt;
      &lt;li&gt;LZ4，从文档看unity应该用的是&lt;a href=&quot;http://www.findbestopensource.com/product/lz4hc&quot;&gt;LZ4HC&lt;/a&gt;，一个LZ4的高压缩版本。由于unity从5.3以后缓存也可以压缩了，而且这个算法是基于块的，所以在综合性上比较好。&lt;/li&gt;
      &lt;li&gt;LZMA，必须先解压在压缩，如果不是因为网络传输需要节省流量，不建议使用。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-1&quot;&gt;指导方针，满满的干货&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;如果是将AssetBundle打包到游戏中，也就是AssetBundle跟着安装包走的话，推荐LZ4+AssetBundle.LoadFromFileAsync，既有压缩省空间，又有最快的加载性能可能性，给你读取内存buff的快感。&lt;/li&gt;
  &lt;li&gt;如果是网络下载可下载内容（DLC），则使用LZMA+LoadFromCacheOrDownload/WebRequest，这样可以获得最好的压缩比。缓存到本地后使用AssetBundle.LoadFromFile加载。这里需要注意，如果是一些需要持久化的内容，是需要实实在在的保存到本地的，否则进程结束后内存中的cache会清除。&lt;/li&gt;
  &lt;li&gt;如果是加密的AssetBundle，则使用LZ4+LoadFromMemoryAsync。其实也可以理解，毕竟需要加载到内容后进行解密。而且这个差不多是LoadFromMemory[Async]唯一的使用场景。&lt;/li&gt;
  &lt;li&gt;当使用自定义压缩时，请使用不压缩来创建AssetBundle，然后自己解压后使用AssetBundle.LoadFromFileAsync来加载。&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Mon, 20 Mar 2017 18:00:00 +0800</pubDate>
        <link>https://caihua.tech/2017/03/20/AssetBundle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2-%E5%8E%8B%E7%BC%A9/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/03/20/AssetBundle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2-%E5%8E%8B%E7%BC%A9/</guid>
        
        <category>AssetBundle学习笔记</category>
        
        
      </item>
    
      <item>
        <title>我所了解的法线贴图</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;两篇文章&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;本文大多数内容来自这两篇文章，看完后基本明白了法线贴图的种种细节。&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;http://www.66acg.com/m/?post=468&quot;&gt;凹凸映射&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/flytrace/p/3387748.html&quot;&gt;写给笨人的法线贴图原理&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;一些基本的概念&lt;/h2&gt;

&lt;h4 id=&quot;section-2&quot;&gt;1.法线贴图的定义&lt;/h4&gt;

&lt;p&gt;顾名思义，法线贴图保存的是法线的信息贴图。&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;2.用来干什么&lt;/h4&gt;
&lt;p&gt;用来进行凹凸映射。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;凹凸映射的目的是使用一张纹理来修改模型表面的法线，以便为模型提供更多的细节。这种方法不会真的改变模型的顶点位置，只是让模型看起来好像是“凹凸不平”的，但可以从模型的轮廓处看出“破绽”。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;有两种主要的方法可以用来进行凹凸映射：一种方法是使用一张高度纹理(height map)来模拟表面位移(displacement)，然后得到一个修改后的法线值，这种方法也被称为高度映射(height mapping);另一种方法则是使用一张法线纹理(normal map)来直接存储表面法线，这种方法又被称为法线映射(normal mapping)。尽管我们常常将凹凸映射和法线映射当成是相同的技术，但要知道它们之间的不同。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;section-4&quot;&gt;3.种类&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;世界空间下的法线纹理&lt;/li&gt;
  &lt;li&gt;模型空间下的法线纹理&lt;/li&gt;
  &lt;li&gt;切线空间下的法线纹理&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-5&quot;&gt;对比不同的法线贴图&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;首先按照不同的坐标系得到了不同类型的法线贴图。模型顶点的法线根据所处坐标系的不同，在成图后表现也是不同的。以模型法线贴图和切线法线贴图为例：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://www.66acg.com/content/uploadfile/201609/8e0f1474641756.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图 左边: 模型空间下的法线纹理   右边: 切线空间下的法线纹理&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;不同的颜色是因为法线作为一个Vector3类型的需要转换到2D的颜色，而通常来说我们可以把颜色的RGB看成一个坐标系，这样法线就对应了一个RGB颜色。但是法线的范围是[-1,1]，而颜色是没有赋值的，因此有以下的转换过程。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;法线纹理存储的是表面的法线方向。由于法线方向的分量范围在[-1, 1]，而像素的分量范围为[0, 1]，因此我们需要做一个映射，通常使用的映射就是： 
pixel=(normal + 1) / 2 
这就要求，我们在Shader中对法线纹理进行纹理采样后，还需要对结果进行一次反映射的过程，以得到原先的法线方向。反映射的过程实际就是使用上面映射函数的逆函数： 
normal=pixel × 2 - 1&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;world-space-normal-map&quot;&gt;1.world space normal map&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;一旦从贴图里解压出来后,就可以直接用了,效率很高.但是有个缺点,这个world space normal 是固定了,如果物体没有保持原来的方向和位置,那原来生成的normal map就作废了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;世界坐标下的顶点的法线是现成的，因此好用。不过如果进入模型在U3D里面进行了位置或者方向的转换，那么在没有转换矩阵的情况下，法线信息就是错误的，也就无法使用了。进一步思考如果场景中存在大量的静态模型，可以考虑用这个。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;object-space-normal-map&quot;&gt;2.object space normal map&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;对于模型顶点自带的法线，它们是定义在模型空间中的，因此一种直接的想法就是将修改后的模型空间中的表面法线存储在一张纹理中，这种纹理被称为模型空间的法线纹理(object-space normal map)。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;对象空间的法线贴图，这个贴图中记录的法线信息是基于模型空间的，因此数值是相对的，这样模型在场景中是可以位移和旋转的，只要在计算的时候乘上对应的矩阵即可。而且从上面的图里可以看到贴图是彩色的，因为模型上的顶点法线在这个空间中是朝各个方向的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对象空间的法线贴图比起世界空间的在使用了已经有了很大的进步，不过它仍旧有自己的局限性，就是这样的贴图还是依赖于模型本身。从其定义也可以看出来，它也是一种“绝对位置”。如果模型发生了形变，则这个贴图的信息就是错误的。从目前来看，我只能想到模型在场景中存在动画这个问题。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;tangent-space-normal-map&quot;&gt;3.tangent space normal map&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;对于模型的每一个顶点，它都有一个属于自己的切线空间，这个切线空间的原点就是该顶点本身，而z轴是顶点的法线方向(n),x轴是顶点的切线方向(t)，而y轴可由法线和切线叉积而得，也被称为副切线(bitangent, b)或副法线。这种纹理被称为是切线空间的法线纹理(tangent-space normal map)。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;定义很好理解，从本质上讲切线空间的法线贴图解决了模型变形的问题。因为在另一个模型上的顶点的切线空间坐标系里面，法线贴图中的信息是可以使用的，它不依赖于模型本身、也不依赖于模型所处的坐标系。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-6&quot;&gt;4.切线空间下的法线贴图如何生成&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;以3DMAX为例，法线贴图需要高模和低模配合，具体过程不说了，网上大把的视频。&lt;/li&gt;
  &lt;li&gt;重点是法线贴图的生成需要高模和低模，因为没有高模就不知道法线方向,没有低模,就不知道高模上某点的法线对应于低模上哪个点。&lt;/li&gt;
  &lt;li&gt;下面才是重点，因为多个高模的面使用了同一个低模的面，因此在生成法线贴图时，高模不能使用自己的tangent space，而是使用低模的tangent space。这样一些高模上的点的法线与低模面上的法线出现了不一致，你可以想象低模上的某个面上的法线指向一个方向，但是对应了几个高模的点，可能一些点的法线与低模面的法线方向一样，那么很好，完美融入低模的切线空间，颜色呈现出淡蓝色。但是其它那些和低模面法线不一致的点的法线就产生了夹角，就造成了在切线法线贴图上那些不是[0.5,0.5,1]色值的点。
    &lt;blockquote&gt;
      &lt;p&gt;低模上的这个tangent space，也必须与高模上的坐标系tangent space。因为低模上的一个面,可能对应了高模上的几个面(精度高)，按照新方法每个面都有一个局部坐标系，那对于低模上的每个面，高模因为存在好几个面，就会出现好几个局部坐标系，这肯定是不行的。所以高模所用的tangent space，就是低模上的。生成法线贴图，必定会确认高模上哪些面都对应低模上的哪个面，然后高模上的这几个面的法线，都会转换为低模这个面上所构建的tangent space的坐标。这样，当低模变形时，即三角面变化时，它的tangent space也会跟着变化，保存在贴图里的法线乘以低模这个面的tangent space到外部坐标系的转换矩阵即可得到外部坐标。顺便再提一点，高模保存的这个法线，是高模上object space里的法线。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;对于上述的内容，这张图做了很好的诠释。
&lt;img src=&quot;http://images.cnitblog.com/blog/278594/201310/26011616-6fe1f456a1b94c408c883ab302c59f99.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-7&quot;&gt;如何将高模的法线贴图用在低模上&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;对于object space normal map，低模的object space坐标系与高模中的object space坐标系是重合的。所以不需要构建,所以低模上某点才能直接用高模的法线替换自己的法线。&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Thu, 16 Mar 2017 15:20:05 +0800</pubDate>
        <link>https://caihua.tech/2017/03/16/%E6%88%91%E6%89%80%E4%BA%86%E8%A7%A3%E7%9A%84%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/03/16/%E6%88%91%E6%89%80%E4%BA%86%E8%A7%A3%E7%9A%84%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE/</guid>
        
        <category>Unity3D</category>
        
        
      </item>
    
      <item>
        <title>游戏设计模式读书笔记：原型模式</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;原型模式&lt;/h2&gt;
&lt;h4 id=&quot;section-1&quot;&gt;定义&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F&quot;&gt;定义&lt;/a&gt;：原型模式是创建型模式的一种,其特点在于通过“复制”一个已经存在的实例来返回新的实例,而不是新建实例。被复制的实例就是我们所称的“原型”，这个原型是可定制的。
原型模式多用于创建复杂的或者耗时的实例，因为这种情况下，复制一个已经存在的实例使程序运行更高效；或者创建值相等，只是命名不一样的同类数据。&lt;/li&gt;
  &lt;li&gt;看图
&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/thumb/1/14/Prototype_UML.svg/678px-Prototype_UML.svg.png&quot; alt=&quot;image&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;模式的理解&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;当需要快速并且尽可能少的占用内存的情况下，创建一个新的对象可以采用这个模式。前提是浅拷贝，因为深拷贝就是创建一个新的对象。&lt;/li&gt;
  &lt;li&gt;如果在必须是深拷贝，那么这个模式只是在使用上有便利，或者说代码上更优雅而已。&lt;/li&gt;
  &lt;li&gt;在扩展一个基础类型时，可以使用原型模式。但是C#中如果是结构体还好说，如果是个类完全可以用继承。&lt;/li&gt;
  &lt;li&gt;根据定义这个不是新建一个实例，那么本质上是浅拷贝。至于到底是深拷贝还是浅拷贝我认为可以根据自己的需要去做。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;unity&quot;&gt;Unity中的实现&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;其实在C#中已经实现了ICloneable接口，直接继承接口，然后实现方法即可。而且.net还提供了MemberwiseClone方法，直接实现了浅拷贝。&lt;/li&gt;
  &lt;li&gt;要做深拷贝就是new一个对象返回即可。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-3&quot;&gt;吐槽&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;这个文章不知所谓。作者自己都不喜欢这个模式。或者说他用这个模式的方向应该不是这个模式原本希望人们使用的方式吧。&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Thu, 16 Mar 2017 15:20:05 +0800</pubDate>
        <link>https://caihua.tech/2017/03/16/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/03/16/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</guid>
        
        <category>游戏设计模式读书笔记</category>
        
        
      </item>
    
      <item>
        <title>AssetBundle学习笔记：1、概述和创建</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;前言&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;打算彻底搞清楚AssetBundle的原理和使用，目前计划刷完官方文档和最佳实践系列文章，而且笔记中的内容会大量是官方文档的内容。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;概述&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;AssetBundle可以包含任意unity能识别的类型文件，甚至是一个场景。如果想包含自定义的二进制文件，需要文件后缀名是.bytes，unity会将这样的文件导入为TextAsset。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;ab&quot;&gt;AB流程&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://docs.unity3d.com/uploads/Main/AssetBundlesBuildPlusUpload.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Editor编辑，场景中使用。&lt;/li&gt;
  &lt;li&gt;上传AB到服务器，其实这个不是必须的，也可以放到本地，后面会讲到这种case下怎么做才是最高效的。程序会按需加载AB，然后每个AB中的asset各自处理。其实就是在AssetBundle中按照需要加载不同的资源。&lt;/li&gt;
  &lt;li&gt;下载AB到本地，方法也非常多，各有优劣，后面会说。&lt;/li&gt;
  &lt;li&gt;从AssetBundle中加载GameObject，这个有一个AssetBundle→asset→GameObject的过程。而AB之前还可能有www。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-2&quot;&gt;友情提示&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;你必须看&lt;a href=&quot;http://unity3d.com/learn/tutorials/topics/best-practices/guide-assetbundles-and-resources&quot;&gt;这个&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;assetbundle&quot;&gt;创建AssetBundle&lt;/h2&gt;

&lt;h4 id=&quot;assetbundle-1&quot;&gt;设置AssetBundle&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;定义AssetBundle名称，在一个资源的最下方会有一个AssetBundle的设置。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://docs.unity3d.com/uploads/Main/AssetBundleInspectorNewBundle.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;点击New按钮可以创建新包，并给它命名。下图的例子中资源被添加到一个名为environment/desert的AssetBundle中，这里面可能包含了之前已经放置的资源。另外在AssetBundle命名时unity会当名称转为小写。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://docs.unity3d.com/uploads/Main/AssetBundleEditor.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果创建了一些AssetBundle，但是没有放置任何的资源通过Remove Unused Names选项可以删除定义的名字。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;从上述的说明感觉这个new出来的是一个空文件夹识，在设置资源时这个文件夹的名字作为了标识来使用。而Remove Unused Names按钮就是一键删除空文件夹。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;assetbundle-2&quot;&gt;代码生成AssetBundle&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;这里有一段代码。代码很简单，而且没有很多容错机制。而且说实话这个代码很粗暴，所有被标记（就是上面说的设置）了AssetBundle的资源：prefab、scene文件等都会被无脑的build进指定的AssetBundle中。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;using UnityEditor;

public class CreateAssetBundles
{
    [MenuItem (&quot;Assets/Build AssetBundles&quot;)]
    static void BuildAllAssetBundles ()
    {
        BuildPipeline.BuildAssetBundles (&quot;Assets/AssetBundles&quot;, BuildAssetBundleOptions.None, BuildTarget.StandaloneOSXUniversal);
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;同时生成的manifest文件包含一下内容：
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%BE%AA%E7%92%B0%E5%86%97%E9%A4%98%E6%A0%A1%E9%A9%97&quot;&gt;CRC&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;AssetFileHash：AssetBundle中所有asset文件的hash，一个单独的hash。只用来做增量build时的检查。&lt;/li&gt;
      &lt;li&gt;TypeTreeHash：AssetBundle中所有类型的hash，只用来做增量build时的检查。&lt;/li&gt;
      &lt;li&gt;ClassTypes： AssetBundle中包含的所有类类型，这些数据用来得到一个新的单独的hash当typetree做增量build检测。&lt;/li&gt;
      &lt;li&gt;Asset names.所有在AssetBundle中的asset的名称。&lt;/li&gt;
      &lt;li&gt;Dependent AssetBundle names. AssetBundle所依赖的其它AssetBundle的名字&lt;/li&gt;
      &lt;li&gt;这个manifest文件只是用来做增量build的，非运行时必须。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;放一个自己的测试数据&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ManifestFileVersion: 0
CRC: 1763426742
Hashes:
  AssetFileHash:
    serializedVersion: 2
    Hash: eed209af1be31231fa135faaff2ab7b6
  TypeTreeHash:
    serializedVersion: 2
    Hash: 31d6cfe0d16ae931b73c59d7e0c089c0
HashAppended: 0
ClassTypes: []
Assets:
- Assets/Test.unity
Dependencies:
- E:/CodeDemo/New Unity Project 2/Assets/AssetBundles/sphere
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;还有两个文件生成，文件名就是打包目的地文件夹的名字，比如上面的代码就在AssetBundles文件夹下生成，名字是AssetBundles，一个是没有后缀的一个是以manifest为后缀，打开manifest文件可以看到下面的内容，可以看出来是这个目录下AssetBundle的信息。&lt;strong&gt;&lt;em&gt;其实它只包含两个  信息，一个是所有的AssetBundle名字和它们的依赖。&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ManifestFileVersion: 0
CRC: 4270654667
AssetBundleManifest:
  AssetBundleInfos:
    Info_0:
      Name: cube
      Dependencies: {}
    Info_1:
      Name: scene
      Dependencies: {}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;做了个小测试，添加了两个新的AssetBundle，名字也不一样，每次添加这个文件的内容跟着变，并且CRC也在变。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ManifestFileVersion: 0
CRC: 2591254959
AssetBundleManifest:
  AssetBundleInfos:
    Info_0:
      Name: cube
      Dependencies: {}
    Info_1:
      Name: scene
      Dependencies:
        Dependency_0: sphere
        Dependency_1: capsule
    Info_2:
      Name: sphere
      Dependencies: {}
    Info_3:
      Name: capsule
      Dependencies: {}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;继续小测试，把Capsule的AssetBundle从capsule改为sphere。果然只是简单记录了下目录中的AssetBundle信息。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ManifestFileVersion: 0
CRC: 3856405611
AssetBundleManifest:
  AssetBundleInfos:
    Info_0:
      Name: cube
      Dependencies: {}
    Info_1:
      Name: scene
      Dependencies:
        Dependency_0: sphere
    Info_2:
      Name: sphere
      Dependencies: {}
      
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;再次小测试，在UI的AssetBundle设定中第一栏设定了多层次的名称结果如下。而且从文件夹结构上看one和two都是两个文件夹，而在two里面则是一个名为xx.three的文件。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ManifestFileVersion: 0
CRC: 2167406161
AssetBundleManifest:
  AssetBundleInfos:
    Info_0:
      Name: scene
      Dependencies:
        Dependency_0: sphere
    Info_1:
      Name: sphere
      Dependencies: {}
    Info_2:
      Name: one/two/xx.three
      Dependencies: {}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;shadershader-stripping&quot;&gt;shader剥离（Shader stripping）&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;如果AssetBundle中包含shader，unity编辑器会根据当前场景和光照贴图的设置来决定使用哪种Lightmap modes。这还意味着你在打包的时候需要将打开着一个配置的场景。我的理解是因为需要根据当前场景来作为因素来做某个事情，所以这个场景需要时打开的。&lt;/li&gt;
  &lt;li&gt;也可以指定一个场景用来计算光照贴图模式，这个在用命令行buildbundle时是必须的。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://docs.unity3d.com/uploads/Main/AssetBundleShaderStripping.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;引擎代码剥离&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;代码剥离这个事情是将没有在任何场景（特指Build Settings &amp;gt; Scene list中的场景）中使用的代码移除，减少了包的大小。不过只能用在iOS、Android和webGL。选择IL2CPP的是时候是默认打开的。而且顾名思义，只剥离引擎代码，你自己的代码不会被剥离。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://docs.unity3d.com/uploads/Main/BuildingAssetBundles-enginecodestripping.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;如果一个引擎代码在build的时候被剥离了，但是在运行时又被请求使用，那么就会报错，因为被剥离的代码无法再被访问。如何避免这个错呢？把player（此处我认为不是玩家的意思，而是引擎）可能用到的AssetBundle列出来，放置到一个manifest文件中，代码剥离系统使用这个文件中列出来的AssetBundle (along with the Scenes in the build)来确定哪些code需要保留。当一些平台或build不支持代码剥离，又或者没有勾选剥离时assetBundleManifestPath属性是被忽略的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;从代码角度来看就是&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;using UnityEngine;

using UnityEditor;

namespace AssetBundles

{

    public class BuildScript

    {

        public static void BuildPlayer()

        {

            BuildPlayerOptions buildPlayerOptions = new BuildPlayerOptions();   

            // example hard-coded platform manifest path

            buildPlayerOptions.assetBundleManifestPath = &quot;AssetBundles/iOS/iOS.manifest&quot;;

            // build the Player ensuring engine code is included for 

            // AssetBundles in the manifest.

            BuildPipeline.BuildPlayer(buildPlayerOptions);

        }

    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-4&quot;&gt;几个小工具代码&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;列出所有在build process中产生的AssetBundle的名称&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;using UnityEditor;
using UnityEngine;

public class GetAssetBundleNames
{
    [MenuItem (&quot;Assets/Get AssetBundle names&quot;)]
    static void GetNames ()
    {
        var names = AssetDatabase.GetAllAssetBundleNames();
        foreach (var name in names)
            Debug.Log (&quot;AssetBundle: &quot; + name);
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;一个asset发生改变时的监听，讲道理这个函数从说明到函数名都看着真么不协调。&lt;em&gt;从函数名看感觉是AssetBundle名字变化，但是说明又是AssetBundle中一个asset发生变化。&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;using UnityEngine;
using UnityEditor;

public class MyPostprocessor : AssetPostprocessor {

    void OnPostprocessAssetbundleNameChanged ( string path,
            string previous, string next) {
        Debug.Log(&quot;AB: &quot; + path + &quot; old: &quot; + previous + &quot; new: &quot; + next);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;assetbundle-3&quot;&gt;AssetBundle变体&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;这个玩意有什么意义呢？&lt;/li&gt;
  &lt;li&gt;下图中在后一个label中填入一个名字，就可以形成变体。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://docs.unity3d.com/uploads/Main/AssetBundle50Editor.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;从文档上看可以同一批asset创建不同的变体，而且在这些变体AssetBundle中asset有意义的内部ID。需要注意这样的变体AssetBundle的全名是由AssetBundle name + the variant name组成的，如果你创建了一个名为MyAssets.hd的AssetBundle，那它只是一个普通的AssetBundle而不是变体的。而且 “MyAssets”+“hd”和“MyAssets.hd”+”“不能同时存在因为它们具有相同的全称。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-5&quot;&gt;脚本建议&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;妈蛋总算快完了。&lt;/li&gt;
  &lt;li&gt;呵呵，我不打算写了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;typetrees&quot;&gt;Typetrees&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;默认写到AssetBundle中，但是metro除外，因为不同的序列化方案。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 14 Mar 2017 11:40:00 +0800</pubDate>
        <link>https://caihua.tech/2017/03/14/AssetBundle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1-%E6%A6%82%E8%BF%B0%E5%92%8C%E5%88%9B%E5%BB%BA/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/03/14/AssetBundle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1-%E6%A6%82%E8%BF%B0%E5%92%8C%E5%88%9B%E5%BB%BA/</guid>
        
        <category>AssetBundle学习笔记</category>
        
        
      </item>
    
      <item>
        <title>SendMessage测试</title>
        <description>&lt;ul&gt;
  &lt;li&gt;5.5.2中没有了以前那种参数是对象的SendMessage方法，WTF.&lt;/li&gt;
  &lt;li&gt;obj.SendMessage(“Foo”, 1, SendMessageOptions.DontRequireReceiver);如果设置了DontRequireReceiver，那么找不到Foo方法不会报错，如果没有写这个参数默认是RequireReceiver，则报错。&lt;/li&gt;
  &lt;li&gt;如果Foo的参数不对，会提示&lt;code class=&quot;highlighter-rouge&quot;&gt;MissingMethodException: The best match for method Foo has some invalid parameter.&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    public void Foo(string s)
    {
        Debug.Log(s);
    }

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;如果Foo是没有参数的，SendMessage有参数也没关系。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;总之最好指定的函数是存在的，参数是匹配的。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Wed, 08 Mar 2017 15:34:13 +0800</pubDate>
        <link>https://caihua.tech/2017/03/08/SendMessage%E6%B5%8B%E8%AF%95/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/03/08/SendMessage%E6%B5%8B%E8%AF%95/</guid>
        
        <category>Unity3D</category>
        
        
      </item>
    
      <item>
        <title>关于AssetBundle解压的讨论结果</title>
        <description>&lt;ul&gt;
  &lt;li&gt;一切的起源在于&lt;a href=&quot;《http://blog.uwa4d.com/archives/ABTheory.html》&quot;&gt;这篇文章&lt;/a&gt;，在文中对AssetBundle的加载进行了详细的描述，但是疑问也由此而生。以下是我在UWA讨论群的提问：
    &lt;blockquote&gt;
      &lt;p&gt;在讲WWW的时候有这样一段话【解压后的内容，通常为原Bundle文件的4~5倍大小，纹理资源比例可能更大】，在我理解就是www这样的方式获取到的资源（压缩形式的）会被解压缩，并放置到webstream中。而在【AssetBundle加载进阶】部分的【前者劣势】部分，又有【每次加载都涉及到解压操作】，请问这个【加载】指的是什么？是www.assetBundle还是AssetBundle.Load？还有【解压缩】是指的什么？不是在WWW的时候已经解压缩了吗？&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;张鑫大神是这样回答的
    &lt;blockquote&gt;
      &lt;p&gt;是这样的，我们所说的AssetBundle【加载】指的是New WWW（或其他加载AB的API）和www.assetbundle的统称，而真正的【解压】过程，是在New WWW进行的。同时，需要说明的是，这个是5.3版本之前Unity对于AssetBundle的处理方式，5.3版本后，由于Unity新增了LZ4压缩方式，所以如果AssetBundle在制作时已经是LZ4格式的，那么在加载时就已经不会在进行解压了。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;身为一个程序猿一定要弄清楚才行，所以有了另一个疑问
    &lt;blockquote&gt;
      &lt;p&gt;那么【每次加载都涉及到解压操作】是不是可以这样理解：对于new WWW实际是解压到webstream。而如果是用的LoadFromCacheOrDownload，那么资源是在磁盘的，所以在调用www.assetbundle时才做解压。或者正如你说的只要是加载AB的API，都会有一个解压过程。那么有个问题，如果使用直接获取AssetBundle的那些API，解压过程是怎样的呢？CreateFromFile是在调用assetbundle.load的时候从磁盘解压，CreateFromMemory是直接解压到webstream？还有个问题，对于WebStream来说，同一个www对象多次调用www.assetbundle方法时，得到了栈上的多个变量，但是这些变量都指向同一个WebStream中的对象吗？&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;其实在这里我犯了一个错误，就是对于资源最终放到磁盘上的AB来说在调用LoadFromCacheOrDownload和LoadFromFile（5.3之前是CreateFromFile）方法的过程中就已经解压缩了，LoadFromCacheOrDownload是上面文章中说明了我自己看漏了，但是LoadFromFile是有一个演进的过程的。
    &lt;blockquote&gt;
      &lt;p&gt;在5.3之前，如果需要解压，都在四个API（New WWW、CreateFromFile、LoadFromMemory、LoadFromCache等）中进行，而不是在后面执行&lt;/p&gt;

      &lt;p&gt;CreateFromFile在4.x的API，只能加载非压缩的AB，而在5.0以后，对应的是LoadFromFile，5.3之后可以加载任何压缩格式的AB了&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;至此可以总结一点就是&lt;strong&gt;&lt;em&gt;解压缩发生在New WWW、CreateFromFile、LoadFromMemory、LoadFromCache函数调用过程中&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;至于张鑫大神提到的LZ4不要解压缩这个事情，从&lt;a href=&quot;https://docs.unity3d.com/Manual/AssetBundleCompression.html&quot;&gt;文档&lt;/a&gt;上看LZ4还是需要解压缩的，只不过是基于块的，也就是说当你从LZ4文件中加载一个object的时候，只会解压缩这个object对应的压缩块，这个当然效率就高了很多。但是这句我甚是不解，如果一个LZ4文件压缩了一个很大的对象且只有这个对象，解压的时候难道不要时间？？在群里问完大神在来补充吧。
    &lt;blockquote&gt;
      &lt;p&gt;This occurs on-the-fly, meaning there are no wait times for the entire bundle to be decompressed before use.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;em&gt;第二天的更新&lt;/em&gt;：&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;看了文档也和群里讨论了一下，应该还是我理解上有误。所谓&lt;code class=&quot;highlighter-rouge&quot;&gt;5.3版本后，由于Unity新增了LZ4压缩方式，所以如果AssetBundle在制作时已经是LZ4格式的，那么在加载时就已经不会在进行解压了。&lt;/code&gt;的前提是在AB的基础上的，5.3以后的AB压缩格式3种：LZMA、LZ4和不压缩（Uncompressed Format，原文如此），LZMA是默认的AB压缩格式，unity在使用socket下载LZMA格式的文件时，一边下载，一边解压，并且一边压缩为LZ4。和大家讨论了下认为应该是考虑到传输的流量成本、节约内存和磁盘的空间，所以解压后再压缩为LZ4。一是因为LZMA压缩比高，适合传输，但是解压后会占用内容和磁盘空间比较大，而且是整体解压并且过程较慢，不适合用时在解压。所以解压后使用LZ4压缩一下节约空间，而且LZ4前面也说了是按需逐块解压的速度比较快，因此适合已经是内存中或者本地的解压。从这个角度说，如果直接AB压成LZ4就可以直接在需要的时候解压了，没有了解压再压缩的过程。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;最后还是要刷&lt;a href=&quot;https://unity3d.com/cn/learn/tutorials/topics/best-practices/guide-assetbundles-and-resources?playlist=30089&quot;&gt;这个&lt;/a&gt;才行。&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sun, 05 Mar 2017 23:15:13 +0800</pubDate>
        <link>https://caihua.tech/2017/03/05/%E5%85%B3%E4%BA%8EAssetBundle%E8%A7%A3%E5%8E%8B%E7%9A%84%E8%AE%A8%E8%AE%BA%E7%BB%93%E6%9E%9C/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/03/05/%E5%85%B3%E4%BA%8EAssetBundle%E8%A7%A3%E5%8E%8B%E7%9A%84%E8%AE%A8%E8%AE%BA%E7%BB%93%E6%9E%9C/</guid>
        
        <category>Unity3D</category>
        
        
      </item>
    
      <item>
        <title>游戏设计模式读书笔记：双缓冲</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;第三篇：序列模型&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;双缓冲模式算是书中第三篇：序列模型中的一个，它与游戏循环和更新方法组成了第三篇。后两者可以说是在我做Unity中最常用到的，而且也是游戏引擎本身已经实现了的。谨以&lt;a href=&quot;http://gpp.tkchu.me/sequencing-patterns.html&quot;&gt;下文&lt;/a&gt;来说明下序列模型部分的重要性。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;电子游戏之所有有趣，很大程度上归功于它们会将我们带到别的地方。 几分钟后（或者，诚实点，可能会更长），我们活在一个虚拟的世界。 创造那样的世界是游戏程序员至上的欢愉。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;大多数游戏世界都有的特性是时间——虚构世界以其特定的节奏运行。 作为世界的架构师，我们必须发明时间，制造推动游戏时间运作的齿轮。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;这本篇的模式是建构这些的工具。 游戏循环是时钟的中心轴。 对象通过更新方法来聆听时钟的滴答声。 我们可以用双缓冲模式存储快照来隐藏计算机的顺序执行，这样看起来世界可以进行同步更新。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section-1&quot;&gt;双缓冲&lt;/h2&gt;
&lt;h4 id=&quot;section-2&quot;&gt;一个典型的例子&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;这个例子非常经典，就是渲染时候的双缓冲。只有当一帧的色值数据完全计算出来后，才能在屏幕上展示出来，如果在计算的同时就开始渲染，那么屏幕只会出现一部分的色彩。所以我们在屏幕看到的色彩值其实往往是GPU算出的上一帧的数据。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-3&quot;&gt;使用场景&lt;/h4&gt;
&lt;blockquote&gt;
  &lt;p&gt;我们需要维护一些被逐步改变着的状态量。&lt;/p&gt;

  &lt;p&gt;同个状态可能会在其被修改的同时被访问到。&lt;/p&gt;

  &lt;p&gt;我们希望避免访问状态的代码能看到具体的工作过程。&lt;/p&gt;

  &lt;p&gt;我们希望能够读取状态但不希望等到写入操作的完成。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;section-4&quot;&gt;我对双缓冲的理解&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;说白了，双缓冲是为了维护完整性。它展示给外界的永远是一个完整的，已经准备好被使用的内容。在其内部，有一个缓冲是用于写入数据的，写入的过程可能是缓慢的，但是没关系，另一个缓冲已经做好了被使用的准备，外界读取的是这个已经写好的缓冲。&lt;/li&gt;
  &lt;li&gt;当写入完成时，两个缓冲互换，刚刚写完的这个缓冲变为准备被读取的一个，而被读取的缓冲开始作为写入缓冲使用。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-5&quot;&gt;设计决策&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;缓冲区如何交互？
    &lt;ul&gt;
      &lt;li&gt;在文中作者使用的是C++，因此交换只不过是一个指针重定向的过程。&lt;/li&gt;
      &lt;li&gt;如果不能指针重定向，就要考虑数据拷贝了。&lt;/li&gt;
      &lt;li&gt;C#中一个集合对象表现出来的也是一个指针（引用），可以直接做重定向。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;缓冲的粒度
    &lt;ul&gt;
      &lt;li&gt;书中提到两个粒度，一个是缓冲区是单个整体，也就是渲染的时候一个图像的内容就在一个缓冲区中。&lt;/li&gt;
      &lt;li&gt;另一种情况就是多个对象中都存在一个缓冲数据。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sat, 25 Feb 2017 16:43:13 +0800</pubDate>
        <link>https://caihua.tech/2017/02/25/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%8F%8C%E7%BC%93%E5%86%B2/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/02/25/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%8F%8C%E7%BC%93%E5%86%B2/</guid>
        
        <category>游戏设计模式读书笔记</category>
        
        
      </item>
    
      <item>
        <title>游戏设计模式读书笔记：观察者模式与事件队列</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;观察者模式&lt;/h2&gt;
&lt;h4 id=&quot;section-1&quot;&gt;定义&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F&quot;&gt;定义&lt;/a&gt;：在此种模式中，一个目标对象管理所有相依于它的观察者对象，并且在它本身的状态改变时主动发出通知。这通常透过呼叫各观察者所提供的方法来实现。此种模式通常被用来实时事件处理系统。&lt;/li&gt;
  &lt;li&gt;看图
&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/e/e2/Observer-pattern-class-diagram.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-2&quot;&gt;模式的理解&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;观察者模式由来已久，其目的就是为了解耦。观察对象保存观察者的链接，使得观察者与被观察者解耦。这一点与C#中的事件刚好相反。&lt;/li&gt;
  &lt;li&gt;传统的观察者模式也有其弊端。比如书中提到的使用链表作为观察者集合时，如果删除某个观察者需要遍历。并且每个观察者只有一个next指针的情况，这就使得它只能观察一个对象。当然作者也给出来解决的办法，就是使用链表节点池来解决一个观察者注册多个被观察者的问题。不过在C#的事件系统中这个是不需要的。&lt;/li&gt;
  &lt;li&gt;当出现被观察者或者观察者销毁时需要额外的注意。一个被观察者销毁产生的问题比较小，因为最多就是不发送消息了。而如果一个观察者销毁但是被观察者还不知道，那么被观察者会发送一个消息给空指针，这样问题就大。 在C#中这个问题也是一样的，当要dispose的时候，需要使用&lt;code class=&quot;highlighter-rouge&quot;&gt;-=&lt;/code&gt;操作来去掉观察引用。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-3&quot;&gt;观察则模式和事件的区别&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;长久以来我都认为C#中的事件就是观察者模式，当然实际上有所差别。因为按照经典的设计模式来说观察者是需要类的支持的，当你需要让某个对象可被观察，并为此创建几个观察者时你需要执行诸如继承这样的典型的面向对象编程，需要做一大摊子的事情。但是，很多情况下我们只是希望一个类中的某个对象被观察，也就是一个对象中可能发生多个&lt;code class=&quot;highlighter-rouge&quot;&gt;事件&lt;/code&gt;。这也是C#中事件系统所作的事情，在C#中我们观察的是一个对象，而不是一个事情。（参考原文的旁白说明。）&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;unity&quot;&gt;在unity中的使用&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;这个其实没啥说的，就按照标准的C#程序中使用事件的方式即可，只不过我比较习惯用Action或者Func来替代delegate+event。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-4&quot;&gt;事件队列&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;对于事件队列，不要只认为是事件，它也包含消息或者请求等等。按照我的理解来说就是一个具体要做的事情。&lt;/li&gt;
  &lt;li&gt;为何要把事件队列和观察者模式写到一起，因为在我看了它们的作用是一样的，就是为了解耦消息的发送者（被观察者）和接受者（观察者）。事件队列在复杂度上要高于观察者模式，这个是因为事件队列在时间上做了进一步的解耦。&lt;/li&gt;
  &lt;li&gt;怎么理解时间上的解耦？事件队列在接收到一个事件后，何时执行是不确定的。考虑到事件会带上发生时的数据，那么在执行时是不需要依赖时间的。&lt;/li&gt;
  &lt;li&gt;时间的解耦有个弊端，就是如果你需要实时反馈，那么这个做不到。&lt;/li&gt;
  &lt;li&gt;还有一个需要注意的是不要形成消息和处理者的循环。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-5&quot;&gt;消息汇总与合并&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;书中作者提到了一个声音播放系统，当队列中存在多个相同音频的请求时需要进行合并。当然这个是因为同一音频短时间内容播放会出现音爆。不过这个也提醒了我们，如果在实际的业务中有这样需要合并的时候，在每个update（也就是要开始执行某个事件时）中要进行合并。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-6&quot;&gt;如何实现队列&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;作者提到了循环缓冲区的问题，通过使用一个数组来实现消息队列，这样可以有效的减少内存的使用。不过我认为弊端就不好定一个数组的大小，如果过小可能来不及做循环，而如果太大一样存在内存的浪费。&lt;/li&gt;
  &lt;li&gt;从C#角度看，这个队列可以Queue来实现，可以说是完美契合的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-7&quot;&gt;设计决策&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;入队的是什么：
    &lt;ul&gt;
      &lt;li&gt;事件：如果是事件需要考虑多监听器的情况下让监听器做过滤。其实这个就是一个观察者模式。在这里就有点像异步观察者模式。&lt;/li&gt;
      &lt;li&gt;消息：一般消息都是一对一的，这个其实也是异步的意思。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;谁能从队列里读取：
    &lt;ul&gt;
      &lt;li&gt;事件的话轮到了执行就好，有没有监听者无所谓。如果是一个固定类型的消息，那么可能就是一个具体的业务的方法来获取队列中的消息了。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;谁能写入队列：
    &lt;ul&gt;
      &lt;li&gt;如果只有一个写入者，那么这个东西在时间上会执行的很快，和同步的观察者模式差不多。&lt;/li&gt;
      &lt;li&gt;如果是多个写入者，需要将发送方本身的引用加入到事件的数据当中。就像我们在C#中开发基于UI的程序一样，如果你有经验会知道每个事件处理函数中第一个参数总是某个具体的控件。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;队列中对象的生命周期
    &lt;ul&gt;
      &lt;li&gt;在我看来应该就是事件出队列时就是其周期的结束，当然因为GC的问题这个对象也许并不会立刻被销毁。&lt;/li&gt;
      &lt;li&gt;书中提到了可以将对象的所有权进行转移，到具体的执行方去。也可以让队列一直拥有它。这个方面我还没有觉得有这个必要保留对象，也许是没有遇到一个典型的例子吧。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Sat, 25 Feb 2017 13:11:05 +0800</pubDate>
        <link>https://caihua.tech/2017/02/25/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E4%B8%8E%E4%BA%8B%E4%BB%B6%E9%98%9F%E5%88%97/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/02/25/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E4%B8%8E%E4%BA%8B%E4%BB%B6%E9%98%9F%E5%88%97/</guid>
        
        <category>游戏设计模式读书笔记</category>
        
        
      </item>
    
      <item>
        <title>《Unity預計算即時GI》笔记：三、Clusters和总结</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;说明&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;这篇文章是对&lt;a href=&quot;http://unitytaiwan.blogspot.tw/2016/12/unity-gi-1.html&quot;&gt;《Unity預計算即時GI》&lt;/a&gt;这个系列文章的笔记。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;clusters&quot;&gt;Clusters&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;叢集，透過修改叢集(Clusters)也是一個降低Unity預計算流程所需要執行的工作數量的好方法。降低叢集數量也能提高執行時的效能。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;當採用PRGI來計算場景光照時，Unity會簡化產生一個立體像素化結構的計算，這些立體像素(Voxel)叫做叢集。叢集實際上是反映到場景靜態幾何表面用於照明的表面，叢集用一種層級關聯的結構來儲存，用來預計算Unity的全域光照漫反射所需要的複雜運算。雖然叢集和光照圖很像，但兩者用途是各自獨立的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;通过设置CPU Usage即可。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;微調光照參數&lt;/h2&gt;

&lt;h4 id=&quot;section-2&quot;&gt;创建&lt;/h4&gt;
&lt;blockquote&gt;
  &lt;p&gt;要建立一個Lightmap Parameters資源，先找到Project視窗,
從Create下拉選單建立(Create &amp;gt; Lightmap Parameters)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;我們也可以在Project介面裡按右鍵選(Asset &amp;gt; Create &amp;gt; Lightmap Parameters) 來建立。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;section-3&quot;&gt;使用&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;從Hierarchy介面選擇你要指定變數集的物件，物件必須是帶有Mesh Renderer元件的靜態物件。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;開啟Lighting介面(Window &amp;gt; Lighting)並選擇Object頁籤&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;從Advance Parameters下拉選單指定你的變數集給物件，右邊的”Edit”按鈕是開啟編輯光照變數的捷徑。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-4&quot;&gt;光照參數集說明&lt;/h3&gt;

&lt;h4 id=&quot;resolution&quot;&gt;Resolution&lt;/h4&gt;
&lt;blockquote&gt;
  &lt;p&gt;解析度的值確訂了物件採用的光照貼圖解析，這個值會和Lighting介面裡的解析度做加乘。比如說，如果場景解析度設為2，這裡的解析度設為0.5，那所有帶有這個參數集的物件都會採用1texel/unit來計算光照貼圖。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;这个&lt;code class=&quot;highlighter-rouge&quot;&gt;Lighting介面裡的解析度&lt;/code&gt;指的是&lt;a href=&quot;https://unity3d.com/cn/learn/tutorials/topics/graphics/fine-tuning-lightmap-parameters?playlist=17102&quot;&gt;Scene-wide Realtime Resolution specified in the Scene tab of the Lighting window&lt;/a&gt;，翻译的时候没说清楚啊。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;irradiance-budget&quot;&gt;Irradiance Budget&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://unity3d.com/sites/default/files/dappling.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;解析度值很大光照貼圖所產生的影子斑點可以把Irradiance Budget這個參數調高來獲得緩解。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;注意，當解析度值很大時，在較低解析度下可能會產生奇怪的陰影，這些陰影在最終的光照貼圖裡可能看起來像是斑點或髒汙。如果有這種情況可以試著把Irradiance Budget參數提高來獲得改善。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;cluster-resolution&quot;&gt;Cluster Resolution&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;叢集解析度用來決定1個像素裡能有多少叢集數量。假如這個值設為1，代表光照圖裡面每個像素都都會有一個叢集，0.5代表一個像素會有2個叢集，換句話說叢集會是光照圖的兩倍大。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;imagine our Scene’s global Realtime Resolution was set to 1. We create a cube with a size of 1x1x1 units, and then assign a Lightmap Parameters asset to this object. If our Lightmap Parameters asset specified a Resolution of 1 and a Cluster Resolution of 1, we would have 1 Cluster per side of the cube. If we then increased our Resolution to 2, the result would be 2x(1x1) Clusters per side of the cube, giving 4 Clusters.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;將光照貼圖解析和叢集解析度保持指定比例，這樣我們可以和場景整體的解析度建立一個相對關係。我們可以把Lighting介面裡面的解析度定義為高解析度作為整體設定，然後針對個別物
件微調各自的光照參數集。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;说白了，数值越大单位像素上cluster越多，与计算时间越长。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;irradiance-budget-1&quot;&gt;Irradiance Budget&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;我們之前說明過光照計算是如何用叢集來計算靜態物件的預計算光照，在預計算的過程裡，叢集之間的關係被建立起來，好讓光線得以在叢集網內快速傳遞。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;在本質上，光照貼圖像素值的算法是基於叢集從該像素的位置對場景的一個檢視所計算得來，這會讓我們可以很快計算叢集之間的光照反射最後產生一個全域光照，這些叢集就能在畫面渲染完之前給予適當的樣本數。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Irradiance Budget(輻照度範圍)用來制訂當叢集採樣時每個光照貼圖像素所使用到的記憶體量，&lt;strong&gt;這會決定照明結果的精度，數值太低代表每個貼圖像素在記錄時使用較少記憶體同時提升CPU效能，代價就是會失真，數值越低光照結果會越模糊。反過來看，數值拉高GI會更準確，但記憶體和CPU的消耗都會提升。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;越低效率越高，适合大精细的模型，很大、模糊或者遥远的模型。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;irradiance-quality&quot;&gt;Irradiance Quality&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;當計算PRGI時，每個光照貼圖像素會開始對場景投出射線，然後將可視資料報告給附近的叢集，然後貼圖像素就會得到每個叢集的百分比數值，這個值用來定義光照貼圖裡每個像素從叢集所分到的可視數據，&lt;strong&gt;而一欄設定就是用來設定每個像素能對場景投射多少射線。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果場景裡的物件和周圍物件光照不合的情況下可以斟酌加大這個值，有時該暗的時候光照結果卻意想不到的亮，有可能是因為投射到場景的射線不足或遮擋到，導致漏算叢集資料。同樣該亮的的放如果射線沒有檢查到，可能會造成過暗。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;提高射線的投射量就能解決類似的問題，代價就是增加預計算的時間，要優化這個時間，我們應該找出最適合的值來達到我們理想的照明效果。請注意，這個值不會影響到Runtime時的效能。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;-还是越大越耗性能。&lt;/p&gt;

&lt;h4 id=&quot;backface-tolerance&quot;&gt;Backface Tolerance&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;當射線從光照貼圖像素投射出，從場景叢集蒐集光線時有時會打到幾何的背面，當計算全域光照時我們只需要關心投射到物體表面的光照，從背面來的光照資源通常都會忽略掉，這些從背面來的光照資料會破壞光照結果，因此調整這個值能防止這類情況發生。
&lt;img src=&quot;https://unity3d.com/sites/default/files/backfacetolerance.png&quot; alt=&quot;image&quot; /&gt;
這裡的地板上的陰影就是Unity在計算期間從物件無效的背面所創造的，增加Backface Tolerance能改善這個問題。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Backface Tolerance必須指定從前方光源來的百分比，好讓正面的像素被判定為有效。假如一個貼圖像素沒通過測試，Unity會採用鄰近的像素值嘗試算得正確光照資料。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;調整這個值並不會影響PRGI運算效能，也不會對預計算時間長度有太大影響。反而是蠻適合在調整Irradiance Budget都無法解決的場景貼圖太亮或太暗問題時，Backface tolerance會是一個不錯的除錯工具。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;調整這個值並不會影響PRGI運算效能，也不會對預計算時間長度有太大影響。2333333333&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-5&quot;&gt;总结&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;學習如何評估專案場景並決定適合的光照解析度
了解光照圖，PRGI過程中最耗效能的元素之一，並學習如何降低它的數量。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;核心，需掌握。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;學習如何幫小物件設定光照探針。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;蛋疼的玩意。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;學習如何調整Unity的預計算參數，讓拆UV過程可以減少光照圖的數量。
了解甚麼是叢集，如何使用與它對全域光照的影響。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;核心，需掌握。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;學習如何微調影響場景物件的光照貼圖變數，在不失真的情況下還能提高預計算效能。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;还是比较有用的，主要还是通过影响cluster。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;个人总结：这个系列的文章本质上是讲的如何减少光照图。通过改变分辨率、优化UV展开的结果等手段来实现。不过这篇文章如果单纯的看有点单薄，建议结合&lt;a href=&quot;http://mp.weixin.qq.com/s/uYX4T-fTgWxz_fWr6G4dPA&quot;&gt;《Unity 5 中的全局光照技术详解！》&lt;/a&gt;这篇文章看。回头看完在写笔记。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-6&quot;&gt;这个系列文章中提到的一些有意思的点&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;PRGI只會呈現場景裡的漫反射(diffuse)和間接照明&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Unity的拆解演算法會嘗試把不同Shell做調整將UV邊緣拼接在一起來簡化UV貼圖&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在某些情況下，網格匯入器可能會拆開幾何圖形。例如，如果有個網格有非常多的三角面，Unity可以為了效能把它分割成幾個獨立的子網格。通常這麼做是為了符合特定硬體需求，例如為了減少每個Draw Call所需要呼叫的三角面數量。分割通常會發生在相鄰的網格面之間法向角度有大變化的區域，比如銳角邊(hard edges)。這樣的拆分網格方式會在模型導入流程時執行，在這個過程中，UV Shell也可能會被拆分開來放到不同的光照圖，造成額外的光照圖消耗。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;當計算PRGI時，每個光照貼圖像素會開始對場景投出射線，然後將可視資料報告給附近的叢集，然後貼圖像素就會得到每個叢集的百分比數值，這個值用來定義光照貼圖裡每個像素從叢集所分到的可視數據&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;當計算PRGI時，每個光照貼圖像素會開始對場景投出射線，然後將可視資料報告給附近的叢集，然後貼圖像素就會得到每個叢集的百分比數值，這個值用來定義光照貼圖裡每個像素從叢集所分到的可視數據。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Wed, 22 Feb 2017 22:47:53 +0800</pubDate>
        <link>https://caihua.tech/2017/02/22/Unity%E9%A0%90%E8%A8%88%E7%AE%97%E5%8D%B3%E6%99%82GI-%E7%AC%94%E8%AE%B0-%E4%B8%89-Clusters%E5%92%8C%E6%80%BB%E7%BB%93/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/02/22/Unity%E9%A0%90%E8%A8%88%E7%AE%97%E5%8D%B3%E6%99%82GI-%E7%AC%94%E8%AE%B0-%E4%B8%89-Clusters%E5%92%8C%E6%80%BB%E7%BB%93/</guid>
        
        <category>Unity預計算即時GI笔记</category>
        
        
      </item>
    
      <item>
        <title>《Unity預計算即時GI》笔记：二、光照图</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;说明&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;这篇文章是对&lt;a href=&quot;http://unitytaiwan.blogspot.tw/2016/12/unity-gi-1.html&quot;&gt;《Unity預計算即時GI》&lt;/a&gt;这个系列文章的笔记。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;光照图&lt;/h2&gt;

&lt;h3 id=&quot;section-2&quot;&gt;什么是光照图&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;光照图在第三章中有如下的定义，读起来很是费解。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;一個光照圖(Chart)是表示一個光照貼圖的區域，用來映射場景物件的光照貼圖UV。你可以想像是能影響物件的一張小磁磚圖，一張光照圖由兩部分組成:輻照度(照明)和方向性(主要光線方向編碼)。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;到了第六章又有如下讲解，读完之后我更加费解了，所以暂时搁置吧。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;產生光照圖(Charts)的目的主要是用來包住靜態網格著色器(Static Mesh Renderer)的UV貼圖座標。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-3&quot;&gt;如何生成&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;一個物件所需要的光照圖數量主要是看物件有多少片UV shell需要拆解。所謂拆UV的學問就是保持幾何面上貼圖像素扭曲度和所需的Shell數量之間的平衡。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;光照圖是在網格導入流程的一個拆解階段(Unwrapping stage)被產生出來的。對於PRGI來說，這些光照圖會在預計算裡的幾何階段(Geometry stage)被打包到不同的圖集(Atlas)裡，這是為了確保它們不會相互重疊。一旦預計算的幾何階段完成之後就會產生可視化數據，我們就能預覽光照圖。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;这个部分要结合&lt;a href=&quot;http://unitytaiwan.blogspot.tw/2016/12/unitygi-6.html&quot;&gt;原文&lt;/a&gt;的图来看，从这个部分的文章中可以看到，在模型导入时决定了它需要几个光照图，而&lt;code class=&quot;highlighter-rouge&quot;&gt;場景裡面有大量的光照圖可能會是PRGI耗時的原因之一&lt;/code&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;从上下文的介绍来看，光照图是光照贴图的映射，记录了实时计算的结果，当计算光照时，需要从中提取信息。&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;看看下列範例圖:&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://unity3d.com/sites/default/files/unwrap01.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;這樣的UV拆解不會變形，但需要多張UV shells&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://unity3d.com/sites/default/files/unwrap02.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;用單一UV shell所產生的結果，但貼圖變形很嚴重&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://unity3d.com/sites/default/files/unwrap03.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;比較理想的結果，單一UV shell且貼圖沒有變形&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;從上面我們可以看到三個拆UV不同的例子&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;從第一張圖裡我們可以看到做為貼圖的棋盤格圖案像磁磚一樣保持比例的貼在方塊表面上並沒有變形。試想如果這個棋盤圖案是一個光照貼圖(一個打在物件上的光照圖像)，我們會得到一個視覺上看起來沒有問題的結果，只是會需要耗費六個UV shells。那就表示待會用Unity PRGI計算的時候也會產生六張光照圖，不管條件如何，每個光照圖最少都需要4x4個貼圖像素來表示，還沒考慮解析度之前最少就會耗掉96個像素。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;在第二張圖裡我們會遇到不同的狀況，物件的UV貼圖座標只用一個UV shell就涵蓋所有範圍，雖然這樣所產生的光照圖最少，但視覺效果卻不是我們要的。我們會看到物件表面上的貼圖歪掉了，貼圖在UV空間裡也相互重疊，代表如果這是一張光照貼圖，物件一面的光照可能會錯投到相反面上。很明顯的這種拆法是有問題的。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;**第三張圖的結果比較理想，棋盤沒有扭曲，磁磚比例也保持正方形。而且還成功用一張UV shell覆蓋物體的所有面。屆時透過連接或縫合對應在模型上的邊緣來把位置合上。 
如果用技術的邏輯來看，整個過程做了哪些事情呢? 首先，我們會將UV圖用正交投影(Orthogonal Projection)在物件上來產生獨立的Shell，然後我們就會分析哪些Shell和物件的邊緣有相連關係，一旦我們找到了這些邊緣，我們就會把UV shell的內容移進去並和相鄰的Shell縫合起來。 **&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-4&quot;&gt;如何查看已经生成的光照图&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;首先需要生成LightingData数据，将场景中的模型勾选static，然后在light window中点击build(也可以选择Auto) 。&lt;/li&gt;
  &lt;li&gt;场景窗口中选择，&lt;code class=&quot;highlighter-rouge&quot;&gt;UV Charts模式會把場景裡不同光照圖用不同顏色表示&lt;/code&gt;
&lt;img src=&quot;https://unity3d.com/sites/default/files/charting.png&quot; alt=&quot;image&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-5&quot;&gt;如何减少光照图&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;需要对以下几个参数进行设置&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://unity3d.com/sites/default/files/maxdistance.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;先放一下原模型的图，后续会有大量的结果图。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://images2015.cnblogs.com/blog/23250/201702/23250-20170214120221660-1264214124.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;auto-uv-max-distanceuv&quot;&gt;Auto UV Max Distance(自動最大UV距離)&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;Unity的拆解演算法會嘗試把不同Shell做調整將UV邊緣拼接在一起來簡化UV貼圖。當Shell放入後還能保持在Auto UV Max Distance規定的範圍內時才會被考慮進來。這個範圍是用Unity的世界空間座標來定義的，在我們的範例裡是1米。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;在許多情況下，預設的0.5就能給出不錯的結果，但對於具有大面積的特大物件可能要提高這個值來防止本來應該被縫合的UV圖被演算法排除在外。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;增加這個值通常會讓物件所需的光照圖數量減少，而降低這個值通常有助於解決貼圖像素被拉扯的問題，當然就會需要產生更多的光照圖來覆蓋。改變這個值後你可以透過檢視場景UV Charts繪製模式，從覆蓋的棋盤圖來評估並實驗出一個最好的平衡點。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;这个属性应该是用于控制拼接UV图的，值越大就会使得原本一些间距比较大的shell能够进行合并，这样就可以减少光照图的数量。&lt;/li&gt;
  &lt;li&gt;做了一个简单的测试，分别设置为0.1、0.5、0.8。明显可以看出来，当数值很小的时候会分出更多的光照图，而且从浅蓝色线条可以看出是模型的边。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://images2015.cnblogs.com/blog/23250/201702/23250-20170213125059160-379163503.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Auto UV Max Distance:0.1  /  Auto UV Max Angle:89&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2015.cnblogs.com/blog/23250/201702/23250-20170213125103254-453985663.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Auto UV Max Distance:0.5  /  Auto UV Max Angle:89&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2015.cnblogs.com/blog/23250/201702/23250-20170213125105004-1204223525.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Auto UV Max Distance:0.8  /  Auto UV Max Angle:89&lt;/p&gt;

&lt;h4 id=&quot;auto-uv-max-angleuv&quot;&gt;Auto UV Max Angle(自動最大UV角度)&lt;/h4&gt;
&lt;blockquote&gt;
  &lt;p&gt;提高這個值會讓Unity的演算法更容易組合UV圖，這也表示能透過這個功能來降低單一物件的光照圖數量，但是如果設的太寬鬆有時候會出現貼圖被拉扯的狀況。反之降低這個值會造成演算法不好把相鄰的UV排一起，雖然拉扯的情況會降低但是會產生更多光照圖。相同，檢視UV Charts繪製模式裡的棋盤圖並試出一個最適合的值。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;基本原理和Auto UV Max Distance一直，更大的数值使得更多比较扭曲的UV Shell能够合并，弊端也说的比较明确。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;以下仍旧是一组对比图&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://images2015.cnblogs.com/blog/23250/201702/23250-20170214111950769-2033724574.jpg&quot; alt=&quot;image&quot; /&gt;
Auto UV Max Distance:0.5  /  Auto UV Max Angle:50&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2015.cnblogs.com/blog/23250/201702/23250-20170213125103254-453985663.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Auto UV Max Distance:0.5  /  Auto UV Max Angle:89&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2015.cnblogs.com/blog/23250/201702/23250-20170214112002129-1529342405.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Auto UV Max Distance:0.5  /  Auto UV Max Angle:120&lt;/p&gt;

&lt;h4 id=&quot;preserve-uvsuv&quot;&gt;Preserve UVs(保留UV)&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;在某些情況下，自動拆UV如果無法獲得理想結果，可能會產生過多的光照圖或是貼圖失真(GI Charts繪製模式可以做拉扯檢查)。在這種情況下可能需要在模型的UV01通道手動建立UV。這必須要在其他工具完成。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果這種情況發生，我們可以在Preserve UVs選項讓Unity演算法強制採用模型UV01通道指定的UV Shell。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;當需要手動保持UV圖時，Preserve UVs選項很有用&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;要注意的是這些Shell會被重新打包來節省光照貼圖空間，它們會被單獨解開保留，而不是只有把在光照貼圖內的座標記錄起來而已。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;使用這個功能時必須小心，當指定的UV貼圖包含著大量的UV shells時，這個功能可能會讓預計算的時間拉長，因為Unity的拆解演算法被跳過，手動保留的UV Shells到時候會全餵給預計算流程。記住，最好的結果是儘可能的降低UV shells和光照圖並保持可以接受的貼圖拉扯範圍。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;感觉大多数时间是不需要这个东西的，即使unity自己UI展开的不好如果不伤大雅也可以不用。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;生成的图放到下面进行对比&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;ignore-normals&quot;&gt;Ignore Normals(忽略法線)&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;在某些情況下，網格匯入器可能會拆開幾何圖形，這也會影響到光照圖的數量。例如，如果有個網格有非常多的三角面，Unity可以為了效能把它分割成幾個獨立的子網格。通常這麼做是為了符合特定硬體需求，例如為了減少每個Draw Call所需要呼叫的三角面數量。分割通常會發生在相鄰的網格面之間法向角度有大變化的區域，比如銳角邊(hard edges)。這樣的拆分網格方式會在模型導入流程時執行，在這個過程中，UV Shell也可能會被拆分開來放到不同的光照圖，造成額外的光照圖消耗。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;信息量略大，首先为了减少Draw Call时三角形面数过多，unity在导入网格是进行拆分，自然这就导致了产生一些多余的UV Shell。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Ignore Normals選項可以防止模型在匯入時光照圖被拆開&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;有時候放著上述的問題不管不太值得，得到的結果讓光照圖數量增加拉長了預計算的時間，還有可能在照明的接縫造成不必要的視覺假象。在這樣的情況下，啟用Ignore Normals選項有助於防止光照圖在預計算的時候被分割開來。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;請注意，這個選項只有對預計算即時光照(PRGI)有影響，物件被拆分的網格仍然會被保留以用在其他用途。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;挺好，只是为了PRGI，正常的网格还是会被拆分已做别的用途。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;最后放下结果对比&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://images2015.cnblogs.com/blog/23250/201702/23250-20170214113959175-1239106089.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Auto UV Max Distance:0.5  /  Auto UV Max Angle:89 / 使用模型UV&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2015.cnblogs.com/blog/23250/201702/23250-20170213125103254-453985663.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Auto UV Max Distance:0.5  /  Auto UV Max Angle:89&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2015.cnblogs.com/blog/23250/201702/23250-20170214114011285-1460825901.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Auto UV Max Distance:0.5  /  Auto UV Max Angle:89  / 忽略法线&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;目测这个模型按照默认设置效果就挺好的。&lt;/li&gt;
  &lt;li&gt;后续讲了一些实际的操作，还是自己读文章吧。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-6&quot;&gt;光照图总结&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;目前来看整个PRGI的大头在于光照图，而如何减少光照图是重中之重。&lt;/li&gt;
  &lt;li&gt;参数虽然都已经很清楚，而且UV Charts中可以看到具体的效果。不过，在多个模型的场景中每个模型做优化也是个很费时间的事情。&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Wed, 22 Feb 2017 22:46:02 +0800</pubDate>
        <link>https://caihua.tech/2017/02/22/Unity%E9%A0%90%E8%A8%88%E7%AE%97%E5%8D%B3%E6%99%82GI-%E7%AC%94%E8%AE%B0-%E4%BA%8C-%E5%85%89%E7%85%A7%E5%9B%BE/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/02/22/Unity%E9%A0%90%E8%A8%88%E7%AE%97%E5%8D%B3%E6%99%82GI-%E7%AC%94%E8%AE%B0-%E4%BA%8C-%E5%85%89%E7%85%A7%E5%9B%BE/</guid>
        
        <category>Unity預計算即時GI笔记</category>
        
        
      </item>
    
  </channel>
</rss>
