<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>蔡华的博客</title>
    <description>Be publicly useful and privately happy.</description>
    <link>https://caihua.tech/</link>
    <atom:link href="https://caihua.tech/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Fri, 26 Jan 2018 00:19:34 +0800</pubDate>
    <lastBuildDate>Fri, 26 Jan 2018 00:19:34 +0800</lastBuildDate>
    <generator>Jekyll v3.2.1</generator>
    
      <item>
        <title>七周七并发模型：线程与锁</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;为何使用多线程和锁&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;为了能够并行的计算一些东西&lt;/li&gt;
  &lt;li&gt;因为在多线程下，如果要修改同一个对象是值会出现竞态条件（即代码行为取决于各操作的时序）。它的表现可能是值的不对，甚至某些时候这个值的前半段是一个线程修改的，后半段是另一个线程修改的。因为这个对象可能不是原子的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;锁，或者说是并行控制的进化&lt;/h2&gt;

&lt;h3 id=&quot;section-2&quot;&gt;第一阶段：锁与同步方法&lt;/h3&gt;

&lt;h4 id=&quot;section-3&quot;&gt;基础的锁&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;从代码层面看就是一个lock函数&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-4&quot;&gt;同步方法&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;在java或者C#中可以通过attribute来让方法同步执行，但是这个的效率是很低的。&lt;/li&gt;
  &lt;li&gt;同时还引出了另外一个问题，当同时使用多个锁的时候不但效率会进一步降低，而且容易产生死锁。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-5&quot;&gt;基础锁带来的问题&lt;/h4&gt;

&lt;h5 id=&quot;section-6&quot;&gt;死锁&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;当出现多个锁的时候，因为执行顺的问题，导致多个对象都持有一个锁，同时在等待其他人释放锁。例子就是哲学家进餐问题。&lt;/li&gt;
  &lt;li&gt;哲学家进餐问题的解决方法就是:
    &lt;blockquote&gt;
      &lt;p&gt;一个线程想使用多把锁时，就需要考虑死锁的可能。幸运的是，有一个简单的规则可以避开死锁——总是按照一个全局的固定的顺序获取多把锁。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-7&quot;&gt;外星方法问题&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;所谓外星方法指的是在锁的block中调用了一个外部的方法，但是这个方法中可能会要求获得当前锁的权限，但是因为这个锁正在被使用，导致了代码出现死锁。&lt;/li&gt;
  &lt;li&gt;解决方案：
    &lt;ul&gt;
      &lt;li&gt;唯一的解决思路是避免持有锁时调用外星方法；&lt;/li&gt;
      &lt;li&gt;一种方法是在遍历之前对listeners进行保护性复制（defensive copy），再针对这份副本进行遍历；&lt;/li&gt;
      &lt;li&gt;PS：但是我的理解是这个情况只有当数据是并发read时，如果是并发的write想来就有问题了。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-8&quot;&gt;第二阶段： 进击的锁&lt;/h3&gt;
&lt;h4 id=&quot;section-9&quot;&gt;中断死锁&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;死锁问题是很让人沮丧的，而且也是很多时候都会遇到的。在我们的C#代码中使用lock来做锁，如果遇到死锁，我们是没有办法终止这个被锁的线程的。但是好在还有办法可以结束锁，在java中就是书中说的&lt;code class=&quot;highlighter-rouge&quot;&gt;ReentrantLock &lt;/code&gt;，对应的在C#中是&lt;code class=&quot;highlighter-rouge&quot;&gt;Monitor&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;PS：java的部分可以看下&lt;a href=&quot;http://blog.csdn.net/lipeng_bigdata/article/details/52154637&quot;&gt;这篇文章&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;PS2：两个类的功能基本是一致的，都包含了超时的功能。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-10&quot;&gt;问题是否得到了解决？&lt;/h4&gt;
&lt;blockquote&gt;
  &lt;p&gt;虽然tryLock()方案避免了无尽地死锁，但这并不是一个足够好的方案。首先，这个方案并不能避免死锁——它只是提供了从死锁中恢复的手段。其次，这个方案会受到活锁现象的影响——如果所有死锁线程同时超时，它们极有可能再次陷入死锁。虽然死锁没有永远持续下去，但对资源的争夺状况却没有得到任何改善。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;有一些方法可以减小活锁的几率。比如为每个线程设置不同的超时时间，来减少所有线程同时超时的几率。但通过设置超时来处理死锁不能说是一个好的方案——以后我们还可以做得更好。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;section-11&quot;&gt;条件变量&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;C#中的Monitor有wait、Pulse和PulseAll，对应了ReentrantLock的&lt;code class=&quot;highlighter-rouge&quot;&gt;reachSixCondition&lt;/code&gt;对应。用法参考&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.threading.monitor.pulse.aspx&quot;&gt;这里&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;该方法可以显著调高并发度&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-12&quot;&gt;原子变量&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;C#中可以使用Interlocked.Increment来做计算，这个是原子性的。在计数类的场景比较实用。&lt;/li&gt;
  &lt;li&gt;这个是为了解决基础锁使用过程中对于数据的操作比较繁琐的问题。比如对于计数类的变量，需要保证其get\set都有锁的保护，这样写的方法就比较多了。&lt;/li&gt;
  &lt;li&gt;原子变量是无锁（lock-free）非阻塞（non-blocking）算法的基础，这种算法可以不用锁和阻塞来达到同步的目的。无锁的代码比起有锁的代码更为复杂。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-13&quot;&gt;第三阶段：终极形态&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;书中以一个大数据的单词解析为例。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-14&quot;&gt;线程池&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;好处就是可以节约线程数，因此往往不能无限制的使用多线程。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;影响线程池最优大小的因素有很多，例如硬件的性能、线程任务是CPU密集型还是IO密集型、是否有其他任务在同时运行。还有很多其他原因也会产生影响。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;话虽如此，但也存在经验法则：对于CPU密集型的任务，线程池大小应接近于可用核数；对于IO密集型的任务，线程池可以设置得更大些。
当然，最佳的方法是建立一个真实环境下的压力测试来衡量性能&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;section-15&quot;&gt;解决方案的进化&lt;/h4&gt;

&lt;h5 id=&quot;section-16&quot;&gt;生产者消费者模式&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;将数据的解析与计算分割为生产者与消费者。从而分析出性能的瓶颈在消费者（统计单词量）这边。&lt;/li&gt;
  &lt;li&gt;使用多线程分别进行生产和消费。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;关键在于生产者和消费者可能不会（几乎肯定不会）保持相同的速度。比如，当生产者的速度快于消费者的速度时，队列会越来越大。Wikipedia的dump差不多有40 GiB，很容易就让队列大小超过内存容量。
相比之下，阻塞队列只允许生产者的速度在一定程度上超过消费者的速度，但不会超过很多。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&quot;section-17&quot;&gt;消费者端的并发执行&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;将解析出来的数据放入到一个HashMap中&lt;/li&gt;
  &lt;li&gt;在计算上，使用多线程来对HashMap进行统计，但是真正的计算方法本身采样lock。&lt;/li&gt;
  &lt;li&gt;问题是从结果统计看并没有提高效率。其原因为：&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;答案是因为过度竞争——过多的线程尝试同时使用一个共享资源。在我们的程序中，消费者花费大量时间等待被其他消费者锁住的counts，它们的等待时间比实际运算时间还要长，最终导致惨烈的性能下降。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&quot;concurrenthashmap&quot;&gt;使用ConcurrentHashMap来解决共享资源的并发访问&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;C#中对应的是&lt;code class=&quot;highlighter-rouge&quot;&gt;ConcurrentDictionary&amp;lt;TKey, TValue&amp;gt;.AddOrUpdate Method (TKey, TValue, Func&amp;lt;TKey, TValue, TValue&amp;gt;)&lt;/code&gt;。也就是并发集合，依赖于内置的并发集合来提高并发的访问。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;concurrenthashmap-1&quot;&gt;使用多个ConcurrentHashMap&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;使用ConcurrentHashMap并没有完全的释放多核的威力。&lt;/li&gt;
  &lt;li&gt;对原来的数据进一步拆分，进而分配给不同的线程来统计，极大的利用了多核。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-18&quot;&gt;优缺点&lt;/h2&gt;
&lt;h4 id=&quot;section-19&quot;&gt;优点&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;线程与锁模型的最大优点是其适用面很广。它是其他许多技术的基础，适用于解决很多类型的问题。同时，线程与锁模型更接近于“本质”——近似于对硬件工作方式的形式化——正确使用时，其效率很高。这也意味着它能够解决从小到大不同粒度的问题。&lt;/li&gt;
  &lt;li&gt;另外，这个模型可以被轻松地集成到大多数编程语言中。语言设计者们可以轻易让一门指令式语言或面向对象语言支持线程与锁模型。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-20&quot;&gt;缺点&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;线程与锁模型没有为并行提供直接的支持。&lt;/li&gt;
  &lt;li&gt;线程与锁模型仅支持共享内存模型。如果要支持分布式内存模型（无论是地理分布型或者容错型），就需要寻求其他技术的帮助。这也意味着线程与锁模型不适用于单个系统无力解决的问题。&lt;/li&gt;
  &lt;li&gt;多线程的难点不在于难以编程，而在于难以测试。&lt;/li&gt;
  &lt;li&gt;我们要全程保证所有对象的同步都是正确的、必须按照顺序来获取多把锁、持有锁时不调用外星方法。&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Wed, 17 Jan 2018 00:01:05 +0800</pubDate>
        <link>https://caihua.tech/2018/01/17/%E4%B8%83%E5%91%A8%E4%B8%83%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B-%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%94%81/</link>
        <guid isPermaLink="true">https://caihua.tech/2018/01/17/%E4%B8%83%E5%91%A8%E4%B8%83%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B-%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%94%81/</guid>
        
        <category>并发模型</category>
        
        
      </item>
    
      <item>
        <title>侯捷C++学习笔记：对象的创建和销毁</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;概述&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;本文会记录CPP中对象的创建和销毁的过程中的细节&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;big-three&quot;&gt;big three函数&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;拷贝构造函数&lt;/li&gt;
  &lt;li&gt;拷贝赋值函数&lt;/li&gt;
  &lt;li&gt;析构函数&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-1&quot;&gt;用途：这三个函数是在类中包含了指针的情况下使用的。&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;当有一个成员变量是一个指针时，就有了给这个变量赋值的问题。如果这个赋值需要深拷贝，那么就需要申请内存空间。这样在析构函数中就需要对指针进行delete。&lt;/li&gt;
  &lt;li&gt;这个成员变量可以是在对象构造函数中被赋值的，比如是个拷贝构造函数。也可以是在拷贝赋值函数中被赋值的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;对象创建&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Complex c1(1,2)&lt;/code&gt;这样的形式还是&lt;code class=&quot;highlighter-rouge&quot;&gt;Complex* c2 = new Complex(1,2)&lt;/code&gt;这样的形式，都可以创建对象。&lt;/li&gt;
  &lt;li&gt;构造函数不能直接被指针调用&lt;code class=&quot;highlighter-rouge&quot;&gt;p-&amp;gt;P::P()&lt;/code&gt;，这样写在某些编译器下可以通过编译但是某些不行。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;new&quot;&gt;new做了什么&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://imglf0.nosdn.127.net/img/Nld0N0tacnNuUGtzTWNrbTJLM0pKZXdRcjVXdmlqelZyVUZlU3pqajNjazBUdk80Rm1yYlJRPT0.png?imageView&amp;amp;thumbnail=1680x0&amp;amp;quality=96&amp;amp;stripmeta=0&amp;amp;type=jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;生命周期&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;对于c1这样在栈上的，生命周期就是C1的作用域。&lt;/li&gt;
  &lt;li&gt;对于C2这样指针的，生命周期也看C2的生命周期，比如C2是个函数的局部变量，那么在函数结束时因为要调用&lt;code class=&quot;highlighter-rouge&quot;&gt;delete c2&lt;/code&gt;，此时对象也就被销毁了。&lt;/li&gt;
  &lt;li&gt;如果一个c3是static的，那么按照C里面的约定这个变量的生命周期就是进程的生命周期，不管这个C3是全局还是局部。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-4&quot;&gt;对象在内存中是什么样的布局&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://imglf.nosdn.127.net/img/Nld0N0tacnNuUG0vaVk3MW1oaWJMY3Vzcis3WUhrNWRNelB4aWVwUGZkYlE1K3RtVkY4Z3pnPT0.png?imageView&amp;amp;thumbnail=1680x0&amp;amp;quality=96&amp;amp;stripmeta=0&amp;amp;type=jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;section-5&quot;&gt;看图说话&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;图是VC中的内存布局，一个对象的大小必须是16字节的倍数。&lt;/li&gt;
  &lt;li&gt;灰色部分是debug模式下才有的，用于debug。&lt;/li&gt;
  &lt;li&gt;Release模式下一个对象包含上下hook共4*2=8个字节，对象本身的字节数（complex那个例子下就是实部和虚部共2个double，即4*2=8字节）。如果不够16的倍数就会出现墨绿色部分的pad，也就是填补内存。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-6&quot;&gt;对象的销毁&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;生成的对象c1和c2都会在作用域结束后销毁。如果是c1那么它这个对象本身就在栈上保存，因此销毁后全部内存就释放掉了。但是指针的形式，因为对象是在堆上的，如果c2指针被销毁了，那么堆上这块内存就无法找到并销毁了（直到进程结束），造成了内存泄漏。&lt;/li&gt;
  &lt;li&gt;因此对于指针形式的c2，在其使用完成后就可以直接调用&lt;code class=&quot;highlighter-rouge&quot;&gt;delete c2&lt;/code&gt;来实现销毁。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-7&quot;&gt;析构函数&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;如果一个对象中动态的分配了内存，那么需要在析构函数找那个对分配的内存进行删除。&lt;/li&gt;
  &lt;li&gt;如果不显式的去写析构函数编译器应该会生成一个，如果我没有记错的话。&lt;/li&gt;
  &lt;li&gt;上面的c1中如果是在栈上的，那么变量离开作用域后会自动销毁并调用析构函数。&lt;/li&gt;
  &lt;li&gt;构造函数执行两个步骤，第一个执行&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;delete&quot;&gt;delete做了什么&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://imglf2.nosdn.127.net/img/Nld0N0tacnNuUGtzTWNrbTJLM0pKUmgvZmViUytFdzB1dGE5ZHFJNzkrclBFbHlEbnk3Vi93PT0.png?imageView&amp;amp;thumbnail=1680x0&amp;amp;quality=96&amp;amp;stripmeta=0&amp;amp;type=jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-8&quot;&gt;数组删除&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;如果动态生产了数组内存，则在析构函数或者当需要删除对象时需要用&lt;code class=&quot;highlighter-rouge&quot;&gt;delete[]&lt;/code&gt;。在这个过程中具体干了什么呢？&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://imglf0.nosdn.127.net/img/Nld0N0tacnNuUGtzTWNrbTJLM0pKVlNpclgvbmkxK2xPZmJWSGZMSkx0L0IrZ1lTOG9ic2pnPT0.png?imageView&amp;amp;thumbnail=1680x0&amp;amp;quality=96&amp;amp;stripmeta=0&amp;amp;type=jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;上面也说了，delete会先执行析构函数，其实对于一个对象来说，由于上下hook的存在因此析构函数可以完美的删除这个对象所占用的内存。所以图中左右两个delete都可以删除p所指向的数组，但是因为数组中是string的指针， 所以删除数组后string指针对指向的string对象本身并没有删除。而这个string对象本身其实就是char[]。这才是不用delete[]造成内存泄漏的本质。&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Tue, 16 Jan 2018 23:49:53 +0800</pubDate>
        <link>https://caihua.tech/2018/01/16/%E4%BE%AF%E6%8D%B7C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E9%94%80%E6%AF%81/</link>
        <guid isPermaLink="true">https://caihua.tech/2018/01/16/%E4%BE%AF%E6%8D%B7C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E9%94%80%E6%AF%81/</guid>
        
        <category>CPP</category>
        
        
      </item>
    
      <item>
        <title>侯捷C++学习笔记：Object Model</title>
        <description>&lt;h4 id=&quot;composition--delegate--inherit-&quot;&gt;composition &amp;amp; delegate &amp;amp; inherit 的构造和析构顺序&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;如果有以下代码：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class A
{
public：
    A();
    ~A();
    Foo();
}

class B
{
public：
    B();
    ~B();
}

class C:A
{
public：
    C();
    ~C();
private:
    B* b;
}

main()
{
    C c;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;在前面面向对象中讲过，B和C组成了composition &amp;amp; delegate，而A和C是继承关系。&lt;/li&gt;
  &lt;li&gt;那么在内存使用的顺序上会先调用A的构造函数，然后调用B的构造函数。最后调用C的构造函数。&lt;/li&gt;
  &lt;li&gt;在析构时的顺序是：先调用C的析构，在调用B的，最后调用A的。&lt;/li&gt;
  &lt;li&gt;其顺序可以从代码层面这样的解释&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;C::C() ：A(), B() { // c在构造函数中要做的事情}

C::~C()
{
    // c的析构
    ~B();
    ~C();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;vptr--vtbl&quot;&gt;vptr &amp;amp; vtbl&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;在C++中函数分为虚函数和非虚函数，对于非虚函数来说调用的时候编译器会编译为&lt;code class=&quot;highlighter-rouge&quot;&gt;call(method address)&lt;/code&gt;的形式，也就是说函数的地址是已知的，即使是继承下来的函数，等于也是调用了父类的函数的地址。这个被称为静态绑定。&lt;/li&gt;
  &lt;li&gt;但是对于虚函数，因为有override的情况，所以C++中采用了虚机制，也可以说是动态绑定。&lt;/li&gt;
  &lt;li&gt;虚机制的基础是虚指针和虚表。虚指针是对象中的一个指向虚表的指针，虚表是一个对象中所有的虚函数地址表。&lt;/li&gt;
  &lt;li&gt;与C#方法列表进行比对： C#中方法列表包含了所有函数的地址，而C++的虚表中只是虚函数的。因为不知道子对象是否会override父类虚函数，所以这个虚表里面的函数可能指向了父类的虚函数，也可能指向了子类的虚函数，还有可能是子类override的虚函数。&lt;/li&gt;
  &lt;li&gt;什么时候C++会使用动态绑定呢？
    &lt;ul&gt;
      &lt;li&gt;调用方法的对象是一个指针&lt;/li&gt;
      &lt;li&gt;对象使用时是up cast，也就是协变。&lt;/li&gt;
      &lt;li&gt;调用的是虚函数&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;本质：从下面的代码看*(p-&amp;gt;vptr)是虚指针指向的虚表，虚表中其实是函数地址的数组，调用某个函数就是去数组的值，然后传递参数。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;( *(p-&amp;gt;vptr) [n] )(...)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;PS：对于栈上的对象的方法调用，就不考虑虚机制。下面例子中B继承自A，AB中均有虚函数vFunc的情况下，结果是调用了A的虚函数，因为a不是指针。如果a是指针，那么走虚机制，应该执行的是B的vFunc。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;B b;

A a = (A)b;

a.vFunc();

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Tue, 09 Jan 2018 23:48:28 +0800</pubDate>
        <link>https://caihua.tech/2018/01/09/%E4%BE%AF%E6%8D%B7C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Object-Model/</link>
        <guid isPermaLink="true">https://caihua.tech/2018/01/09/%E4%BE%AF%E6%8D%B7C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Object-Model/</guid>
        
        <category>CPP</category>
        
        
      </item>
    
      <item>
        <title>侯捷C++学习笔记：Reference</title>
        <description>&lt;h4 id=&quot;section&quot;&gt;本质&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;通过指针实现，所以本质就是指针&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-1&quot;&gt;意义&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;是某个变量的代表，因此下面的代码中，x的值为5。在给x赋值后i和x都是6。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int i = 5;

int&amp;amp; x = i;

x = 6;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-2&quot;&gt;编译器的一些做法&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;以一下代码为例，如果有一个变量b是a的引用，那么有&lt;code class=&quot;highlighter-rouge&quot;&gt;sizeof(a) == sizeof(b)&lt;/code&gt;而且&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;a == &amp;amp;b&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;上面也说了引用是个指针，在32位系统中sizeof指针应该是4个byte。但是因为b是a的引用，它代表了a，所以代码中&lt;code class=&quot;highlighter-rouge&quot;&gt;sizeof(b)&lt;/code&gt;是16byte。而且a和b取地址得到的值也是一样的，虽然我们知道这个在内存中肯定是不一样的。只不过编译器做了这些的处理。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typedef struct A {int a, b, c, d};

A a;
A&amp;amp; b = a;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;reference&quot;&gt;reference的常用方式&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;主要用于参数的修饰，很少用来声明变量。&lt;/li&gt;
  &lt;li&gt;参考以下的代码，在使用上引用传递在写法上和值传递是一样的，当然本质不同。但是从代码的优雅性上引用会比指针的参数形式好。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void Func1 (Cls a)
void Func2 (Cls&amp;amp; a)
void Func3 (Cls* a)

...

Cls obj;

Func1(obj);
Func2(obj);
Func3(&amp;amp;obj);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;需要注意以下两个函数不能同时定义，因为在调用上会出现歧义。但是const修饰符可以实现重载。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void Func (Cls a)
void Func (Cls&amp;amp; a)

......

Cls obj;
Func(obj);

......

void Func (Cls a) const
void Func (Cls&amp;amp; a)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Sun, 07 Jan 2018 23:45:30 +0800</pubDate>
        <link>https://caihua.tech/2018/01/07/%E4%BE%AF%E6%8D%B7C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Reference/</link>
        <guid isPermaLink="true">https://caihua.tech/2018/01/07/%E4%BE%AF%E6%8D%B7C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Reference/</guid>
        
        <category>CPP</category>
        
        
      </item>
    
      <item>
        <title>侯捷C++学习笔记：偏特化</title>
        <description>&lt;h4 id=&quot;section&quot;&gt;什么是偏特化&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;泛化（泛型）的反义&lt;/li&gt;
  &lt;li&gt;分为个数的偏特化和范围的偏特化&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-1&quot;&gt;数量偏特化&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;举个例子，如果有如下class的定义，第一个class的就是泛型的，而第二个class，也是两个参数，但是第一个参数是个确定类型的，第二个是泛型的。这样就叫个人的偏特化。这固定类型的位置必须是从左至右的，不能跳着写。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;template&amp;lt;typename T, typename U&amp;gt;
class vector {}


template&amp;lt;typename U&amp;gt;
class vector&amp;lt;bool, U&amp;gt; {}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-2&quot;&gt;范围偏特化&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;说白了进一步约束泛型的类型。这个和C#中泛型的where约束有点像。&lt;/li&gt;
  &lt;li&gt;对于下面的例子来说，第一个C约束几乎没有，但是第二个就约束为指针类型了。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;template&amp;lt;typename T&amp;gt;
class C {}


template&amp;lt;typename U&amp;gt;
class C&amp;lt;U*&amp;gt; {}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Tue, 02 Jan 2018 23:45:30 +0800</pubDate>
        <link>https://caihua.tech/2018/01/02/%E4%BE%AF%E6%8D%B7C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%81%8F%E7%89%B9%E5%8C%96/</link>
        <guid isPermaLink="true">https://caihua.tech/2018/01/02/%E4%BE%AF%E6%8D%B7C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%81%8F%E7%89%B9%E5%8C%96/</guid>
        
        <category>CPP</category>
        
        
      </item>
    
      <item>
        <title>侯捷C++学习笔记：类型转换</title>
        <description>&lt;h4 id=&quot;section&quot;&gt;自己转换为别的类型&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;做法：使用&lt;code class=&quot;highlighter-rouge&quot;&gt;operator&lt;/code&gt;关键字，无需返回值，函数名称就是返回值。如有需要加上const修饰。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Class A
{
Public:
    A(int arg1, int arg2) 
     : x(arg1), y(arg2) {}
    
    operator double() const
    {
        return (double)(x/y);
    }
    
private:
    int x;
    int y;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;non-explicit-one-argument-ctor&quot;&gt;non-explicit-one-argument ctor&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;本质是编译器将别的对象转化为我们定义的对象&lt;/li&gt;
  &lt;li&gt;要求的自定义构造函数比较特殊&lt;/li&gt;
  &lt;li&gt;在实例代码中编译器会把4装换为A，然后执行+ 操作。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Class A
{
Public:
    A(int arg1, int arg2) 
     : x(arg1), y(arg2) {}
    
    A operator +(const A&amp;amp; a) 
    {
        return A(....);
    }
    
private:
    int x;
    int y;
}

A a(2,3);
double d = a + 4;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-1&quot;&gt;编译器有时会不清楚&lt;/h4&gt;

&lt;p&gt;-下面的代码中a+4时编译器发现可以用double操作，也可以用+操作，在这样的情况下编译器会不知道如何选择进而报错。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Class A
{
Public:
    A(int arg1, int arg2) 
     : x(arg1), y(arg2) {}
    
    A operator +(const A&amp;amp; a) 
    {
        return A(....);
    }
    
    operator double() const
    {
        return (double)(x/y);
    }
    
private:
    int x;
    int y;
}

A a(2,3);
double d = a + 4;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;explicit-one-argument-ctor&quot;&gt;explicit-one-argument ctor&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;explicit关键字几乎都是用到构造函数前面的，告诉编译器不要随便的把别的类型转换为我自定的类型。&lt;/li&gt;
  &lt;li&gt;下面的例子中，编译器不会再把4转成A，因此这个表达式是错误的。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Class A
{
Public:
    explicit A(int arg1, int arg2) 
     : x(arg1), y(arg2) {}
    
    A operator +(const A&amp;amp; a) 
    {
        return A(....);
    }
    
private:
    int x;
    int y;
}

A a(2,3);
double d = a + 4;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Tue, 02 Jan 2018 23:44:24 +0800</pubDate>
        <link>https://caihua.tech/2018/01/02/%E4%BE%AF%E6%8D%B7C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</link>
        <guid isPermaLink="true">https://caihua.tech/2018/01/02/%E4%BE%AF%E6%8D%B7C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</guid>
        
        <category>CPP</category>
        
        
      </item>
    
      <item>
        <title>侯捷C++学习笔记：面向对象</title>
        <description>&lt;h4 id=&quot;composition&quot;&gt;Composition&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;组合&lt;/li&gt;
  &lt;li&gt;其实就是一个类（Container）中包含了另一个类的实例（Component），注意是实例。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;delegate&quot;&gt;delegate&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;组合的一种&lt;/li&gt;
  &lt;li&gt;但是包含的是一个类的引用(reference)。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section&quot;&gt;组合的使用&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;用这样的方式可以做出adapter模式，比如A功能很多但是如果只要暴露出一部分，可以用B来包含A，然后只在B中定义一些方法，这些方法都是直接调用A的即可。&lt;/li&gt;
  &lt;li&gt;还可以引申出面向接口编程。比如A中要调用某一类的功能，但是这些功能可以由B\C\D来提供，或者说不通的条件下使用不通的提供者，那么我们就可以为这些功能定义一个接口，然后让BCD实现接口，A中只要是一个对接口类型的引用即可。&lt;/li&gt;
  &lt;li&gt;PS：目前我看到C++里面的接口是用虚函数实现的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;no-virtualvirtual&quot;&gt;no-virtual&amp;amp;virtual&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;C++的函数使用virtual关键字标记为虚函数。&lt;/li&gt;
  &lt;li&gt;虚函数分为纯虚函数和虚函数，区别就是虚函数是有实现的，哪怕只是个空的函数体&lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;&lt;/code&gt;。但是纯虚函数是没有实现的，定义方式为&lt;code class=&quot;highlighter-rouge&quot;&gt;virtual void Foo() = 0&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;虚函数不要求子对象一定实现override，但是纯虚函数要求一定实现。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 02 Jan 2018 23:42:45 +0800</pubDate>
        <link>https://caihua.tech/2018/01/02/%E4%BE%AF%E6%8D%B7C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</link>
        <guid isPermaLink="true">https://caihua.tech/2018/01/02/%E4%BE%AF%E6%8D%B7C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</guid>
        
        <category>CPP</category>
        
        
      </item>
    
      <item>
        <title>侯捷C++学习笔记：基础</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;1.类&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;带指针的类&lt;/li&gt;
  &lt;li&gt;不带指针的类：大多数不需要析构函数&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;2.定义头文件&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;防御式代码，避免多次include时重复导入&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#ifndef _COMPLEX_
#define _COMPLEX_

...

#endif
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;头文件布局:
    &lt;ul&gt;
      &lt;li&gt;前置声明&lt;/li&gt;
      &lt;li&gt;类声明
        &lt;ul&gt;
          &lt;li&gt;class head &lt;code class=&quot;highlighter-rouge&quot;&gt;class Complex&lt;/code&gt;&lt;/li&gt;
          &lt;li&gt;class body : 定义数据和函数&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;类定义&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Class A
{
Public:
    A(int arg1, int arg2) 
     : x(arg1), y(arg2) {}
    
    operator double() const
    {
        return (double)(x/y);
    }
    
private:
    int x;
    int y;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-2&quot;&gt;3.函数&lt;/h2&gt;

&lt;h4 id=&quot;section-3&quot;&gt;构造函数&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;默认参数&lt;/li&gt;
  &lt;li&gt;initialization list，只有构造函数有&lt;/li&gt;
  &lt;li&gt;用法：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; A(int arg1, int arg2) 
     : x(arg1), y(arg2) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;如果构造函数的参数是类型本身，那么叫拷贝构造。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;只要类带指针必须有拷贝构造函数。PS: 同时要有拷贝赋值函数。&lt;/strong&gt; 编译器会默认生成，但是需要根据情况自己写。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;inline&quot;&gt;inline函数：&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;当一个函数在class body内定义并且实现了功能，则会自动成为inline函数。&lt;/li&gt;
  &lt;li&gt;在外部实现并且加上inline关键字的函数，只是作为inline函数的一个候选人，是否成为一个inline函数完全看编译器会不会这样来编译它。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-4&quot;&gt;函数重载&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;CPP中重载函数在代码中同名，但是在编译后不同名。&lt;/li&gt;
  &lt;li&gt;如果出现一个函数&lt;code class=&quot;highlighter-rouge&quot;&gt;foo()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;foo(int i = 0)&lt;/code&gt;这样的情况，实际上是不行的，因为编译器认为在调用的无参版本时两个函数都可以，这样就出现了错误。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;const-member-functions-&quot;&gt;const member functions (常量成员函数)&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;以下面的函数为例，参数括号后加上const修饰符，则说明这个函数是不改变对象中数据的值。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; double real () const { return re; }
 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;在函数的使用上可能与如下的方式，说明我生成的对象c1中的数据是不希望修改的，那么如果real函数中没有const的话编译时会报错。因为如果没有const，说明real函数可能会修改对象中的数据的值，但是我们定义的c1又是一个不会被修改的，那么就有矛盾了。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; const complex c1()
 c1.real()
 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;passreturn-by-value-vs-passreturn-by-reference-to-const&quot;&gt;pass（return） &lt;em&gt;by value&lt;/em&gt; vs pass（return） &lt;em&gt;by reference&lt;/em&gt; (to const)&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;&lt;/code&gt;这个符号在c中是取地址的操作，在C++中也有这个用发，但是多了一个用法。比如如下的代码中：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;complex&amp;amp; operator += (const complex&amp;amp;);

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;参数类型后面加&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;&lt;/code&gt;说明这个参数是按引用传递，本质就是指针。如果不加const修饰，则函数中可以修改参数的值，如果加了则说明这个参数就是按指针传递给函数使用，但是不能修改其值。&lt;/li&gt;
  &lt;li&gt;通常来说尽可能用按引用传递，因为毕竟指针只有4个byte，对于多数情况来说是比较快速和省资源的（栈上的数据少）。但是如果遇到传递的值是char的，也可以安值传递。&lt;/li&gt;
  &lt;li&gt;传递者无需知道接受者是以reference的形式接收。传递者把对象传递个函数，但是函数是使用值形式的参数还是引用形式的参数完全看函数的定义，但是调用者无需关心。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;value&quot;&gt;何时使用value来传递呢？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;如果函数的返回值是函数内部的一个local object就需要安值传递。因为在函数结束后对象就从栈中销毁了，此时用引用的话在获取值的时候，对象已经没了。&lt;/li&gt;
  &lt;li&gt;++&lt;strong&gt;所以是返回引用还是值，根本上要看这个返回值内存是在函数内还是函数外。&lt;/strong&gt;++&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-5&quot;&gt;友元函数&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;加&lt;code class=&quot;highlighter-rouge&quot;&gt;friend&lt;/code&gt;修饰符，只是告诉类某个函数是友元的，可以直接访问private的变量。&lt;/li&gt;
  &lt;li&gt;++&lt;strong&gt;相同class的各个对象互为friend（友元）&lt;/strong&gt;++&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int foo(const complex&amp;amp; param)
{
    return param.re + param.im;
}

...

complex c1(1,2);
complex c2;

c2.foo(c1);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-6&quot;&gt;静态函数&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;与C#不同的是CPP中静态函数可以通过对象来调用，同时当有也可以用类+函数名的方式调用。即&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Class::StaticFuntion();

Class c1;
c1.StaticFunction();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-7&quot;&gt;总结&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;数据一定放在private里面&lt;/li&gt;
  &lt;li&gt;参数和返回值尽可能用reference来传递，加不加const根据实际情况&lt;/li&gt;
  &lt;li&gt;class body中函数如果没有修改数据则加const&lt;/li&gt;
  &lt;li&gt;构造函数尽量用初始列表&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 01 Jan 2018 23:40:45 +0800</pubDate>
        <link>https://caihua.tech/2018/01/01/%E4%BE%AF%E6%8D%B7C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80/</link>
        <guid isPermaLink="true">https://caihua.tech/2018/01/01/%E4%BE%AF%E6%8D%B7C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80/</guid>
        
        <category>CPP</category>
        
        
      </item>
    
      <item>
        <title>每天一点UWA：第二十周</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;小结&amp;amp;新的开始&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;从今年的7月29号发布第一周的笔记算起不知不觉已经二十周了，当时的想法也很简单就是下定决心读完当时算下来是168篇文章。5个月过去了，在写这篇的文章的时候基本上已经通读完了所有厚积薄发版块的关于unity的文章，真的感觉这是我这些年来做的最有毅力的一件事情。可以说在这二十周里面对于unity的理解尤其是图形学上学到了很多东西，而且也学会了很多优化的理论和别人实践的方法。&lt;/li&gt;
  &lt;li&gt;理论已经学习完了，在后面的工作中就是一个实践的过程了。现在的项目会开始使用GOT工具进行优化的工作，真正的把优化这条路走下去。&lt;/li&gt;
  &lt;li&gt;由于UWA出文章的速度不可能太快，而且自己的工作也很忙，所以每周的笔记可能会改成每月一篇了，继续加油。&lt;/li&gt;
  &lt;li&gt;还有就是UWA都开始搞UE了，还有什么理由不开始学UE。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;gameplay&quot;&gt;GamePlay&lt;/h2&gt;
&lt;h4 id=&quot;uwameshuwa-got200mbunloadunusedassets&quot;&gt;在UWA的测评结果中，我们的Mesh文件内存过高（使用UWA GOT测试最大的场景会达到200MB），大部分是由于场景的物件导致的。我们的场景物件是这样加载的：场景有一个基础的框架（地面、天空盒和个别大的物件等），在进入场景后，会根据位置来加载其他的物件，加载的物件在离开视野后，为了防止下次再加载，只将其隐藏了，并没有销毁，这样的话，人物如果在场景里跑了一圈，就相当于整个场景的物件，都会进入内存。请问，是不是将离开视野的场景物件销毁比较好呢，销毁后是不是要调用UnloadUnusedAssets才能彻底从内存中去除呢？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;如果题主做的是移动游戏，那么200MB确实太大了。&lt;/li&gt;
  &lt;li&gt;建议题主建立一个Memory Pool来缓存场景中的物体，至少有以下两个规则：
    &lt;ul&gt;
      &lt;li&gt;Pool必须有一个上限，一般为容器的数量，超过最大阈值后即开始进行清理；&lt;/li&gt;
      &lt;li&gt;为Pool中每个Object记录一个存储时间，当时间超过一定阈值后进行清理，或者当Pool满了后，将时间最长的进行Deactive Object进行清理。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;通过缓存池来进行销毁较长时间不再显示的的物体，同时，可以通过UnloadAsset API来卸载相关的资源，Resources.UnloadUnusedAssets API一般只建议在场景切换处进行使用。&lt;/li&gt;
  &lt;li&gt;PS:说两句，如果一个最长时间的物体正好在视线内就不好办了。所以这个答案有点太粗暴，个人感觉还是要根据摄像机位置进行动态的删除对象。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;navmeshasset&quot;&gt;解析NavMesh.asset数据，用于服务器寻路。&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;https://blog.uwa4d.com/archives/2110.html&lt;/li&gt;
  &lt;li&gt;Q3&lt;/li&gt;
  &lt;li&gt;给大佬跪了&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;reflectionprobe&quot;&gt;ReflectionProbe在移动平台丢失部分高光数据&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;https://blog.uwa4d.com/archives/2110.html&lt;/li&gt;
  &lt;li&gt;Q4&lt;/li&gt;
  &lt;li&gt;仅记录，没仔细看过后续版本的bugfix，遇到了在处理吧。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;animator-controller&quot;&gt;大批量地合入美术资源时，经常会出现构建出来的版本出现材质引用丢失、Animator Controller引用错误、贴图引用错误等资源引用错误的问题。&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;出现这个问题可能是如下原因：&lt;/li&gt;
  &lt;li&gt;是否使用代码混淆。在Prefab 上挂的脚本忘记添加到排除混淆的列表，导致序列化的字段被混淆，打完Bundle后的Prefab资源加载时候，挂接的脚本出现引用错误；&lt;/li&gt;
  &lt;li&gt;资源导入都重载过OnPostProcess并处理了资源设置，这一步是否修改了什么不合理的地方，比如破坏了引用关系；&lt;/li&gt;
  &lt;li&gt;打包AssetBundle时，在构建Bundle 之前有没有使用文件操作API（不是 Unity 的AssetDatabase的API）来直接修改了某个文件夹或者其他会破坏引用关系的行为，然后构建Bundle，完成后恢复文件夹名字（或者恢复资源原始状态），这样丢失引用关系的几率很大；&lt;/li&gt;
  &lt;li&gt;有没有可能发布机器上，看着正常，但是Perforce里面已经存在一堆已修改的Meta文件；这种问题常出现于美术本地有两个A1，A2个相同资源在不同文件夹，A1受版本控制，但是由于某种操作，本地临时资源A2使用了原本A1的Guid，原本正确的 A1 被迫使用了不正确的新生成Guid（相当于两人交换），然后上传了A1的Meta，结果发布机器的下来的A1 Meta就会跟别人丢失引用，或者更新下来本地重新分配了新的Guid；美术策划最容易犯这个错误；&lt;/li&gt;
  &lt;li&gt;我们是Unity 5.3.8p2，上周遇到一个疑似bug，美术多上传了一组相同的资源，我们更新下来都会重新生成Guid，但是很多挂起的Meta在Unity里重新导入后，在版本控制里神奇地消失了，但修改还在；&lt;/li&gt;
  &lt;li&gt;如果都不是，只能尝试最小排除法了，删除项目绝大部分资源，一点点增加，然后打包，重现，排除原因；不行的话然后删除代码，一点点添加，打包，重现…有时候笨办法也是最容易接近真相的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;animatoroverridenameclip3-6cpu50-180mslisthttpsdocsunity3dcomscriptreferenceanimatoroverridecontrollerapplyoverrideshtml-lateupdateapplyoverrides400msoverridescount73clip&quot;&gt;游戏对战时因为会频繁更换武器或释放技能（主要是网络玩家），会替换不同的动作，但是发现每次设置animatorOverride[name]=clip（每次设置3-6个），CPU占用50-180ms，请问这是什么原因？我按照官方的指导存了一个list（https://docs.unity3d.com/ScriptReference/AnimatorOverrideController.ApplyOverrides.html） ，然后每次LateUpdate的时候调用ApplyOverrides，发现占用更高了，每次400ms，请问这个要怎么解决？目前每个网络玩家玩家OverRidesCount是73，会不会是Clip过多的原因？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;在真机运行时发现animatorOverride[name]=clip的耗时会受到animatorcotrollor中的clip数目的影响，随数目的增多耗时会明显增加，70个以上的clip耗时确实能达到50ms(红米note2)以上。&lt;/li&gt;
  &lt;li&gt;换为applyOverrides方法时耗时仍然很高，而且出现了堆内存分配，但并没有达到400ms那么高。&lt;/li&gt;
  &lt;li&gt;尝试了整体替换AnimatorOverrideController，即不在现用的AnimatorOverrideController中替换clip，而是在另一OverrideController中换好clip后，再整体替换到runtimeAnimatorController，这样耗时就会降到很低了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;texture&quot;&gt;Texture&lt;/h2&gt;
&lt;h4 id=&quot;unity-551sprite-packeriosrgba-pvrtc4spritepvrtc4467&quot;&gt;Unity 5.5.1版本下，Sprite Packer在iOS平台下RGBA PVRTC4打包图集失真非常严重（对单个的Sprite设置PVRTC4是正常的），参照了4.6.7版本是正常的，我想知道为什么呢？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;unity的bug&lt;/li&gt;
  &lt;li&gt;在 Windows 下尝试用 4.7 的 pvrtextool.exe 替换了 5.x 的，暂时解决了这个问题，建议也尝试一下。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;asynchronous-texture-upload&quot;&gt;异步纹理加载Asynchronous Texture Upload这个功能最后到底有没有实用？&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2FTechSharing_84%2F5.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;这个是默认就开启的，只是得开启多线程渲染才有效，因为要在 Render Thread 里上传纹理，还有文档里提到的各种限制，比如只针对关闭了 Read/Write 的纹理… 非多线程渲染时，异步加载纹理的时候，可以在 Loading.UpdatePreLoading 这个函数里看到较高的 Texture.AwakeFromLoad。但多线程渲染时，这部分的开销就会变得很小，因为这部分开销被放到 Render Thread 去了，如下图中的 Gfx.UploadTexture。&lt;/li&gt;
  &lt;li&gt;但需要注意的是，这个地方的异步并不是流式的加载，也就是说，当加载一个大纹理的时候，还是一次性完成的，并不会分帧去做，如下图加载了一张2048的纹理，图中绿色峰值是Gfx.WaitForPresent，也就是主线程在等待 Render Thread。&lt;/li&gt;
  &lt;li&gt;综上，这个功能实际上就是把某些满足要求的纹理的加载时间从主线程移到了渲染线程。在某些情况下，确实是可以提高总体的加载速度的。但这个功能并不能真正地“解决异步加载时纹理却只能同步加载”的问题，只是把卡顿放到渲染线程去了（如果耗时高了，主线程还是要等的）。&lt;/li&gt;
  &lt;li&gt;非常好的问题，建议直接看答案。 https://blog.uwa4d.com/archives/TechSharing_84.html Q3&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;unity&quot;&gt;在目前的Unity版本中，使用多维材质是否会对效率产生影响，用多维材质和把模型分块哪个更好？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;制作美术资源时，应该尽量避免使用多维材质。&lt;/li&gt;
  &lt;li&gt;先举例说明多维材质的一个优点是拆分模型做不到的： 一块大石头有石头和草地两个材质，做成一个整体的模型，使用多维材质，作为一个物件进行烘焙，在Lightmap上的UV分布是一个整体，不会出现拆分为两个模型烘焙产生的接缝问题。&lt;/li&gt;
  &lt;li&gt;除了上面这种情况，其他情况下推荐将模型拆分成多个模型赋予不同的材质。&lt;/li&gt;
  &lt;li&gt;优点是：
    &lt;ul&gt;
      &lt;li&gt;1、多个模型会作为多个MeshObject参与到裁剪、静态批次等优化中 ；&lt;/li&gt;
      &lt;li&gt;2、拆分的模型和贴图可以进行材质合并，程序才能进行下一步的优化，如果本身是多维材质，就无法进行合并DrawCall的优化；&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;第一个优点就能带来很大的收益。制作上应该按照一个模型对应一个贴图的做法进行，如果模型是一个整体，比如房子由底座、墙体、屋顶组成，建议将他们多选导出成一个FBX。&lt;/li&gt;
  &lt;li&gt;另外，不同材质的模型建议做成多个模型，再多选导出成一个FBX，仍然是一个模型对应一个贴图的规范进行制作。&lt;/li&gt;
  &lt;li&gt;PS: 对于人物模型可能不考虑剪裁，但是至少减少了drawcall。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ui&quot;&gt;UI&lt;/h2&gt;
&lt;h4 id=&quot;ugui-uirootscreen-space---camera-culling-mask-uirootuilayer&quot;&gt;我在UGUI 使用一个UIRoot，类型使用Screen Space - Camera，使用摄像机的 Culling Mask, 如果UIRoot可视，下面的UI子物体设置不可视Layer，是不是不会被裁掉？有没有什么解决办法吗？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;UGUI的网格合并是以Canvas为单位的，所以只能改Canvas的Layer才有效。&lt;/li&gt;
  &lt;li&gt;如果只是个别UI元素要快速隐藏和显示，可以考虑用Scale为0来做，Scale为0时UI的顶点信息会被清空，所以隐藏时就不会参与网格重建了。&lt;/li&gt;
  &lt;li&gt;PS:顶点清空的第一帧应该会出现rebuild，后续帧不参与rebuild。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;ui867outline-canvas&quot;&gt;在UI中，有两个字体控件每帧都要显示不同的数字，第一个有8个字，第二个有6~7个字，需要开outline增加辨识度，从而引起了较高的性能开销。 把这两个控件单独放到另外独立的Canvas，该问题依然存在。现已确定该开销是由这两个字体控件每帧的文本更改引起的。&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;提到一个是8个字，一个是6到7个字，都开启了outline。 首先建议再做一次确认，看是不是禁用这两个之后，SendWill就确实没开销了。因为这个字数看上去并不应该造成很明显的开销；&lt;/li&gt;
  &lt;li&gt;其次，如果确实是这两个造成的，那么就需要先考虑下能不能转成带outline效果的静态字体，不行的话再考虑下能不能降低更新的频率了，是不是确实要每帧都变；&lt;/li&gt;
  &lt;li&gt;如果要再降低，就只能考虑静态字体了，如果文本是一些比较固定的内容就很好处理，但如果是像聊天一样，内容无法预知的话似乎就没什么办法了。或者就是低端机用shadow来做。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;resourcesloaduiprefabui&quot;&gt;现在用Resources.Load()加载资源时，UI动画会出现卡顿的现象，如果想消除卡顿，是不是只能通过异步加载，分拆Prefab和优化材质网格动画之类的操作来实现？还是说UI动画可以在另外的线程播放之类呢？另外我想问下，异步速度是不是一定比同步慢呢？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;不直接贴答案了&lt;/li&gt;
  &lt;li&gt;总结一下就是遇到这样的卡顿的解决办法
    &lt;ul&gt;
      &lt;li&gt;分析卡顿原因&lt;/li&gt;
      &lt;li&gt;使用异步方法&lt;/li&gt;
      &lt;li&gt;拆分功能、预加载&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;工具&lt;/h2&gt;
&lt;h4 id=&quot;unityframe-debuggerprofilerdraw-calldrawcall&quot;&gt;Unity中的Frame Debugger中的渲染顺序以及数量和Profiler中看到的Draw Call数量，以及在高通的调试工具里看到的DrawCall数，它们之间有什么关系呢？哪个数值是影响渲染的重要指标？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;简单来说，Unity引擎中Total Batches是我们建议最需要关注的指标。&lt;/li&gt;
  &lt;li&gt;1个Setpass Call或者Batch，相当于是一次Render State的切换，而1个Draw Call则是CPU让GPU去进行渲染某一个Object的1次操作。在当前的移动设备中，1次Render State的切换要1个Draw Call本身要耗时。&lt;/li&gt;
  &lt;li&gt;所以，Total Batches是我们较为建议的关注指标，也是UWA性能报告中所提供的Draw Call查看指标。而Frame Debugger中，其数量是与Total Batches相一致的，即查看的是每一个Batch的渲染物体。 更为详细一些的说明，可以查看https://answer.uwa4d.com/question/58d29b8b5a5050b366a6b6ae&lt;/li&gt;
  &lt;li&gt;而Unity Profiler中的Draw Call，其理论上对应的则是glDrawElements的调用次数，其与高通或其他第三方工具所返回的Gl Trace信息操作数量不太一致，但应该与其中的glDrawElements API的调用次数基本一致，题主可以自行检测看看。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;uwa-gotcpustacktraceutility&quot;&gt;我用UWA GOT进行本地性能测试，在CPU的数据分析中发现，某些帧StackTraceUtility耗时特别高，这是什么原因导致的呢？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;StackTraceUtility.XXX是Unity引擎的Log输出，可能是本身Debug.Log/LogError的调用输出，也可能是使用过程中引擎端出现了Warning/Error等信息而自动输出的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;profilerassetbundlelockpersistentmanager&quot;&gt;我在Profiler中观察性能曲线，发现某一帧AssetBundle加载中，LockPersistentManager耗时比较大。请问这部分能否优化？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;这说明当前帧或前几帧中存在较大量的资源在通过LoadAsync来进行加载，其本质是所加载的资源过大所致，对自身资源进行合理优化可降低Loading.LockPersistentManager的开销。&lt;/li&gt;
  &lt;li&gt;另外，将异步加载换成同步加载，LockPersistentManager就不会出现了，但其总加载耗时是没有变化的，因为总加载量没变。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;profilerpciosandroidandroidgraphics-jobsplayer-settings&quot;&gt;我在安卓真机上跑游戏，发现Profiler下的合批数据和PC或者iOS下的不一样，因此不确定Android的合批是否有效。经过分析，Android上不能设置Graphics Jobs(在Player Settings里面)，也是不断打包测试发现这个问题，想了解一下具体是什么原因呢？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Graphics Job目前在Android平台上是为Vulkan而设计的，也就是只有支持Vulkan设备的才会真正起作用。按照Unity原厂的说法，该选项在不支持Vulkan的Android设备上应该是没有效果的。&lt;/li&gt;
  &lt;li&gt;另外，Graphics Job和MultiThread Rendering并不建议同时使用，而且以目前的Android设备来说，建议只开启MultiThread Rendering一项即可。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;模型&amp;amp;动画&lt;/h2&gt;
&lt;h4 id=&quot;unity3danimationclipframerate&quot;&gt;在Unity3d的官方文档中，animationclip.framerate的解释如下：&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;“Frame rate at which keyframes are sampled. (Read Only) This is the frame rate that was used in the animation program you used to create the animation or model.”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;section-3&quot;&gt;我对此有些疑问：&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;1）这个是否为动画系统每一秒钟更新动画的次数？如果是，当这个值高于Application.targetFrameRate时，一秒钟更新动画的次数依据哪个为准&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;2）这个是否只是调节动画播放速度的一个参数，而每秒钟动画状态更新的次数不受影响？&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;A: 动画采样的时候是根据当前播放的时间去找对应的前后两个关键帧做插值。所以动画本身得告诉Unity两个关键帧（没做keyframe reduction时）的间隔时间是多少，或者一秒有几帧，这个值就是framerate。所以这个是只读的，导出时就应该是确定的。因此这个值也不会影响运行时动画的更新次数，默认情况下动画就是每帧更新一次的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;loadlevelasyncloadlevelloadlevelasyncloadlevel40loadlevelloadingloadlevelasyncloadingprefabprefabresourcesloadasync2200ms&quot;&gt;在手机上测试LoadLevelAsync和LoadLevel的加载速度，同一个场景，LoadLevelAsync要比LoadLevel多花费40%左右的时间，请问这是正常的么？LoadLevel会有卡顿，导致Loading进度条不平滑，但是LoadLevelAsync好像又会增加Loading的时间？我项目中场景动态加载的做法是，是把物件做成Prefab，然后根据主角的位置做动态加载相应的Prefab，用的是Resources.LoadAsync方法。现在加载一些比较大的物件时，在红米2等低端机上，仍然比较卡，要消耗200ms以上。请问有什么好的方式，能平滑这个加载过程么，谢谢！&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;LoadLevelAsync一般情况下是要比LoadLevel慢的，但是否要慢40%，这个其实是根据每个场景所要加载的不同量而定的，并不是确数。&lt;/li&gt;
  &lt;li&gt;LoadLevel和LoadLevelAsync其实最本质的区别，是前者一定要在下一帧结束前完成加载操作，所以当加载场景较大时，其随后的单帧开销就会很大，而后者则没有这个限制，引擎可以根据当前的使用情况或者ThreadPriority（这个值是是否对LoadLevelAsync有影响，还没做过具体实验，但对于LoadAsync确实有影响 ）来自行调控。&lt;/li&gt;
  &lt;li&gt;还需要说明一点的是，不是说使用Async，它就一定是绝对平滑，下图红框是LoadLevel，绿框是LoadLevelAsync操作。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2FTechSharing_86%2F1.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;关于真正“平滑”异步的加载方式，Unity引擎目前还是没有的。在遇到较为复杂的Prefab（比如大纹理、多AnimationClip等等）时，其加载依然会出现卡顿。如果想要缓解该问题，建议如下：定位资源-&amp;gt;查看资源为何开销-&amp;gt;采用预加载的方式处理这样的资源。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;il2cppmonoil2cppprofilermanagedobject-int32&quot;&gt;我使用了IL2CPP后是否还存在Mono内存呢？使用IL2CPP后，通过Profiler工具获取的managedObject（例如： int32[]）是哪种内存？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;可以简单地认为，Il2CPP只是替换掉了Mono的虚拟机实现，所以该分配堆内存的地方还是会一样的分配（可能会有某些细节的地方不一样）。&lt;/li&gt;
  &lt;li&gt;IL2CPP在堆内存分配方面和Mono 最大的不同主要是Reserved Total 是可以下降的，而 Mono的 Reserved Total 只会上升不会下降。&lt;/li&gt;
  &lt;li&gt;PS：原来是这样，我一直以为是直接转成了CPP语言。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-4&quot;&gt;物理&lt;/h2&gt;
&lt;h4 id=&quot;boxcollider2d00f00f--10f10fphysics2dboxcastnew-vector210f1702-vector210f-14f-0-vector200f10f-20f-1700-17021706&quot;&gt;我的游戏场景中有一个boxcollider2D，位置在(0.0f,0.0f) 到 (1.0f,1.0f)；调用Physics2D.BoxCast(new Vector2(1.0f,1.702), Vector2(1.0f, 1.4f), 0, Vector2(0.0f,1.0f), 2.0f); 会产生碰撞，理论上碰撞的边界在1.700 ，我已经将位置放到1.702，应该是规避了浮点数误差的问题的，如果我将该值放大了1.706就不会产生碰撞了，请问哪里可以调整这个误差值的范围呢?&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Unity 2017.1版本的Physics2DSettings里面有一个Default Contact Offset，表示当两个collider之间的距离小于它们的ContactOffset之和就会产生碰撞。把这个值设置小一点应该能解决题主的问题。&lt;/li&gt;
  &lt;li&gt;Unity 5.x中Contact Offset，默认是0.01，这也是为何1.702不行，而1.706可以的原因。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-5&quot;&gt;性能综合&lt;/h2&gt;
&lt;h4 id=&quot;uigameobjectdestroyresourcesunloadunusedassets&quot;&gt;释放了资源，但纹理还在内存中，且引用数为0，要如何销毁呢？纹理所在的UI的GameObject是通过Destroy销毁的，并且执行了Resources.UnloadUnusedAssets();&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Ref Count为0应该就是可以通过Resources.UnloadUnusedAssets或Resources.UnloadAsset来进行卸载了。&lt;/li&gt;
  &lt;li&gt;出现这种情况建议如下：
    &lt;ul&gt;
      &lt;li&gt;尝试将Resources.UnloadUnusedAssets在Destroy稍后几帧执行；&lt;/li&gt;
      &lt;li&gt;在加载时尝试直接获取这些资源，然后在Destroy后通过Resources.UnloadAsset来卸载指定资源。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;resourcesunloadunusedassets-uwa&quot;&gt;Resources.UnloadUnusedAssets() 在卸载旧场景后加载新场景前调用好，还是在加载新场景后调用比较好呢？如果考虑内存峰值的话，我觉得是前者好，但是在UWA上看到有些文章说是加载场景后调用。&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;如果是通过LoadLevel(Async)类似的方式来加载场景的话，那么Unity自身会在底层执行一次类似Resources.UnloadUnusedAssets的操作。所以，这时如果手动调用Resources.UnloadUnusedAssets操作，时间间隔很短，其实这个是有些重复的。因此才建议在新场景加载后再调用一次。&lt;/li&gt;
  &lt;li&gt;但如果使用LoadLevelAdditive或其他类似的API来切换场景的话，那么Unity是不会调用Resources.UnloadUnusedAssets的，这时在旧场景卸载后调用，其实也是很不错的选择。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 23 Dec 2017 16:55:12 +0800</pubDate>
        <link>https://caihua.tech/2017/12/23/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%91%A8/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/12/23/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%91%A8/</guid>
        
        <category>UWA</category>
        
        
      </item>
    
      <item>
        <title>每天一点UWA：第十九周</title>
        <description>&lt;h2 id=&quot;assetbundle&quot;&gt;AssetBundle&lt;/h2&gt;
&lt;h4 id=&quot;assetbundleplayersettingsoptimize-mesh-data-optimize-mesh-datamesh-&quot;&gt;在移动平台上打AssetBundle时，为了控制包体大小，会开启PlayerSettings中的Optimize Mesh Data，对网格文件使用范围比较多的资源有较好的优化效果。 然而这带来了一个问题，就是在部分使用网格的特效中，美术会对模型上一些顶点做特殊处理，以达到一种网格遮罩的效果，而这个设置需要用到网格的顶点色。然而在开启Optimize Mesh Data这一选项后，打出来包中Mesh上的顶点色会丢失。 请问有什么比较好的解决方法，既能使用此方法优化网格，又能保留网格的顶点色效果？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;一般来说，开启“Optimize Mesh Data”选项，引擎会在发布时遍历所有的网格数据，去除其多余数据，从而降低其数据量大小。需要注意的是，这里的“多余”数据是指Mesh数据中包含了渲染时Shader中所不需要的数据，即如果Mesh数据中含有Position、UV、Normal、Color、Tangent等顶点数据，但其渲染所用的Shader中仅需要Position、UV和Normal，则Mesh数据中的Color和Tangent则为“多余”数据，引擎在发布游戏时，会将这些数据自动去除。&lt;/li&gt;
  &lt;li&gt;开启这个选项是一把双刃剑。对于在Runtime情况下有更换Shader需求的Mesh，建议研发团队对其特别注意。如果Runtime时需要为某一个GameObject更换更为复杂、需要访问更多顶点属性的Shader，则建议先将这些Shader挂载在相应的Prefab上再进行发布，以免引擎去除Runtime时会使用到的网格数据。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;assetbundleassetbundlewwwassetbundlegameobjectwwwdisposeassetbundleunloaddestroydestoyimmediatassetbundleassets-&quot;&gt;对于运行时动态加载的普通模型比如怪物，我们目前的打包策略是把它单独打一个AssetBundle包，通过AssetBundle加载并实例化的消耗。如下图所示，对于WWW、AssetBundle、GameObject，卸载方法分别为WWW.Dispose、assetBundle.Unload、Destroy/DestoyImmediat。但对于通过AssetBundle加载出来的Assets资源， 这块的资源用什么策略清理合适？&lt;/h4&gt;
&lt;blockquote&gt;
  &lt;p&gt;1）Resources.UnloadUnusedAssets，但该函数比较费时，一般只在切换场景时候使用；&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;2）assetBundle.Unload(true); 运行时Assetbundle在Instantiate prefab完成后也立即执行了unload(false)，所以也不适用；&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;对实例化出来的GameObject在使用后即使执行了DestroyImmediate，模型引用的贴图还驻留在内存中，难道要遍历GameObject使用的Assets分别执行UnloadAsset么？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;如果是仅加载Prefab，那么随Prefab一起加载进来的资源是不太方便被“优雅”地卸载的，即便是对应的GameObject被Destroy了，那么它对应的资源会变成“游离”状态（没有Refcount），只能等到手动调用Resources.UnloadUnusedAssets或场景切换时被引擎卸载。 所以，一般建议研发团队尝试通过依赖关系进行打包，将资源和Prefab进行分离，这样可以将加载资源和加载Prefab分开，从而可以通过“显式”地方式加载资源并将其进行储存，这样当你想精准释放资源时，则可以直接通过Resources.UnloadAsset来进行卸载。&lt;/li&gt;
  &lt;li&gt;PS: 这个问题本身就很有内容。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;audio&quot;&gt;Audio&lt;/h2&gt;
&lt;h4 id=&quot;unity-472unity-553apk200mb472apk553200mbkbunity-472mp3unity-553wav&quot;&gt;将一个Unity 4.7.2的项目升级到Unity 5.5.3。打成安卓包，发现APK文件比之前大了200MB。然后分别对4.7.2打出来的APK包和5.5.3打出来的包分别进行解包，发现音频文件个数一样，但所占大小多了200MB左右，平均每个文件都大了几百KB。Unity 4.7.2的解包为Mp3格式，Unity 5.5.3的解包为Wav格式。&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;于是我在Unity 4.7.2和Unity 5.5.3下，分别新建一个空工程，将单独一个音频文件（ogg格式）放入Resources文件下，即两个Unity版本的空工程里只有一个Resources文件夹，文件夹里只有一个相同的Ogg格式音频文件，打成安卓包。使用解包工具解包，发现Unity 4.7.2的音频文件转成了mp3格式，大小几十kb；Unity 5.5.3的音频文件转成Wav格式，大小200多KB。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;请问这种问题怎么解决？针对音频，Unity 4.x和Unity 5.x在打包过程中，作了那些修改？&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;引用Unity 5.0的release note：https://unity3d.com/unity/whats-new/unity-5.0
“Rewritten Audio asset pipeline and AudioClip backend.””Much improved audio formats in terms of memory and CPU usage.** The Format property no longer refers to a specific platform-specific file format, but to a encoding method** (Uncompressed, Compressed, ADPCM).”&lt;/li&gt;
    &lt;li&gt;可以看到，在Unity 5.x中，不同平台的音频不再与特定的文件格式关联，而是与文件编码关联。文件格式不等同于音频编码，虽然同是Wav格式的文件，但其有不同的编码方法（PCM，ADPCM，Vorbis，Wav也可以用mp3编码），编码方法会影响到Apk的大小。选定编码方式后降低quality和sample rate也会降低apk大小。
&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2FTechSharing_79%2F7.png&quot; alt=&quot;image&quot; /&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;font&quot;&gt;Font&lt;/h2&gt;
&lt;h4 id=&quot;iphone5cfontcachefontfortextuwablogfonttexturefont-texture-34&quot;&gt;我们在iPhone5c上测试时发现Font.CacheFontForText会造成很严重的卡顿，看了UWA的Blog，了解到可能是因为创建FontTexture导致的开销。那是否可以认为如果我们一开始申请了足够大的Font Texture，后面即便有新的文字，开销也不会很大？ 如果可以这么做，一开始申请使用的字符串是根据自己项目生成一个字典，还是直接使用网上3、4千字的常用字库更好？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;是的，如果Font.CacheFontForText开销较大，那么在无法降低字体数量的情况下，一开始增大Font Texture是较为可行的方法。建议根据自己项目的字体来撑大Font Texture，避免不必要的浪费。 同时，也建议看一下这篇&lt;a href=&quot;https://blog.uwa4d.com/archives/Sparkle_Font.html&quot;&gt;关于字体的精简优化方法&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;gameplay&quot;&gt;GamePlay&lt;/h2&gt;
&lt;h4 id=&quot;colliderboundssize-aabbobb&quot;&gt;我想了解下如何获取物体的最小包围盒？Collider.bounds.size 获取的是与世界坐标系坐标轴平行的包围盒(AABB)，当物体旋转时包围盒大小会发生变化。那如何获取物体的OBB，使包围盒的大小不会随物体旋转而改变呢？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;获取 OBB 可以用 Mesh.bonuds(模型空间)。注意蒙皮Mesh这一类在Shader中修改顶点坐标的操作。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;scriptableobjectassetassetbundledlldllscriptableobjectassetbundleassetbundleprotobufscriptableobjectscriptableobject&quot;&gt;安卓客户端存在大量的模板数据需要配置，其中一些模板表甚至可能达到万级的数据条目，那么怎么对这些数据模板表进行打包和加载，可以兼顾加载速度和热更新表结构？一开始我们采用了ScriptableObject，把全部模板数据加载到内存并序列化为Asset的方式进行Assetbundle打包，该方案加载速度较为理想。但当我们通过Dll替换热更新安卓客户端时，发现这种方式不支持热更新，一旦Dll中修改了模板表结构，热更新替换后，ScriptableObject的AssetBundle就无法读取了，提示损坏的AssetBundle，目前的方案是采用Protobuf代替ScriptableObject进行序列化，可以实现热更新模板表结构，但是加载速度相对ScriptableObject有较大的差距，目前数据模板加载较慢便导致了玩家进入世界的时间比较久。因此想了解大家有什么好的建议呢？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;用ScriptableObject或者BinaryFormatter二进制存储然后反序列化成保存数据结构的对象，这两种方法应该是加载速度最快的。
我们实际没有采取这个方案，也使用的是Protobuf，是出于以下考虑:
    &lt;ul&gt;
      &lt;li&gt;一份二进制数据，客户端和服务器可以通用。从服务器推数据很方便；&lt;/li&gt;
      &lt;li&gt;策划习惯使用Excel编辑，有脚本可以把表格内容导出成Protobuf的二进制数据，另外，还有.cs/.go表结构描述文件需要重点考虑。也就是说，策划修改表结构、增减表，服务器和客户端的结构描述文件可以自动生成好；&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;第一个问题：配置表存储格式
现在主流的数据存储基本分为三大类，各有优劣，需要根据实际情况选择：
    &lt;ul&gt;
      &lt;li&gt;ProtoBuf或类似序列化库，这种方式兼容性高，但是加载速度一般；&lt;/li&gt;
      &lt;li&gt;自己实现二进制数据存储，兼容性差，需要精心设计达到较高的数据表达能力；&lt;/li&gt;
      &lt;li&gt;采用Lua热更新方案的游戏，普遍直接把数据存储为Lua表。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;第二个问题：配置表数据与代码兼容
一般不建议大量修改数据结构，比如增删字段，如果实在无法避免，需要代码连同数据一起发布进行热更，做好版本管理即可。&lt;/li&gt;
  &lt;li&gt;第三个问题：配置读取速度优化
    &lt;ul&gt;
      &lt;li&gt;先从数据量上约减，减小数据冗余重复，数据存储设计优化，多次引用的字段多引用等等；&lt;/li&gt;
      &lt;li&gt;采用多线程加载，避免使用Unity提供的API，在游戏启动时，并行加载配置表，充分利用多核优势；&lt;/li&gt;
      &lt;li&gt;就我们自己项目而言，没有使用Lua的更新方案，但是我们依然采用Lua作为了数据存储，经过优化后加载速度也不错，可以参考 LuaTableOptimizer。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;maincamera--screen-depth-buffer-camera2--maincamera--rendertexture--screen-depth-buffer--camera2rendertexturecolorbuffer--camera2--unity--screen-depth-buffer--rendertexturecolorbuffer-&quot;&gt;MainCamera 渲染完场景后，在 Screen Depth Buffer 上记录了整个场景的深度信息。Camera2 在 MainCamera 后，将模型绘制到一个 RenderTexture 上，我想利用 Screen Depth Buffer + Camera2.RenderTexture.ColorBuffer 对 Camera2 绘制的内容进行深度剔除，这时 Unity 会提示 Screen Depth Buffer 和 RenderTexture.ColorBuffer 不能混用。这样的需求该怎么做呢？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;这是一个很有意思的问题，参考https://blog.uwa4d.com/archives/1945.html&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;inspectordictionary--public-dictionarystringstring-dict&quot;&gt;请问怎么在inspector中显示Dictionary呢？ 例如： Public Dictionary&amp;lt;string,string&amp;gt; dict;&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Unity 无法序列化Dictionary类型，无法将其显示在inspector中。一个Workaround是将Dictionary的Key和Value拆到两个list中，list可以在Inspector中显示。利用API：ISerializationCallbackReceiver （https://docs.unity3d.com/ScriptReference/ISerializationCallbackReceiver.html 有示例代码）可以在序列化/反序列化时将Dictoionary中的内容与list内容同步。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;unityfloat&quot;&gt;Unity需要对float进行相等判定&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Mathf.Approximately&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;uguibuttononclickaddlistenerbuttonbuttoncdelegategetinvocationlistdbuttonapibutton&quot;&gt;通常UGUI中的Button点击事件在代码中是通过onClick.addListener()来添加的。而且这种按钮的点击事件通常只会执行一次，如果添加了多次就会出现点击一次、按钮调用多次的事件函数。如果该Button只会添加一种事件，可以通过引用来判断是否添加了重复事件，从而不再重复添加相同事件。但是如果Button添加了多种点击事件，那么引用的方式就无效了。C#中的Delegate中有一个函数GetInvocationListD()可以获取此委托中的事件列表，从而剔除相同事件。然而让人头痛的是，我查看了Button的API似乎并没有暴露出此Button添加了的事件列表，所以没有办法剔除相同事件。不知道是否有什么办法可以解决这个问题?&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;onClick是一个ButtonClickedEvent对象，而ButtonClickedEvent的基类是UnityEventBase。UnityEventBase里有一个InvokableCallList对象，里面应该就存了事件列表，但这个是private的，可能只能尝试通过反射，去取里面的值来对比了。看上去并没有比较简便的方法。&lt;/li&gt;
  &lt;li&gt;可以考虑扩展下Button组件，封装一个AddUniqueListener的接口，保留一下已经onClick.addListener的UnityEvent，然后每次Add前都先和这些UnityEvent做个对比，没有重复再进行onClick.addListener。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section&quot;&gt;如果场景中有大量物体，请问如何利用相机拾取获取不同范围内的物体？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;采用Physics.SphereCastAll函数来获取，类似下面这个场景：
&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2FTechSharing_79%2F1.png&quot; alt=&quot;image&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;在SphereCastAll这个API的参数中，第二radius可以控制获取半径，我们分别设置5和10的效果是这样的：
radius=5：
&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2FTechSharing_79%2F2.png&quot; alt=&quot;image&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;radius=10：
&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2FTechSharing_79%2F3.png&quot; alt=&quot;image&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;unityandroidunityiosandroidunity552&quot;&gt;如下图，蓝色部分为Unity视图，绿色为Android图片，我现在需要把Unity蓝色区域透视或者去除，iOS上已经透视成功，但Android一直失败，Unity版本为5.5.2，大家有什么建议呢？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;只记录下方案 https://blog.uwa4d.com/archives/TechSharing_79.html&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;guilayoutscrollview&quot;&gt;改变GUILayout中ScrollView滑动条宽度&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;GUIStyle gs = GUI.skin.verticalScrollbar;
GUIStyle gs1 = GUI.skin.verticalScrollbarThumb;
        
gs.fixedWidth = 30;
gs1.fixedWidth = 30;
......
pos = GUILayout.BeginScrollView(pos);
......
GUILayout.EndScrollView();
......
gs.fixedWidth = 0;
gs1.fixedWidth = 0;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;staticbatchlightmaprendererlightmapindex-and-offsetlightingdataassetlightmapsettingrendererlightmapindex-and-offset-lightmaplightingdataasset-uwa&quot;&gt;我这边做了个测试，把场景中的物件进行StaticBatch，用Lightmap烘焙，并且在烘焙完记录每个物件Renderer的lightmapindex and offset，然后在运行中，我删除了生成的LightingData.Asset，自己设置了Lightmapsetting，并且恢复了每个物体Renderer的Lightmapindex and offset, 结果我发现烘焙出来的场景Lightmap还是不对的。我怀疑是不是LightingData.Asset 还记录了别的东西，想问问看UWA有没有什么经验呢？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;这个问题还是出在Static Batching上。经过测试我们发现如果去掉场景中物件的“Static Batching”标记，换成手动Batching，即采用StaticBatchingUtility.Combine的方式结果就正确了。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2FTechSharing_81%2F2.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;同时，我们发现使用LightingData.Asset时，开启Static Batching与不开启都正确，因此我们认为LightingData.Asset可能记录了与CombinedMesh有关的数据，导致如果仅仅使用gameobject的LightMap参数无法正确读取CombinedMesh的LightMap UV。另外一种可能是Unity的一个Bug。
最后，我们建议采用上述手动Batching的方式，即可解决此问题。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;linearuiuilinearuilinear&quot;&gt;当使用Linear设置时，UI上图片透明度等也跟着变化，出来的效果与美术人员的需求不一样。请问有什么办法可以让UI不使用Linear或者让UI可以在Linear影响下也正常呢？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;值记录下做法：https://blog.uwa4d.com/archives/2066.html&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;texture&quot;&gt;Texture&lt;/h2&gt;
&lt;h4 id=&quot;iospvrtc-&quot;&gt;请问在iOS上，图集如何设置成PVRTC的格式呢？ 下图中的设置是否正确？&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2FTechSharing_74%2F1.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;图集的设置需要考虑到该图集的用法，如果是作为普通的Texture给3D物体用的，那么TextureType选择Texture，然后Format选择Compressed就可以，因为在iOS上，Unity会自动处理NPOT（把纹理拉伸为边长为2的幂次的正方形），并默认采用PVRTC。&lt;/li&gt;
  &lt;li&gt;设置之后可以看一下下方的预览面板，会直接显示PVRTC的；如果是给UGUI用，那不同情况下，设置又不一样了；如果是给NGUI用，可以按照问题中截图里的设置即可，最终再确认下预览图上是不是PVRTC。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;loadsubsasyncloadsubsspritedata-loadtextureloadsubsloadsubsasyncspritedata-loadsubsasyncloadsubstexturespritedatatexturespritedata&quot;&gt;LoadSubsAsync和LoadSubs加载SpriteData，我想请问一下： 如果先LoadTexture加载纹理再加载LoadSubs，或者LoadSubsAsync函数调用加载SpriteData，纹理是否会加载两次，以及性能如何呢？ 按照我的理解，LoadSubsAsync或者LoadSubs，它自身有Texture属性，我断点调试可以看到SpriteData内的Texture会随着SpriteData加载而出来。&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;LoadSub和LoadSubAsync是会同时加载Texture的。 而先Load再LoadSub，并不会造成冗余问题，所以Load过Texture后，LoadSub的耗时就很小了。 但如果Texture里的Sprite是打了图集的，那么LoadSub的时候还是会有个图集加载的耗时。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ui&quot;&gt;UI&lt;/h2&gt;
&lt;h4 id=&quot;q1uguicanvassendwillrenderviewviewcanvasgroupscalesendwillrender&quot;&gt;Q1：众所周知，UGUI中有个Canvas.sendWillRender()函数在View打开的时候很耗时，所以通常的做法是把View移出屏幕外，或者Canvas.group，或者Scale等类似的处理机制。这样虽然能解决SendWillRender()消耗过高的问题，但也会有新的问题出现：&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;EventSystem.Update()。由于各个View都是Active的状态，所以这个函数底下的Graphic.GetDepth()消耗很大，而且又由于不止一个GraphicRaycaster组件，所以这个函数下面的List.Sort()消耗巨大，更何况是每帧都在耗。&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;还有一个函数ScrollRect.LateUpdate()，它的开销也很高。而如果将Scale设置成0，其消耗更大，这种情况下，我还是倾向于用回Active/Deactive的处理机制，因为就界面打开的时候会卡一下，而不至于影响总体的帧率。&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;界面的快速隐藏和显示，比较推荐的做法是：
    &lt;ul&gt;
      &lt;li&gt;把界面单独作为一个Canvas，并绑定一个相机，同时在绑定相机的Culling Mask中设置一个不渲染的Layer；&lt;/li&gt;
      &lt;li&gt;隐藏时，把Canvas移出相机范围，同时把Canvas的Layer改为不被渲染的Layer，禁用对应的GraphicRaycaster组件，把Canvas中所有的动态UI元素停止。&lt;/li&gt;
      &lt;li&gt;显示时，移回Canvas，改回Layer，激活GraphicRaycaster组件。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;针对题主的问题1，禁用GraphicRaycaster组件后就没问题了，被禁用的GraphicRaycaster不会进行Raycast操作；&lt;/li&gt;
  &lt;li&gt;针对题主的问题2，ScrollRect.LateUpdate中会通过EnsureLayoutHasRebuilt提前触发Canvas.SendWillRenderCanvases()，所以实际上还是Canvas.SendWillRenderCanvases()的开销。Canvas.SendWillRenderCanvases()开销高，是因为用Scale改为0的方式会清除顶点信息，在Scale改回1的时候还是需要重新创建顶点信息，开销肯定还是很高的，所以不推荐用Scale改为0来隐藏复杂的UI界面。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;uistaticstatic--&quot;&gt;UI界面勾选Static是会节省一部分性能，但是如果我移动了某个设置为Static界面下的元素，这个界面还算是静态的么? 还是等运动的元素停下来后的界面才算静态的? 如果是这样，是不是我全部界面都设置静态就好了?&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;如果题主所指的“勾选static”是指GameObject右上角的Static框，这个Static和UI是无关的，不会对UI有影响；如果是NGUI的UIPanel上的Static选项，勾上之后，子节点中的UI元素是无法移动的（即使改了Transform，其图标位置也不会更新）。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;工具&lt;/h2&gt;
&lt;h4 id=&quot;profilerassetsscene-memorymeshscene-memorymesh2meshcombinedmeshroot-sceneassetsmesh100meshmeshassetsmeshreferenced-byhierarchy&quot;&gt;Profiler里Assets和Scene Memory的区别是什么？比如Mesh这一项，在Scene Memory的Mesh中看到的只有2个合并的Mesh：CombinedMesh(root: scene)，在Assets的Mesh里看到的有100多个，包括场景里的非合并Mesh，动态加载出来的角色Mesh等。并且Assets的Mesh中的某些点击后选择右边的Referenced By，在Hierarchy里会自动选中场景中的物体，怎么看也不像是单纯的模板，而是实例化出来的东西。&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2FTechSharing_75%2F2.png&quot; alt=&quot;image&quot; /&gt;
&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2FTechSharing_75%2F3.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Resources.Load/Assetbundle.Load出来的ParticleSystem都是放Assets下的，可以认为是模板资源，并不在场景里。Instantiate出来的放在Scene Memory下，是出现在场景里的。&lt;/strong&gt; 所以两边都有是正常的。&lt;/li&gt;
  &lt;li&gt;在Unity里资源至少分为两类：
    &lt;ul&gt;
      &lt;li&gt;一类是可以被引用的，比如Mesh、Texture，如果要渲染多个相同的Mesh，并不需要对Mesh实例化，只需要在场景里多创建几份MeshRenderer/MeshFilter去引用它即可。所以Assets下的Mesh不应该被认为是实例化出来的东西，这些Mesh仅仅是通过AsssetBundle.Load/Resources.Load加载出来的，只是被场景里的东西引用了；&lt;/li&gt;
      &lt;li&gt;但SceneMemory下的Mesh通常是通过new Mesh或者Instantiate创建的，这部分可以说是实例化出来的了，另外像CombinedMesh是Unity自己创建的，也可以算是实例化的。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;另一类是不可被引用的，通常是组件资源，比如ParticleSystem，如果要渲染多个相同的ParticleSystem，就需要实例化多份出来，ParticleSystem的模板在Assets下，而实例化出来的在SceneMemory下。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;editor-mono672mb515mbgccollectmono&quot;&gt;我在Editor下测试， 前一帧Mono还是67.2MB，下一帧突然自己掉到了51.5MB。然而并没有gc.collect()调用，这Mono是为什么减少？因为有不明原因的减少，所以担心也有不明原因的增多。&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;如果题主是在Editor测的，这个Mono的回落就正常了。Editor本身（渲染窗口，处理交互事件等）就会造成内存分配，同时也会触发GC。&lt;/li&gt;
  &lt;li&gt;但默认情况下，Editor本身的开销在Profiler里是看不到的，除非题主点击一下“Profile Editor”。 点击之后，就可以看到Editor本身函数的耗时和GC的触发了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;模型&amp;amp;动画&lt;/h2&gt;
&lt;h4 id=&quot;hierarchyanimation-windowmissingcurve&quot;&gt;场景中放置一动画物体，原先正常进行动画，修改了物体Hierarchy某结点的名称，然后动画就异常了。打开Animation Window，发现动画曲线变为Missing。把物体名称改回后又恢复正常。我的疑问是动画Curve是与物体名称绑定的吗？如果是，如何修改动画物体的名称呢？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;anim文件里有节点路径的：
比如：curve: serializedVersion: 2 m_Curve:
    &lt;ul&gt;
      &lt;li&gt;time: 0 value: {x: -0.187, y: -0.003, z: 0.062} inSlope: {x: 0, y: 0, z: 0} outSlope: {x: 0, y: 0, z: 0} tangentMode: 0&lt;/li&gt;
      &lt;li&gt;time: 0.93333334 value: {x: -0.187, y: -0.003, z: 0.062} inSlope: {x: 0, y: 0, z: 0} outSlope: {x: 0, y: 0, z: 0} tangentMode: 0 m_PreInfinity: 2 m_PostInfinity: 2 m_RotationOrder: 4 path: Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 R Clavicle/Bip001 R UpperArm/Bip001 R Forearm/Bip001 R Hand/Bip001 R Finger1&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Animation Curve与动画物体是名称绑定的（名称包含其Hierarchy的Path，除去Root）；&lt;/li&gt;
  &lt;li&gt;Animation Window中可以修改Curve的绑定名，可以将其更新为改名后物体的Path；&lt;/li&gt;
  &lt;li&gt;如李先生所说Animation文件包含结点路径，可以“ForceText”后用文本工具来修改，比较方便；&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-3&quot;&gt;平时研究动画系统的时候有几个不太明白的问题：&lt;/h4&gt;
&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;BlendTree（不论1D或者2D） 在采样的时候，如果BlendTree内的AnimationClip的长度不同，那么输出的动画长度是可变的。不同的BlendTree参数会导致不同的BlendTree输出的动画长度。问题是BlendTree最终输出的动画长度是如何计算出来的？采样AnimationClip的时候，对于动画的TimeScale做了什么调整？ 图例：run是一个BlendTree2D，当它的参数Speed=300时，和Speed=900时的长度是不一样的。
&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2FTechSharing_78%2F2.png&quot; alt=&quot;image&quot; /&gt;&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;2.Unity的BlendTree2D是如何根据两个动画参数确定该在哪几个AnimationClip中采样？这些AnimationClip各自的权重是多少？ 图例：当Direction=-19，Speed=777的时候，黄箭头所指的动画实际上是由红箭头所指的4个动画混合而成的。那么混合权重分别是多少？
&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2FTechSharing_78%2F3.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;对于不同的Clip动画数据进行Blend时，Unity会把所有Clip的时间都归一化（展开为相同长度）后，再根据各个Clip的权重进行加权平均。&lt;/li&gt;
  &lt;li&gt;Blend后的时间长度与各Clip的权重相关，时间更接近权重大的Clip的时间（近似时间长度的加权平均）。BlendTree参数值用来决定当前Blend各Clip的权重值，参数不同导致权重不同，因此时间也就不同。参数值如何决定哪些Clip进行Blend，其权重则跟不同Clip的参数threshhold相关。&lt;/li&gt;
  &lt;li&gt;2D时在参数空间中根据（x,y)的坐标位置对临近的Clips进行插值。不同2D Blend 类型使用的插值方法不同，而插值方法的实现也就决定了各Clip的权重。对于插值算法可以参考这里提供的pdf：
http://answers.unity3d.com/questions/1206428/how-weights-of-2d-blending-are-calculated.html&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-4&quot;&gt;性能综合&lt;/h2&gt;
&lt;h4 id=&quot;scriptmapperstandardshaderstandardshader&quot;&gt;如下图，不理解ScriptMapper具体是什么，为什么会引用StandardShader，有什么办法可以彻底把StandardShader从内存里移除呢？&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2FTechSharing_75%2F1.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;这说明是有代码在索引这个Shader。建议题主尝试以下方法来定位Standard Shader的具体引用：
    &lt;ul&gt;
      &lt;li&gt;在游戏运行时遍历所有的GameObject或者Material，然后获取其所使用的Shader信息，查找跟“Standard”名称相对应的Shader，然后就可以定位它是出自哪个Material或GameObject。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;上述方法应该适用于大部分情况，但无法适用于以下情况：
    &lt;ul&gt;
      &lt;li&gt;Shader被加载后直接被缓存在代码脚本中；&lt;/li&gt;
      &lt;li&gt;Shader是通过AssetBundle.LoadAll加载的；&lt;/li&gt;
      &lt;li&gt;Shader通过Preload Shader加载的。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;unitygameobjectactiveactiveuwaunityactive&quot;&gt;Unity对GameObject.active()这个底层具体做了什么？因为在优化项目的时候看见有些界面active()这个函数造成的开销比较高，我采取的办法是移除摄像机的范围，这是参照UWA以前文章找到的办法，但是我还是想知道Unity对Active底层具体做了哪些操作，否则会有点困惑。&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;至少SetActive后，如果GameObject被激活，那么会调用该GameObject和所有子GameObject上的所有组件的OnEnable函数。而各种不同的UI组件的OnEnable中也有各种不同的操作。 如果题主希望深入研究下，可以看一下NGUI或者UGUI的源码，OnEnable具体做了什么都可以看到。同时，针对UI界面而言，还会在同一帧里触发其他的相关函数，出现后续的开销，如UGUI里的SendWillRenderCanvases和NGUI里的UIPanel.LateUpdate。&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Fri, 22 Dec 2017 16:49:12 +0800</pubDate>
        <link>https://caihua.tech/2017/12/22/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E5%8D%81%E4%B9%9D%E5%91%A8/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/12/22/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E5%8D%81%E4%B9%9D%E5%91%A8/</guid>
        
        <category>UWA</category>
        
        
      </item>
    
  </channel>
</rss>
