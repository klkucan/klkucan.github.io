<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>蔡华的博客</title>
    <description>Be publicly useful and privately happy.</description>
    <link>https://caihua.tech/</link>
    <atom:link href="https://caihua.tech/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sat, 21 Apr 2018 20:16:27 +0800</pubDate>
    <lastBuildDate>Sat, 21 Apr 2018 20:16:27 +0800</lastBuildDate>
    <generator>Jekyll v3.2.1</generator>
    
      <item>
        <title>游戏设计模式读书笔记：状态模式</title>
        <description>&lt;h4 id=&quot;section&quot;&gt;解决了什么问题&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;在游戏开发中状态是一种常见的用于描述游戏对象的方法，在状态比较简单的情况下可能通过多个标志位变量就可以组合出不同的状态。例如书中举得英雄行走、跳跃、蹲下等操作。但是一旦当对象的状态可是变得比较多，而且需要通过比较多的变量才能描述清楚时，只使用标志位变量的弊端就出现了：那就是过多的变量在代码编写时需要的条件语句会很多，而且变量的组合也不利于管理。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;switch&quot;&gt;使用switch管理状态&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;首先需要将状态从变量组合变为一个明确的字段，此时我们可以使用enum来实现这个。&lt;/li&gt;
  &lt;li&gt;在switch中对于每个枚举状态开设分支。这样从一定程度上解决了大量变量带来的编程的复杂度。而且从逻辑上清晰的划分了状态。&lt;/li&gt;
  &lt;li&gt;但是这个仍旧存在问题，用书中的例子来说，当你需要在某个状态中进行一个计时操作时。就需要在switch代码块和update代码块中修改功能，这说明功能没有能很好的封装，你需要修改两处才能实现功能的修改。如果我们在修改功能的时候只修改一个地方就能够避免一些麻烦，比如一次修改就要同时修改多处，万一遗漏了一个就可能造成bug。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-1&quot;&gt;状态模式&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;允许一个对象在其内部状态发生变化时改变自己的行为，该对象看起来好像修改了它的类型。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;这句话有点让人难以理解，实际上状态模式是这么干的：
    &lt;ul&gt;
      &lt;li&gt;定义状态接口&lt;/li&gt;
      &lt;li&gt;让每个状态成为一个类并实现接口&lt;/li&gt;
      &lt;li&gt;对象持有状态对象的引用，从而使得从外部看（实际就是获取对象的某些属性或者调用函数）这个对象具有不同的状态。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;对于一个状态的接口一般都包含如下的函数：Enter、Update、Exit。除此之外也可以根据实际情况设计一些函数，比如设计一个Init函数，它是在状态对象实例化时进行初始化用的。&lt;/li&gt;
  &lt;li&gt;静态状态：如果一个状态它只有函数没有字段，也就是说它是对象无关的，那么完全可以使用静态类来定义状态，这样做可以节省内存，管理起来也比较简单。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;fsm&quot;&gt;有限状态机（FSM）&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;FSM我个人认为其作用在于专职的管理状态，比如状态的创建、切换、销毁等。&lt;/li&gt;
  &lt;li&gt;对象持有的不在是一个具体的状态对象，而是一个FSM对象。而状态的切换也需要在FSM中实现，FSM中有一个所有状态的集合，同时保存当前的状态的引用。&lt;/li&gt;
  &lt;li&gt;在切换状态时先要执行当前状态的Exit函数，然后执行下一个状态的Enter。&lt;/li&gt;
  &lt;li&gt;在unity中对于不同的FSM一般使用一个专门的管理类来管理所有的FSM。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-2&quot;&gt;并发状态机&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;并发状态机和下面谈到的另外两个其实都是在上面所说的基础上的扩展，用于不同的场景。&lt;/li&gt;
  &lt;li&gt;顾名思义，并发状态机实际上就是对象同时拥有两种不同的状态。以书中的例子来说，就是英雄角色具有一个状态机，而英雄手中的武器也具有一个状态机。&lt;/li&gt;
  &lt;li&gt;两个不同的状态机之间可能会有交互，为了完成这个，你也许会在状态的代码中做一些粗糙的if测试其他状态来协同，这不是最优雅的解决方案，但这可以搞定工作。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-3&quot;&gt;分层状态机&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;当不同状态具有某个共同点时使用。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;举个例子，我们的英雄也许有站立、行走、奔跑和滑铲状态。在这些状态中，按B跳，按下蹲。如果使用简单的状态机实现，我们在每个状态中的都重复了代码。如果我们能够实现一次，在多个状态间重用就好了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;状态可以有父状态（这让它变为子状态）。当一个事件进来，如果子状态没有处理，它就会交给链上的父状态。 换言之，它像重载的继承方法那样运作。事实上，如果我们使用状态模式实现FSM，我们可以使用继承来实现层次。 定义一个基类作为父状态：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class OnGroundState : public HeroineState
{
public:
  virtual void handleInput(Heroine&amp;amp; heroine, Input input)
  {
    if (input == PRESS_B)
    {
      // 跳跃……
    }
    else if (input == PRESS_DOWN)
    {
      // 俯卧……
    }
  }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class DuckingState : public OnGroundState
{
public:
  virtual void handleInput(Heroine&amp;amp; heroine, Input input)
  {
    if (input == RELEASE_DOWN)
    {
      // 站起……
    }
    else
    {
      // 没有处理输入，返回上一层
      OnGroundState::handleInput(heroine, input);
    }
  }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;除了使用继承外，还可以显式的使用状态栈而不是单一状态来表示当前状态的父状态链。栈顶的状态是当前状态，在他下面是它的直接父状态，然后是那个父状态的父状态，以此类推。 当你需要状态的特定行为，你从栈的顶端开始，然后向下寻找，直到某一个状态处理了它。（如果到底也没找到，就无视它。）&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-4&quot;&gt;下推自动机&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;下推状态机解决的问题是有限状态机没有任何历史的概念。你记得正在什么状态中，但是不记得曾在什么状态。 没有简单的办法重回上一状态。&lt;/li&gt;
  &lt;li&gt;有限状态机有一个指向状态的指针，下推自动机有一栈指针。 在FSM中，新状态代替了之前的那个状态。 下推自动机不仅能完成那个，还能给你两个额外操作：
    &lt;ul&gt;
      &lt;li&gt;你可以将新状态压入栈中。“当前的”状态总是在栈顶，所以你能转到新状态。 但它让之前的状态待在栈中而不是销毁它。&lt;/li&gt;
      &lt;li&gt;你可以弹出最上面的状态。这个状态会被销毁，它下面的状态成为新状态。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-5&quot;&gt;总结&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;状态模式在游戏开发中使用的最为广泛的就是FSM，它有效的将游戏对象的不同状态进行了封装，从而使得对象的操作更加简单。&lt;/li&gt;
  &lt;li&gt;对于单个的游戏对象不同的状态中可能会有更多的操作，比如对象在行走状态下需要控制移动的方向、速度、对于碰撞体的处理等。这个就需要在状态机中进行功能编写了。&lt;/li&gt;
  &lt;li&gt;对于FSM的实现推荐看下GameFramework中的&lt;a href=&quot;https://github.com/EllanJiang/GameFramework/tree/master/GameFramework/Fsm&quot;&gt;FSM&lt;/a&gt;部分。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 21 Apr 2018 20:15:35 +0800</pubDate>
        <link>https://caihua.tech/2018/04/21/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</link>
        <guid isPermaLink="true">https://caihua.tech/2018/04/21/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</guid>
        
        <category>游戏设计模式读书笔记</category>
        
        
      </item>
    
      <item>
        <title>七周七并发模式：Lambda架构</title>
        <description>&lt;h3 id=&quot;lambda&quot;&gt;Lambda架构&lt;/h3&gt;

&lt;h4 id=&quot;section&quot;&gt;定义&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;Lambda架构使用了可以进行大规模数据批处理的MapReduce技术，也使用了可以快速处理数据并及时反馈的流处理技术，这样的混搭能够为大数据问题提供扩展性、响应性和容错性都很优秀的解决方案。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Lambda架构是站在大规模场景的角度来解决问题的，它可以将数据和计算分布到几十台或几百台机器构成的集群上进行。这种技术不但解决了之前因为规模庞大而无法解决的难题，还可以构建出对硬件错误和人为错误进行容错的系统。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Lambda架构源自于它与函数式编程的相似性。从本质上说，Lambda架构是将计算函数施加于大量数据的一种通用方法。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;不变原始数据是Lambda架构的基础。对于不变的数据进行处理的时候，不在需要锁机制和事物机制。多个线程可以并行地访问数据，而不用担心相互之间的作用。我们可以对数据进行复制，再对副本进行操作，而不用担心数据过期，所以在集群中分布地处理数据就变得非常容易。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-1&quot;&gt;传统数据系统的缺陷&lt;/h4&gt;
&lt;blockquote&gt;
  &lt;p&gt;扩展性：利用某些技术（比如复制、分片等）可以将传统数据库扩展到多台计算机上，但随着计算机数量和查询数量的增加，应用这种方案会变得越来越困难。超过一定程度，增加计算机资源将无法继续改善性能。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;维护成本：维护一个跨多台计算机的数据库的成本是比较高的。如果要求维护时不能停机，那么维护将变得更加困难——比如对数据库进行重新分片。随着数据量和查询数量的增加，容错、备份、确保数据一致性等工作的难度都会呈几何级数增长。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;复杂度：复制和分片通常要求应用层面提供一些支持——应用需要知道将查询发给哪一台计算机，以及应该更新哪一个数据分片（每个更新所对应的分片通常不一样，规则也比较复杂）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;人为错误&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;报表和分析：在独立的数据仓库中用另一种格式来维护历史数据。数据从业务数据库向数据仓库的迁移过程就是著名的萃取（extract）、转置（transform）、加载（load）（简称ETL）。这种方案不仅复杂，而且需要准确预测将来我们需要什么信息。有时会碰到这种情况：由于缺乏必要的信息或者信息格式不对，无法生成所需报表或进行某些分析。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;section-2&quot;&gt;批处理视图（批处理层） &amp;amp; 服务层&lt;/h4&gt;
&lt;blockquote&gt;
  &lt;p&gt;如果能够准确预测出未来会对原始数据进行怎样的查询，就可以预计算出一个批处理视图，这个视图包含这些查询将要返回的衍生信息，或者那些可以计算出这些衍生信息的数据。Lambda架构的批处理层就是用来计算这些批处理视图的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;批处理视图可以包含衍生信息，比如：假设要用一系列编辑记录来构建Wikipedia的页面——批处理视图将只包含从页面的编辑记录中计算得来的页面内容。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;批处理视图也可以包含可以计算出衍生信息的数据，这类情况会稍微复杂一些。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;需要对生成的批处理视图进行索引，这样就可以对索引进行查询了。另外，还需要一个地方来存放程序逻辑（说明一个查询该如何合并批处理视图的逻辑）。这就是服务层的任务。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;总结来说利用不变数据利于并行的特显对海量数据进行加工（mapper + reducer），生成批处理视图。然后再通过简单的查询得到想要的结果。&lt;/li&gt;
  &lt;li&gt;后面提到的Hadoop就是应用于批处理层&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-3&quot;&gt;加速层&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;有新数据产生时，除了会将数据投入到原始数据还会进行扔给加速层生成实时视图，结合最新的批处理视图可以满足对于新数据的查询。&lt;/li&gt;
  &lt;li&gt;当新的批处理视图产生后，实时视图就被丢弃了。&lt;/li&gt;
  &lt;li&gt;这个东西的目的应该是为了快速响应新数据，在批处理层还没有出新版本时，临时使用实时视图+当前最新的批处理视图就组成了未来会出现的批处理视图。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;后面讲的Storm系统应用于加速层&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;最后放一张架构图&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Hiak8vv9WbJhL7pjGiaFVnTiadKXQrjsjrGQSJxEQo5ebHvmq6UDuBnfyhcUPe44QHPNjAiaVTG8UXkbU6aNZOQXkg/0?wx_fmt=jpeg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;mapreduce&quot;&gt;MapReduce&lt;/h3&gt;

&lt;h4 id=&quot;section-4&quot;&gt;定义&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;MapReduce是一个多义的术语。其可以指代一类算法，这类算法分为两个步骤：对一个数据结构首先进行映射（map）操作，然后进行化简（reduce）操作。之前的词频统计的函数式版本正是这样的例子（frequencies就是用reduce函数实现的）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;MapReduce还可以指代一类系统——这类系统使用了上面的算法，将计算过程高效地分布到一个集群上。这类系统不仅可以将数据和数据处理分布到集群的多台计算机上，还可以在一台或多台计算机崩溃时继续正常运转。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;一个MapReduce任务由两种主要的组件构成：mapper和reducer。mapper负责将某种输入格式（通常是文本）映射为许多键值对。reducer负责将这些键值对转换成最终的输出格式（通常也是一系列键值对）。mapper和reducer可以分布在很多不同的计算机上（它们的数目不必相同）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;hadoop&quot;&gt;Hadoop&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;一个包含了MapReduce的&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;输入通常由一个或多个大文本文件构成。Hadoop对这些文件进行分片（每一片的大小是可配置的，通常为64 MB），并将每个分片发送给一个mapper。mapper将输出一系列键值对，Hadoop再将这些键值对发送给reducer。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;一个mapper产生的键值对可以发送给多个reducer。键值对的键决定了哪个reducer会接受这个键值对——Hadoop确保具有相同键的键值对（无论是由哪个mapper产生的）都会发送给同一个reducer处理。这个阶段通常被称为洗牌阶段（shuffle phase）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Hadoop为每个键调用一次reducer，并传入所有与该键对应的值。reducer将这些值合并，再生成最终输出结果（通常是键值对，也可以不是）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;mapper--reducer&quot;&gt;mapper &amp;amp; reducer&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;书中demo的Map继承了Hadoop的Mapper类，其接受四个类型参数：输入的键类型、输入的值类型、输出的键类型、输出的值类型。它里面的方法本质是将一行文本进行拆分，输出一个键值对。&lt;/li&gt;
  &lt;li&gt;对于每个键，都会调用一次reduce()方法，values是这个键对应的所有值的集合。reduce()方法对这些值进行求和，并产生描述某个单词出现总数的键值对。&lt;/li&gt;
  &lt;li&gt;Hadoop在键值对传给reducer前会对键进行排序&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;driver&quot;&gt;Driver&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;从下面的代码看driver就是配置Hadoop。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;这里不需要设置输入的键类型和值类型，因为默认情况下Hadoop认为我们处理的是文本文件。也不需要分别设置mapper输出的键/值类型和reducer输入的键/值类型，因为默认情况下Hadoop认为mapper的输出和reducer的输入具有相同的键/值类型。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;使用setInputFormatClass()将XmlInputFormat设置为分片器，并且配置xmlinput.start和xmlinput.end来告诉分片器我们关注的是哪个标签。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;setCombinerClass()来设置combiner。combiner是一种优化手段，使键值对可以在发往reducer前进行合并。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class WordCount extends Configured implements Tool { 
    public int run(String[] args) throws Exception { 
        Configuration conf = getConf();
        conf.set(&quot;xmlinput.start&quot;, &quot;&amp;lt;text&quot;);
        conf.set(&quot;xmlinput.end&quot;, &quot;&amp;lt;/text&amp;gt;&quot;);
        Job job = Job.getInstance(conf, &quot;wordcount&quot;);
        job.setJarByClass(WordCount.class);
        job.setInputFormatClass(XmlInputFormat.class);
        job.setMapperClass(Map.class);
        job.setCombinerClass(Reduce.class);
        job.setReducerClass(Reduce.class);
        job.setOutputKeyClass(Text.class);  job.setOutputValueClass(IntWritable.class);  FileInputFormat.addInputPath(job, new Path(args[0]));    FileOutputFormat.setOutputPath(job, new Path(args[1]));
        boolean success = job.waitForCompletion(true);
        return success ? 0 : 1;    15  
    } 
    
    public static void main(String[] args) throws Exception {
        int res = ToolRunner.run(new Configuration(), new WordCount(), args);
        System.exit(res);
        
    }   
    
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;hadoop-1&quot;&gt;Hadoop的优势&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;可以在多台计算机上更快地处理海量的数据&lt;/li&gt;
  &lt;li&gt;Hadoop天生就具有处理错误和从错误中恢复的能力，这点很好保证了在使用集群时的稳定性。&lt;/li&gt;
  &lt;li&gt;与上一条相关，不仅要考虑将节点崩溃时正在处理的任务重新执行，还需要考虑当存储发生故障时如何保证数据不丢失。Hadoop默认使用Hadoop分布式文件系统（HDFS），这个有容错能力的分布式文件系统可以在多个节点之间冗余数据。&lt;/li&gt;
  &lt;li&gt;涉及吉字节级别以上的数据时，就不能将所有中间数据或结果全部存放在内存中。Hadoop在处理过程中将键值对存储在HDFS中，这样就可以不受内存限制，完成数据量非常大的任务。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;storm&quot;&gt;Storm&lt;/h3&gt;

&lt;h4 id=&quot;spoutbolttopology&quot;&gt;Spout、Bolt和Topology&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Storm系统处理的是元组（tuple）的流。Storm的元组类似于之前我们在第5章看到的actor模型的元组，但不同于Elixir的元组，Storm元组的元素是有名字的。&lt;/li&gt;
  &lt;li&gt;元组由spout（出水管）组件创建，并由bolt（螺栓）组件进行处理，bolt也会输出元组。用流将spout和bolt连接在一起，就形成了topology（拓扑结构）。&lt;/li&gt;
  &lt;li&gt;topology也可以很复杂——bolt可以消费多个流，而一个流也可以被多个bolt消费，构成一个有向无环图。spout和bolt都是并行化和分布式的。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;worker：spout和bolt不仅相互之间是并行的，而且其内部也都是并行的——每一个个体内部都是由很多worker实现的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;下图是一个topology&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Hiak8vv9WbJhL7pjGiaFVnTiadKXQrjsjrGmynzZ5p8YUL4CB2Pm97vOGyOTaVMz7zZialvEJS70D3cia7GoXhicAp9w/0?wx_fmt=gif&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-5&quot;&gt;容错&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;将一个spout或bolt的多个worker分布在多台计算机上的主要原因是容错性。如果集群中的某一台计算机发生故障，topology可以将元组分发给仍存活的计算机，这样topology就可以继续运行。&lt;/li&gt;
  &lt;li&gt;Storm会监视元组之间的依赖——如果某一个元组没能完成，Storm会将其依赖的spout元组置为失败并进行重试。这也就是说Storm默认使用的是“至少会执行一次”的处理策略。应用必须知道这个事实：元组可能会被重试，直到其结果正确。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-6&quot;&gt;总结&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Lambda目前主要作为大数据平台的架构&lt;/li&gt;
  &lt;li&gt;如果用Hadoop作为Batch Layer，而用Storm作为Speed Layer，那就需要维护两份使用不同技术的代码。所以目前有另外的一个解决方案是Apache Spark，它可以作为Lambda Architecture一体化的解决方案。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-7&quot;&gt;引用&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.zhihu.com/question/26568496&quot;&gt;与 Hadoop 对比，如何看待 Spark 技术？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 20 Apr 2018 17:19:43 +0800</pubDate>
        <link>https://caihua.tech/2018/04/20/%E4%B8%83%E5%91%A8%E4%B8%83%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F-Lambda%E6%9E%B6%E6%9E%84/</link>
        <guid isPermaLink="true">https://caihua.tech/2018/04/20/%E4%B8%83%E5%91%A8%E4%B8%83%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F-Lambda%E6%9E%B6%E6%9E%84/</guid>
        
        <category>并发模型</category>
        
        
      </item>
    
      <item>
        <title>七周七并发模式：通信顺序进程（CSP）</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;概念&lt;/h3&gt;

&lt;h4 id=&quot;csp&quot;&gt;CSP&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;与actor模型类似，通信顺序进程（Communicating Sequential Processe，CSP）模型也是由独立的、并发执行的实体所组成，实体之间也是通过发送消息进行通信。但两种模型的重要差别是：CSP模型不关注发送消息的实体，而是关注发送消息时使用的channel（通道）。channel是第一类对象，它不像进程那样与信箱是紧耦合的，而是可以单独创建和读写，并在进程之间传递。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;从这段话可以看出CSP本质上也是独立运行的执行单元，但是它没有mailbox，那么它执行的数据来自哪里呢？来自于channel。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;channel&quot;&gt;Channel&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;一个channel就是一个线程安全的队列，任何任务只要持有channel的引用，就可以向一端添加消息，也可以从另一端删除消息。在actor模型中，消息是从指定的一个actor发往指定的另一个actor的；与之不同，使用channel发送消息时发送者并不知道谁是接收者，反之亦然。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;也就是说CSP更像是在不同的actor之间共享mailbox，但是这里mailbox编程了channel。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;默认情况下，channel是同步的（或称无缓存的）——一个任务向channel写入消息的操作会一直阻塞，直到另一个任务从channel中读出消息。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;emmm，阻塞了一个写入的线程。这样有些浪费线程，因此有了带&lt;code class=&quot;highlighter-rouge&quot;&gt;缓存区&lt;/code&gt;的channel。当channel的缓存区有足够空间时，向其中写入消息的操作会立刻完成，不会阻塞。&lt;/li&gt;
  &lt;li&gt;对于有缓存的channel，一次性写入超过缓存区大小的数据时策略也是不同的，可以是只保留前面写入的（dropping），也可以是保留后面写入的(slide)，甚至是直接阻塞式的（blocking），这个一般都有语言级别的策略支持。&lt;/li&gt;
  &lt;li&gt;PS：是否支持可扩展的buffer这个问题书中提到是不支持，不过可能也只是这个语言不支持。因为我还没有看过其它的编程语言中是如何处理buffer的。&lt;/li&gt;
  &lt;li&gt;channel也可以被关闭，此时read/write的处理不同的语言可能会有不同的处理方式。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;go&quot;&gt;go块&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;在说这个概念之前需要先看看在它之前的线程操作过程中遇到的问题，只有弄清楚了存在什么问题，我们才能理解为何会有go块，而它又是干什么的。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;线程启动和运行时都有一定开销，这正是现在的程序都避免直接创建线程、转而使用线程池的原因。然而线程池并不总是适用。尤其是当程序阻塞时，使用线程池可能会造成麻烦。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;线程池技术是处理CPU密集型任务的利器——任务进行时会占用某个线程，任务结束后将线程返还给线程池，使线程可以被复用。但涉及线程通信时使用线程池是否仍然合适呢？如果线程被阻塞，那么它将无限期被占用，这就削弱了使用线程池技术的优势。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;这种问题是有一些解决方案的，但它们通常会对代码风格加以限制，使之变成事件驱动的形式。虽然这些方案都能解决问题，但它们破坏了控制流的自然的表达形式，让代码变得难以阅读和理解。更糟糕的是，这些方案还会大量使用全局状态，因为事件处理器需要保存一些数据，以便之后的事件处理器使用。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;从上面的摘抄中已经可以看出来多线程、线程池其实是各种局限，而加入了事件驱动后也是有问题的。在这样的情况下，一个能够支持事件驱动，又可以保证代码在编写和阅读时看上去是顺序执行（这样比较符合人的阅读习惯和理解），同时还把状态数据封装起来的东西，emmm，此时我第一个反应就是unity中的Coroutine，而unity的coroutine本质是个状态机。这样一路的推导下来，我们也就明白了go块的本质就是一个状态机。而它的诞生也是为了解决上面说提到的种种问题。&lt;/li&gt;
  &lt;li&gt;本书中对于go块的使用demo使用了Clojure这个语言，我觉得没必要细说具体实现，因为每个语言也不同。不过go块中需要强调一点，它是非阻塞的。当然如果是阻塞的并不是不能工作，但是又回到了线程大量使用而又阻塞的问题了。&lt;/li&gt;
  &lt;li&gt;在书中提到go块的成本很低，这与线程不同，因为目前我所知道的语言中go块这样的概念都是基于协程的。golang中甚至没有线程的概念。而C#中task也是协程的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;csp-1&quot;&gt;使用CSP&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;实际上本章第二节的例子基本都是利用channel的同步性。比如超时处理就可以让一个定时器过一定时间后写入channel，在这之前另一个方法用来读取channel。&lt;/li&gt;
  &lt;li&gt;还有一些异步操作也是利用了channel的同步性，在以前可能异步操作需要使用回调，但是这样的话不同函数就成了互相调用的情况，但是使用CSP可以让函数基于channel来执行。比如：A函数读取一个channel的数据，在channel被写入数据前，调用A的线程阻塞；在IO操作完成后将结果写入channel，这样A函数就可以读取IO的结果了，而且两个函数不需要知道对方的存在，完全依赖channel来通信。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-1&quot;&gt;总结&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;首先与Actor比，CSP更加灵活。Actor负责通信的媒介（mailbox）与执行单元是紧耦合的，而CSP中channel可以被独立的创建、读写数据。从耦合性上将CSP更好。&lt;/li&gt;
  &lt;li&gt;然后CSP的go块使得异步编程更加高效，比起写很长的回调式的代码，CSP的代码更简洁。&lt;/li&gt;
  &lt;li&gt;至于书中提到的CSP的缺点：分布式和容错性支持的不够好，这个我个人觉得因语言而异，因为很少做相关的开发不好发表意见。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-2&quot;&gt;参考&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/ants/p/8601947.html#_label1&quot;&gt;Golang的CSP很酷？其实.NET也可以轻松完成&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://www.voidcn.com/article/p-qrvdpmgk-bnw.html&quot;&gt;CSP与并发编程&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 02 Apr 2018 16:33:43 +0800</pubDate>
        <link>https://caihua.tech/2018/04/02/%E4%B8%83%E5%91%A8%E4%B8%83%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B-%E9%80%9A%E4%BF%A1%E9%A1%BA%E5%BA%8F%E8%BF%9B%E7%A8%8B/</link>
        <guid isPermaLink="true">https://caihua.tech/2018/04/02/%E4%B8%83%E5%91%A8%E4%B8%83%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B-%E9%80%9A%E4%BF%A1%E9%A1%BA%E5%BA%8F%E8%BF%9B%E7%A8%8B/</guid>
        
        <category>并发模型</category>
        
        
      </item>
    
      <item>
        <title>Unity ECS：基本组件和功能</title>
        <description>&lt;h3 id=&quot;ecs&quot;&gt;ECS的组成&lt;/h3&gt;
&lt;h4 id=&quot;entity&quot;&gt;Entity：&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;近似一个轻量级的GameObject对象。&lt;/li&gt;
  &lt;li&gt;内部没有什么东西，这个和GameObject还不一样，毕竟在GameObject的继承链中具有很多成员和函数。&lt;/li&gt;
  &lt;li&gt;可以添加和移除组件&lt;/li&gt;
  &lt;li&gt;具有一个ID，这个是唯一稳定的。这个ID是entity在被保存时的唯一引用。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;icomponentdataisharedcomponentdata&quot;&gt;IComponentData和ISharedComponentData&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;前文说到过，ECS中的Component是一个结构体，里面只有数据。&lt;/li&gt;
  &lt;li&gt;这个结构体可以继承IComponentData或ISharedComponentData，从源码看这两个接口是空的。&lt;/li&gt;
  &lt;li&gt;IComponentData可以理解为不同entity之间不同的数据，而ISharedComponentData代表了相同的数据。其实从后者的名称上也可以看到一些蛛丝马迹。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;entityarchetype&quot;&gt;EntityArchetype&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;其实看到archetype（原型）这个词就大致明白这个类的作用了。&lt;/li&gt;
  &lt;li&gt;EntityArchetype是一个具有唯一性的ComponentType数组，它可以在创建entity时被作为参数使用，一个entity具有什么能力，完全在于它上面挂了什么Component，而多个component组成了一个能力组，这个就是EntityArchetype了。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Using typeof to create an EntityArchetype from a set of components
EntityArchetype archetype = EntityManager.CreateArchetype(typeof(MyComponentData), typeof(MySharedComponent));

// Same API but slightly more efficient
EntityArchetype archetype = EntityManager.CreateArchetype(ComponentType.Create&amp;lt;MyComponentData&amp;gt;(), ComponentType.Create&amp;lt;MySharedComponent&amp;gt;());

// Create an Entity from an EntityArchetype
var entity = EntityManager.CreateEntity(archetype);

// Implicitly create an EntityArchetype for convenience
var entity = EntityManager.CreateEntity(typeof(MyComponentData), typeof(MySharedComponent));
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;entitymanager&quot;&gt;EntityManager&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;一个管理所有EntityData、Archetype、SharedComponentData  和ComponentGroup的类。与ComponentSystems是同等地位的，看来unity ECS确实是一套新的系统。&lt;/li&gt;
  &lt;li&gt;从下面的代码中可以看出，实际上所有的Entity的创建、添加组件、查询live状态等操作的API都在这个类里面。应该是核心类。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Create an Entity with no components on it
var entity = EntityManager.CreateEntity();

// Adding a component at runtime
EntityManager.AddComponent(entity, new MyComponentData());

// Get the ComponentData
MyComponentData myData = EntityManager.GetComponentData&amp;lt;MyComponentData&amp;gt;(entity);

// Set the ComponentData
EntityManager.SetComponentData(entity, myData);

// Removing a component at runtime
EntityManager.RemoveComponent&amp;lt;MyComponentData&amp;gt;(entity);

// Does the Entity exist and does it have the component?
bool has = EntityManager.HasComponent&amp;lt;MyComponentData&amp;gt;(entity);

// Is the Entity still alive?
bool has = EntityManager.Exists(entity);

// Instantiate the Entity
var instance = EntityManager.Instantiate(entity);

// Destroy the created instance
EntityManager.DestroyEntity(instance);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// EntityManager also provides batch APIs
// to create and destroy many Entities in one call. 
// They are significantly faster 
// and should be used where ever possible
// for performance reasons.

// Instantiate 500 Entities and write the resulting Entity IDs to the instances array
var instances = new NativeArray&amp;lt;Entity&amp;gt;(500, Allocator.Temp);
EntityManager.Instantiate(entity, instances);

// Destroy all 500 entities
EntityManager.DestroyEntity(instances);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;entity-1&quot;&gt;对entity的一个小总结&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;EntityManager在生成一个entity时实际使用的是EntityDataManager类中的方法，而EntityDataManager中Entity&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当一个entity添加或者移除一个component时，实际上改变了其archetype的结构，此时会创建（优先从已有的archetype集合中查询）一个新的archetype来赋值给entity。参考EntityManager源码中相关的代码。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;chunk&quot;&gt;Chunk&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;chunk是所有ComponentData存储的方式，或者说在内存中的排列方式。&lt;/li&gt;
  &lt;li&gt;chunk连接着（或者说对应着）一个EntityArchetype。所有使用同一个EntityArchetype的entity都具有相同的内存布局，在内存中这些entity上的components的布局也比较奇特（原谅我用这个词）。它们（components）在存储时按照类型紧密排列的，。同一类型的component实例在内存中被连续的放在一起，后面是另一个类型的所有component实例。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;archetypechunk&quot;&gt;从内存角度看看archetype和chunk&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;从函数GetOrCreateArchetype可以看到每当新创建一个archetype时本质还是mallco一块内存，但是比较复杂的是一个archetype还包含了很多其它的数据，比如所有ISharedComponentData的类型。&lt;/li&gt;
  &lt;li&gt;但是正如上面提到的，chunk对于着一个archetype，其实chunk不过是一个内存地址。ChunkAllocator中的m_LastChunk维护这一个chunk的链表。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;jobcomponentsystem&quot;&gt;JobComponentSystem&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;上一篇最后的代码中提到了JobComponentSystem，它主要是用于自动管理job的依赖。一个例子就是在多个job在操作同一个ComponentData时，如果前面几个是在并行的read数据，突然出现一个write数据的job，此时就要等已经执行的read全部结束后暂停其它的job，让write job完成后在执行其它的。这个东西本质上与.NET的Parallel API是一样的，而大多数并行操作都会采用这样的方式，比如一个典型的例子就是SQLit的操作。&lt;/li&gt;
  &lt;li&gt;同时系统内部还使用Injection和ComponentGroup在管理依赖。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 27 Mar 2018 20:07:00 +0800</pubDate>
        <link>https://caihua.tech/2018/03/27/Unity-ECS-%E5%9F%BA%E6%9C%AC%E7%BB%84%E4%BB%B6%E5%92%8C%E5%8A%9F%E8%83%BD/</link>
        <guid isPermaLink="true">https://caihua.tech/2018/03/27/Unity-ECS-%E5%9F%BA%E6%9C%AC%E7%BB%84%E4%BB%B6%E5%92%8C%E5%8A%9F%E8%83%BD/</guid>
        
        <category>Unity3D</category>
        
        
      </item>
    
      <item>
        <title>Unity ECS：C# Job System</title>
        <description>&lt;h3 id=&quot;job-system&quot;&gt;Job system&lt;/h3&gt;
&lt;h4 id=&quot;job-system-1&quot;&gt;Job system解决了什么问题&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;unity是支持多线程的，虽然有些缺陷。但是我们在代码里面编写大量的线程，即使使用thread pool也无法避免上下文切换的问题。而Job System本质上还是线程(wrok thread)，只不过它的工作线程的数量和CPU逻辑上的核数量一致，这样就避免了上下文切换。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;job-system-2&quot;&gt;Job System如何工作&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;在这个系统中真正发挥作用的是job单元，它类似方法的调用，包含了参数和数据。job被填入Job Queue中，然后work thread负责调用它。&lt;/li&gt;
  &lt;li&gt;job system中有dependency（依赖）的概念，如果job A依赖于job B，那么系统会保证B在A执行前完成。&lt;/li&gt;
  &lt;li&gt;job system不是现存的任何C#线程模型中的一种。&lt;/li&gt;
  &lt;li&gt;它被集成在引擎内部，这意味着我们开发者所编写的代码会让unity引擎共享work thread，这样才能避免对于CPU的竟态使用。&lt;/li&gt;
  &lt;li&gt;PS: 我很怀疑是否代码写的很糟糕的情况下，会影响引擎本身的效率。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;job-system-3&quot;&gt;Job System如何避免竟态&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;我觉得文档想描述的很大程度上是数据原子性的问题&lt;/li&gt;
  &lt;li&gt;job system会检查所有潜在的竟态。&lt;/li&gt;
  &lt;li&gt;让所有的job操作同一份数据拷贝&lt;/li&gt;
  &lt;li&gt;job只能访问blittable data(这种数据在托管和非托管中具有相同的内存结构)，而不是managed types。&lt;/li&gt;
  &lt;li&gt;鉴于上面提到的数据拷贝的就行，为了解决现实世界复杂的问题，提供了NativeContainers：
    &lt;ul&gt;
      &lt;li&gt;类型包括：NativeArray, NativeList, NativeHashMap, and NativeQueue.&lt;/li&gt;
      &lt;li&gt;这些类型能够被unity追踪，谁在读写它们。比如两个job同时写入时需要使用Schedule来安排执行顺序，安全系统会抛出一个明确的异常来说明这些。&lt;/li&gt;
      &lt;li&gt;多个job同时读取一个数据时是并发的&lt;/li&gt;
      &lt;li&gt;读写的限制同样适用于main thread&lt;/li&gt;
      &lt;li&gt;一些container有特殊的规则，以便适应来自&lt;code class=&quot;highlighter-rouge&quot;&gt;ParallelFor jobs&lt;/code&gt;的安全、明确的写入访问。比如&lt;code class=&quot;highlighter-rouge&quot;&gt;NativeHashMap.Concurrent&lt;/code&gt;允许使用&lt;code class=&quot;highlighter-rouge&quot;&gt;IJobParallelFor&lt;/code&gt;并发的添加item。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;job&quot;&gt;调度job&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;job system依赖blittable data和NativeContainer&lt;/li&gt;
  &lt;li&gt;实现步骤：
    &lt;ul&gt;
      &lt;li&gt;定一个实现了IJob接口的struct&lt;/li&gt;
      &lt;li&gt;创建struct对象，填充数据，调用Schedule方法。&lt;/li&gt;
      &lt;li&gt;调用方法后得到一个job handle对象。它可以做为其它job的依赖对象；也可以等待它完成工作。如果说需要在主线程访问传入job的NativeContainer，那就等待这个handle完成。这部分具体看代码比较好理解。&lt;/li&gt;
      &lt;li&gt;需要注意的是在主线程想要访问NativeContainers数据之前，需要让所有的 job依赖都完成，此时只用JobHandle.IsDone来判断是不够的，需要手动调用 JobHandle.Complete方法。Complete方法还会清空jobs debugger中的状态。&lt;/li&gt;
      &lt;li&gt;如果每一帧都调用一个新的job，这个job还依赖于上一帧的job的话，会出现内存泄漏。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;从下面的代码可以看出，一个job就是一个实现了IJob的struct。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;定义struct：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Job adding two floating point values together
public struct MyJob : IJob
{
    public float a;
    public float b;
    NativeArray&amp;lt;float&amp;gt; result;
    public void Execute()
    {
        result[0] = a + b;
    }
}

public struct AddOneJob : IJob
{
    public NativeArray&amp;lt;float&amp;gt; result;
    public void Execute()
    {
        result[0] = result[0] + 1;
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;创建单个job实例，进行调用：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Create a native array of a single float to store the result in. This example will wait for the job to complete, which means we can use Allocator.Temp
NativeArray&amp;lt;float&amp;gt; result = new NativeArray&amp;lt;float&amp;gt;(1, Allocator.Temp);
// Setup the job data
MyJob jobData = new MyJob();
jobData.a = 10;
jobData.b = 10;
jobData.result = result;
// Schedule the job
JobHandle handle = jobData.Schedule();
// Wait for the job to complete
handle.Complete();
// All copies of the NativeArray point to the same memory, we can access the result in &quot;our&quot; copy of the NativeArray
float aPlusB = result[0];
// Free the memory allocated by the result array
result.Dispose();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;使用schedule调用多个job&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NativeArray&amp;lt;float&amp;gt; result = new NativeArray&amp;lt;float&amp;gt;(1, Allocator.Temp);
// Setup the job data
MyJob jobData = new MyJob();
jobData.a = 10;
jobData.b = 10;
jobData.result = result;
// Schedule the job
JobHandle firstHandle = jobData.Schedule();
AddOneJob incJobData = new AddOneJob();
incJobData.result = result;
JobHandle handle = incJobData.Schedule(firstHandle);
// Wait for the job to complete
handle.Complete();
// All copies of the NativeArray point to the same memory, we can access the result in &quot;our&quot; copy of the NativeArray
float aPlusB = result[0];
// Free the memory allocated by the result array
result.Dispose();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;parallelfor-jobs&quot;&gt;ParallelFor jobs&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;ParallelForJob适用于对于多个物体的并发操作，比如集合中的item。&lt;/li&gt;
  &lt;li&gt;并不是每个item对应一个job，而是每个CPU CORE对应一个job。这个也是上文说的为了保证减少上下文切换。&lt;/li&gt;
  &lt;li&gt;在使用ParallelForJob时需要传递两个参数：
    &lt;ul&gt;
      &lt;li&gt;数组的长度，这个数组应该是你要用来迭代的数组。&lt;/li&gt;
      &lt;li&gt;PS：实际上这部分文档上写的很奇怪，通过长度来区分数组？&lt;/li&gt;
      &lt;li&gt;一次批处理的个数，这个决定了job的个数。建议一开始使用的一个job然后慢慢的增加。直到性能提升的不明显了。&lt;/li&gt;
      &lt;li&gt;PS：其实在并行问题上，线程越多未必能够效率越高。以为还存在一个锁的问题。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Job adding two floating point values together
public struct MyParallelJob : IJobParallelFor
{
    [ReadOnly]
    public NativeArray&amp;lt;float&amp;gt; a;
    [Readonly]
    public NativeArray&amp;lt;float&amp;gt; b;
    public NativeArray&amp;lt;float&amp;gt; result;
    public void Execute(int i)
    {
        result[i] = a[i] + b[i];
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var jobData = new MyParallelJob();
jobData.a = 10;  
jobData.b = 10;
jobData.result = result;
// Schedule the job with one Execute per index in the results array and only 1 item per processing batch
JobHandle handle = jobData.Schedule(result.Length, 1);
// Wait for the job to complete
handle.Complete();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;job-system-4&quot;&gt;Job System还存在的问题&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;无法访问static数据，这个功能后续应该会有。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section&quot;&gt;参考&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;//docs.microsoft.com/en-us/dotnet/framework/interop/blittable-and-non-blittable-types&quot;&gt;Blittable and Non-Blittable Types&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 23 Mar 2018 16:07:00 +0800</pubDate>
        <link>https://caihua.tech/2018/03/23/Unity-ECS-C-Job-System/</link>
        <guid isPermaLink="true">https://caihua.tech/2018/03/23/Unity-ECS-C-Job-System/</guid>
        
        <category>Unity3D</category>
        
        
      </item>
    
      <item>
        <title>Unity ECS：概述</title>
        <description>&lt;h4 id=&quot;section&quot;&gt;前言&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;看来unity已经认识到现在编写代码的一些问题了：OO的模型、mono所编译的糟糕的机器码、GC和单线程。emmm&lt;/li&gt;
  &lt;li&gt;ECS的推出就是为了解决上面的问题，同时使用ECS是为了能够利用C# Job System和Burst compiler。job system是支持多线程的（( Ĭ ^ Ĭ )）&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;componentsystem&quot;&gt;ComponentSystem&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;在后面的文章中会说到ECS中的Component，这里简单说下，新的component模型只包含了数据，而ComponentSystem包含了行为。&lt;/li&gt;
  &lt;li&gt;一个ComponentSystem负责在每帧中对物体进行操作，这些物体必须匹配ComponentSystem所定义的一组component。有点类似后面讲到的的EntityArchetype。看下代码的例子：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Rotator : MonoBehaviour
{
    // The data - editable in the inspector
    public float Speed;
}

class RotatorSystem : ComponentSystem
{
    struct Group
    {
        // Define what components are required for this 
        // ComponentSystem to handle them.
        Transform Transform;
        Rotator   Rotator;
    }
    
    override protected OnUpdate()
    {
        // We can immediately see a first optimization.
        // We know delta time is the same between all rotators,
        // so we can simply keep it in a local variable 
        // to get better performance.
        float deltaTime = Time.deltaTime;
        
        // ComponentSystem.GetEntities&amp;lt;Group&amp;gt; 
        // lets us efficiently iterate over all GameObjects
        // that have both a Transform &amp;amp; Rotator component 
        // (as defined above in Group struct).
        foreach (var e in GetEntities&amp;lt;Group&amp;gt;())
        {
            e.Transform.rotation *= Quaternion.AxisAngle(e.Rotator.Speed * deltaTime, Vector3.up);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;Rotator是现在系统中的一个MonoBehaviour，而RotatorSystem是一个ComponentSystem。后者包含了一个Group用于匹配GameObject，而OnUpdate方法则是处理行为的函数。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;componentsystem-1&quot;&gt;如何在现有的系统中使用ComponentSystem&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;目前是需要在每个GameObject上挂一个GameObjectEntity脚本，它在OnEnable方法中会创建一个entity，挂上GameObject上的所有组件。然后就能被ComponentSystem使用了。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;这意味着你可以将所有的行为处理从MonoBehaviour.Updata中转移到 ComponentSystem.OnUpdate中，数据仍旧可以保持在MonoBehaviour中。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;这样做的优势
    &lt;ul&gt;
      &lt;li&gt;数据（MonoBehaviour）与行为（ComponentSystem）的分离&lt;/li&gt;
      &lt;li&gt;一些对象上的系统操作是批量的（应该是基于Job System），便于优化代码。比如上面代码中的deltaTime的使用。&lt;/li&gt;
      &lt;li&gt;可以继续使用现存的inspector、editor工具等。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;劣势
    &lt;ul&gt;
      &lt;li&gt;实例化时间没有改善&lt;/li&gt;
      &lt;li&gt;加载的时间没有改善&lt;/li&gt;
      &lt;li&gt;数据时随机访问的，非线性。线性数据访问的问题下面会说到。&lt;/li&gt;
      &lt;li&gt;非多核的&lt;/li&gt;
      &lt;li&gt;非&lt;a href=&quot;https://en.wikipedia.org/wiki/SIMD&quot;&gt;SIMD&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;总结来说这样的混合方案性能提升有限&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;pure-ecs&quot;&gt;Pure ECS&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;ECS不支持托管类型，支持struct和NativeContainer类型。所以只有IComponentData可以被C# Job安全的访问。&lt;/li&gt;
  &lt;li&gt;EntityManager（后面会提到）保证了线性的内存布局 ，这是性能提升很重要的部分。通过job和IComponentData可以做到。&lt;/li&gt;
  &lt;li&gt;目前想将ComponentData添加到GameObject上需要使用ComponentDataWrapper&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// The rotation speed component simply stores the Speed value
[Serializable]
public struct RotationSpeed : IComponentData
{
    public float Value;
}

// This wrapper component is currently necessary to add ComponentData to GameObjects.
// In the future we want to make this wrapper component automatic.
public class RotationSpeedComponent : ComponentDataWrapper&amp;lt;RotationSpeed&amp;gt; { } 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Using IJobProcessComponentData to iterate over all entities matching the required component types.
// Processing of entities happens in parallel. The main thread only schedules jobs.
public class RotationSpeedSystem : JobComponentSystem
{
    // IJobProcessComponentData is a simple way of iterating over all entities given the set of required compoenent types.
    // It is also more efficient than IJobParallelFor and more convenient.
    [ComputeJobOptimization]
    struct RotationSpeedRotation : IJobProcessComponentData&amp;lt;Rotation, RotationSpeed&amp;gt;
    {
        public float dt;

        public void Execute(ref Rotation rotation, [ReadOnly]ref RotationSpeed speed)
        {
            rotation.Value = math.mul(math.normalize(rotation.Value), math.axisAngle(math.up(), speed.Value * dt));
        }
    }

    // We derive from JobComponentSystem, as a result the system proviides us 
    // the required dependencies for our jobs automatically.
    //
    // IJobProcessComponentData declares that it will read RotationSpeed and write to Rotation.
    //
    // Because it is declared the JobComponentSystem can give us a Job dependency, which contains all previously scheduled
    // jobs that write to any Rotation or RotationSpeed.
    // We also have to return the dependency so that any job we schedule 
    // will get registered against the types for the next System that might run.
    // This approach means:
    // * No waiting on main thread, just scheduling jobs with dependencies (Jobs only start when dependencies have completed)
    // * Dependencies are figured out automatically for us, so we can write modular multithreaded code
    protected override JobHandle OnUpdate(JobHandle inputDeps)
    {
        var job = new RotationSpeedRotation() { dt = Time.deltaTime };
        return job.Schedule(this, 64, inputDeps);
    } 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;这段代码和ComponentSystem的部分有类似的结构，但是它结合了JobSystem，做到了并发执行。而且里面还有依赖注入的部分，下一篇在将ECS功能的时候会详细来说。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-1&quot;&gt;总结&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Unity ECS做到了数据与行为的分离，而且更加轻量级。&lt;/li&gt;
  &lt;li&gt;通过结合JobSystem实现了CPU多核的利用。&lt;/li&gt;
  &lt;li&gt;目前来看在已有系统结构上使用ECS有点累赘的感觉。&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Thu, 22 Mar 2018 01:07:00 +0800</pubDate>
        <link>https://caihua.tech/2018/03/22/Unity-ECS-%E6%A6%82%E8%BF%B0/</link>
        <guid isPermaLink="true">https://caihua.tech/2018/03/22/Unity-ECS-%E6%A6%82%E8%BF%B0/</guid>
        
        <category>Unity3D</category>
        
        
      </item>
    
      <item>
        <title>七周七并发模式：Actor</title>
        <description>&lt;h4 id=&quot;actor&quot;&gt;什么是Actor&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;在本书提到的观点中，认为Actor是一个线程或者进程。在这个线程或者进程中执行了一段代码（函数)，这个代码可以包含状态（数据）也可以不包含。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;所谓Actor模型是Sequential Processes和Functions transforming data values两者的结合，可以理解为是综合了过程式计算和函数式计算的一个计算模型。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;一个Actor会把接收到的消息映射为三个部分，传给其他Actor的消息，一个新的行为（用来处理下一个消息），和创造一些新的Actors。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;actor-1&quot;&gt;为什么会出现Actor&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;在本书的第二章谈到了线程和锁，其中提到了这个并发模式存在的一些问题，比如竞争共享资源所导致的阻塞、多重锁导致的死锁等问题。&lt;/li&gt;
  &lt;li&gt;Actor正是为了解决这些问题而产生的。从定义看actor就是多线程，只不过它避免了对于共享资源的并发调用。一个actor只使用自己的资源，而不是直接使用共享资源，它作用单一，顺序执行。不同的Actor之间使用message来传递数据。&lt;/li&gt;
  &lt;li&gt;PS：这里实际上并不存在真的不使用锁。只要存在多个actor共同访问一个数据对象就存在锁的问题，只不过可能无需开发者自己去写相关的代码。因此书中在提到actor缺点时也提到了可能出现死锁的问题。&lt;/li&gt;
  &lt;li&gt;PS2：在书中最后使用Actor来统计wiki的例子里，实际上是将wiki的页面进行拆分，然后不同的page用不同的Actor开统计。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section&quot;&gt;消息和信箱&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;因为actor模型没有提供直接回复消息的机制，所以将发送进程的标识符包含在消息中。通过这个机制，消息的接收者可以回复消息。&lt;/li&gt;
  &lt;li&gt;异步地发送消息是用actor模型编程的重要特性之一。消息并不是直接发送到一个actor，而是发送到一个信箱（mailbox）。&lt;/li&gt;
  &lt;li&gt;每个Actor都有一个信箱&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-1&quot;&gt;分布式&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;与其说Actor是为了并发，不如说Actor是为了分布式。&lt;/li&gt;
  &lt;li&gt;书中使用Elixir语言进行了demo的编写。在不同的设备或者操作系统中（这里可以是一个设备上有多个不同的虚拟机，也就是逻辑意义上的一个主机），不同的Actor可以进行通信，可以协作来处理一些数据。整个过程是异步的，每个Actor因为都看上去是无状态的，或者说即使有状态也是内部的。所以每个Actor的运行并不会影响其它Actor。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;actor-2&quot;&gt;Actor的实现&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;这个是我比较郁闷的地方，因为书中使用了Elixir这个我完全不熟悉的语言，因此我对于代码也是看个大概，具体某些语法和函数为什么这么写也是一知半解。&lt;/li&gt;
  &lt;li&gt;但是从demo code来看，也是创建纤程（这个概念个人认为和golang里面的应该是一样的）来实现actor，而一个actor本质就是一个module，里面包含了一些函数用于处理逻辑，收发消息。&lt;/li&gt;
  &lt;li&gt;对于Actor可以使用缓存机制来统一进行管理。这样的好处还有可以控制错误的处理。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;actor-3&quot;&gt;Actor的错误处理&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;书中对于Actor的错误处理有这样一个观点：任其崩溃。&lt;/li&gt;
  &lt;li&gt;这个观点得益于Actor的独立性，在一个Actor出现异常后，以为它对于某些消息的处理是失败的，因此消息队列或者信箱可以将没有处理的消息交给其它的Actor来处理。&lt;/li&gt;
  &lt;li&gt;出现异常的Actor什么我们可以不做任何的处理。&lt;/li&gt;
  &lt;li&gt;不过如果出现Actor一启动就崩溃了，那么也不能无限制的创建新的Actor。因此书中提到了Actor创建频率的问题，过高的时候就要考虑错误的问题了。&lt;/li&gt;
  &lt;li&gt;对于Actor的错误处理建议的做法是创建一个错误处理内核，这就有一个要求了：&lt;strong&gt;&lt;em&gt;那么该系统正确运行的前提是其错误处理内核必须正确运行&lt;/em&gt;&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;如何保证错误处理内核正确运行呢？这需要内核是&lt;code class=&quot;highlighter-rouge&quot;&gt;顶层的管理者&lt;/code&gt;，书中是使用actor的缓存来实现的。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://c1.staticflickr.com/1/791/39040480120_d12837240a_z.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;同时在错误处理时还要保证消息的必达性：
    &lt;ul&gt;
      &lt;li&gt;没有异常发生，消息一定能被送达并被处理&lt;/li&gt;
      &lt;li&gt;如果某个环节出现异常，异常一定会通知到使用者（假设使用者已经连接到或正在管理发生异常的进程）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;actor-4&quot;&gt;Actor的优势和缺点&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;从前面的讲述来看，其优点是：
    &lt;ul&gt;
      &lt;li&gt;消息的传输和封装性很好&lt;/li&gt;
      &lt;li&gt;容错能力比较好&lt;/li&gt;
      &lt;li&gt;天然支持分布式。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;而缺点是：
    &lt;ul&gt;
      &lt;li&gt;同样有死锁问题&lt;/li&gt;
      &lt;li&gt;信箱溢出（这个可能是指的actor如果处理不够及时，mailbox可能会数据量过大)&lt;/li&gt;
      &lt;li&gt;actor本身没有直接提供并发，需要通过并发技术来构造并发方案。&lt;/li&gt;
      &lt;li&gt;由于多个actor并不共享状态，仅通过消息传递来进行交流，所以不太适合实施细粒度的并行。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-2&quot;&gt;吐槽&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;这本书是好书，不过其使用的编程语言确实比较丰富，导致我看代码时很痛苦。&lt;/li&gt;
  &lt;li&gt;像是OTP部分完全是依赖于某个编程语言来写的，对于其真正的机制我觉得描述的不够清楚。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-3&quot;&gt;参考&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.zhihu.com/question/37792465/answer/73537924&quot;&gt;为什么我觉得 Actor很难用？&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.zhihu.com/question/266384753&quot;&gt;如果理解并行计算中的参与者模式（Actor Model）？&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;PS：在这里说下C#的进程间通信实现，可以通过pipe来实现。可以参考：https://gist.github.com/klkucan/b76c85c77fdfcde51aa4eeb1c6f7cd0b&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Thu, 15 Mar 2018 22:47:43 +0800</pubDate>
        <link>https://caihua.tech/2018/03/15/%E4%B8%83%E5%91%A8%E4%B8%83%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B-Actor/</link>
        <guid isPermaLink="true">https://caihua.tech/2018/03/15/%E4%B8%83%E5%91%A8%E4%B8%83%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B-Actor/</guid>
        
        <category>并发模型</category>
        
        
      </item>
    
      <item>
        <title>使用整体性学习方法来提高学习效率</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;前言&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;这篇文章可以说是一篇读书笔记，内容来自《如何高效学习：1年完成MIT4年33门课程的整体性学习法》这本书。&lt;/li&gt;
  &lt;li&gt;实际上看到书名的时候我的第一反应这是本讲费曼技巧的书，因为在很多年前我看到过一篇&lt;a href=&quot;https://kb.cnblogs.com/page/162480/&quot;&gt;文章&lt;/a&gt;，标题和这个非常类似，直到我重新翻出来后发现文中所讲的那个人正是这本书的作者。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-1&quot;&gt;书的内容&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;在这里我不打算过多的写书中的内容，只是简单的把一些核心的内容列出来。实际上如果没有时间看书，我觉得看上面链接中的那篇文章是一样的。因为这本书的观点比较简单，大部分内容是来证明这些观点，并且列出了一些如何实践的方法。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-2&quot;&gt;结构、模型和高速公路&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;这本书虽然叫做如何高效学习，但实际上主要讲的是整体性学习方法。作者一上来先讲了三个主要的观点：结构、模型和高速公路。&lt;/li&gt;
  &lt;li&gt;结构：理解是结构高度发达完善的结果，结构是学习新知识时与其它知识建立联系。&lt;/li&gt;
  &lt;li&gt;模型：
    &lt;ul&gt;
      &lt;li&gt;简化的结构、结构的快照&lt;/li&gt;
      &lt;li&gt;模型的目的是压缩信息&lt;/li&gt;
      &lt;li&gt;核心概念联系在一起创建模型&lt;/li&gt;
      &lt;li&gt;模型是逐渐调整和更新的&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;高速公路：结构之间的联系&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;实际上这三点是整体性学习的核心内容或者说是最终形态。在我的理解中所谓的整体性学习更像是用类比的方式来快速对新知识进行学习，而在类比的过程中对于已有的知识需要一个结构或者模型，在这个基础上通过联想、类比等方法来进行学习。不同的知识之间是有相似性或者本身就是有联系的，这就是高速公路。&lt;/li&gt;
  &lt;li&gt;以学习编程语言为例，我们知道目前的编程语言会分成不同的范式，比如有面向对象的、面向过程的、函数式的、命令式的等等。现代的编程语言往往包含了多个范式，以C#为例它是面向对象的，也是命令式和函数式都有的。在学会了C#之后，对于java这样的编程的语言在学习上会很快，因为他们几乎在编程范式是一样的，在语法上的差异和API的时候在使用的过程中再慢慢熟悉即可。但是在赋值、条件判断、循环、多线程、文件操作、lambda等等上都非常的接近，这样就可以通过类比的当时来快速的学习。&lt;/li&gt;
  &lt;li&gt;对于lua、python或者JavaScript这样的脚本语言来说，其在赋值、条件判断、循环这些基本操作上也是一样的，再加上函数式编程的范式使得学习起来也会有一种熟悉的感觉。这也是为啥工作了几年的人在学习一门新的编程语言时会比较快，因为会有一种熟悉感、进而进行类比的学习。快速掌握共同点、重点学习不同点和API就可以很快的掌握。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-3&quot;&gt;五个信息类型&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;书中列出了五种信息类型，也是知识类型。分别是：
    &lt;ul&gt;
      &lt;li&gt;随意信息&lt;/li&gt;
      &lt;li&gt;观点信息&lt;/li&gt;
      &lt;li&gt;过程信息&lt;/li&gt;
      &lt;li&gt;具体信息&lt;/li&gt;
      &lt;li&gt;抽象信息&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;其中随意信息是最难以记忆的，因为它们往往是一些事实，比如历史中的事件的时间，这些东西往往就是枯燥的记忆内容，没有什么很好的类比方式。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-4&quot;&gt;学习的顺序&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;文中还列出了一个学习的顺序，实际上就是一种知识的学习过程：
    &lt;ul&gt;
      &lt;li&gt;获取：快速阅读和笔记法&lt;/li&gt;
      &lt;li&gt;理解：使用内在化、类比、比喻等技巧。所谓内在化更像是观想法，也就是把知识具现化。&lt;/li&gt;
      &lt;li&gt;拓展：同上&lt;/li&gt;
      &lt;li&gt;纠错&lt;/li&gt;
      &lt;li&gt;应用&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;这个没什么特别的地方，基本上就是一个获取知识的过程。实际上，这本书中很多的内容对于天朝读了十几年书的人来说都是没什么新意。&lt;/li&gt;
  &lt;li&gt;书中用了很大的篇幅来描述着5个过程，比如获取就介绍了快速阅读和笔记法。在这里快速阅读推荐指读法，也就是用手指的移动来带动阅读，这样可以让人的注意力集中在手指所在的地方。而笔记法，推荐使用康奈尔笔记法或者与其接近的黄金三分法来做笔记。&lt;/li&gt;
  &lt;li&gt;对于理解和拓展，就是内在化、图表法等。&lt;/li&gt;
  &lt;li&gt;对于随意信息的记忆推荐联想法、信息压缩技术。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-5&quot;&gt;真正的干货 - 费曼技巧&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;费曼技巧的过程：
    &lt;ul&gt;
      &lt;li&gt;选择要学习的概念&lt;/li&gt;
      &lt;li&gt;设想你是老师，正在试图教会一名新生这个知识点&lt;/li&gt;
      &lt;li&gt;当你感到疑惑时，回过头来，重新阅读参考材料、听讲座或找老师解答，直到你觉得搞懂了为止，然后把解释记到纸上。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;总结来说就是小学老师告诉我们的，如果你能给你的同学讲明白一个知识点你就是真的懂了这个知识点。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-6&quot;&gt;我所总结出来的学习方法&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;在学习一个新的知识点的时候尽可能的联系已经学过的知识，通过知识的连接和类比来快速掌握知识。&lt;/li&gt;
  &lt;li&gt;实际上费曼技巧是很实用而且也比较容易实施的方法，费曼技巧的根本理论在于找出自己没有真正掌握的知识，从而查漏补缺。&lt;/li&gt;
  &lt;li&gt;使用思维导图来做联想、类比和内在化。书中很多方法都提到了联想、内在化、图表法等，在我看来都可以总结为思维导图。思维导图的制作本身就是一个查漏补缺和思维拓展的过程。&lt;/li&gt;
  &lt;li&gt;使用方格笔记和黄金三分法，这个技巧也是有人专门写过书的，个人认为还是很有用的。&lt;/li&gt;
  &lt;li&gt;最后这本书的笔记可以看&lt;a href=&quot;https://www.flickr.com/photos/142765619@N07/40075301272/in/dateposted-public/&quot;&gt;这里&lt;/a&gt;
&lt;img src=&quot;https://c1.staticflickr.com/5/4602/40075301272_eb0642788d_b.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 18 Feb 2018 01:49:43 +0800</pubDate>
        <link>https://caihua.tech/2018/02/18/%E4%BD%BF%E7%94%A8%E6%95%B4%E4%BD%93%E6%80%A7%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E6%9D%A5%E6%8F%90%E9%AB%98%E5%AD%A6%E4%B9%A0%E6%95%88%E7%8E%87/</link>
        <guid isPermaLink="true">https://caihua.tech/2018/02/18/%E4%BD%BF%E7%94%A8%E6%95%B4%E4%BD%93%E6%80%A7%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E6%9D%A5%E6%8F%90%E9%AB%98%E5%AD%A6%E4%B9%A0%E6%95%88%E7%8E%87/</guid>
        
        <category>杂记</category>
        
        
      </item>
    
      <item>
        <title>七周七并发模型：函数式编程</title>
        <description>&lt;h4 id=&quot;section&quot;&gt;概念&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;命令式编程的代码由一系列改变全局状态的语句构成，而函数式编程则是将计算过程抽象成表达式求值。&lt;/li&gt;
  &lt;li&gt;这些表达式由纯数学函数构成，而这些数学函数是第一类对象（我们可以像操作数值一样操作第一类对象）并且没有副作用。由于没有副作用，函数式编程可以更容易做到线程安全，因此特别适合于并发编程。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-1&quot;&gt;为什么在并发和并行问题时会用到函数式编程&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;有关锁的一些规则，都是针对于线程之间共享的可变的数据——换个说法就是共享可变状态。而对于不变的数据，多线程不使用锁就可以安全地进行访问。&lt;/li&gt;
  &lt;li&gt;这就是为什么在解决并发和并行问题时函数式编程会如此引人注目——它没有可变状态，所以不会遇到由共享可变状态带来的种种问题。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;纯粹的函数式语言中，函数都具有引用透明性——在任何调用函数的地方，都可以用函数运行的结果来替换函数的调用，而不会对程序产生副作用。这个特性也使得可以任意安排多个计算过程的求值顺序，包括让它们并行&lt;em&gt;。&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;所有函数（至少是理论上）都可以同时执行。这种执行方式被称为数据流式编程（dataflow programming）。&lt;/li&gt;
  &lt;li&gt;PS：其实本书在第三章函数式编程部分的前两天中的内容，在我看来更多的是利用语言或者运行时本书的并发能力。后续会专门写个文章总结下C#中对应的并发功能。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-2&quot;&gt;写在2018.2.8的第一版总结&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;函数式编程确实是个大话题，在七周七并发模式看到第三章的时候我卡到了函数式编程这里。然后看完了《函数式编程思维》这本书，《C#函数式程序设计》还在路上，我想这是一次很不错的机会，让我好好的学习下。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-3&quot;&gt;参考&lt;/h2&gt;

&lt;h4 id=&quot;c&quot;&gt;从C#的角度看看&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Map、Reduce、Filter分别对应了C# linq中的三个函数&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Map = Select | Enumerable.Range(1, 10).Select(x =&amp;gt; x + 2);
Reduce = Aggregate | Enumerable.Range(1, 10).Aggregate(0, (acc, x) =&amp;gt; acc + x);
Filter = Where | Enumerable.Range(1, 10).Where(x =&amp;gt; x % 2 == 0);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;Map从下面函数式编程部分的含义看就是接收一个函数，作用于范畴中每一个值，使得范畴从A变成B。&lt;/li&gt;
  &lt;li&gt;Filter就是过滤，在我理解里面其实也就是一个传递给map的函数，这里的map是函子中的map。&lt;/li&gt;
  &lt;li&gt;Reduce，正如下图说的，它是个折叠的作用。要我说就是sum的过程。只不过也许并不是真的对数值进行累加，而是可以做其它的处理。总之细细体会下面图片中的文字吧。&lt;/li&gt;
  &lt;li&gt;PS:折叠这个词用的好。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;httpswwwzhihucomquestion28292740&quot;&gt;来自知乎的一个&lt;a href=&quot;https://www.zhihu.com/question/28292740&quot;&gt;回答&lt;/a&gt;&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;结论：函数式编程会把数据的结构外显，而命令式则把执行过程外显。
或者这样说：你在读函数式代码时，经常会想不清楚执行过程；而你在读命令式代码时，会经常搞不清楚当前对象有哪些属性。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-4&quot;&gt;函数式编程思维&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://c1.staticflickr.com/5/4669/40374586841_18f607ea60.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;函数式编程&lt;/h3&gt;
&lt;h4 id=&quot;section-6&quot;&gt;原文&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2017/02/fp-tutorial.html&quot;&gt;函数式编程入门教程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-7&quot;&gt;范畴&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;彼此之间存在某种关系的概念、事物、对象等等，都构成”范畴”。随便什么东西，只要能找出它们之间的关系，就能定义一个”范畴”。&lt;/li&gt;
  &lt;li&gt;范畴的数学模型：
    &lt;ul&gt;
      &lt;li&gt;所有成员是一个集合&lt;/li&gt;
      &lt;li&gt;变形关系是函数&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-8&quot;&gt;容器&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;可以把”范畴”想象成是一个容器，里面包含两样东西。
    &lt;ul&gt;
      &lt;li&gt;值（value）&lt;/li&gt;
      &lt;li&gt;值的变形关系，也就是函数。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-9&quot;&gt;范畴论与函数式编程的关系&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;范畴论使用函数，表达范畴之间的关系。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;本质上，函数式编程只是范畴论的运算方法，跟数理逻辑、微积分、行列式是同一类东西，都是数学方法，只是碰巧它能用来写程序。&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;为什么函数式编程要求函数必须是纯的，不能有副作用？因为它是一种数学运算，原始目的就是求值，不做其他事情，否则就无法满足函数运算法则了。&lt;/li&gt;
  &lt;li&gt;总之，在函数式编程中，&lt;strong&gt;函数就是一个管道（pipe）。这头进去一个值，那头就会出来一个新的值，没有其他作用。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-10&quot;&gt;函子&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;函子是函数式编程里面最重要的数据类型，也是基本的运算单位和功能单位。&lt;/li&gt;
  &lt;li&gt;++&lt;strong&gt;它首先是一种范畴，也就是说，是一个容器，包含了值和变形关系&lt;/strong&gt;++。&lt;strong&gt;比较特殊的是，它的变形关系可以依次作用于每一个值，将当前容器变形成另一个容器。&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;一般约定，函子的标志就是容器具有map方法。该方法将容器里面的每一个值，映射到另一个容器。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;函数式编程里面的运算，都是通过函子完成，即运算不直接针对值，而是针对这个值的容器—-函子。函子本身具有对外接口（map方法），各种函数就是运算符，通过接口接入容器，引发容器里面的值的变形。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;PS:实际上函子通过map方法接收函数来实现转换。而所有的计算本质还是这个函数对函子中的值的计算&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-11&quot;&gt;常见的函子&lt;/h4&gt;

&lt;h5 id=&quot;of&quot;&gt;of&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;new一个函子&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;maybe&quot;&gt;Maybe&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;Maybe 函子就是为了解决内部值为null而设计的。简单说，它的map方法里面设置了空值检查。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;either&quot;&gt;Either&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;条件运算if…else是最常见的运算之一，函数式编程里面，使用 Either 函子表达。&lt;/li&gt;
  &lt;li&gt;Either 函子内部有两个值：左值（Left）和右值（Right）。右值是正常情况下使用的值，左值是右值不存在时使用的默认值。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;ap&quot;&gt;ap&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;函子B内部的函数，可以使用函子A内部的值进行运算。这时就需要用到 ap 函子。&lt;/li&gt;
  &lt;li&gt;ap 是 applicative（应用）的缩写。凡是部署了ap方法的函子，就是 ap 函子。&lt;/li&gt;
  &lt;li&gt;ap是为了解决一个函子使用另一个函子的值的问题。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;monad&quot;&gt;Monad&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;Monad 函子的作用是，总是返回一个单层的函子。&lt;/li&gt;
  &lt;li&gt;它有一个flatMap方法，与map方法作用相同，唯一的区别是如果生成了一个嵌套函子，它会取出后者内部的值，保证返回的永远是一个单层的容器，不会出现嵌套的情况。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Monad 函子的重要应用，就是实现 I/O （输入输出）操作。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;举例说明：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Monad extends Functor {
  join() {
    return this.val;
  }
  flatMap(f) {
    return this.map(f).join();
  }
}

// 具体事例

var fs = require('fs');

var readFile = function(filename) {
  return new IO(function() {
    return fs.readFileSync(filename, 'utf-8');
  });
};

var print = function(x) {
  return new IO(function() {
    console.log(x);
    return x;
  });
}

readFile('./user.txt')
.flatMap(print)

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;上面第一段代码中如果f函数返回一个函子，map本身也是返回函子。这样就的造成了this.map(f)是函子的嵌套。&lt;/li&gt;
  &lt;li&gt;从事例的角度看，&lt;code class=&quot;highlighter-rouge&quot;&gt;readFile('./user.txt')&lt;/code&gt;本身是返回了一个函子IO，其中的值为函数&lt;code class=&quot;highlighter-rouge&quot;&gt;function() { return fs.readFileSync(filename, 'utf-8');}&lt;/code&gt;（注意：函子的值可以是函数，而且因为这里的new实际就是上面的of，所以里面的参数应该是值），它其实是从文件中读取到的数据。而&lt;code class=&quot;highlighter-rouge&quot;&gt;.flatMap(print)&lt;/code&gt;根据上面的描述&lt;code class=&quot;highlighter-rouge&quot;&gt;它会取出后者内部的值，保证返回的永远是一个单层的容器，不会出现嵌套的情况。&lt;/code&gt;
。它取出的就是第一个IO函子中的值（函数），然后在将这个值作为参数传递到print函数中。只有就形成了函数链。&lt;/li&gt;
  &lt;li&gt;PS：以上只是我的理解，这篇文章的评论区有很多质疑，但是因为我确实对这个不了解，所以就按照原文的理解来解释了。&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Thu, 08 Feb 2018 20:52:19 +0800</pubDate>
        <link>https://caihua.tech/2018/02/08/%E4%B8%83%E5%91%A8%E4%B8%83%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</link>
        <guid isPermaLink="true">https://caihua.tech/2018/02/08/%E4%B8%83%E5%91%A8%E4%B8%83%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</guid>
        
        <category>并发模型</category>
        
        
      </item>
    
      <item>
        <title>七周七并发模型：线程与锁</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;为何使用多线程和锁&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;为了能够并行的计算一些东西&lt;/li&gt;
  &lt;li&gt;因为在多线程下，如果要修改同一个对象是值会出现竞态条件（即代码行为取决于各操作的时序）。它的表现可能是值的不对，甚至某些时候这个值的前半段是一个线程修改的，后半段是另一个线程修改的。因为这个对象可能不是原子的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;锁，或者说是并行控制的进化&lt;/h2&gt;

&lt;h3 id=&quot;section-2&quot;&gt;第一阶段：锁与同步方法&lt;/h3&gt;

&lt;h4 id=&quot;section-3&quot;&gt;基础的锁&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;从代码层面看就是一个lock函数&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-4&quot;&gt;同步方法&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;在java或者C#中可以通过attribute来让方法同步执行，但是这个的效率是很低的。&lt;/li&gt;
  &lt;li&gt;同时还引出了另外一个问题，当同时使用多个锁的时候不但效率会进一步降低，而且容易产生死锁。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-5&quot;&gt;基础锁带来的问题&lt;/h4&gt;

&lt;h5 id=&quot;section-6&quot;&gt;死锁&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;当出现多个锁的时候，因为执行顺的问题，导致多个对象都持有一个锁，同时在等待其他人释放锁。例子就是哲学家进餐问题。&lt;/li&gt;
  &lt;li&gt;哲学家进餐问题的解决方法就是:
    &lt;blockquote&gt;
      &lt;p&gt;一个线程想使用多把锁时，就需要考虑死锁的可能。幸运的是，有一个简单的规则可以避开死锁——总是按照一个全局的固定的顺序获取多把锁。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-7&quot;&gt;外星方法问题&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;所谓外星方法指的是在锁的block中调用了一个外部的方法，但是这个方法中可能会要求获得当前锁的权限，但是因为这个锁正在被使用，导致了代码出现死锁。&lt;/li&gt;
  &lt;li&gt;解决方案：
    &lt;ul&gt;
      &lt;li&gt;唯一的解决思路是避免持有锁时调用外星方法；&lt;/li&gt;
      &lt;li&gt;一种方法是在遍历之前对listeners进行保护性复制（defensive copy），再针对这份副本进行遍历；&lt;/li&gt;
      &lt;li&gt;PS：但是我的理解是这个情况只有当数据是并发read时，如果是并发的write想来就有问题了。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-8&quot;&gt;第二阶段： 进击的锁&lt;/h3&gt;
&lt;h4 id=&quot;section-9&quot;&gt;中断死锁&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;死锁问题是很让人沮丧的，而且也是很多时候都会遇到的。在我们的C#代码中使用lock来做锁，如果遇到死锁，我们是没有办法终止这个被锁的线程的。但是好在还有办法可以结束锁，在java中就是书中说的&lt;code class=&quot;highlighter-rouge&quot;&gt;ReentrantLock &lt;/code&gt;，对应的在C#中是&lt;code class=&quot;highlighter-rouge&quot;&gt;Monitor&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;PS：java的部分可以看下&lt;a href=&quot;http://blog.csdn.net/lipeng_bigdata/article/details/52154637&quot;&gt;这篇文章&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;PS2：两个类的功能基本是一致的，都包含了超时的功能。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-10&quot;&gt;问题是否得到了解决？&lt;/h4&gt;
&lt;blockquote&gt;
  &lt;p&gt;虽然tryLock()方案避免了无尽地死锁，但这并不是一个足够好的方案。首先，这个方案并不能避免死锁——它只是提供了从死锁中恢复的手段。其次，这个方案会受到活锁现象的影响——如果所有死锁线程同时超时，它们极有可能再次陷入死锁。虽然死锁没有永远持续下去，但对资源的争夺状况却没有得到任何改善。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;有一些方法可以减小活锁的几率。比如为每个线程设置不同的超时时间，来减少所有线程同时超时的几率。但通过设置超时来处理死锁不能说是一个好的方案——以后我们还可以做得更好。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;section-11&quot;&gt;条件变量&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;C#中的Monitor有wait、Pulse和PulseAll，对应了ReentrantLock的&lt;code class=&quot;highlighter-rouge&quot;&gt;reachSixCondition&lt;/code&gt;对应。用法参考&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.threading.monitor.pulse.aspx&quot;&gt;这里&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;该方法可以显著调高并发度&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-12&quot;&gt;原子变量&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;C#中可以使用Interlocked.Increment来做计算，这个是原子性的。在计数类的场景比较实用。&lt;/li&gt;
  &lt;li&gt;这个是为了解决基础锁使用过程中对于数据的操作比较繁琐的问题。比如对于计数类的变量，需要保证其get\set都有锁的保护，这样写的方法就比较多了。&lt;/li&gt;
  &lt;li&gt;原子变量是无锁（lock-free）非阻塞（non-blocking）算法的基础，这种算法可以不用锁和阻塞来达到同步的目的。无锁的代码比起有锁的代码更为复杂。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-13&quot;&gt;第三阶段：终极形态&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;书中以一个大数据的单词解析为例。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-14&quot;&gt;线程池&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;好处就是可以节约线程数，因此往往不能无限制的使用多线程。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;影响线程池最优大小的因素有很多，例如硬件的性能、线程任务是CPU密集型还是IO密集型、是否有其他任务在同时运行。还有很多其他原因也会产生影响。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;话虽如此，但也存在经验法则：对于CPU密集型的任务，线程池大小应接近于可用核数；对于IO密集型的任务，线程池可以设置得更大些。
当然，最佳的方法是建立一个真实环境下的压力测试来衡量性能&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;section-15&quot;&gt;解决方案的进化&lt;/h4&gt;

&lt;h5 id=&quot;section-16&quot;&gt;生产者消费者模式&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;将数据的解析与计算分割为生产者与消费者。从而分析出性能的瓶颈在消费者（统计单词量）这边。&lt;/li&gt;
  &lt;li&gt;使用多线程分别进行生产和消费。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;关键在于生产者和消费者可能不会（几乎肯定不会）保持相同的速度。比如，当生产者的速度快于消费者的速度时，队列会越来越大。Wikipedia的dump差不多有40 GiB，很容易就让队列大小超过内存容量。
相比之下，阻塞队列只允许生产者的速度在一定程度上超过消费者的速度，但不会超过很多。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&quot;section-17&quot;&gt;消费者端的并发执行&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;将解析出来的数据放入到一个HashMap中&lt;/li&gt;
  &lt;li&gt;在计算上，使用多线程来对HashMap进行统计，但是真正的计算方法本身采样lock。&lt;/li&gt;
  &lt;li&gt;问题是从结果统计看并没有提高效率。其原因为：&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;答案是因为过度竞争——过多的线程尝试同时使用一个共享资源。在我们的程序中，消费者花费大量时间等待被其他消费者锁住的counts，它们的等待时间比实际运算时间还要长，最终导致惨烈的性能下降。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&quot;concurrenthashmap&quot;&gt;使用ConcurrentHashMap来解决共享资源的并发访问&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;C#中对应的是&lt;code class=&quot;highlighter-rouge&quot;&gt;ConcurrentDictionary&amp;lt;TKey, TValue&amp;gt;.AddOrUpdate Method (TKey, TValue, Func&amp;lt;TKey, TValue, TValue&amp;gt;)&lt;/code&gt;。也就是并发集合，依赖于内置的并发集合来提高并发的访问。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;concurrenthashmap-1&quot;&gt;使用多个ConcurrentHashMap&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;使用ConcurrentHashMap并没有完全的释放多核的威力。&lt;/li&gt;
  &lt;li&gt;对原来的数据进一步拆分，进而分配给不同的线程来统计，极大的利用了多核。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-18&quot;&gt;优缺点&lt;/h2&gt;
&lt;h4 id=&quot;section-19&quot;&gt;优点&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;线程与锁模型的最大优点是其适用面很广。它是其他许多技术的基础，适用于解决很多类型的问题。同时，线程与锁模型更接近于“本质”——近似于对硬件工作方式的形式化——正确使用时，其效率很高。这也意味着它能够解决从小到大不同粒度的问题。&lt;/li&gt;
  &lt;li&gt;另外，这个模型可以被轻松地集成到大多数编程语言中。语言设计者们可以轻易让一门指令式语言或面向对象语言支持线程与锁模型。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-20&quot;&gt;缺点&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;线程与锁模型没有为并行提供直接的支持。&lt;/li&gt;
  &lt;li&gt;线程与锁模型仅支持共享内存模型。如果要支持分布式内存模型（无论是地理分布型或者容错型），就需要寻求其他技术的帮助。这也意味着线程与锁模型不适用于单个系统无力解决的问题。&lt;/li&gt;
  &lt;li&gt;多线程的难点不在于难以编程，而在于难以测试。&lt;/li&gt;
  &lt;li&gt;我们要全程保证所有对象的同步都是正确的、必须按照顺序来获取多把锁、持有锁时不调用外星方法。&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Wed, 17 Jan 2018 00:01:05 +0800</pubDate>
        <link>https://caihua.tech/2018/01/17/%E4%B8%83%E5%91%A8%E4%B8%83%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B-%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%94%81/</link>
        <guid isPermaLink="true">https://caihua.tech/2018/01/17/%E4%B8%83%E5%91%A8%E4%B8%83%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B-%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%94%81/</guid>
        
        <category>并发模型</category>
        
        
      </item>
    
  </channel>
</rss>
