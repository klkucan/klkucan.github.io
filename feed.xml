<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>蔡华的博客</title>
    <description>Be publicly useful and privately happy.</description>
    <link>https://caihua.tech/</link>
    <atom:link href="https://caihua.tech/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Mon, 25 Dec 2017 22:53:36 +0800</pubDate>
    <lastBuildDate>Mon, 25 Dec 2017 22:53:36 +0800</lastBuildDate>
    <generator>Jekyll v3.2.1</generator>
    
      <item>
        <title>每天一点UWA：第二十周</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;小结&amp;amp;新的开始&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;从今年的7月29号发布第一周的笔记算起不知不觉已经二十周了，当时的想法也很简单就是下定决心读完当时算下来是168篇文章。5个月过去了，在写这篇的文章的时候基本上已经通读完了所有厚积薄发版块的关于unity的文章，真的感觉这是我这些年来做的最有毅力的一件事情。可以说在这二十周里面对于unity的理解尤其是图形学上学到了很多东西，而且也学会了很多优化的理论和别人实践的方法。&lt;/li&gt;
  &lt;li&gt;理论已经学习完了，在后面的工作中就是一个实践的过程了。现在的项目会开始使用GOT工具进行优化的工作，真正的把优化这条路走下去。&lt;/li&gt;
  &lt;li&gt;由于UWA出文章的速度不可能太快，而且自己的工作也很忙，所以每周的笔记可能会改成每月一篇了，继续加油。&lt;/li&gt;
  &lt;li&gt;还有就是UWA都开始搞UE了，还有什么理由不开始学UE。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;gameplay&quot;&gt;GamePlay&lt;/h2&gt;
&lt;h4 id=&quot;uwameshuwa-got200mbunloadunusedassets&quot;&gt;在UWA的测评结果中，我们的Mesh文件内存过高（使用UWA GOT测试最大的场景会达到200MB），大部分是由于场景的物件导致的。我们的场景物件是这样加载的：场景有一个基础的框架（地面、天空盒和个别大的物件等），在进入场景后，会根据位置来加载其他的物件，加载的物件在离开视野后，为了防止下次再加载，只将其隐藏了，并没有销毁，这样的话，人物如果在场景里跑了一圈，就相当于整个场景的物件，都会进入内存。请问，是不是将离开视野的场景物件销毁比较好呢，销毁后是不是要调用UnloadUnusedAssets才能彻底从内存中去除呢？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;如果题主做的是移动游戏，那么200MB确实太大了。&lt;/li&gt;
  &lt;li&gt;建议题主建立一个Memory Pool来缓存场景中的物体，至少有以下两个规则：
    &lt;ul&gt;
      &lt;li&gt;Pool必须有一个上限，一般为容器的数量，超过最大阈值后即开始进行清理；&lt;/li&gt;
      &lt;li&gt;为Pool中每个Object记录一个存储时间，当时间超过一定阈值后进行清理，或者当Pool满了后，将时间最长的进行Deactive Object进行清理。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;通过缓存池来进行销毁较长时间不再显示的的物体，同时，可以通过UnloadAsset API来卸载相关的资源，Resources.UnloadUnusedAssets API一般只建议在场景切换处进行使用。&lt;/li&gt;
  &lt;li&gt;PS:说两句，如果一个最长时间的物体正好在视线内就不好办了。所以这个答案有点太粗暴，个人感觉还是要根据摄像机位置进行动态的删除对象。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;navmeshasset&quot;&gt;解析NavMesh.asset数据，用于服务器寻路。&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;https://blog.uwa4d.com/archives/2110.html&lt;/li&gt;
  &lt;li&gt;Q3&lt;/li&gt;
  &lt;li&gt;给大佬跪了&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;reflectionprobe&quot;&gt;ReflectionProbe在移动平台丢失部分高光数据&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;https://blog.uwa4d.com/archives/2110.html&lt;/li&gt;
  &lt;li&gt;Q4&lt;/li&gt;
  &lt;li&gt;仅记录，没仔细看过后续版本的bugfix，遇到了在处理吧。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;animator-controller&quot;&gt;大批量地合入美术资源时，经常会出现构建出来的版本出现材质引用丢失、Animator Controller引用错误、贴图引用错误等资源引用错误的问题。&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;出现这个问题可能是如下原因：&lt;/li&gt;
  &lt;li&gt;是否使用代码混淆。在Prefab 上挂的脚本忘记添加到排除混淆的列表，导致序列化的字段被混淆，打完Bundle后的Prefab资源加载时候，挂接的脚本出现引用错误；&lt;/li&gt;
  &lt;li&gt;资源导入都重载过OnPostProcess并处理了资源设置，这一步是否修改了什么不合理的地方，比如破坏了引用关系；&lt;/li&gt;
  &lt;li&gt;打包AssetBundle时，在构建Bundle 之前有没有使用文件操作API（不是 Unity 的AssetDatabase的API）来直接修改了某个文件夹或者其他会破坏引用关系的行为，然后构建Bundle，完成后恢复文件夹名字（或者恢复资源原始状态），这样丢失引用关系的几率很大；&lt;/li&gt;
  &lt;li&gt;有没有可能发布机器上，看着正常，但是Perforce里面已经存在一堆已修改的Meta文件；这种问题常出现于美术本地有两个A1，A2个相同资源在不同文件夹，A1受版本控制，但是由于某种操作，本地临时资源A2使用了原本A1的Guid，原本正确的 A1 被迫使用了不正确的新生成Guid（相当于两人交换），然后上传了A1的Meta，结果发布机器的下来的A1 Meta就会跟别人丢失引用，或者更新下来本地重新分配了新的Guid；美术策划最容易犯这个错误；&lt;/li&gt;
  &lt;li&gt;我们是Unity 5.3.8p2，上周遇到一个疑似bug，美术多上传了一组相同的资源，我们更新下来都会重新生成Guid，但是很多挂起的Meta在Unity里重新导入后，在版本控制里神奇地消失了，但修改还在；&lt;/li&gt;
  &lt;li&gt;如果都不是，只能尝试最小排除法了，删除项目绝大部分资源，一点点增加，然后打包，重现，排除原因；不行的话然后删除代码，一点点添加，打包，重现…有时候笨办法也是最容易接近真相的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;animatoroverridenameclip3-6cpu50-180mslisthttpsdocsunity3dcomscriptreferenceanimatoroverridecontrollerapplyoverrideshtml-lateupdateapplyoverrides400msoverridescount73clip&quot;&gt;游戏对战时因为会频繁更换武器或释放技能（主要是网络玩家），会替换不同的动作，但是发现每次设置animatorOverride[name]=clip（每次设置3-6个），CPU占用50-180ms，请问这是什么原因？我按照官方的指导存了一个list（https://docs.unity3d.com/ScriptReference/AnimatorOverrideController.ApplyOverrides.html） ，然后每次LateUpdate的时候调用ApplyOverrides，发现占用更高了，每次400ms，请问这个要怎么解决？目前每个网络玩家玩家OverRidesCount是73，会不会是Clip过多的原因？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;在真机运行时发现animatorOverride[name]=clip的耗时会受到animatorcotrollor中的clip数目的影响，随数目的增多耗时会明显增加，70个以上的clip耗时确实能达到50ms(红米note2)以上。&lt;/li&gt;
  &lt;li&gt;换为applyOverrides方法时耗时仍然很高，而且出现了堆内存分配，但并没有达到400ms那么高。&lt;/li&gt;
  &lt;li&gt;尝试了整体替换AnimatorOverrideController，即不在现用的AnimatorOverrideController中替换clip，而是在另一OverrideController中换好clip后，再整体替换到runtimeAnimatorController，这样耗时就会降到很低了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;texture&quot;&gt;Texture&lt;/h2&gt;
&lt;h4 id=&quot;unity-551sprite-packeriosrgba-pvrtc4spritepvrtc4467&quot;&gt;Unity 5.5.1版本下，Sprite Packer在iOS平台下RGBA PVRTC4打包图集失真非常严重（对单个的Sprite设置PVRTC4是正常的），参照了4.6.7版本是正常的，我想知道为什么呢？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;unity的bug&lt;/li&gt;
  &lt;li&gt;在 Windows 下尝试用 4.7 的 pvrtextool.exe 替换了 5.x 的，暂时解决了这个问题，建议也尝试一下。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;asynchronous-texture-upload&quot;&gt;异步纹理加载Asynchronous Texture Upload这个功能最后到底有没有实用？&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2FTechSharing_84%2F5.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;这个是默认就开启的，只是得开启多线程渲染才有效，因为要在 Render Thread 里上传纹理，还有文档里提到的各种限制，比如只针对关闭了 Read/Write 的纹理… 非多线程渲染时，异步加载纹理的时候，可以在 Loading.UpdatePreLoading 这个函数里看到较高的 Texture.AwakeFromLoad。但多线程渲染时，这部分的开销就会变得很小，因为这部分开销被放到 Render Thread 去了，如下图中的 Gfx.UploadTexture。&lt;/li&gt;
  &lt;li&gt;但需要注意的是，这个地方的异步并不是流式的加载，也就是说，当加载一个大纹理的时候，还是一次性完成的，并不会分帧去做，如下图加载了一张2048的纹理，图中绿色峰值是Gfx.WaitForPresent，也就是主线程在等待 Render Thread。&lt;/li&gt;
  &lt;li&gt;综上，这个功能实际上就是把某些满足要求的纹理的加载时间从主线程移到了渲染线程。在某些情况下，确实是可以提高总体的加载速度的。但这个功能并不能真正地“解决异步加载时纹理却只能同步加载”的问题，只是把卡顿放到渲染线程去了（如果耗时高了，主线程还是要等的）。&lt;/li&gt;
  &lt;li&gt;非常好的问题，建议直接看答案。 https://blog.uwa4d.com/archives/TechSharing_84.html Q3&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;unity&quot;&gt;在目前的Unity版本中，使用多维材质是否会对效率产生影响，用多维材质和把模型分块哪个更好？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;制作美术资源时，应该尽量避免使用多维材质。&lt;/li&gt;
  &lt;li&gt;先举例说明多维材质的一个优点是拆分模型做不到的： 一块大石头有石头和草地两个材质，做成一个整体的模型，使用多维材质，作为一个物件进行烘焙，在Lightmap上的UV分布是一个整体，不会出现拆分为两个模型烘焙产生的接缝问题。&lt;/li&gt;
  &lt;li&gt;除了上面这种情况，其他情况下推荐将模型拆分成多个模型赋予不同的材质。&lt;/li&gt;
  &lt;li&gt;优点是：
    &lt;ul&gt;
      &lt;li&gt;1、多个模型会作为多个MeshObject参与到裁剪、静态批次等优化中 ；&lt;/li&gt;
      &lt;li&gt;2、拆分的模型和贴图可以进行材质合并，程序才能进行下一步的优化，如果本身是多维材质，就无法进行合并DrawCall的优化；&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;第一个优点就能带来很大的收益。制作上应该按照一个模型对应一个贴图的做法进行，如果模型是一个整体，比如房子由底座、墙体、屋顶组成，建议将他们多选导出成一个FBX。&lt;/li&gt;
  &lt;li&gt;另外，不同材质的模型建议做成多个模型，再多选导出成一个FBX，仍然是一个模型对应一个贴图的规范进行制作。&lt;/li&gt;
  &lt;li&gt;PS: 对于人物模型可能不考虑剪裁，但是至少减少了drawcall。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ui&quot;&gt;UI&lt;/h2&gt;
&lt;h4 id=&quot;ugui-uirootscreen-space---camera-culling-mask-uirootuilayer&quot;&gt;我在UGUI 使用一个UIRoot，类型使用Screen Space - Camera，使用摄像机的 Culling Mask, 如果UIRoot可视，下面的UI子物体设置不可视Layer，是不是不会被裁掉？有没有什么解决办法吗？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;UGUI的网格合并是以Canvas为单位的，所以只能改Canvas的Layer才有效。&lt;/li&gt;
  &lt;li&gt;如果只是个别UI元素要快速隐藏和显示，可以考虑用Scale为0来做，Scale为0时UI的顶点信息会被清空，所以隐藏时就不会参与网格重建了。&lt;/li&gt;
  &lt;li&gt;PS:顶点清空的第一帧应该会出现rebuild，后续帧不参与rebuild。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;ui867outline-canvas&quot;&gt;在UI中，有两个字体控件每帧都要显示不同的数字，第一个有8个字，第二个有6~7个字，需要开outline增加辨识度，从而引起了较高的性能开销。 把这两个控件单独放到另外独立的Canvas，该问题依然存在。现已确定该开销是由这两个字体控件每帧的文本更改引起的。&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;提到一个是8个字，一个是6到7个字，都开启了outline。 首先建议再做一次确认，看是不是禁用这两个之后，SendWill就确实没开销了。因为这个字数看上去并不应该造成很明显的开销；&lt;/li&gt;
  &lt;li&gt;其次，如果确实是这两个造成的，那么就需要先考虑下能不能转成带outline效果的静态字体，不行的话再考虑下能不能降低更新的频率了，是不是确实要每帧都变；&lt;/li&gt;
  &lt;li&gt;如果要再降低，就只能考虑静态字体了，如果文本是一些比较固定的内容就很好处理，但如果是像聊天一样，内容无法预知的话似乎就没什么办法了。或者就是低端机用shadow来做。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;resourcesloaduiprefabui&quot;&gt;现在用Resources.Load()加载资源时，UI动画会出现卡顿的现象，如果想消除卡顿，是不是只能通过异步加载，分拆Prefab和优化材质网格动画之类的操作来实现？还是说UI动画可以在另外的线程播放之类呢？另外我想问下，异步速度是不是一定比同步慢呢？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;不直接贴答案了&lt;/li&gt;
  &lt;li&gt;总结一下就是遇到这样的卡顿的解决办法
    &lt;ul&gt;
      &lt;li&gt;分析卡顿原因&lt;/li&gt;
      &lt;li&gt;使用异步方法&lt;/li&gt;
      &lt;li&gt;拆分功能、预加载&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;工具&lt;/h2&gt;
&lt;h4 id=&quot;unityframe-debuggerprofilerdraw-calldrawcall&quot;&gt;Unity中的Frame Debugger中的渲染顺序以及数量和Profiler中看到的Draw Call数量，以及在高通的调试工具里看到的DrawCall数，它们之间有什么关系呢？哪个数值是影响渲染的重要指标？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;简单来说，Unity引擎中Total Batches是我们建议最需要关注的指标。&lt;/li&gt;
  &lt;li&gt;1个Setpass Call或者Batch，相当于是一次Render State的切换，而1个Draw Call则是CPU让GPU去进行渲染某一个Object的1次操作。在当前的移动设备中，1次Render State的切换要1个Draw Call本身要耗时。&lt;/li&gt;
  &lt;li&gt;所以，Total Batches是我们较为建议的关注指标，也是UWA性能报告中所提供的Draw Call查看指标。而Frame Debugger中，其数量是与Total Batches相一致的，即查看的是每一个Batch的渲染物体。 更为详细一些的说明，可以查看https://answer.uwa4d.com/question/58d29b8b5a5050b366a6b6ae&lt;/li&gt;
  &lt;li&gt;而Unity Profiler中的Draw Call，其理论上对应的则是glDrawElements的调用次数，其与高通或其他第三方工具所返回的Gl Trace信息操作数量不太一致，但应该与其中的glDrawElements API的调用次数基本一致，题主可以自行检测看看。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;uwa-gotcpustacktraceutility&quot;&gt;我用UWA GOT进行本地性能测试，在CPU的数据分析中发现，某些帧StackTraceUtility耗时特别高，这是什么原因导致的呢？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;StackTraceUtility.XXX是Unity引擎的Log输出，可能是本身Debug.Log/LogError的调用输出，也可能是使用过程中引擎端出现了Warning/Error等信息而自动输出的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;profilerassetbundlelockpersistentmanager&quot;&gt;我在Profiler中观察性能曲线，发现某一帧AssetBundle加载中，LockPersistentManager耗时比较大。请问这部分能否优化？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;这说明当前帧或前几帧中存在较大量的资源在通过LoadAsync来进行加载，其本质是所加载的资源过大所致，对自身资源进行合理优化可降低Loading.LockPersistentManager的开销。&lt;/li&gt;
  &lt;li&gt;另外，将异步加载换成同步加载，LockPersistentManager就不会出现了，但其总加载耗时是没有变化的，因为总加载量没变。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;profilerpciosandroidandroidgraphics-jobsplayer-settings&quot;&gt;我在安卓真机上跑游戏，发现Profiler下的合批数据和PC或者iOS下的不一样，因此不确定Android的合批是否有效。经过分析，Android上不能设置Graphics Jobs(在Player Settings里面)，也是不断打包测试发现这个问题，想了解一下具体是什么原因呢？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Graphics Job目前在Android平台上是为Vulkan而设计的，也就是只有支持Vulkan设备的才会真正起作用。按照Unity原厂的说法，该选项在不支持Vulkan的Android设备上应该是没有效果的。&lt;/li&gt;
  &lt;li&gt;另外，Graphics Job和MultiThread Rendering并不建议同时使用，而且以目前的Android设备来说，建议只开启MultiThread Rendering一项即可。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;模型&amp;amp;动画&lt;/h2&gt;
&lt;h4 id=&quot;unity3danimationclipframerate&quot;&gt;在Unity3d的官方文档中，animationclip.framerate的解释如下：&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;“Frame rate at which keyframes are sampled. (Read Only) This is the frame rate that was used in the animation program you used to create the animation or model.”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;section-3&quot;&gt;我对此有些疑问：&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;1）这个是否为动画系统每一秒钟更新动画的次数？如果是，当这个值高于Application.targetFrameRate时，一秒钟更新动画的次数依据哪个为准&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;2）这个是否只是调节动画播放速度的一个参数，而每秒钟动画状态更新的次数不受影响？&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;A: 动画采样的时候是根据当前播放的时间去找对应的前后两个关键帧做插值。所以动画本身得告诉Unity两个关键帧（没做keyframe reduction时）的间隔时间是多少，或者一秒有几帧，这个值就是framerate。所以这个是只读的，导出时就应该是确定的。因此这个值也不会影响运行时动画的更新次数，默认情况下动画就是每帧更新一次的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;loadlevelasyncloadlevelloadlevelasyncloadlevel40loadlevelloadingloadlevelasyncloadingprefabprefabresourcesloadasync2200ms&quot;&gt;在手机上测试LoadLevelAsync和LoadLevel的加载速度，同一个场景，LoadLevelAsync要比LoadLevel多花费40%左右的时间，请问这是正常的么？LoadLevel会有卡顿，导致Loading进度条不平滑，但是LoadLevelAsync好像又会增加Loading的时间？我项目中场景动态加载的做法是，是把物件做成Prefab，然后根据主角的位置做动态加载相应的Prefab，用的是Resources.LoadAsync方法。现在加载一些比较大的物件时，在红米2等低端机上，仍然比较卡，要消耗200ms以上。请问有什么好的方式，能平滑这个加载过程么，谢谢！&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;LoadLevelAsync一般情况下是要比LoadLevel慢的，但是否要慢40%，这个其实是根据每个场景所要加载的不同量而定的，并不是确数。&lt;/li&gt;
  &lt;li&gt;LoadLevel和LoadLevelAsync其实最本质的区别，是前者一定要在下一帧结束前完成加载操作，所以当加载场景较大时，其随后的单帧开销就会很大，而后者则没有这个限制，引擎可以根据当前的使用情况或者ThreadPriority（这个值是是否对LoadLevelAsync有影响，还没做过具体实验，但对于LoadAsync确实有影响 ）来自行调控。&lt;/li&gt;
  &lt;li&gt;还需要说明一点的是，不是说使用Async，它就一定是绝对平滑，下图红框是LoadLevel，绿框是LoadLevelAsync操作。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2FTechSharing_86%2F1.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;关于真正“平滑”异步的加载方式，Unity引擎目前还是没有的。在遇到较为复杂的Prefab（比如大纹理、多AnimationClip等等）时，其加载依然会出现卡顿。如果想要缓解该问题，建议如下：定位资源-&amp;gt;查看资源为何开销-&amp;gt;采用预加载的方式处理这样的资源。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;il2cppmonoil2cppprofilermanagedobject-int32&quot;&gt;我使用了IL2CPP后是否还存在Mono内存呢？使用IL2CPP后，通过Profiler工具获取的managedObject（例如： int32[]）是哪种内存？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;可以简单地认为，Il2CPP只是替换掉了Mono的虚拟机实现，所以该分配堆内存的地方还是会一样的分配（可能会有某些细节的地方不一样）。&lt;/li&gt;
  &lt;li&gt;IL2CPP在堆内存分配方面和Mono 最大的不同主要是Reserved Total 是可以下降的，而 Mono的 Reserved Total 只会上升不会下降。&lt;/li&gt;
  &lt;li&gt;PS：原来是这样，我一直以为是直接转成了CPP语言。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-4&quot;&gt;物理&lt;/h2&gt;
&lt;h4 id=&quot;boxcollider2d00f00f--10f10fphysics2dboxcastnew-vector210f1702-vector210f-14f-0-vector200f10f-20f-1700-17021706&quot;&gt;我的游戏场景中有一个boxcollider2D，位置在(0.0f,0.0f) 到 (1.0f,1.0f)；调用Physics2D.BoxCast(new Vector2(1.0f,1.702), Vector2(1.0f, 1.4f), 0, Vector2(0.0f,1.0f), 2.0f); 会产生碰撞，理论上碰撞的边界在1.700 ，我已经将位置放到1.702，应该是规避了浮点数误差的问题的，如果我将该值放大了1.706就不会产生碰撞了，请问哪里可以调整这个误差值的范围呢?&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Unity 2017.1版本的Physics2DSettings里面有一个Default Contact Offset，表示当两个collider之间的距离小于它们的ContactOffset之和就会产生碰撞。把这个值设置小一点应该能解决题主的问题。&lt;/li&gt;
  &lt;li&gt;Unity 5.x中Contact Offset，默认是0.01，这也是为何1.702不行，而1.706可以的原因。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-5&quot;&gt;性能综合&lt;/h2&gt;
&lt;h4 id=&quot;uigameobjectdestroyresourcesunloadunusedassets&quot;&gt;释放了资源，但纹理还在内存中，且引用数为0，要如何销毁呢？纹理所在的UI的GameObject是通过Destroy销毁的，并且执行了Resources.UnloadUnusedAssets();&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Ref Count为0应该就是可以通过Resources.UnloadUnusedAssets或Resources.UnloadAsset来进行卸载了。&lt;/li&gt;
  &lt;li&gt;出现这种情况建议如下：
    &lt;ul&gt;
      &lt;li&gt;尝试将Resources.UnloadUnusedAssets在Destroy稍后几帧执行；&lt;/li&gt;
      &lt;li&gt;在加载时尝试直接获取这些资源，然后在Destroy后通过Resources.UnloadAsset来卸载指定资源。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;resourcesunloadunusedassets-uwa&quot;&gt;Resources.UnloadUnusedAssets() 在卸载旧场景后加载新场景前调用好，还是在加载新场景后调用比较好呢？如果考虑内存峰值的话，我觉得是前者好，但是在UWA上看到有些文章说是加载场景后调用。&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;如果是通过LoadLevel(Async)类似的方式来加载场景的话，那么Unity自身会在底层执行一次类似Resources.UnloadUnusedAssets的操作。所以，这时如果手动调用Resources.UnloadUnusedAssets操作，时间间隔很短，其实这个是有些重复的。因此才建议在新场景加载后再调用一次。&lt;/li&gt;
  &lt;li&gt;但如果使用LoadLevelAdditive或其他类似的API来切换场景的话，那么Unity是不会调用Resources.UnloadUnusedAssets的，这时在旧场景卸载后调用，其实也是很不错的选择。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 23 Dec 2017 16:55:12 +0800</pubDate>
        <link>https://caihua.tech/2017/12/23/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%91%A8/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/12/23/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%91%A8/</guid>
        
        <category>UWA</category>
        
        
      </item>
    
      <item>
        <title>每天一点UWA：第十九周</title>
        <description>&lt;h2 id=&quot;assetbundle&quot;&gt;AssetBundle&lt;/h2&gt;
&lt;h4 id=&quot;assetbundleplayersettingsoptimize-mesh-data-optimize-mesh-datamesh-&quot;&gt;在移动平台上打AssetBundle时，为了控制包体大小，会开启PlayerSettings中的Optimize Mesh Data，对网格文件使用范围比较多的资源有较好的优化效果。 然而这带来了一个问题，就是在部分使用网格的特效中，美术会对模型上一些顶点做特殊处理，以达到一种网格遮罩的效果，而这个设置需要用到网格的顶点色。然而在开启Optimize Mesh Data这一选项后，打出来包中Mesh上的顶点色会丢失。 请问有什么比较好的解决方法，既能使用此方法优化网格，又能保留网格的顶点色效果？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;一般来说，开启“Optimize Mesh Data”选项，引擎会在发布时遍历所有的网格数据，去除其多余数据，从而降低其数据量大小。需要注意的是，这里的“多余”数据是指Mesh数据中包含了渲染时Shader中所不需要的数据，即如果Mesh数据中含有Position、UV、Normal、Color、Tangent等顶点数据，但其渲染所用的Shader中仅需要Position、UV和Normal，则Mesh数据中的Color和Tangent则为“多余”数据，引擎在发布游戏时，会将这些数据自动去除。&lt;/li&gt;
  &lt;li&gt;开启这个选项是一把双刃剑。对于在Runtime情况下有更换Shader需求的Mesh，建议研发团队对其特别注意。如果Runtime时需要为某一个GameObject更换更为复杂、需要访问更多顶点属性的Shader，则建议先将这些Shader挂载在相应的Prefab上再进行发布，以免引擎去除Runtime时会使用到的网格数据。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;assetbundleassetbundlewwwassetbundlegameobjectwwwdisposeassetbundleunloaddestroydestoyimmediatassetbundleassets-&quot;&gt;对于运行时动态加载的普通模型比如怪物，我们目前的打包策略是把它单独打一个AssetBundle包，通过AssetBundle加载并实例化的消耗。如下图所示，对于WWW、AssetBundle、GameObject，卸载方法分别为WWW.Dispose、assetBundle.Unload、Destroy/DestoyImmediat。但对于通过AssetBundle加载出来的Assets资源， 这块的资源用什么策略清理合适？&lt;/h4&gt;
&lt;blockquote&gt;
  &lt;p&gt;1）Resources.UnloadUnusedAssets，但该函数比较费时，一般只在切换场景时候使用；&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;2）assetBundle.Unload(true); 运行时Assetbundle在Instantiate prefab完成后也立即执行了unload(false)，所以也不适用；&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;对实例化出来的GameObject在使用后即使执行了DestroyImmediate，模型引用的贴图还驻留在内存中，难道要遍历GameObject使用的Assets分别执行UnloadAsset么？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;如果是仅加载Prefab，那么随Prefab一起加载进来的资源是不太方便被“优雅”地卸载的，即便是对应的GameObject被Destroy了，那么它对应的资源会变成“游离”状态（没有Refcount），只能等到手动调用Resources.UnloadUnusedAssets或场景切换时被引擎卸载。 所以，一般建议研发团队尝试通过依赖关系进行打包，将资源和Prefab进行分离，这样可以将加载资源和加载Prefab分开，从而可以通过“显式”地方式加载资源并将其进行储存，这样当你想精准释放资源时，则可以直接通过Resources.UnloadAsset来进行卸载。&lt;/li&gt;
  &lt;li&gt;PS: 这个问题本身就很有内容。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;audio&quot;&gt;Audio&lt;/h2&gt;
&lt;h4 id=&quot;unity-472unity-553apk200mb472apk553200mbkbunity-472mp3unity-553wav&quot;&gt;将一个Unity 4.7.2的项目升级到Unity 5.5.3。打成安卓包，发现APK文件比之前大了200MB。然后分别对4.7.2打出来的APK包和5.5.3打出来的包分别进行解包，发现音频文件个数一样，但所占大小多了200MB左右，平均每个文件都大了几百KB。Unity 4.7.2的解包为Mp3格式，Unity 5.5.3的解包为Wav格式。&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;于是我在Unity 4.7.2和Unity 5.5.3下，分别新建一个空工程，将单独一个音频文件（ogg格式）放入Resources文件下，即两个Unity版本的空工程里只有一个Resources文件夹，文件夹里只有一个相同的Ogg格式音频文件，打成安卓包。使用解包工具解包，发现Unity 4.7.2的音频文件转成了mp3格式，大小几十kb；Unity 5.5.3的音频文件转成Wav格式，大小200多KB。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;请问这种问题怎么解决？针对音频，Unity 4.x和Unity 5.x在打包过程中，作了那些修改？&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;引用Unity 5.0的release note：https://unity3d.com/unity/whats-new/unity-5.0
“Rewritten Audio asset pipeline and AudioClip backend.””Much improved audio formats in terms of memory and CPU usage.** The Format property no longer refers to a specific platform-specific file format, but to a encoding method** (Uncompressed, Compressed, ADPCM).”&lt;/li&gt;
    &lt;li&gt;可以看到，在Unity 5.x中，不同平台的音频不再与特定的文件格式关联，而是与文件编码关联。文件格式不等同于音频编码，虽然同是Wav格式的文件，但其有不同的编码方法（PCM，ADPCM，Vorbis，Wav也可以用mp3编码），编码方法会影响到Apk的大小。选定编码方式后降低quality和sample rate也会降低apk大小。
&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2FTechSharing_79%2F7.png&quot; alt=&quot;image&quot; /&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;font&quot;&gt;Font&lt;/h2&gt;
&lt;h4 id=&quot;iphone5cfontcachefontfortextuwablogfonttexturefont-texture-34&quot;&gt;我们在iPhone5c上测试时发现Font.CacheFontForText会造成很严重的卡顿，看了UWA的Blog，了解到可能是因为创建FontTexture导致的开销。那是否可以认为如果我们一开始申请了足够大的Font Texture，后面即便有新的文字，开销也不会很大？ 如果可以这么做，一开始申请使用的字符串是根据自己项目生成一个字典，还是直接使用网上3、4千字的常用字库更好？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;是的，如果Font.CacheFontForText开销较大，那么在无法降低字体数量的情况下，一开始增大Font Texture是较为可行的方法。建议根据自己项目的字体来撑大Font Texture，避免不必要的浪费。 同时，也建议看一下这篇&lt;a href=&quot;https://blog.uwa4d.com/archives/Sparkle_Font.html&quot;&gt;关于字体的精简优化方法&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;gameplay&quot;&gt;GamePlay&lt;/h2&gt;
&lt;h4 id=&quot;colliderboundssize-aabbobb&quot;&gt;我想了解下如何获取物体的最小包围盒？Collider.bounds.size 获取的是与世界坐标系坐标轴平行的包围盒(AABB)，当物体旋转时包围盒大小会发生变化。那如何获取物体的OBB，使包围盒的大小不会随物体旋转而改变呢？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;获取 OBB 可以用 Mesh.bonuds(模型空间)。注意蒙皮Mesh这一类在Shader中修改顶点坐标的操作。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;scriptableobjectassetassetbundledlldllscriptableobjectassetbundleassetbundleprotobufscriptableobjectscriptableobject&quot;&gt;安卓客户端存在大量的模板数据需要配置，其中一些模板表甚至可能达到万级的数据条目，那么怎么对这些数据模板表进行打包和加载，可以兼顾加载速度和热更新表结构？一开始我们采用了ScriptableObject，把全部模板数据加载到内存并序列化为Asset的方式进行Assetbundle打包，该方案加载速度较为理想。但当我们通过Dll替换热更新安卓客户端时，发现这种方式不支持热更新，一旦Dll中修改了模板表结构，热更新替换后，ScriptableObject的AssetBundle就无法读取了，提示损坏的AssetBundle，目前的方案是采用Protobuf代替ScriptableObject进行序列化，可以实现热更新模板表结构，但是加载速度相对ScriptableObject有较大的差距，目前数据模板加载较慢便导致了玩家进入世界的时间比较久。因此想了解大家有什么好的建议呢？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;用ScriptableObject或者BinaryFormatter二进制存储然后反序列化成保存数据结构的对象，这两种方法应该是加载速度最快的。
我们实际没有采取这个方案，也使用的是Protobuf，是出于以下考虑:
    &lt;ul&gt;
      &lt;li&gt;一份二进制数据，客户端和服务器可以通用。从服务器推数据很方便；&lt;/li&gt;
      &lt;li&gt;策划习惯使用Excel编辑，有脚本可以把表格内容导出成Protobuf的二进制数据，另外，还有.cs/.go表结构描述文件需要重点考虑。也就是说，策划修改表结构、增减表，服务器和客户端的结构描述文件可以自动生成好；&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;第一个问题：配置表存储格式
现在主流的数据存储基本分为三大类，各有优劣，需要根据实际情况选择：
    &lt;ul&gt;
      &lt;li&gt;ProtoBuf或类似序列化库，这种方式兼容性高，但是加载速度一般；&lt;/li&gt;
      &lt;li&gt;自己实现二进制数据存储，兼容性差，需要精心设计达到较高的数据表达能力；&lt;/li&gt;
      &lt;li&gt;采用Lua热更新方案的游戏，普遍直接把数据存储为Lua表。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;第二个问题：配置表数据与代码兼容
一般不建议大量修改数据结构，比如增删字段，如果实在无法避免，需要代码连同数据一起发布进行热更，做好版本管理即可。&lt;/li&gt;
  &lt;li&gt;第三个问题：配置读取速度优化
    &lt;ul&gt;
      &lt;li&gt;先从数据量上约减，减小数据冗余重复，数据存储设计优化，多次引用的字段多引用等等；&lt;/li&gt;
      &lt;li&gt;采用多线程加载，避免使用Unity提供的API，在游戏启动时，并行加载配置表，充分利用多核优势；&lt;/li&gt;
      &lt;li&gt;就我们自己项目而言，没有使用Lua的更新方案，但是我们依然采用Lua作为了数据存储，经过优化后加载速度也不错，可以参考 LuaTableOptimizer。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;maincamera--screen-depth-buffer-camera2--maincamera--rendertexture--screen-depth-buffer--camera2rendertexturecolorbuffer--camera2--unity--screen-depth-buffer--rendertexturecolorbuffer-&quot;&gt;MainCamera 渲染完场景后，在 Screen Depth Buffer 上记录了整个场景的深度信息。Camera2 在 MainCamera 后，将模型绘制到一个 RenderTexture 上，我想利用 Screen Depth Buffer + Camera2.RenderTexture.ColorBuffer 对 Camera2 绘制的内容进行深度剔除，这时 Unity 会提示 Screen Depth Buffer 和 RenderTexture.ColorBuffer 不能混用。这样的需求该怎么做呢？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;这是一个很有意思的问题，参考https://blog.uwa4d.com/archives/1945.html&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;inspectordictionary--public-dictionarystringstring-dict&quot;&gt;请问怎么在inspector中显示Dictionary呢？ 例如： Public Dictionary&amp;lt;string,string&amp;gt; dict;&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Unity 无法序列化Dictionary类型，无法将其显示在inspector中。一个Workaround是将Dictionary的Key和Value拆到两个list中，list可以在Inspector中显示。利用API：ISerializationCallbackReceiver （https://docs.unity3d.com/ScriptReference/ISerializationCallbackReceiver.html 有示例代码）可以在序列化/反序列化时将Dictoionary中的内容与list内容同步。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;unityfloat&quot;&gt;Unity需要对float进行相等判定&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Mathf.Approximately&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;uguibuttononclickaddlistenerbuttonbuttoncdelegategetinvocationlistdbuttonapibutton&quot;&gt;通常UGUI中的Button点击事件在代码中是通过onClick.addListener()来添加的。而且这种按钮的点击事件通常只会执行一次，如果添加了多次就会出现点击一次、按钮调用多次的事件函数。如果该Button只会添加一种事件，可以通过引用来判断是否添加了重复事件，从而不再重复添加相同事件。但是如果Button添加了多种点击事件，那么引用的方式就无效了。C#中的Delegate中有一个函数GetInvocationListD()可以获取此委托中的事件列表，从而剔除相同事件。然而让人头痛的是，我查看了Button的API似乎并没有暴露出此Button添加了的事件列表，所以没有办法剔除相同事件。不知道是否有什么办法可以解决这个问题?&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;onClick是一个ButtonClickedEvent对象，而ButtonClickedEvent的基类是UnityEventBase。UnityEventBase里有一个InvokableCallList对象，里面应该就存了事件列表，但这个是private的，可能只能尝试通过反射，去取里面的值来对比了。看上去并没有比较简便的方法。&lt;/li&gt;
  &lt;li&gt;可以考虑扩展下Button组件，封装一个AddUniqueListener的接口，保留一下已经onClick.addListener的UnityEvent，然后每次Add前都先和这些UnityEvent做个对比，没有重复再进行onClick.addListener。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section&quot;&gt;如果场景中有大量物体，请问如何利用相机拾取获取不同范围内的物体？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;采用Physics.SphereCastAll函数来获取，类似下面这个场景：
&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2FTechSharing_79%2F1.png&quot; alt=&quot;image&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;在SphereCastAll这个API的参数中，第二radius可以控制获取半径，我们分别设置5和10的效果是这样的：
radius=5：
&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2FTechSharing_79%2F2.png&quot; alt=&quot;image&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;radius=10：
&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2FTechSharing_79%2F3.png&quot; alt=&quot;image&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;unityandroidunityiosandroidunity552&quot;&gt;如下图，蓝色部分为Unity视图，绿色为Android图片，我现在需要把Unity蓝色区域透视或者去除，iOS上已经透视成功，但Android一直失败，Unity版本为5.5.2，大家有什么建议呢？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;只记录下方案 https://blog.uwa4d.com/archives/TechSharing_79.html&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;guilayoutscrollview&quot;&gt;改变GUILayout中ScrollView滑动条宽度&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;GUIStyle gs = GUI.skin.verticalScrollbar;
GUIStyle gs1 = GUI.skin.verticalScrollbarThumb;
        
gs.fixedWidth = 30;
gs1.fixedWidth = 30;
......
pos = GUILayout.BeginScrollView(pos);
......
GUILayout.EndScrollView();
......
gs.fixedWidth = 0;
gs1.fixedWidth = 0;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;staticbatchlightmaprendererlightmapindex-and-offsetlightingdataassetlightmapsettingrendererlightmapindex-and-offset-lightmaplightingdataasset-uwa&quot;&gt;我这边做了个测试，把场景中的物件进行StaticBatch，用Lightmap烘焙，并且在烘焙完记录每个物件Renderer的lightmapindex and offset，然后在运行中，我删除了生成的LightingData.Asset，自己设置了Lightmapsetting，并且恢复了每个物体Renderer的Lightmapindex and offset, 结果我发现烘焙出来的场景Lightmap还是不对的。我怀疑是不是LightingData.Asset 还记录了别的东西，想问问看UWA有没有什么经验呢？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;这个问题还是出在Static Batching上。经过测试我们发现如果去掉场景中物件的“Static Batching”标记，换成手动Batching，即采用StaticBatchingUtility.Combine的方式结果就正确了。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2FTechSharing_81%2F2.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;同时，我们发现使用LightingData.Asset时，开启Static Batching与不开启都正确，因此我们认为LightingData.Asset可能记录了与CombinedMesh有关的数据，导致如果仅仅使用gameobject的LightMap参数无法正确读取CombinedMesh的LightMap UV。另外一种可能是Unity的一个Bug。
最后，我们建议采用上述手动Batching的方式，即可解决此问题。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;linearuiuilinearuilinear&quot;&gt;当使用Linear设置时，UI上图片透明度等也跟着变化，出来的效果与美术人员的需求不一样。请问有什么办法可以让UI不使用Linear或者让UI可以在Linear影响下也正常呢？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;值记录下做法：https://blog.uwa4d.com/archives/2066.html&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;texture&quot;&gt;Texture&lt;/h2&gt;
&lt;h4 id=&quot;iospvrtc-&quot;&gt;请问在iOS上，图集如何设置成PVRTC的格式呢？ 下图中的设置是否正确？&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2FTechSharing_74%2F1.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;图集的设置需要考虑到该图集的用法，如果是作为普通的Texture给3D物体用的，那么TextureType选择Texture，然后Format选择Compressed就可以，因为在iOS上，Unity会自动处理NPOT（把纹理拉伸为边长为2的幂次的正方形），并默认采用PVRTC。&lt;/li&gt;
  &lt;li&gt;设置之后可以看一下下方的预览面板，会直接显示PVRTC的；如果是给UGUI用，那不同情况下，设置又不一样了；如果是给NGUI用，可以按照问题中截图里的设置即可，最终再确认下预览图上是不是PVRTC。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;loadsubsasyncloadsubsspritedata-loadtextureloadsubsloadsubsasyncspritedata-loadsubsasyncloadsubstexturespritedatatexturespritedata&quot;&gt;LoadSubsAsync和LoadSubs加载SpriteData，我想请问一下： 如果先LoadTexture加载纹理再加载LoadSubs，或者LoadSubsAsync函数调用加载SpriteData，纹理是否会加载两次，以及性能如何呢？ 按照我的理解，LoadSubsAsync或者LoadSubs，它自身有Texture属性，我断点调试可以看到SpriteData内的Texture会随着SpriteData加载而出来。&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;LoadSub和LoadSubAsync是会同时加载Texture的。 而先Load再LoadSub，并不会造成冗余问题，所以Load过Texture后，LoadSub的耗时就很小了。 但如果Texture里的Sprite是打了图集的，那么LoadSub的时候还是会有个图集加载的耗时。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ui&quot;&gt;UI&lt;/h2&gt;
&lt;h4 id=&quot;q1uguicanvassendwillrenderviewviewcanvasgroupscalesendwillrender&quot;&gt;Q1：众所周知，UGUI中有个Canvas.sendWillRender()函数在View打开的时候很耗时，所以通常的做法是把View移出屏幕外，或者Canvas.group，或者Scale等类似的处理机制。这样虽然能解决SendWillRender()消耗过高的问题，但也会有新的问题出现：&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;EventSystem.Update()。由于各个View都是Active的状态，所以这个函数底下的Graphic.GetDepth()消耗很大，而且又由于不止一个GraphicRaycaster组件，所以这个函数下面的List.Sort()消耗巨大，更何况是每帧都在耗。&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;还有一个函数ScrollRect.LateUpdate()，它的开销也很高。而如果将Scale设置成0，其消耗更大，这种情况下，我还是倾向于用回Active/Deactive的处理机制，因为就界面打开的时候会卡一下，而不至于影响总体的帧率。&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;界面的快速隐藏和显示，比较推荐的做法是：
    &lt;ul&gt;
      &lt;li&gt;把界面单独作为一个Canvas，并绑定一个相机，同时在绑定相机的Culling Mask中设置一个不渲染的Layer；&lt;/li&gt;
      &lt;li&gt;隐藏时，把Canvas移出相机范围，同时把Canvas的Layer改为不被渲染的Layer，禁用对应的GraphicRaycaster组件，把Canvas中所有的动态UI元素停止。&lt;/li&gt;
      &lt;li&gt;显示时，移回Canvas，改回Layer，激活GraphicRaycaster组件。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;针对题主的问题1，禁用GraphicRaycaster组件后就没问题了，被禁用的GraphicRaycaster不会进行Raycast操作；&lt;/li&gt;
  &lt;li&gt;针对题主的问题2，ScrollRect.LateUpdate中会通过EnsureLayoutHasRebuilt提前触发Canvas.SendWillRenderCanvases()，所以实际上还是Canvas.SendWillRenderCanvases()的开销。Canvas.SendWillRenderCanvases()开销高，是因为用Scale改为0的方式会清除顶点信息，在Scale改回1的时候还是需要重新创建顶点信息，开销肯定还是很高的，所以不推荐用Scale改为0来隐藏复杂的UI界面。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;uistaticstatic--&quot;&gt;UI界面勾选Static是会节省一部分性能，但是如果我移动了某个设置为Static界面下的元素，这个界面还算是静态的么? 还是等运动的元素停下来后的界面才算静态的? 如果是这样，是不是我全部界面都设置静态就好了?&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;如果题主所指的“勾选static”是指GameObject右上角的Static框，这个Static和UI是无关的，不会对UI有影响；如果是NGUI的UIPanel上的Static选项，勾上之后，子节点中的UI元素是无法移动的（即使改了Transform，其图标位置也不会更新）。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;工具&lt;/h2&gt;
&lt;h4 id=&quot;profilerassetsscene-memorymeshscene-memorymesh2meshcombinedmeshroot-sceneassetsmesh100meshmeshassetsmeshreferenced-byhierarchy&quot;&gt;Profiler里Assets和Scene Memory的区别是什么？比如Mesh这一项，在Scene Memory的Mesh中看到的只有2个合并的Mesh：CombinedMesh(root: scene)，在Assets的Mesh里看到的有100多个，包括场景里的非合并Mesh，动态加载出来的角色Mesh等。并且Assets的Mesh中的某些点击后选择右边的Referenced By，在Hierarchy里会自动选中场景中的物体，怎么看也不像是单纯的模板，而是实例化出来的东西。&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2FTechSharing_75%2F2.png&quot; alt=&quot;image&quot; /&gt;
&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2FTechSharing_75%2F3.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Resources.Load/Assetbundle.Load出来的ParticleSystem都是放Assets下的，可以认为是模板资源，并不在场景里。Instantiate出来的放在Scene Memory下，是出现在场景里的。&lt;/strong&gt; 所以两边都有是正常的。&lt;/li&gt;
  &lt;li&gt;在Unity里资源至少分为两类：
    &lt;ul&gt;
      &lt;li&gt;一类是可以被引用的，比如Mesh、Texture，如果要渲染多个相同的Mesh，并不需要对Mesh实例化，只需要在场景里多创建几份MeshRenderer/MeshFilter去引用它即可。所以Assets下的Mesh不应该被认为是实例化出来的东西，这些Mesh仅仅是通过AsssetBundle.Load/Resources.Load加载出来的，只是被场景里的东西引用了；&lt;/li&gt;
      &lt;li&gt;但SceneMemory下的Mesh通常是通过new Mesh或者Instantiate创建的，这部分可以说是实例化出来的了，另外像CombinedMesh是Unity自己创建的，也可以算是实例化的。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;另一类是不可被引用的，通常是组件资源，比如ParticleSystem，如果要渲染多个相同的ParticleSystem，就需要实例化多份出来，ParticleSystem的模板在Assets下，而实例化出来的在SceneMemory下。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;editor-mono672mb515mbgccollectmono&quot;&gt;我在Editor下测试， 前一帧Mono还是67.2MB，下一帧突然自己掉到了51.5MB。然而并没有gc.collect()调用，这Mono是为什么减少？因为有不明原因的减少，所以担心也有不明原因的增多。&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;如果题主是在Editor测的，这个Mono的回落就正常了。Editor本身（渲染窗口，处理交互事件等）就会造成内存分配，同时也会触发GC。&lt;/li&gt;
  &lt;li&gt;但默认情况下，Editor本身的开销在Profiler里是看不到的，除非题主点击一下“Profile Editor”。 点击之后，就可以看到Editor本身函数的耗时和GC的触发了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;模型&amp;amp;动画&lt;/h2&gt;
&lt;h4 id=&quot;hierarchyanimation-windowmissingcurve&quot;&gt;场景中放置一动画物体，原先正常进行动画，修改了物体Hierarchy某结点的名称，然后动画就异常了。打开Animation Window，发现动画曲线变为Missing。把物体名称改回后又恢复正常。我的疑问是动画Curve是与物体名称绑定的吗？如果是，如何修改动画物体的名称呢？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;anim文件里有节点路径的：
比如：curve: serializedVersion: 2 m_Curve:
    &lt;ul&gt;
      &lt;li&gt;time: 0 value: {x: -0.187, y: -0.003, z: 0.062} inSlope: {x: 0, y: 0, z: 0} outSlope: {x: 0, y: 0, z: 0} tangentMode: 0&lt;/li&gt;
      &lt;li&gt;time: 0.93333334 value: {x: -0.187, y: -0.003, z: 0.062} inSlope: {x: 0, y: 0, z: 0} outSlope: {x: 0, y: 0, z: 0} tangentMode: 0 m_PreInfinity: 2 m_PostInfinity: 2 m_RotationOrder: 4 path: Bip001/Bip001 Pelvis/Bip001 Spine/Bip001 Spine1/Bip001 Neck/Bip001 R Clavicle/Bip001 R UpperArm/Bip001 R Forearm/Bip001 R Hand/Bip001 R Finger1&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Animation Curve与动画物体是名称绑定的（名称包含其Hierarchy的Path，除去Root）；&lt;/li&gt;
  &lt;li&gt;Animation Window中可以修改Curve的绑定名，可以将其更新为改名后物体的Path；&lt;/li&gt;
  &lt;li&gt;如李先生所说Animation文件包含结点路径，可以“ForceText”后用文本工具来修改，比较方便；&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-3&quot;&gt;平时研究动画系统的时候有几个不太明白的问题：&lt;/h4&gt;
&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;BlendTree（不论1D或者2D） 在采样的时候，如果BlendTree内的AnimationClip的长度不同，那么输出的动画长度是可变的。不同的BlendTree参数会导致不同的BlendTree输出的动画长度。问题是BlendTree最终输出的动画长度是如何计算出来的？采样AnimationClip的时候，对于动画的TimeScale做了什么调整？ 图例：run是一个BlendTree2D，当它的参数Speed=300时，和Speed=900时的长度是不一样的。
&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2FTechSharing_78%2F2.png&quot; alt=&quot;image&quot; /&gt;&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;2.Unity的BlendTree2D是如何根据两个动画参数确定该在哪几个AnimationClip中采样？这些AnimationClip各自的权重是多少？ 图例：当Direction=-19，Speed=777的时候，黄箭头所指的动画实际上是由红箭头所指的4个动画混合而成的。那么混合权重分别是多少？
&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2FTechSharing_78%2F3.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;对于不同的Clip动画数据进行Blend时，Unity会把所有Clip的时间都归一化（展开为相同长度）后，再根据各个Clip的权重进行加权平均。&lt;/li&gt;
  &lt;li&gt;Blend后的时间长度与各Clip的权重相关，时间更接近权重大的Clip的时间（近似时间长度的加权平均）。BlendTree参数值用来决定当前Blend各Clip的权重值，参数不同导致权重不同，因此时间也就不同。参数值如何决定哪些Clip进行Blend，其权重则跟不同Clip的参数threshhold相关。&lt;/li&gt;
  &lt;li&gt;2D时在参数空间中根据（x,y)的坐标位置对临近的Clips进行插值。不同2D Blend 类型使用的插值方法不同，而插值方法的实现也就决定了各Clip的权重。对于插值算法可以参考这里提供的pdf：
http://answers.unity3d.com/questions/1206428/how-weights-of-2d-blending-are-calculated.html&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-4&quot;&gt;性能综合&lt;/h2&gt;
&lt;h4 id=&quot;scriptmapperstandardshaderstandardshader&quot;&gt;如下图，不理解ScriptMapper具体是什么，为什么会引用StandardShader，有什么办法可以彻底把StandardShader从内存里移除呢？&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2FTechSharing_75%2F1.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;这说明是有代码在索引这个Shader。建议题主尝试以下方法来定位Standard Shader的具体引用：
    &lt;ul&gt;
      &lt;li&gt;在游戏运行时遍历所有的GameObject或者Material，然后获取其所使用的Shader信息，查找跟“Standard”名称相对应的Shader，然后就可以定位它是出自哪个Material或GameObject。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;上述方法应该适用于大部分情况，但无法适用于以下情况：
    &lt;ul&gt;
      &lt;li&gt;Shader被加载后直接被缓存在代码脚本中；&lt;/li&gt;
      &lt;li&gt;Shader是通过AssetBundle.LoadAll加载的；&lt;/li&gt;
      &lt;li&gt;Shader通过Preload Shader加载的。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;unitygameobjectactiveactiveuwaunityactive&quot;&gt;Unity对GameObject.active()这个底层具体做了什么？因为在优化项目的时候看见有些界面active()这个函数造成的开销比较高，我采取的办法是移除摄像机的范围，这是参照UWA以前文章找到的办法，但是我还是想知道Unity对Active底层具体做了哪些操作，否则会有点困惑。&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;至少SetActive后，如果GameObject被激活，那么会调用该GameObject和所有子GameObject上的所有组件的OnEnable函数。而各种不同的UI组件的OnEnable中也有各种不同的操作。 如果题主希望深入研究下，可以看一下NGUI或者UGUI的源码，OnEnable具体做了什么都可以看到。同时，针对UI界面而言，还会在同一帧里触发其他的相关函数，出现后续的开销，如UGUI里的SendWillRenderCanvases和NGUI里的UIPanel.LateUpdate。&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Fri, 22 Dec 2017 16:49:12 +0800</pubDate>
        <link>https://caihua.tech/2017/12/22/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E5%8D%81%E4%B9%9D%E5%91%A8/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/12/22/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E5%8D%81%E4%B9%9D%E5%91%A8/</guid>
        
        <category>UWA</category>
        
        
      </item>
    
      <item>
        <title>Unity特效学习：动画</title>
        <description>&lt;h4 id=&quot;unity&quot;&gt;Unity动画创建&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;选中物体后按Ctrl+6可以开启动画编辑器。
&lt;img src=&quot;http://imglf5.nosdn.127.net/img/Nld0N0tacnNuUGx5S01XL01RMGE2NDQ4M1Z2TlZ0TFU1b1VpaHZqb0dFR0F1TlNaeDhDSFRnPT0.jpg?imageView&amp;amp;thumbnail=1680x0&amp;amp;quality=96&amp;amp;stripmeta=0&amp;amp;type=jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;点击Add Property可以选中你要编辑的物体对象上的属性。可以看到几乎物体上所有组件的可编辑的属性都可以通过动画来编辑。这也意味着很多东西不需要编码来完成，比如你要做物体transform的变化、要做shader属性的变化等。以往可能需要进行代码编辑，在update或者某个corroutine中来使用Time.deltatime来做变化，但是现在只要通过动画编辑器就可以实现了。&lt;/li&gt;
  &lt;li&gt;有时间线的区域就是帧动画编辑区&lt;/li&gt;
  &lt;li&gt;红线是时间线&lt;/li&gt;
  &lt;li&gt;可以右键然后选项add key来实现关键帧的添加。也可以拖动红线到某个位置，测试在inspector中改变对于属性的值时会自动的添加一个key。
&lt;img src=&quot;http://imglf3.nosdn.127.net/img/Nld0N0tacnNuUGx5S01XL01RMGE2NmdVMlVtaWFlOXlWWFZxazNsNWtYcnduRFVzdG9UVzdnPT0.jpg?imageView&amp;amp;thumbnail=1680x0&amp;amp;quality=96&amp;amp;stripmeta=0&amp;amp;type=jpg&quot; alt=&quot;image&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;最下面有Dopesheet和Curves的不同模式。下图是选择了rotation后的curves，可以看到X和Z就是一条直线没有变化，因为这个动画我确实只是选择了Y轴，而Y所对应的黄色曲线有明显的变化。
&lt;img src=&quot;http://imglf5.nosdn.127.net/img/Nld0N0tacnNuUGx5S01XL01RMGE2NWhmK2k0NzlFeS9MMTNSclF4YjJrSkVheU4rL1ZQMWtRPT0.jpg?imageView&amp;amp;thumbnail=1680x0&amp;amp;quality=96&amp;amp;stripmeta=0&amp;amp;type=jpg&quot; alt=&quot;image&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;Curves的编辑：和unity中其他的curves一样，右键添加key，然后key有各种的设置，总之动画效果完全是可视化编辑的。
&lt;img src=&quot;http://imglf4.nosdn.127.net/img/Nld0N0tacnNuUGx5S01XL01RMGE2eEFBTWhIR0l0WXlGK3RCblNyamU3WFVnelVwVStKc3dnPT0.jpg?imageView&amp;amp;thumbnail=1680x0&amp;amp;quality=96&amp;amp;stripmeta=0&amp;amp;type=jpg&quot; alt=&quot;image&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;d&quot;&gt;使用3D软件制作动画&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;事实上unity能够制作的动画比较简单。一个真正游戏中的复杂模型的动画还是靠的3D软件来制作。&lt;/li&gt;
  &lt;li&gt;还有我不会3D软件 (｡◕ˇ∀ˇ◕)&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section&quot;&gt;如何修改动画软件导入的动画信息&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;通过FBX得到的动画信息可以通过Animation编辑器打开，但是会显示为read-only。这有有个小机器，就是我们选择FBX的动画片段后，Ctrl+D 复制一个动画出来，在打开后就可以编辑啦。&lt;/li&gt;
  &lt;li&gt;另外一个小技巧是，在运行unity时播放某个动画的时候，暂停然后选择Hierarchy面板中的对象，选择copy，然后停止unity play。在hierarchy中paste，此时会粘贴模型到hierarchy中，而且模型的动作就是copy的瞬间的动画动作。好神奇！！！&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-1&quot;&gt;说明&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;Demo的地址为https://github.com/klkucan/UnityEffect&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 09 Dec 2017 22:35:34 +0800</pubDate>
        <link>https://caihua.tech/2017/12/09/Unity%E7%89%B9%E6%95%88%E5%AD%A6%E4%B9%A0-%E5%8A%A8%E7%94%BB/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/12/09/Unity%E7%89%B9%E6%95%88%E5%AD%A6%E4%B9%A0-%E5%8A%A8%E7%94%BB/</guid>
        
        <category>Unity</category>
        
        
      </item>
    
      <item>
        <title>Unity特效学习：粒子</title>
        <description>&lt;h4 id=&quot;section&quot;&gt;参数&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;只记录一些特别的参数&lt;/li&gt;
  &lt;li&gt;Prewarm: 预热，效果是直接播一个周期后的效果。也就是呈现一个周期的最终效果。目前来看应该是用到一些一开始就呈现效果的场合。&lt;/li&gt;
  &lt;li&gt;StartSpeed：这个是很常规的参数，但是当为负数时粒子方向会相反。值得留意。&lt;/li&gt;
  &lt;li&gt;Color：
    &lt;ul&gt;
      &lt;li&gt;Gradient：梯度，更像是设定一个颜色的变化范围。但是某个粒子从创建之后颜色不会变化。&lt;/li&gt;
      &lt;li&gt;Random：粒子颜色从两个值随机取&lt;/li&gt;
      &lt;li&gt;还有梯度随机&lt;/li&gt;
      &lt;li&gt;纯粹随机：这个可以自定义N个颜色区间。&lt;/li&gt;
      &lt;li&gt;梯度编辑器很强大。注意：点击颜色条上沿添加的节点是调整alpha的，下沿是调整颜色的。藏的好深啊。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Emission:
    &lt;ul&gt;
      &lt;li&gt;Rate over Distance:按照移动距离发射粒子。不动的情况下就不发射。可以用来模拟移动的汽车的尾气。动起来才有，不动就没有了。必须配合world模式。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Shape:
    &lt;ul&gt;
      &lt;li&gt;发射器可以选择不同的形状。当选择了Emit from为Base shell，并且将start speed设置为0时粒子就会出现在外轮廓的固定位置。可以呈现比较特殊的粒子效果。尤其是圆形或者柱状时。
&lt;img src=&quot;http://imglf5.nosdn.127.net/img/Nld0N0tacnNuUG41dzJIUXdRQVJiLythcEdyaE01eGtmc0RPdjltcXZYSTRyNm5veW9yd0JBPT0.jpg?imageView&amp;amp;thumbnail=1809y511&amp;amp;type=jpg&amp;amp;quality=96&amp;amp;stripmeta=0&amp;amp;type=jpg&quot; alt=&quot;image&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;mesh:想做特殊形状的粒子需要这个，很特别，看下图。
&lt;img src=&quot;http://imglf3.nosdn.127.net/img/Nld0N0tacnNuUG41dzJIUXdRQVJiMGdNdDdZMkVPS25yYmdwRU1rVHVRYnVLV0ZBbjlKdzJRPT0.jpg?imageView&amp;amp;thumbnail=1699y586&amp;amp;type=jpg&amp;amp;quality=96&amp;amp;stripmeta=0&amp;amp;type=jpg&quot; alt=&quot;image&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Velocity over lifetime: 简单来说就是在生命周期中给与一个3D方向的移动速度。比如我们只给x一个5的值，那么看上就是有粒子北风吹走的感觉了。目前想到的就是风吹的效果。&lt;/li&gt;
  &lt;li&gt;Limit Velocity over lifetime: 速度的衰减。speed为最终速度、dampen为删减的速度。基本上的公式应该是&lt;code class=&quot;highlighter-rouge&quot;&gt;speed = start speed - dampen * time&lt;/code&gt;。只给可以配合Velocity over lifetime实现一个更为真实的风吹效果。&lt;/li&gt;
  &lt;li&gt;Rotation over left：这个主要是旋转粒子，材质球选择一个具体的纹理图后比较明显。现在看效果比较适合做技能特效。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;External Force：配合风场更适合做各种风的效果。具体设置看Demo。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Sub Emitters:自发射器可以实现多个粒子的配合效果，最常用的就是烟花。
    &lt;ul&gt;
      &lt;li&gt;birth：主粒子产生时产生子粒子&lt;/li&gt;
      &lt;li&gt;collision：主粒子碰撞时产生子粒子&lt;/li&gt;
      &lt;li&gt;death：主粒子消失时产生子粒子&lt;/li&gt;
      &lt;li&gt;在death粒子如果想做出一次性的烟花效果需要注意：首先lifetime要短，其次总离子数量要小于rate over time，这样才能实现一次性发射所有的粒子。具体设置见demo。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://imglf6.nosdn.127.net/img/Nld0N0tacnNuUG41dzJIUXdRQVJiNWJCd0ROTUNyb2lpeXhrZDRDMVQvakgxbGNQTVl3WEV3PT0.jpg?imageView&amp;amp;thumbnail=1680x0&amp;amp;quality=96&amp;amp;stripmeta=0&amp;amp;type=jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Texture Sheet Animation：粒子序列帧动画。需要在材质球中配合特别的序列动画纹理图。最常见的就是做火焰。这个功能极其强大。
    &lt;ul&gt;
      &lt;li&gt;Tiles：动画纹理中动画的横轴纵轴的数量。我demo中的图是8x8的，所以这里也要设置成8x8。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://imglf3.nosdn.127.net/img/Nld0N0tacnNuUG41dzJIUXdRQVJiMEhQMGlNckU0WFJ1MWt4eldWQzlyYSsrbWE0OU1oeCtRPT0.jpg?imageView&amp;amp;thumbnail=1680x0&amp;amp;quality=96&amp;amp;stripmeta=0&amp;amp;type=jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;section-1&quot;&gt;说明&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;Demo的地址为https://github.com/klkucan/UnityEffect&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 09 Dec 2017 14:46:13 +0800</pubDate>
        <link>https://caihua.tech/2017/12/09/Unity%E7%89%B9%E6%95%88%E5%AD%A6%E4%B9%A0-%E7%B2%92%E5%AD%90/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/12/09/Unity%E7%89%B9%E6%95%88%E5%AD%A6%E4%B9%A0-%E7%B2%92%E5%AD%90/</guid>
        
        <category>Unity</category>
        
        
      </item>
    
      <item>
        <title>每天一点UWA：第十八周</title>
        <description>&lt;h2 id=&quot;assetbundle&quot;&gt;AssetBundle&lt;/h2&gt;
&lt;h4 id=&quot;assetbundleshaderalways-includeshadershaderbundleshadershaderbundleunity534f1&quot;&gt;最近的项目使用了AssetBundle的资源管理方案，对于Shader的部分全部放到了Always include里面（这里不仅是系统内置的Shader，还包括自定义的Shader），然后打Bundle资源的目录里是不包含任何Shader的。但是现在发现，Shader还是被作为依赖关系打进了最终的Bundle里，而且造成了冗余，问问大家有没有遇到这个情况呢？我的Unity版本是5.3.4f1。&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;首先，只要资源在工程里并且需要用到它，就会被打包进AssetBundle。&lt;/li&gt;
  &lt;li&gt;然后Always include里built-in Shader不会被打包进AssetBundle，这是一个特例。这个特例仅限于没有放到工程里的部分，有些项目会自己下载built-in Shader放到工程里，这样的Shader和自己写的没有区别，也会被打包。&lt;/li&gt;
  &lt;li&gt;最后，你遇到的问题是正常现象，需要你们通过资源管理的策略避免掉。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;shaderalways-includebundle-shader-shader-feature-enableclipshaderbundleshader-feature-shader-variant&quot;&gt;自定义Shader放入Always include里面，造成Bundle 资源冗余。项目中的某一个自定义的Shader 使用了Shader feature ENABLE_CLIP，Shader被打进最终的Bundle包的时候，这个Shader feature 不起作用了，是因为这个Shader Variant没有被打入最终包吗，官方文档里的说明是：&lt;/h4&gt;
&lt;blockquote&gt;
  &lt;p&gt;the only difference is that unused variants of shader_feature shaders will not be included into game build. So shader_feature makes most sense for keywords that will be set on the materials, while multi_compile for keywords that will be set from code globally.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;shader-featureshader-variant-bundle&quot;&gt;但是我确实有个材质是使用了这个Shader Feature的，为什么这个Shader Variant 没有进入最终的Bundle包呢？&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;据了解，Unity官方有在英文论坛里提到Asset Bundle team正在解决这个问题。如果不将Shader对应的Material与Shader一同打包，当前另外的解决方案包括：
    &lt;ul&gt;
      &lt;li&gt;使用dummy materials / ShaderVariantCollection 与shader打在同一ab内。&lt;/li&gt;
      &lt;li&gt;使用multi_compile替换shader_feature。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;fbxfbxmeshuvreadwrite-able&quot;&gt;我把FBX和粒子系统分开打包了。加载的时候先加载FBX文件，然后再加载粒子系统，结果那些粒子系统是Mesh模式的时候，它们的UV会消失。怎么办呢？开了Read/Write able就不会消失。不分开打包也不会消失，这种情况如何破？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;建议考虑在 FBX 的 AssetBundle 里再放一个带粒子系统，并且引用这个 Mesh 的 Prefab（但不去加载，也不去使用它），只是为了让 UV 可以被正确获得。 理论上这样做的话，基本不需要修改原来的加载方式，也不用开Read/Write。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;gameplay&quot;&gt;Gameplay&lt;/h2&gt;
&lt;h4 id=&quot;shadershadercullcull-off&quot;&gt;我写了一个顶点动画的Shader，对物体顶点位置进行了修改，使其能够跟随相机移动，并总是出现在相机前面。当游戏运行后，开始时物体能够正常显示。相机在场景中移动一段距离后，物体便不再显示，但相机换一下朝向，物体又能显示。目前排除了面剔除的原因，在Shader中已经关闭了Cull（Cull Off），请问还可能是什么其他原因呢？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;消失的原因应当是Unity的Frustum Culling引起。因为顶点动画是在shader中修改的顶点位置，而Frustum Culling是根据顶点修改之前的Mesh的bounds进行的，因此随着相机移动，Mesh实际已经出了Frustum的范围。最简单的解决方法是直接将Mesh的bounds设置足够大，让Unity始终不对其进行Culling：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mesh.bounds = new UnityEngine.Bounds(transform.position, new Vector3(float.MaxValue, float.MaxValue,
float.MaxValue));
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;systeminfographicsdevicenamegpuarmmalit880-mp2t880-mp12t880mp&quot;&gt;使用SystemInfo.graphicsDeviceName获取的GPU信息不太详细。比如ARM系列的Mali，T880 MP2与T880 MP12相差甚远，但是只能获取到T880，无法获取MP的信息。各位是否有办法？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;对于获取GPU名称信息，在Android的Java层中可以利用API：GLES20.glGetString(GLES20.GLRENDERER)获取显示设备名。可以尝试在Unity中利用AndroidJavaClass(https://docs.unity3d.com/ScriptReference/AndroidJavaClass.html)来调用该API，尝试获取更详细的型号。&lt;/li&gt;
  &lt;li&gt;如果获取GPU名称的目的是判断GPU性能，可以看下SystemInfo中其他graphicsDevice相关的GPU性能信息是否够用。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;物理&lt;/h2&gt;
&lt;h4 id=&quot;colliderrigidbodyoncollisionenteroncollsionenter&quot;&gt;两个挂了Collider的物体，一个物体挂了Rigidbody，去碰撞另一物体，为什么每次OnCollisionEnter这个函数在实际还没有碰撞的时候就调用了呢？如下图，这时OnCollsionEnter已经被调用，但从图上可以看到两物体实际还没有接触，这个函数调用之后才会真正碰撞在一起。&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;物理系统在FixedUpdate中触发，包括OnCollisionEnter。而FixedUpdate早于Frame Rendering，因此碰撞实际已经发生，只是画面还没更新。其实在运行时这点时间差几乎应该可以忽略。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;性能综合&lt;/h2&gt;
&lt;h4 id=&quot;unityocclusion-cullingunityocclusion-cullingdrawcalltriangleocclusion-cullingnavmeshdata&quot;&gt;想对场景中的静态物件做一个遮挡剔除，不知道Unity自带的Occlusion Culling对性能优化的提升有多少呢？我们用Unity官方例子测试，启用Occlusion Culling后发现DrawCall、Triangle几乎没有变化。另外也想获知，Occlusion Culling的数据能否像NavMeshData那样可以动态加载呢？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Occlusion Culling在使用后具体能提升多少，这个其实是没有明确数值的，甚至可能不升反降！这个只能题主在自己的项目中进行尝试。&lt;/li&gt;
  &lt;li&gt;一般来说，Occlusion Culling功能特别适合第一人称或第三人称跟随的平视角相机（比如传统意义上的MMO等类似游戏），且适用于在场景中存在大量的遮挡情况。因此，在城市街道漫游、峡谷漫游等特定场景中，比较推荐开启Occlusion Culling功能。&lt;/li&gt;
  &lt;li&gt;但是Occlusion Culling功能本身存在一定的性能开销，因为需要每帧均遍历烘焙的Cell来明确哪些物体需要或不需要渲染，所以场景中Cell越细，那么其查询开销也就越大。因此，如果场景中本身没有大量的遮挡关系，那么开启Occlusion Culling功能后，其节省下来的渲染耗时可能抵不上其Cell查询耗时来的大，这样就得不偿失了。&lt;/li&gt;
  &lt;li&gt;最后，Occlusion Culling的Data目前并不能动态加载，只能随场景来进行加载。因此，可以尝试创造一个拥有Occlusion Culling Data的“空场景”，然后通过LoadLevelAdditive方式来进行加载，从而来达到“动态”加载的效果。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;profilergetmonoheapsizeuiui68mbprofiler&quot;&gt;通过Profiler.GetMonoHeapSize()获取到的堆内存，在操作UI的时候，打开某个节点比较多的UI界面，根据上面接口取到的堆内存会突然涨6~8MB，但是Profiler取不到这个数据，该怎么办呢？我不是固定打开某个界面，而是随机出现在某个界面上，这样的问题该如何入手呢？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Mono总体堆内存一次性涨6-8MB是比较正常的。Mono内存并不是随用随分配的，而是当其发现不够用时，一次性从系统中获取一段连续的内存。在游戏运行一段时间后，这个值一般是8MB。所以，题主遇到的情况很有可能是在连续操作UI界面时，Mono发现堆内存不够用了，于是就有了题主观察到的内存分配。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;渲染&lt;/h2&gt;
&lt;h4 id=&quot;drawcallgpu20msxcode-profilercpu78ms&quot;&gt;下图这一项是指渲染透明物体的渲染消耗么，主要是提交DrawCall是么，现在游戏的GPU消耗在20ms以内Xcode Profiler结果。但是有些粒子系统比较耗CPU，就是这个涨得比较厉害，峰值有7~8ms，请问有没有什么优化建议?&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2FTechSharing_71%2F1.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;首先，需要说明的是，Draw Call是CPU端的耗时开销，XCode上GPU上的开销统计与其关系不大。&lt;/li&gt;
  &lt;li&gt;其次，图中红框所示确实表示的是半透明物体渲染在CPU端的耗时，其不仅与Draw Call数量相关，也和渲染State的切换相关（从图中可以看出，项目使用的是Unity 4.x版本，对应的需要关注Shader.SetPass的开销）。&lt;/li&gt;
  &lt;li&gt;再次，粒子系统的耗时开销很高，如果还是持续在7~8ms左右，那么研发团队关注较高耗时处的游戏场景，并控制粒子系统的使用数量，粒子系统的优化并没有“神奇”的方案，目前研发团队需尽可能控制粒子系统的使用数量。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 03 Dec 2017 22:59:12 +0800</pubDate>
        <link>https://caihua.tech/2017/12/03/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E5%8D%81%E5%85%AB%E5%91%A8/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/12/03/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E5%8D%81%E5%85%AB%E5%91%A8/</guid>
        
        <category>UWA</category>
        
        
      </item>
    
      <item>
        <title>每天一点UWA：第十七周</title>
        <description>&lt;h2 id=&quot;assetbundle&quot;&gt;AssetBundle&lt;/h2&gt;
&lt;h4 id=&quot;texturematerialspritetexture&quot;&gt;当一个Texture被一个material和sprite都引用的时候，将三者分别打包，出现texture内存重复问题。&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.uwa4d.com/archives/TechSharing_66.html&quot;&gt;原文&lt;/a&gt;较长，总结一下就是：如果一个贴图一方面被当成Sprite使用，另一方面被当成Texture使用(譬如RawImage或者Material)，就会断开引用产生多份。目前解决办法是保证用Sprite的Prefab及Material打包在一个AssetBundle。&lt;/li&gt;
  &lt;li&gt;这是一个重要的问题，而且这个问题也是看unity版本的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;assetbundleunloadtrueanimationclip--animationclipprofiler&quot;&gt;使用AssetBundle.Unload(true)释放AnimationClip , 但发现AnimationClip在Profiler看到还存在，请问要怎样才释放干净呢？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;如果这个AnimaitonClip是从AssetBundle中加载过来的，那么当这个AssetBundle调用unload(true)时，该AnimationClip理论上是会被强行卸载的。如果Profiler中查看还有，那么只有两种情况：
    &lt;ul&gt;
      &lt;li&gt;仍然存在的AnimationClip是从其他地方加载来的，而不是来自于该卸载的AssetBundle；&lt;/li&gt;
      &lt;li&gt;Unity引擎的Bug，这种概率不是没有，但很小。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;assetbundlenameassetbundleunityassetbundlenamegetallassetnamesloadallassets&quot;&gt;在打包的时候，有一部分资源是没有设置AssetBundleName的，打包的时候会和依赖它们的资源打到同一个AssetBundle包里（Unity自动完成）。在资源加载的时候，无法主动获取到这些没有设置AssetBundleName的资源。GetAllAssetNames、LoadAllAssets这些接口的返回值中都没有这部分资源。&lt;/h4&gt;
&lt;blockquote&gt;
  &lt;p&gt;请问，在你们看来，这种情况是Unity的设计还是Bug？如果是如此设计的话，有什么特别的意义吗？ 提供一个简单的情景，如下：
１）有A、B两个Prefab，其中A上挂个脚本引用了B
２）打包的时候，设置A的AssetBundleName＝”prefab.unity3d”，B的AssetBundleName=None
３）打包，只产生prefab.unity3d这一个AB包，其中包含了A、B两个资源
４）加载代码使用AssetBundle.LoadAllAssets()，返回的数组里只有一个资源（A）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;我们刚刚在Unity 5.5.2版本上进行了一个测试，得到与题主一样的结论。
我们更加倾向于它是一种设计，而非Bug。&lt;/li&gt;
  &lt;li&gt;因为Prefab B是作为一种参数被引用在A的脚本中，所以在AssetBundle中，它将以GameObject B的形式存在，但是不会存在于AssetBundle的映射表中。&lt;/li&gt;
  &lt;li&gt;而对于题主的这种打包方式而言，AssetBundle的映射表中只会有一个，就是Prefab A。而AssetBundle.LoadAllAssets虽然会把GameObject A、B及其关联的资源全部加载，但其返回的Object[]内容应该就只有一个，也就是Prefab A。&lt;/li&gt;
  &lt;li&gt;所以，UWA推测，AssetBundle中在打包时是自己维护了一个map的，只有明确被设置ABName的资源才会被放入map中，也只有map中的资源才可以通过特定名称进行Load，而其关联的资源则会被打包到AssetBundle中的其他container中，是无法通过LoadAsset或LoadAllAssets API来获取到的。&lt;/li&gt;
  &lt;li&gt;PS：==这是一个需要注意的问题==&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;assetbundlebitmap-aassetbundlealtas-bb&quot;&gt;AssetBundle包字体bitmap A的使用到AssetBundle包Altas B时B冗余&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;出现冗余是因为vip和betaCommon两个Prefab实际上并没有建立其依赖关系（虽然mainfest上注明了存在dependencies）。&lt;/li&gt;
  &lt;li&gt;问题解决方式，只需要将BetaCommon Material设置为一个“显式”的AssetBundleName，那么冗余问题就不会存在了。&lt;/li&gt;
  &lt;li&gt;PS:让bitmap A的material被显示打包。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;font&quot;&gt;Font&lt;/h2&gt;
&lt;h4 id=&quot;unity-55uguitestmesh-prongui&quot;&gt;Unity 5.5版本下的UGUI，我将字体设置为粗体，发现字体只是变宽不加粗，不像正常的粗体，如下图所示。另外，TestMesh Pro需要预渲染，不能用动态字体，只能用于特定范围，有像NGUI(效果还不错)那种对动态字体加粗的方法么？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;动态字体加粗显示的外观是和字体本身有关系的，如果字体中没有包含“粗体”的字形，那么Unity会通过拉伸来“模拟”加粗，因此得到的效果是有问题的。&lt;/li&gt;
  &lt;li&gt;而这个行为在UGUI和NGUI中是一样的。因此，如果要确保加粗显示正确，则需要使用包含了“粗体”字形的字体，甚至需要考虑是否将其include到发布包中（因为某些设备中的内置字体也有可能被精简过）。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;texture&quot;&gt;Texture&lt;/h2&gt;
&lt;h4 id=&quot;uguitaggroupdrawcallgroup&quot;&gt;UGUI自动打包图集时，有时候同一个Tag会自己打出多个Group图集，导致DrawCall增加，有什么解决方法吗？这个分Group的原理是什么？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;产生Group的原因主要有两种：
    &lt;ul&gt;
      &lt;li&gt;纹理的格式不同 。举例来说，有这样四张纹理格式分别为：RGB24，ETC1，RGBA32和ETC2，那么设置一样的Tag后，对应的图集就会有四个Group。&lt;/li&gt;
      &lt;li&gt;纹理量太大。一个Group放不进，这个原因是容易理解的，就不解释了。&lt;/li&gt;
      &lt;li&gt;其中特别容易忽略的一点是，某些小纹理可能没有Alpha通道，导致了图集被分成两个Group，引起DrawCall的增高，这种情况下可以直接修改纹理，也可以强制设定为Aalpha通道的格式。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ui&quot;&gt;UI&lt;/h2&gt;
&lt;h4 id=&quot;ugui-image-sprite-profilerspritemeshgeneratortraceshape-&quot;&gt;请问UGUI Image 在切换Sprite（网络图片） 的时候有卡顿，从Profiler中看到具体卡在SpriteMeshGenerator.TraceShape 这个方法上，如下图所示，有没有什么优化的方法呢？&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2FTechSharing_66%2F9.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;图中的==SpriteMeshGenerator.TraceShape/Decompose/Simplify==的函数，通常出现在加载或者创建（Sprite.Create）SpriteMeshType为==Tight类型==的Sprite时，==Tight类型的Sprite在加载或创建时，需要检测图片的alpha区域从而生成多边形==。计算量较大，建议将其改为FullRect模式。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;工具&lt;/h2&gt;
&lt;h4 id=&quot;unity-profiler&quot;&gt;Unity Profiler中如下函数的耗时异常高，请问是什么原因导致呢？这些函数分别是什么意思，有什么具体优化方法呢？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Profiler.FinalizeAndSendFrame: 这个是Unity Profiler在记录和传输性能数据的开销，研发团队可忽略，因为在release版本中，该项并不存在；&lt;/li&gt;
  &lt;li&gt;WaitForJobGroup:是主线程在等待子线程完成的耗时开销，如果该项较高，那么说明该帧中某子线程的开销很大。就目前我们优化过的项目而言，绝大部分均为UGUI在子线程的开销所致。更多的参考资料建议研发团队参考UWA问答之前的记录：
https://answer.uwa4d.com/question/search?q=waitingforjob&lt;/li&gt;
  &lt;li&gt;Camera.Render:是Unity引擎的主要渲染函数，其中负责了绝大部分场景的渲染工作&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;gfxprocesscommands&quot;&gt;Gfx.ProcessCommands包含哪些行为操作？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;该行为是在RenderThread中，导致该行为耗时的主要原因是DrawCall。&lt;/li&gt;
  &lt;li&gt;另外过程耗时统计还包括顶点、材质贴图以及Shader等从内存到GPU的IO时间。&lt;/li&gt;
  &lt;li&gt;即使是多线程渲染，图形API的调用也需要在同一个线程中。其一，是Android系统的EGLContext一般不是线程独共享的，也就是只有一个线程能向同一个EGLContext里面发送GL指令。其二，如果使用共享的EGLContext，多个线程都能提交图形API，渲染的结果很难保证正确性。比如：如何保证线程A绑定了VBO或者Texture之后，线程B提交DrawCall时一定是它需要的呢。综上所述，我们认为这些行为应该都在一个线程里面执行的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;模型和动画&lt;/h2&gt;
&lt;h4 id=&quot;newmeshmesh&quot;&gt;New出来的Mesh好像都是可读写的，在我填充完数据以后，有什么办法能把这个Mesh改为只读么？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;通过&lt;code class=&quot;highlighter-rouge&quot;&gt;public void UploadMeshData(bool markNoLogerReadable);&lt;/code&gt;来设置。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;meshrendercanvasuimeshrendersortingorderimagerendersortingorder-&quot;&gt;请问我一个MeshRender的显示层级能不能夹在一个Canvas下的两个UI节点下？我通过设置MeshRender.sortingOrder数值在两个Image的Render的sortingOrder数值之间 ，是否能做到呢？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Image的sortingorder设置通常是无效的，因为UGUI会对DrawCall进行合并，调整其渲染顺序。因此，需要将Mesh前后的UI元素拆分到不同的Canvas中，从而直接设置Canvas的sortingorder。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;物理&lt;/h2&gt;
&lt;h4 id=&quot;physicsgameobjectboxcolliderprofilephysicsprocessingprofilerphysicsunity536f1&quot;&gt;在游戏里没有使用物理（Physics)相关功能时，怎么把物理相关的性能消耗降到最低？我们游戏里完全没用到物理相关的功能，只是因为需要做点击碰撞检测，所以GameObject上需要加上BoxCollider组件，但是Profile时会时不时看到Physics.Processing的消耗有点高，也不算非常高，但是理论上如果完全没用物理相关功能的话，总感觉这部分消耗是可以完全干掉的，对于Profiler中Physics模块中给的几个统计不太清楚是怎么计算的，目前使用的Unity版本是5.3.6f1版本。&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;就我们目前的分析来看，在Unity5.4版本之前，物理模块是会每帧都运行的。而在Unity5.4版本之后，如果没有使用任何物理相关的功能时（Rigidbody、CharacterController、Rogdoll、Cloth模拟等等），物理模块会被关闭。所以，就你的问题而言，物理模块的开销只能降低，而不能完全消除。&lt;/li&gt;
  &lt;li&gt;对于物理模块的开销，我们建议从宏观上进行了解，当你的项目完全没有使用物理模块时，那就需要从它的调用次数入手了。&lt;/li&gt;
  &lt;li&gt;Physics.Processing调用次数高：可以看到，很多时候，该函数的CPU耗时其实并不是物理开销过高，而是调用次数过多。这主要是因为Unity 5.x默认设置的Fixed Timestep为0.02，Maximum Allowed TimeStep为0.333。也就是说，物理模块每20ms更新一次，所以如果某一帧很卡（200ms），那么物理模块会被调用10次，这样耗时就直接上去了。而0.333表示如果该帧CPU开销超过333ms了，那么就不会再调用物理模块，所以上图中调用次数中最大是17次。&lt;/li&gt;
  &lt;li&gt;所以，如果想进一步降低物理模块的开销，在完全没有使用物理的情况下，可以将Fixed Timestep设置为0.05或0.1均可，降低它被调用的频率。同时，尽可能优化其他模块耗时，让每帧的总体耗时尽可能降低。&lt;/li&gt;
  &lt;li&gt;另外，需要注意的是，修改Fixed Timestep也会影响FixedUpdate的调用，在修改之前一定要检测项目中是否有使用FixedUpdate。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-3&quot;&gt;性能综合&lt;/h2&gt;
&lt;h4 id=&quot;monobehaviourprefabloadprefab&quot;&gt;MonoBehaviour中包含了被加载出来的Prefab上的组件（通过Load接口加载出来的），而这部分组件只能在Prefab被销毁的时候才会释放。&lt;/h4&gt;

&lt;h4 id=&quot;opengl-es-20ios--metal&quot;&gt;工程里还是选择只使用 OpenGL ES 2.0吗？iOS 是否该加上 Metal？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;目前都是用的Auto，主要有两个原因：
    &lt;ul&gt;
      &lt;li&gt;Metal测试下来CPU Overhead会比GLES低很多&lt;/li&gt;
      &lt;li&gt;GLES3能够有tex2Dlod支持 兼容性上来说只有实在老的机器和模拟器会fallback到GLES2，可能效果上会略差一些不过我们测试下来都可以接受。&lt;/li&gt;
      &lt;li&gt;选ES3.0还有一个原因，就是发现AssetBundle打出来的资源会比选Auto小很多。&lt;/li&gt;
      &lt;li&gt;PS:如果游戏面对的是高端机玩家可以放弃ES2&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;uiassetbundle&quot;&gt;切换UI场景使用AssetBundle加载慢，怎么优化界面进入速度，是应该预加载吗？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;界面加载慢主要的原因有，图集纹理的加载以及大量UI元素的实例化操作。&lt;/li&gt;
  &lt;li&gt;针对图集的加载，可以尝试合理的规划图集，尽量控制界面所引用的图集数量（即使用到了某个图集中的一个Sprite，也会加载整个图集）；&lt;/li&gt;
  &lt;li&gt;可以尝试对公共图集进行预加载，通常公共图集较大，且被使用的概率很大。&lt;/li&gt;
  &lt;li&gt;针对大量UI元素的实例化，这项开销大通常只发生在背包等复杂的界面中，而对于这类复杂界面可以考虑进行分步实例化，即首先实例化如外框、容器等部分的UI元素，然后分帧实例化背包中的UI元素，从而提高界面打开的速度以及流畅性。&lt;/li&gt;
  &lt;li&gt;PS： ==分帧是关键。在FPS60的情况下，只要100ms内响应即可。一帧是16.7，也就是说5~6帧做完就可以了。==&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-4&quot;&gt;渲染&lt;/h2&gt;
&lt;h4 id=&quot;unityshaderios&quot;&gt;Unity官方半透明Shader代码在iOS上运行出现问题&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;PS:遇到了看https://blog.uwa4d.com/archives/TechSharing_70.html&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 02 Dec 2017 22:53:34 +0800</pubDate>
        <link>https://caihua.tech/2017/12/02/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E5%8D%81%E4%B8%83%E5%91%A8/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/12/02/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E5%8D%81%E4%B8%83%E5%91%A8/</guid>
        
        <category>UWA</category>
        
        
      </item>
    
      <item>
        <title>Gamma校正与线性空间</title>
        <description>&lt;h4 id=&quot;section&quot;&gt;前言&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;近期看了&lt;a href=&quot;https://blog.uwa4d.com/archives/1882.html&quot;&gt;一篇文章&lt;/a&gt;，主要讲了如何处理lightmap在Android平台下下偏暗的问题。引发了对gamma校正的好奇。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;gamma&quot;&gt;Gamma校正的由来和计算方式&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;所谓Gamma校正指的是在传统的拍摄相机中会对照片中的亮度进行修正，计算公式为&lt;code class=&quot;highlighter-rouge&quot;&gt;Lout = pow(Lin, 0.45)  &lt;/code&gt;，说白了就是如果某个像素的亮度为0.5，那么保存后的照片的亮度就是0.5的0.45次方，即0.732。从下图可以看到绿色的线就是经过校正后的亮度曲线。在这个坐标系中，x轴为原始亮度，y轴是校正后的数值。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://static1.squarespace.com/static/525ed7ade4b0924d2f499223/t/575f41b427d4bdc48f225b5d/1465860589637/A+graph+of+pow%28x%2C+gamma%29?format=750w&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果以原始亮度0.5作为一个分界线，很明显的看出来0.5之前的亮度在校正后占据了70%（0.732)以上的数据空间。这也是为何会有gamma校正的根本原因，即：肉眼对较暗区域的变化更为敏感，而0.5为灰度的界限，原始亮度小于0.5的部分可以认为是较暗的区域。因此将0.5之前的亮度经过校正，使得其结果的范围变大到0-0.732，这就可以进一步的放大黑暗区域的范围，从而使得照片更加真实。&lt;/li&gt;
  &lt;li&gt;但是从这个曲线我们看到，除了0和1以外的像素的亮度整体的变大了，因此就出现了下图的中左边图中的现象，即经过0.45的gamma校正后图片变亮。但是为何我们最后在电视或者电脑屏幕上看到的图像基本和肉眼看到的真实亮度一样呢， 是因为显示器的硬件也会做一次gamma校正，而这个指数是2.2，即&lt;code class=&quot;highlighter-rouge&quot;&gt;pow(0.732，2.2） ≈ 0.5035&lt;/code&gt; ，和0.5有数值上的差异但是基本接近。这只是个巧合。&lt;/li&gt;
  &lt;li&gt;同理，如果是原始像素的图片不经过gamma校正而直接输出到显示器，其结果就是下图中右边图的结果，也就是亮度整体变暗。这个和上图中蓝色曲线的结果也相同。计算方法也是幂计算。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://static1.squarespace.com/static/525ed7ade4b0924d2f499223/t/575f4222e321408871d71230/1465860711911/Images+representing+various+gamma+values?format=1000w&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;unity&quot;&gt;导入unity中的图片&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;基本上所有的绘图软件在输出的结果上都是做过gamma校正的，否则在电脑屏幕上看到的就是偏暗。&lt;/li&gt;
  &lt;li&gt;因此在导入到unity后，在作用到shader时也是gamma校正后的图片。&lt;/li&gt;
  &lt;li&gt;当然我们也可以在绘图软件中就输出不经过gamma校正的图，这个后面说。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;unity-1&quot;&gt;unity中的颜色空间&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;unity的颜色空间就是gamma或者liner space&lt;/li&gt;
  &lt;li&gt;gamma选项下默认unity在shader中直接用gamma校正后的图片进行光照计算，然后输出到现实设备时硬件会做一次gamma校正，最终输出结果。&lt;/li&gt;
  &lt;li&gt;线性空间选项中，unity shader会对输入的图片进行一次gamma校正（2.2），得到真正的亮度值后进行光照计算。最后在进入颜色缓存区之前做一次gamma校正（0.45），然后图像进入显示设备，再次进行gamma校正（2.2）。&lt;/li&gt;
  &lt;li&gt;两者在最终结果的比对可以参考下图&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://static1.squarespace.com/static/525ed7ade4b0924d2f499223/t/575f42e327d4bdc48f2261e4/1465860851928/An+image+comparing+gamma+and+linear+pipelines?format=1000w&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;可以看出来线性空间下产生的最终渲染效果比较接近于真实。&lt;/li&gt;
  &lt;li&gt;我们以一个亮度为1的点为例进行两种模式的计算，对比下结果，假设这个点的法线与点到光源的向量的夹角为60°。根据Lambert公式，此时该点的亮度（用亮度代替像素值）为Clight * Cdiffuse * max(0, dot(n,I))，为了简化计算我们认为Clight也就是光照颜色也是1， n和I都是1。
    &lt;ul&gt;
      &lt;li&gt;gamma下原始亮度是1的点，Cdeffuse为1，60°的点积是0.5，计算出来的颜色是0.5，输出到屏幕经过gamma校正（2.2）后值为0.218。&lt;/li&gt;
      &lt;li&gt;线性空间下线移除gamma校正，亮度1的移除后结果也是1，60°的光照结果也是0.5，输出到颜色缓冲区线做一次校正（0.45），到屏幕做一次校正（2.2），期结果应该是0.5035。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;可以看出来两者在最后的结果上，线性空间的结果比较接近真实的60°情况下的亮度，这个真实值就是0.5。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-1&quot;&gt;线性空间工作流&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;现在unity中移动平台已经支持线性空间，只是需要OpenGL ES3。那么如果使用线性空间就需要一套类似PBR的流程。&lt;/li&gt;
  &lt;li&gt;首先就是纹理图是移除了gamma校正的。&lt;/li&gt;
  &lt;li&gt;在烘焙光照贴图的时候也要移除gamma校正。&lt;/li&gt;
  &lt;li&gt;后期处理的时候倒是不用额外做什么，因为unity已经对颜色值做了处理。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-2&quot;&gt;引用&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.kinematicsoup.com/news/2016/6/15/gamma-and-linear-space-what-they-are-how-they-differ&quot;&gt;GAMMA AND LINEAR SPACE - WHAT THEY ARE AND HOW THEY DIFFER&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;ps&quot;&gt;PS&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;开头提到的lightmap偏暗的问题，在2017.2.0p1中移动平台lightmap处理LDR时已经加入了是否是gamma的判定，然后根据结果会对LDR的亮度进行不同的补偿。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 30 Nov 2017 00:54:00 +0800</pubDate>
        <link>https://caihua.tech/2017/11/30/Gamma%E6%A0%A1%E6%AD%A3%E4%B8%8E%E7%BA%BF%E6%80%A7%E7%A9%BA%E9%97%B4/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/11/30/Gamma%E6%A0%A1%E6%AD%A3%E4%B8%8E%E7%BA%BF%E6%80%A7%E7%A9%BA%E9%97%B4/</guid>
        
        <category>Unity3D</category>
        
        
      </item>
    
      <item>
        <title>Unity Android二次开发经(血)验(泪)谈(史)</title>
        <description>&lt;h4 id=&quot;httpwwwcnblogscomxtqqkssp6387271html&quot;&gt;主要参考的是&lt;a href=&quot;http://www.cnblogs.com/xtqqkss/p/6387271.html&quot;&gt;这篇文章&lt;/a&gt;，不过在这个期间遇到了各种的问题，在这里写出来，希望看到的人能够少走弯路。&lt;/h4&gt;

&lt;h2 id=&quot;section&quot;&gt;准备工作&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;安装Android Studio（以下用AS代替），然后通过它下载Android SDK和tools。&lt;/li&gt;
  &lt;li&gt;AS目前已经是3.0版本，在3之前不支持java8，也就是说没有lambda和一些新的特性。&lt;/li&gt;
  &lt;li&gt;从AS上可以下载到的build-tool是27，但是最新的tools是unity不支持，会在输出工程的时候报错，目前我使用的是26。&lt;/li&gt;
  &lt;li&gt;PS:实际上在这几天的尝试过程中使用27在unity端会有一个&lt;code class=&quot;highlighter-rouge&quot;&gt;can not get xx list&lt;/code&gt;的错误，通过网上查询说是build tools版本的问题。而AS端似乎也有问题，不过没有记清楚。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;as&quot;&gt;AS中做的事情&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;按照文中的说法做即可。&lt;/li&gt;
  &lt;li&gt;其实作者本人也提到了几个点：
    &lt;ul&gt;
      &lt;li&gt;在建立module后要删除原来的app内存。&lt;/li&gt;
      &lt;li&gt;module名字和unity工程名字相同。&lt;/li&gt;
      &lt;li&gt;这是一个很坑的地方，在最开始的时候，我不断的遇到一个提示错误：library和project使用了同样的package name，而且unity的文档也说了不能同名。但是实际上是完全可以同名的。而且不管是直接用module还是把APP改成module，这两种方式都需要包名相同。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;build-aar&quot;&gt;build AAR&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;其实在AS中只要把工程设置成了module，那么选择build apk出来的也是AAR。&lt;/li&gt;
  &lt;li&gt;AAR文件放到&lt;code class=&quot;highlighter-rouge&quot;&gt;Assets\Plugins\Android\libs&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;或者通过gradle直接生成，这个方式是目前用这最方便的。看下图，双击即可build。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://imglf5.nosdn.127.net/img/Nld0N0tacnNuUGtyd2tYaDIzbUF2MEYyMUkyRlJuZlExM3VTUUJCUkpVeWdBc3JxQ3JkcDJ3PT0.jpg?imageView&amp;amp;thumbnail=500x0&amp;amp;quality=96&amp;amp;stripmeta=0&amp;amp;type=jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;图中的classes.jar就是我们自己的代码，libs文件夹下的是我们拷贝unity的，要删除掉。
&lt;img src=&quot;http://imglf4.nosdn.127.net/img/Nld0N0tacnNuUGx4UzhpR2QzUzFkejc3S3V3eGVEL3hUVWRtczVhU3NGMnFieGJkcjFJdXhBPT0.png?imageView&amp;amp;thumbnail=500x0&amp;amp;quality=96&amp;amp;stripmeta=0&amp;amp;type=jpg&quot; alt=&quot;image&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;unitybuild-apk&quot;&gt;unity中build apk&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;这块分开说下，因为我在整个尝试的过程中尝试了直接使用module方法（以下用方法1替代），这个方法不需要用到AS中的manifest。还有就是将app改造成module（以下用方法2替代），这个需要提供manifest。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;manifest&quot;&gt;方法1因为不需要提供manifest，所以省了很多事。&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;首先按照文中的方法先在AS中改造下manifest文件。&lt;/li&gt;
  &lt;li&gt;拷贝到Plugins/Android文件夹下。&lt;/li&gt;
  &lt;li&gt;在unity的PlayerSetting中进行设置。保证包名一致，保证minimum api level和AS中设置的一样。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在AS中我设置了&lt;code class=&quot;highlighter-rouge&quot;&gt;compileSdkVersion&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;targetSdkVersion&lt;/code&gt;为25，开始按照文中和其他人的说法，在unity中target api level也设置的是25，==但是导出project时遇到android:configChanges错误：==&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;unity  CommandInvokationFailure: Gradle build failed. ‘configChanges’ with value…&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;真正的解决这个问题应该是在unity中Player Setting中将target API level设置为auto，这个要比minimum高才行。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-1&quot;&gt;方法2会遇到的问题：&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;因为开始没有把AndroidManifest.xml放到Plugin下，导致每次unity编译的时候都生成一个新的build-id，与AS中的不一致。这个问题其实只要把AS中的manifest文件放到unityPlugin中，就保证了不会每次编译都ID变的问题。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;==合并manifest==：AS的Gradle插件默认会启用Manifest Merger Tool，若Library项目中也定义了与主项目相同的属性（例如默认生成的android:icon和android:theme），则此时会合并失败。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;解决方法有以下2种：1有效，2没试：&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;方法1：在Manifest.xml的application标签下添加tools:replace=”android:icon, android:theme”（多个属性用,隔开，并且记住在manifest根标签上加入xmlns:tools=”http://schemas.android.com/tools”，否则会找不到namespace哦）&lt;/li&gt;
      &lt;li&gt;PS：其实是这样写&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;category tools:replace=&quot; android:name&quot; android:name=&quot;com.google.intent.category.CARDBOARD&quot; /&amp;gt;&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;方法2：在build.gradle根标签上加上useOldManifestMerger true （懒人方法）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;各种错误的处理&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://kotlintc.com/articles/3938&quot;&gt;Failed to resolve:com.android.support:appcompat-v7:27+:报错处理&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;这个问题本质在于AS或者说本地的工具版本低，从下图中可以找到本地的版本。可以看到时26，所以需要在build.gradle中设置&lt;code class=&quot;highlighter-rouge&quot;&gt;compile 'com.android.support:appcompat-v7:26.+'&lt;/code&gt;，将27改为26即可。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://imglf3.nosdn.127.net/img/Nld0N0tacnNuUG5EUnpPWTVFTzMrZzJGdm5VMHhqWmUveENURXZnajJPUTRPcWpvY010eldBPT0.png?imageView&amp;amp;thumbnail=500x0&amp;amp;quality=96&amp;amp;stripmeta=0&amp;amp;type=jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;在project structure中可以设置java语言的版本，1.7的时候是不支持lambda的。需要注意。如果仍旧抽风般的提示lambda的问题就重启AS.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;AS2.3使用java8，本来3.0直接用的，2.3需要做如下处理。设置成功后也解决了&lt;code class=&quot;highlighter-rouge&quot;&gt;unity Can't read classes.jar&lt;/code&gt;这个问题，&lt;code class=&quot;highlighter-rouge&quot;&gt;是因为项目使用的Java（JDK）版本比较高，而ProGuard, version 4.4支持的版本（最高到1.6），所以产生该问题。&lt;/code&gt;，看了AS是一样的问题。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;android {
  ...
  defaultConfig {
    ...
    jackOptions {
      enabled true
    }
  }
  compileOptions {
    sourceCompatibility JavaVersion.VERSION_1_8
    targetCompatibility JavaVersion.VERSION_1_8
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;下面这个错误印象中是改AS中工程的target版本，或者删除了对应的代码。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Error:(4) Error retrieving parent for item: No resource found that matches the given name ‘android:TextAppearance.Material.Widget.Button.Inverse’.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;AS3版本好像不能支持gradle4.1，找到dependencies改成如下。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dependencies {
		classpath 'com.android.tools.build:gradle:3.0.0'
	}
	
...	

apply plugin: 'com.android.library'

....

defaultConfig {
		targetSdkVersion 27
		//applicationId 'xxxx'
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;这个错误的情况是用unity生成并导出Android的代码，在2017.2p1的情况下输出的代码中gradle是4.1的。&lt;/li&gt;
  &lt;li&gt;如果是用AS自己生成APP或者module就没这样的问题。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;adbexe-&quot;&gt;adb.exe 已停止工作&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;这个问题最终发现是360手机助手占用了5037端口造成的&lt;/li&gt;
  &lt;li&gt;排查过程记录一下：
    &lt;ul&gt;
      &lt;li&gt;在\platform-tools目录下调用adb devices命令&lt;/li&gt;
      &lt;li&gt;提示这个错误：&lt;code class=&quot;highlighter-rouge&quot;&gt;adb server version (31) doesn't match this client (39); killing...
error: could not install *smartsocket* listener: cannot bind to 127.0.0.1:5037: 通常每个套接字地址(协议/网络地址/端口)只允许使用一次。 (1
0048)&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CMD:netstat -ano | findstr &quot;5037&quot;&lt;/code&gt; //查看占用这个端口的APP，发现是进程15128&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CMD:tasklist | findstr &quot;14152&quot;&lt;/code&gt;    //查看这个进程对应的应用&lt;/li&gt;
      &lt;li&gt;下图中的14152进程是adb.exe，此时adb就允许正常了。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://imglf3.nosdn.127.net/img/Nld0N0tacnNuUG16ZHdGdmd1MEpFMkxkdWJUTEdTTURSc1NYYnhuSkUzZkY3MURnYnhRZ0JRPT0.png?imageView&amp;amp;thumbnail=500x0&amp;amp;quality=96&amp;amp;stripmeta=0&amp;amp;type=jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;后记&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;其实在整个的使用过程中还遇到了非常多的问题，都是遇到一个搜索一个。所以也不可能完全的记录下来。&lt;/li&gt;
  &lt;li&gt;另外遗留了一个问题就是目前还不能调用Android中的类方法。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 20 Nov 2017 00:47:54 +0800</pubDate>
        <link>https://caihua.tech/2017/11/20/Unity-Android%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E7%BB%8F(%E8%A1%80)%E9%AA%8C(%E6%B3%AA)%E8%B0%88(%E5%8F%B2)/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/11/20/Unity-Android%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E7%BB%8F(%E8%A1%80)%E9%AA%8C(%E6%B3%AA)%E8%B0%88(%E5%8F%B2)/</guid>
        
        <category>Unity3D</category>
        
        
      </item>
    
      <item>
        <title>PHP的OOP</title>
        <description>&lt;ul&gt;
  &lt;li&gt;在类中可以使用public（公有），protected（受保护）或 private（私有）来修饰属性和方法。如果不修饰默认是public。&lt;/li&gt;
  &lt;li&gt;类中用var定义变量，&lt;code class=&quot;highlighter-rouge&quot;&gt;var $name&lt;/code&gt;，使用方式&lt;code class=&quot;highlighter-rouge&quot;&gt;$this-&amp;gt;name&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;构造函数&lt;code class=&quot;highlighter-rouge&quot;&gt;function __construct()&lt;/code&gt;，析构函数&lt;code class=&quot;highlighter-rouge&quot;&gt;function __destruct()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;继承&lt;code class=&quot;highlighter-rouge&quot;&gt;class Child_Site extends Site&lt;/code&gt;，使用extends关键字&lt;/li&gt;
  &lt;li&gt;实例化类&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Login
{
    var $m_user;
    var $m_pw;

    function __construct($user, $pw)
    {
        $this-&amp;gt;m_user = $user;
        $this-&amp;gt;m_pw = $pw;
    }

    function Login()
    {
        echo $this-&amp;gt;m_user .'-'. $this-&amp;gt;m_user;
    }
}

$user = $_POST['user'];
$pw = $_POST['pw'];

$login = new Login($user, $pw);
$login-&amp;gt;Login();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;可以使用interface&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;?php

// 声明一个'iTemplate'接口
interface iTemplate
{
    public function setVariable($name, $var);
    public function getHtml($template);
}


// 实现接口
class Template implements iTemplate
{
    private $vars = array();
  
    public function setVariable($name, $var)
    {
        $this-&amp;gt;vars[$name] = $var;
    }
  
    public function getHtml($template)
    {
        foreach($this-&amp;gt;vars as $name =&amp;gt; $value) {
            $template = str_replace('{' . $name . '}', $value, $template);
        }
 
        return $template;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;常量&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;?php
class MyClass
{
    const constant = '常量值';

    function showConstant() {
        echo  self::constant . PHP_EOL;
    }
}

echo MyClass::constant . PHP_EOL;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;静态属性不能通过一个类已实例化的对象来访问（但静态方法可以）。&lt;/li&gt;
  &lt;li&gt;静态属性不可以由对象通过 -&amp;gt; 操作符来访问。调用方法是&lt;code class=&quot;highlighter-rouge&quot;&gt;::&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;抽象类与C#一样&lt;/li&gt;
  &lt;li&gt;Final 关键字，作用与C#的sealed一样。&lt;/li&gt;
  &lt;li&gt;子类中调用父类的方法&lt;code class=&quot;highlighter-rouge&quot;&gt;parent::Login();&lt;/code&gt;，与C#的&lt;code class=&quot;highlighter-rouge&quot;&gt;base.Login&lt;/code&gt;结构上一样。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 19 Nov 2017 22:00:09 +0800</pubDate>
        <link>https://caihua.tech/2017/11/19/PHP%E7%9A%84OOP/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/11/19/PHP%E7%9A%84OOP/</guid>
        
        <category>PHP</category>
        
        
      </item>
    
      <item>
        <title>每天一点UWA：第十六周</title>
        <description>&lt;h2 id=&quot;texture&quot;&gt;Texture&lt;/h2&gt;

&lt;h4 id=&quot;etcargb32&quot;&gt;如何处理ETC压缩完图片质量模糊和ARGB32内存占用太大这种关系？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;使用ETC压缩的图片尽量减少过渡，这是美术制作时需要注意的，很多情况下并不需要明显的过渡，只是需要半透明而已；&lt;/li&gt;
  &lt;li&gt;当然，有部分过渡色是必须的，这时候就要把相关小图整合到一张RGBA32的图片上；&lt;/li&gt;
  &lt;li&gt;在资源管理上入手。一般情况下，我们是允许部分资源使用RGBA32，但是要注意，及时卸载掉不使用的资源，以保证内存峰值在可控范围内。&lt;/li&gt;
  &lt;li&gt;果ETC压&amp;gt; 缩效果不好的，会使用RGBA32并降一个尺寸规格来压缩，这样虽然图片会模糊点，但是过渡还是平滑的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;astcandroidmalirgba32astc&quot;&gt;ASTC格式并不是所有机型都支持，在Android端只有配有高端Mali芯片的机器才支持，对于不支持的，引擎会将其解压成RGBA32进行处理，所以图片中的内存值过大，很可能是项目在不支持ASTC格式的设备上所看到的结果。&lt;/h4&gt;

&lt;h2 id=&quot;section&quot;&gt;工具&lt;/h2&gt;

&lt;h4 id=&quot;putgeometryjobfence&quot;&gt;PutGeometryJobFence开销较高&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;就目前我们所优化过的项目而言，推测PutGeometryJobFence是Unity项目的主线程在等子线程的一些网格计算操作完成，其在不同的模块中均有出现（UGUI模块、渲染模块、Mesh.Skin操作、Animator动画模块等等），出现的地方不同，其本身含义也并不相同，不能一概而论。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;transformsetposition&quot;&gt;Transform.set_position的开销很大&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Deep Profiler本身对于耗时的统计影响很大，通常在Deep Profiler下调用次数越多的函数，其耗时的统计就会越明显地偏高，因此，我们首先建议关闭Deep Profiler，同时用Profiler.BeginSample/EndSample将修改Position的代码包进来，再查看其耗时，相对会更加准确。&lt;/li&gt;
  &lt;li&gt;CanvasRenderer.OnTransformChanged过多，移动UI元素相比于移动其他的元素确实会有额外的开销。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;unity-profilercanvasrendersubbatchui&quot;&gt;Unity Profiler中的Canvas.RenderSubBatch是否属于UI上渲染的开销？和重建有关系吗？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;是UI模块（UGUI）的渲染开销，但是跟UI的重建并无太大关系，主要还是跟UI界面的渲染Draw Call相关。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;clear&quot;&gt;Clear的耗时过大&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2FTechSharing_65%2F7.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Clear操作一般是用来清除Camera的各种Render Buffer，当图像后处理使用的越多，则同一帧中开辟更多的Buffer的概率也越大，从而造成Clear的开销也较高。&lt;/li&gt;
  &lt;li&gt;项目中Clear耗时较高，且高耗时较为频繁，则建议先关闭图像后处理操作，来查看该情况是否有所好转。然后再逐步开启各个图像后处理操作，逐步定位造成Clear较高的耗时根源&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;模型&amp;amp;动画&lt;/h2&gt;
&lt;h4 id=&quot;uwa&quot;&gt;如何降低动画文件的浮点数精度？之前UWA给过思路，但具体怎么个执行方法？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;动画文件后处理可以做两件事，1）精度压缩，2）scale曲线剔除。比起用工具修改原始fbx文件，这样比较灵活。
实际测试，在开启Optimal压缩的情况下，加上这个后处理，能再节省40%左右。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 19 Nov 2017 01:04:30 +0800</pubDate>
        <link>https://caihua.tech/2017/11/19/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E5%8D%81%E5%85%AD%E5%91%A8/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/11/19/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E5%8D%81%E5%85%AD%E5%91%A8/</guid>
        
        <category>UWA</category>
        
        
      </item>
    
  </channel>
</rss>
