<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>蔡华的博客</title>
    <description>Be publicly useful and privately happy.</description>
    <link>https://caihua.tech/</link>
    <atom:link href="https://caihua.tech/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sun, 10 Sep 2017 01:10:09 +0800</pubDate>
    <lastBuildDate>Sun, 10 Sep 2017 01:10:09 +0800</lastBuildDate>
    <generator>Jekyll v3.2.1</generator>
    
      <item>
        <title>每天一点UWA：UI优化小结</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;说明&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;经过一个半月的学习，对UI的优化有了一些心得，同时也希望把零散的知识点总结到一起，因此有了这个专题。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;那些需要关注的性能指标函数&lt;/h2&gt;
&lt;h4 id=&quot;ugui&quot;&gt;UGUI参考的函数&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;1、Canvas.SendWillRenderCanvases()
该API为UI元素自身发生变化（比如被Enable或者被缩放，移动并不算）时所产生的调用。发生在canvas被渲染之前。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;2、Canvas.BuildBatch
该API为UI元素合并的Mesh需要改变时所产生的调用。通常之前所提到的Canvas.SendWillRenderCanvases()的调用都会引起Canvas.BuildBatch的调用。另外，Canvas中的UI元素发生移动也会引起Canvas.BuildBatch的调用。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;ngui&quot;&gt;NGUI参考的函数&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;UICamera.Update()
该函数通常在点击时出现开销。因此，当该函数的CPU开销较高时，通常都是因为调用了其他的较为耗时的函数引起。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;UIRect.Update()
该函数通常在需要更新锚点位置时出现开销。因此，当该函数的CPU开销持续较高时，通常是因为当前场景中有较多的UI元素绑定了OnUpdate模式的锚点。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;UIPanel.LateUpdate()
该函数为NGUI最主要的CPU开销，包含了对所有UI界面包括其下UI元素的状态更新、网格重建、DrawCall合并等操作。大量的UI变动或者不合理的UIPanel布局都有可能导致该函数出现较高的峰值。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;UIRect.Start()
该函数主要涉及到UI元素的初始化操作，通常在UI界面被实例化时出现并产生一定的CPU开销。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ui&quot;&gt;一些需要知道的UI原理&lt;/h2&gt;

&lt;h4 id=&quot;mesh&quot;&gt;mesh合并&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;一个Canvas下的所有UI元素都是合在一个Mesh中的。&lt;/li&gt;
  &lt;li&gt;而在Batch前，UGUI会根据这些UI元素的材质（通常就是Atlas）以及渲染顺序进行重排，在不改变渲染结果的前提下，尽可能将相同材质的UI元素合并在同一个SubMesh中。所以同一Canvas下不同的材质的UI可能会合并为多个SubMesh。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;ui-1&quot;&gt;UI重建&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;关于UI重建的说明。UI其实是一些3D的quad，这一下就能够理解为什么存在UI的减少少drawcall了，这个和模型的减dc完全一个原理。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;在UGUI中，网格的更新或重建（为了尽可能合并UI部分的DrawCall）是以Canvas为单位的，且只在其中的UI元素发生变动（位置、颜色等）时才会进行。因此，将动态UI元素与静态UI元素分离后，可以将动态UI元素的变化所引起的网格更新或重建所涉及到的范围变小，从而降低一定的开销。而静态UI元素所在的Canvas则不会出现网格更新和重建的开销。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在这再次对更新和重建进行一些详细的说明：&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;更新指的是UI元素本身的某些属性发生变化，从而需要重新生成，或者更新顶点属性。比如颜色变了，在UGUI中颜色的变化是通过修改顶点色实现的，所以就需要更新UI元素对应的每个顶点的顶点色属性（可以认为就是修改下某个数组里的数值）。位置移动一般是不会造成顶点属性的变化的。所以总的来说，“网格更新”更新的是顶点属性。&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;blockquote&gt;
      &lt;p&gt;UI元素和别的网格不同点在于，UI的网格是需要进行合并的，并且在UGUI中是以Canvas为单位的，在提交GPU之前，同一Canvas下的所有UI元素都会被合入一个Mesh中（但包含多个SubMesh）。所以位置的移动，顶点属性的变化，都会导致这个Mesh要重新合并，也就是网格重建。这也是为什么说要“动静分离”的原因，完全静态的Canvas是不需要重建的，但只要里面有一个UI元素在动，就会引起Canvas的重建。&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;blockquote&gt;
      &lt;p&gt;在UGUI里更改了Image的Color属性，其原理是修改顶点色，因此是会引起网格的Rebuild的（即Canvas.BuildBatch操作，同时也会有Canvas.SendWillRenderCanvases的开销）。通过修改顶点色来实现UI元素变色的好处在于，修改顶点色可以保证其材质不变，因此不会产生额外的Draw Call。&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;blockquote&gt;
      &lt;p&gt;Unity自带的UI Shader处理颜色时，改 _Color属性不会触发顶点重建吗？&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;blockquote&gt;
      &lt;p&gt;在UI的默认Shader中存在一个Tint Color的变量，正常情况下，该值为常数(1,1,1)，且并不会被修改。如果是用脚本访问Image的Material，并修改其上的Tint Color属性时，对UI元素产生的网格信息并没有影响，因此就不会引起网格的Rebuild。但这样做因为修改了材质，所以会增加一个Draw Call。&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;blockquote&gt;
      &lt;p&gt;综上所述，移动不一定会更新，但是会重建。而颜色变化或者大小变化带来的都是重建。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;优化建议：&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;动静分离，动的频率不同也分离，减少Mask组件的使用，使用Mask不仅会增加GPU端渲染的压力，同时也会造成CPU端DrawCall的明显上升。可尝试用RectMask2D来进行替换。&lt;/li&gt;
  &lt;li&gt;减少OnEnable和OnDisable，通过移动位置、改变摄像机culling mask。&lt;strong&gt;后者可能会一定程度地提高内存的开销（UIDrawCall中存储的Mesh）&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;修改material改颜色和直接改color属性在性能消耗要权衡。一个加drawcall一个会重建，要根据测试结果来。&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sun, 10 Sep 2017 01:02:01 +0800</pubDate>
        <link>https://caihua.tech/2017/09/10/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-UI%E4%BC%98%E5%8C%96%E5%B0%8F%E7%BB%93/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/09/10/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-UI%E4%BC%98%E5%8C%96%E5%B0%8F%E7%BB%93/</guid>
        
        <category>UWA</category>
        
        
      </item>
    
      <item>
        <title>每天一点UWA：第七周</title>
        <description>&lt;h2 id=&quot;ui&quot;&gt;UI&lt;/h2&gt;
&lt;h4 id=&quot;npot-tolarger-potuipixel-perfect&quot;&gt;NPOT采用 ToLarger 的模式拉成POT，如果是UI界面（开启Pixel Perfect）的话，可能显示时会有较大视觉损失。&lt;/h4&gt;

&lt;h4 id=&quot;unity-5xugui&quot;&gt;在Unity 5.x版本下，我们在用UGUI的过程中发现它把图集都打进了包里，这样就不能自动更新了，请问图集怎么做自动更新呢？&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;在Unity 5.x中UGUI使用的Atlas确实是不可见的，因此无法直接将其独立打包。&lt;/li&gt;
  &lt;li&gt;建议，可以把Packing Tag相同的源纹理文件，打到同一个AssetBundle中（设置一样的AssetBundle Name），从而避免Atlas的冗余。同时这样打包可以让依赖它的Canvas的打包更加自由，即不需要把依赖它的Canvas都打在一个AssetBundle中，在更新时直接更新Atlas所在的AssetBundle即可。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;scrollrectcanvassendwillrendercanvases&quot;&gt;ScrollRect在滚动的时候，会产生Canvas.SendwillRenderCanvases，有办法消除吗？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;ScrollRect在滚动时，会产生OnTransformChanged的开销，这是UI元素在移动时触发的，但通常这不会触发Canvas.SendWillRenderCanvases。&lt;/li&gt;
  &lt;li&gt;如果观察到Canvas.SendWillRenderCanvases耗时较高，可以检查下ScrollRect所在的Canvas是否开启了Pixel Perfect的选项，该选项的开启会导致UI元素在发生位移时，其长宽会被进行微调（为了对其像素），而ScrollRect中通常有较多的UI元素，从而产生较高的Canvas.SendWillRenderCanvases开销。因此可以尝试关闭Pixel Perfect看效果是否可以接受，或者尝试在滚动过程中暂时关闭Pixel Perfect等方式来消除其开销。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;ngui&quot;&gt;对NGUI字体错乱有什么好的解决方案吗？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;有这么几种可能：
    &lt;ul&gt;
      &lt;li&gt;一次展开文字太多了。这种情况在部分高通机型和Unity早期版本上都经常出现，现在也偶尔有，究其原理是FontTexture的扩容操作做得不够快或者收到了硬件驱动的限制。&lt;/li&gt;
      &lt;li&gt;一般来说有两种方法可以解决：（1）减少面板中的字体内容；（2）一开始就用超大量的字体去扩容，将动态字体的FontTexture扩大到足够大；文字渲染与开发团队编写的多线程渲染发生了冲突。这种情况也常有发生，特别是通过GL.IssuePluginEvent方式来开启多线程渲染的项目，就会容易出现问题。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;就我们的优化经验来看，第一种情况发生的可能性比较大。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;工具&lt;/h2&gt;
&lt;h4 id=&quot;draw-callsetpass-callsetpass-calluwadraw-call&quot;&gt;Draw Call和Setpass Call，这两个指标主要是看哪一个？关于这点众说纷纭，很多地方都是说看SetPass Call，但是在UWA的性能测试中，还是把Draw Call当成唯一指标。&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;在 Unity 5.x 中，SetPass Call与 Draw Call相比，SetPass Call的指标与性能相关性更大（比如Static Batching的开启不影响Draw Call数，而SetPass Call通常会明显下降）。但 SetPass Call在某些情况下也同样存在问题，比如往一个场景中添加任意个相邻且材质相同的大网格物体（使Dynamic Batching失效）时，SetPass Call并不会变化。因此在UWA中，我们所使用的是类似Profiler 中 Total Batches 这一项指标，通常该数值与 Frame Debugger 中的数值基本一致，因此可以通过该工具来查看每个Batch的内容，从而更有针对性地进行优化。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;脚本&lt;/h2&gt;
&lt;h4 id=&quot;editor-getcomponent--tgameobject-gc-alloc&quot;&gt;Editor 下，当调用GetComponent() 且 T组件并不在当前的GameObject 上时，确实会出现GC Alloc。&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;首先在发布后是不会出现的。&lt;/li&gt;
  &lt;li&gt;这是因为在Editor下，Unity的MissingComponentException实现所致，在出现以上情况时，Unity 并不是直接返回一个 NULL，而是返回一个代理 Object用来储存一些相关信息，在后续被访问时可以给出更详细的报错信息。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;eventsystemupdate&quot;&gt;EventSystem.Update()占用过高怎么优化？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;EventSystem.Update 的开销分为两个部分：
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;来自被触发的响应事件，这部分的开销实际上并不属于事件系统本身，比如：某次点击触发了一个开销很高的逻辑函数，尤其是涉及到资源的加载和实例化。对于这类开销，我们建议通过Profiler.Begin/EndSample或者UWA提供的UWA API，对这些逻辑函数进行进一步的分析。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;事件检测的开销，在默认情况下所有的UI元素都是事件检测的目标，因此当界面上UI元素数量很多，且长时间接触屏幕时，会有较高的持续开销。对于这类开销，我们建议通过以下几种方式来优化：&lt;/p&gt;
        &lt;ul&gt;
          &lt;li&gt;合理划分子Canvas，只有需要检测事件的界面才需要挂上GraphicRaycaster组件。&lt;/li&gt;
          &lt;li&gt;在Unity5.2之后的版本中，尽可能将不需要参与事件检测的UI元素的 Raycast Target 属性的勾选去掉。而对于Unity 4.x的版本，则可以尝试对UI部分的源码来进行修改以达到类似的效果。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;模型&amp;amp;动画&lt;/h2&gt;
&lt;h4 id=&quot;animator-controlleranimator-controller&quot;&gt;动态替换Animator Controller后删除旧的Animator Controller，但是其中的动画片段资源没有被删除。&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;销毁Animator Controller并不会释放其内所引用的AnimationClip资源的，所以内存没有明显下降是正常的。建议按照以下方式做个试验：&lt;/li&gt;
  &lt;li&gt;销毁Animator Controller 后，通过Unity Profiler立刻真机Take Sample，查看Animation Clip的Ref count是否为0；&lt;/li&gt;
  &lt;li&gt;如果不是，则需要进一步查看这些资源的索引出处；如果为0，则可以通过UnloadUnusedAssets或UnloadAsset来将其从内存中去除。&lt;/li&gt;
  &lt;li&gt;PS:在unity中很多对象只是个包装器，或者只是包含了其它资源的引用，因此消耗这些包装器并不会真正的销毁资源对象。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-3&quot;&gt;渲染&lt;/h2&gt;
&lt;h4 id=&quot;shaderwarmupallshaderscreategpuprogramshaderassetbundleshadervariantcollectionshader&quot;&gt;我使用Shader.WarmupAllShaders操作，在后续加载资源还是有CreateGPUProgram出现。(Shader都在一个AssetBundle文件中，都是常驻内存的，不会删掉)是必须使用ShaderVariantCollection来加载Shader吗？&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;WarmupAllShaders仅能对当前内存中的Shader进行warm up。后续如果又有Shader加载进来，则仍然会出现CreateGPUProgram操作。&lt;/li&gt;
  &lt;li&gt;所以如果出现问题中的现象应该还是有shader打包到别的AssetBundle中了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;materialsetpassfast&quot;&gt;Material.SetPassFast占用很高，这是在第一次实例化一个特效，但是第二次实例化就不会出现高值了，请问能怎么优化吗？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;该过程是在处理Shader，Unity 5.3以后在第一次显示时才会将Shader进行Warmup，所以就会造成一次峰值卡顿。&lt;/li&gt;
  &lt;li&gt;上面那个问题就很好的解决了这个问题，加载完shader后可以主动调用一次Shader.WarmupAllShaders函数。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;unity-3dshader&quot;&gt;在Unity 3D中，shader是何时编译的，在何时加载入显存中的（本条来自知乎）？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Editor中：修改shader并保存时立即编译。&lt;/li&gt;
  &lt;li&gt;Runtime下，无论哪个平台，都是在进入场景时加载shader object内容到内存，但是首次实际调用渲染时才编译，编译完成之后会cache下来。&lt;/li&gt;
  &lt;li&gt;有两种优化方法：
    &lt;ul&gt;
      &lt;li&gt;
        &lt;ol&gt;
          &lt;li&gt;调用Shader.WarmupAllShaders()，自动编译该场景中用到的所有shader。该方法在Unity5中已经废弃。&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;ol&gt;
          &lt;li&gt;在项目设置的GraphicsSettings中，可以导出ShaderVariantCollection，并在Preloaded Shader中导入，这样的话就可以在载入场景时一并编译需要预加载的shader，这样的优化在移动平台上用得比较多。&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//docs.unity3d.com/Manual/OptimizingShaderLoadTime.html&quot;&gt;具体见&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sun, 10 Sep 2017 00:55:48 +0800</pubDate>
        <link>https://caihua.tech/2017/09/10/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E4%B8%83%E5%91%A8/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/09/10/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E4%B8%83%E5%91%A8/</guid>
        
        <category>UWA</category>
        
        
      </item>
    
      <item>
        <title>从零开始开发一款AR应用</title>
        <description>&lt;h2 id=&quot;vuforia&quot;&gt;Vuforia&lt;/h2&gt;

&lt;h3 id=&quot;vuforia-1&quot;&gt;什么是vuforia&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;我没有自己看过它的概念，但是在使用的过程中它的作用实现图片、模型的识别，识别后就可以显示我们预设好的内容了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section&quot;&gt;怎么使用&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;进入&lt;a href=&quot;https://developer.vuforia.com/&quot;&gt;Vuforia&lt;/a&gt;，右上角注册。&lt;/li&gt;
  &lt;li&gt;点击Develop进入下图&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://imglf.nosdn.127.net/img/Nld0N0tacnNuUG5VNXRRdFoySzlrcHh6WnF5VExXYmU3dStWRlRPak9URkhDR1RnVjNzTmN3PT0.png?imageView&amp;amp;thumbnail=500x0&amp;amp;quality=96&amp;amp;stripmeta=0&amp;amp;type=jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;License Manager：管理你的授权，其实和其它一些SDK一样就是管理一下APP key（就是一串字符串）。在使用vuforia的SDK的时候需要用到。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Target Manager：target就是你扫描的图片或者模型或者其它什么的东西，当你扫描完成后如果匹配上了，就会在手机上显示相关的内容。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;license&quot;&gt;生成License&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;点击add按钮→选择类型（我选的是Development，因为只是用来学习）→输入APP name→点击Confirm&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;完成上述内容后你会得到下图的内容
&lt;img src=&quot;http://imglf1.nosdn.127.net/img/Nld0N0tacnNuUG5VNXRRdFoySzlraDRYN3lNcWlBbW0zTkowTnp6YVBuaGI0a0NPUmtJYmpRPT0.png?imageView&amp;amp;thumbnail=500x0&amp;amp;quality=96&amp;amp;stripmeta=0&amp;amp;type=jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;点击ddd这个license，会进入下图。这个license key在程序开发中需要用到。
&lt;img src=&quot;http://imglf2.nosdn.127.net/img/Nld0N0tacnNuUG5VNXRRdFoySzlra2I4dDJiZmpTWG9DSDQxdFk1b05BLy9GZS9ldVBSUGVnPT0.png?imageView&amp;amp;thumbnail=500x0&amp;amp;quality=96&amp;amp;stripmeta=0&amp;amp;type=jpg&quot; alt=&quot;image&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;target&quot;&gt;生成Target&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;选择Target Manager tab&lt;/li&gt;
  &lt;li&gt;点击add database。其实这里用database是很准确的，因为生成的target就像一个数据库，而我们摄像头扫描到的内容就是数据，通过查询如果在DB中找到了相同的数据就认为是匹配到了。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;选择类型（我用的是Device），输入名字，点击Create。结果如下：
&lt;img src=&quot;http://imglf1.nosdn.127.net/img/Nld0N0tacnNuUG5VNXRRdFoySzlrcVJJdDRQMERyam9NaXI0Ujd0TFUrZy9FWml1Y2xjeTNRPT0.png?imageView&amp;amp;thumbnail=500x0&amp;amp;quality=96&amp;amp;stripmeta=0&amp;amp;type=jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;点击target（ddd）进入
&lt;img src=&quot;http://imglf.nosdn.127.net/img/Nld0N0tacnNuUG5VNXRRdFoySzlrcWtSdVlGMXFzY1pUd3E1dTl5bzRDYm9CWXhpTUlMN0Z3PT0.png?imageView&amp;amp;thumbnail=500x0&amp;amp;quality=96&amp;amp;stripmeta=0&amp;amp;type=jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;点击add target。这个里面有多种target类型。我们选择最简单的single image。这个也是市面上很多AR应用使用的，也就是手机扫描一个图片，然后显示一个对应的模型。在这个页面中，file是选择你要上传的图片。width设置和场景中虚拟内容大小一致即可。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://imglf2.nosdn.127.net/img/Nld0N0tacnNuUG5VNXRRdFoySzlraXhkS2c3eGFqaWh4RUNTZURzYWg3R0lrREhnbjdJaWVnPT0.png?imageView&amp;amp;thumbnail=500x0&amp;amp;quality=96&amp;amp;stripmeta=0&amp;amp;type=jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;输入名字然后点击add，下图是我之前设置好的一些target。
&lt;img src=&quot;http://imglf0.nosdn.127.net/img/Nld0N0tacnNuUG5VNXRRdFoySzlrdnJueVZWd0Z3MlJaNVdpY0FjS2ZHSHp4cmdsR29NbkZnPT0.png?imageView&amp;amp;thumbnail=500x0&amp;amp;quality=96&amp;amp;stripmeta=0&amp;amp;type=jpg&quot; alt=&quot;image&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;-这里如果点击一个target，会进入下图。注意两个红色框，点击下面那个【Show Features】按钮后图片上会出现黄色区域，这个有点像做了个卷积识别色块的边缘。黄色部分越多说明在摄像头识别时越容易。而Augmentable指数对于了这个数值，也是越高越好。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://imglf2.nosdn.127.net/img/Nld0N0tacnNuUG5VNXRRdFoySzlra1FkWEV5T0lHUjRmTjViOVc1TDlFVWVFeDJvOUNoWUF3PT0.png?imageView&amp;amp;thumbnail=500x0&amp;amp;quality=96&amp;amp;stripmeta=0&amp;amp;type=jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;add target页面有个download database按钮，可以选择要下载什么数据。注意对于target的理解完全可以用数据库的概念套入。你下载了什么数据，在应用中才能对下载数据进行使用和比对。点击download后出现
&lt;img src=&quot;http://imglf2.nosdn.127.net/img/Nld0N0tacnNuUG5VNXRRdFoySzlrdVUvSjRUWnVxbDkrYjdlYUwvSmNobTlobjc0VnpqanlBPT0.png?imageView&amp;amp;thumbnail=500x0&amp;amp;quality=96&amp;amp;stripmeta=0&amp;amp;type=jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;选unity editor，然后点击download按钮。会得到一个unitypackage文件，然后导入到工程中。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;unity&quot;&gt;Unity部分的开发&lt;/h2&gt;

&lt;h4 id=&quot;vuforia-sdk&quot;&gt;导入vuforia sdk&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;可以在vuforia官网下载unity对应的sdk，也可以通过asset store下载Vuforia AR Starter Kit来直接使用，我两个都试过在设置上是一样的。后者有很多自带的demo很不错。&lt;/li&gt;
  &lt;li&gt;导入刚才获得的target package。&lt;/li&gt;
  &lt;li&gt;从asset store上随便下载个免费的模型。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-1&quot;&gt;场景设置&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;创建新场景&lt;/li&gt;
  &lt;li&gt;找到ARCamera和ImageTarget的prefab拖入场景。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;arcamera&quot;&gt;ARCamera设置&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://imglf0.nosdn.127.net/img/Nld0N0tacnNuUG5VNXRRdFoySzlrcktNS08wRXdURko4YWZYTDByT1ZQWXFSOWtOT2I0Z0pRPT0.png?imageView&amp;amp;thumbnail=500x0&amp;amp;quality=96&amp;amp;stripmeta=0&amp;amp;type=jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;点击ARCamera，再点击图中按钮进行设置。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://imglf1.nosdn.127.net/img/Nld0N0tacnNuUG5VNXRRdFoySzlrb3BUNkIxc0JZQXhiMCtrR2sxMUoxRWdjUHZrbTFHY0R3PT0.png?imageView&amp;amp;thumbnail=500x0&amp;amp;quality=96&amp;amp;stripmeta=0&amp;amp;type=jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;上图中第一个框就是之前申请的APP key&lt;/li&gt;
  &lt;li&gt;第二个框是它们导入的target，我在这个demo中导入的target的名字就是【target_images】,注意这两个复选框一定要都选。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;imagetarget-&quot;&gt;ImageTarget 设置&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://imglf1.nosdn.127.net/img/Nld0N0tacnNuUG5VNXRRdFoySzlraFhSQVBGbWwzU0xJa0pkYTBXUXAvRU05MnY2MDkzVlZBPT0.png?imageView&amp;amp;thumbnail=500x0&amp;amp;quality=96&amp;amp;stripmeta=0&amp;amp;type=jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;红框部分Type需要选择图中的&lt;/li&gt;
  &lt;li&gt;db选择我们导入的target_images。如果是导入了Vuforia AR Starter Kit会有几个自带的target。&lt;/li&gt;
  &lt;li&gt;image target选择你要用的图片。在一个场景中可以有多个ImageTarget对象，不同的对象选择不同的图片即可。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://imglf.nosdn.127.net/img/Nld0N0tacnNuUG5VNXRRdFoySzlrdkhac0hzOG11MDlKeVYyZ2JEZ3Z5SmR3NE9jSjMyQXNnPT0.png?imageView&amp;amp;thumbnail=500x0&amp;amp;quality=96&amp;amp;stripmeta=0&amp;amp;type=jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;上图中的马就是要显示的模型，注意要作为ImageTarget的子对象。马下面的那个白色就是ImageTarget。&lt;/li&gt;
  &lt;li&gt;对于要显示模型的位置和角度，只要记住手机摄像头面向的方向是白色方块的方向，只要要怎么显示模型就有了参考。我图中的设置是因为我要用摄像头扫描显示器上的图片，所以马是这样放置的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-2&quot;&gt;测试&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;如果你用的笔记本电脑带摄像头的，可以直接运行测试了。没有的，找个webcam就行了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-3&quot;&gt;有用的事件代码&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;DefaultTrackableEventHandler类的OnTrackingFound函数是match到了图片后调用的函数，在这个里面可以做一些逻辑功能。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;apk&quot;&gt;打包apk&lt;/h2&gt;

&lt;h4 id=&quot;keystore&quot;&gt;生成keystore&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;build里面选择Android&lt;/li&gt;
  &lt;li&gt;在player setting里面的publishing setting中可以生成keystore，方法看最后的附录。&lt;/li&gt;
  &lt;li&gt;至于jdk和SDK都可以在网上下载到。NDK比较尴尬，unity在Android上的IL2CPP需要r10e，这个版本已经有点难下到了。我最后没用这个。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-4&quot;&gt;结束语&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;到此为止一个最简单的AR应用就做完了，整个过程浪费时间在注册和下载Android SDK。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-5&quot;&gt;附录&lt;/h2&gt;
&lt;h4 id=&quot;keystore-1&quot;&gt;keystore生成&lt;/h4&gt;
&lt;p&gt;The keystore is a signature file that is used to sign your apk. When you create development builds Unity will not sign the apk.&lt;/p&gt;

&lt;p&gt;You only need one Keystore file for your projects. The file is your signature. To create one do this:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;In the publishing settings check the “Create New Keystore” box.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Click browse and choose a location where you want to store the file. It should be somewhere central since it’s not really related to your project.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Set a protection password for the file and confirm it.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Select “Create a new key” from the “Key Alias” dropdown.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;-PS:此处注意，选择了create a new key后最上面会自动勾选use existing keystore，无视即可。在弹出的窗口里面输入相关内容。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;A window should open which you have to fill with your personal data about your organisation / person. The alias at the top is just a name of the keystore. If you have multiple identities make sure you choose a meaningful name. You need to set a keystore password. Note this is not the same as the protection password above. As far as i know they can be the same, but for security you should use two different. If you haven’t write the passwords onto a sheet of paper ;)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Click “Create Key” to generate your keystore file.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;To use a keystore for signing you have to:&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Check the “Use Existing Keystore” box.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Click browse and select your keystore file.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;enter your protection key.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;select your desired identity from the alias dropdown.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;enter the alias password in the field below&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Make sure you have set your Android Market Licensing RSA Public Key at the bottom of the publishing settings. The public key has to be acquired from your Google market account.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Now create your APK file and it will be signed with your identity.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Note: You can create multiple Keys / Identities in one Keystore file. The first protection password will protect the file itself. When you select an identity from the file in the alias dropdown you have to type in the password for the identity.&lt;/p&gt;

</description>
        <pubDate>Sat, 09 Sep 2017 22:57:20 +0800</pubDate>
        <link>https://caihua.tech/2017/09/09/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%BC%80%E5%8F%91%E4%B8%80%E6%AC%BEAR%E5%BA%94%E7%94%A8/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/09/09/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%BC%80%E5%8F%91%E4%B8%80%E6%AC%BEAR%E5%BA%94%E7%94%A8/</guid>
        
        <category>杂</category>
        
        
      </item>
    
      <item>
        <title>每天一点UWA：第六周</title>
        <description>&lt;h2 id=&quot;assetbundle&quot;&gt;AssetBundle&lt;/h2&gt;
&lt;h4 id=&quot;section&quot;&gt;这是一个很长的问题：&lt;/h4&gt;
&lt;h4 id=&quot;assetbundle-aabbb&quot;&gt;字体作为多个资源的依赖包，会在游戏中被加载多次。我们现在有个问题，AssetBundle A资源依赖于这个字体，加载A的时候加载了一份字体，然后B资源也依赖这字体，而后加载B的时候我们没有去重复加载字体，这时候发现B资源上出现了字体丢失的现象。&lt;/h4&gt;

&lt;h4 id=&quot;unityb&quot;&gt;请问加载资源的时候，Unity会自动去识别内存里是否有它的资源依赖包吗？如果有的话，为什么B加载的时候找不到已经存在内存中的字体？这里需要手动去做些什么处理吗？&lt;/h4&gt;

&lt;h4 id=&quot;bundlemassetbundleunloadfalseassetbundleunloadfalse&quot;&gt;同时我发现依赖包资源如果进行了bundle.m_AssetBundle.Unload(false)以后，其他依赖于这个包的资源就引用不到了。我们流程上对于每个读进来的AssetBundle，都会加载完后马上进行Unload(false)，请问如果是依赖包的话，是不是不能对其进行这步操作？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;这个问题其实是典型的一个AssetBundle使用的问题，其中牵扯的细节在unity的文档中都有。&lt;/li&gt;
  &lt;li&gt;总结来说就是对于公共资源的字体，在A和B加载前要提前加载好，这样unity根据依赖关系会自动的找到字体asset。&lt;/li&gt;
  &lt;li&gt;但是如果加载A完成后直接卸载了字体的AssetBundle，那么加载B时肯定会出错。此时字体asset虽然还在（因为用的是Unload(false)），但是unity已经无法依靠依赖关系来作用在B上了。同时如果测试再次加载字体AssetBundle，则原有的字体asset出现内存泄漏问题。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;shaderbuildin&quot;&gt;自己下载了shader包，如何替换buildin资源？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;需要完全的替换，shader自己不会关联，而且很多时候用的是buildin的material，测试用的就是buildin的shader。&lt;/li&gt;
  &lt;li&gt;还有一个情况是prefab中用的shader的GUID和自己导入的不同，可以用通过如下脚本进行替换。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;using UnityEngine;
using System.Collections;
using UnityEditor;
using System.IO;

public class BuildScript {

    [MenuItem(&quot;Build/RefreshMat&quot;, false, 501)]
    static void RefreshMat() {
        var guids = AssetDatabase.FindAssets(&quot;t:Material&quot;);
        foreach (var guid in guids) {
            var path = AssetDatabase.GUIDToAssetPath(guid);
            if (path.ToLower().EndsWith(&quot;mat&quot;)) {
                var mat = AssetDatabase.LoadAssetAtPath&amp;lt;Material&amp;gt;(path);
                if (mat &amp;amp;&amp;amp; mat.shader) {
                    Debugger.Log(&quot;{0}\n{1}\n{2}\n{3}\n&quot;, path, mat.shader.name,
                        mat.shader.GetInstanceID(),
                        Shader.Find(mat.shader.name).GetInstanceID());
                    mat.shader = Shader.Find(mat.shader.name);
                }
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;font&quot;&gt;Font&lt;/h2&gt;
&lt;h4 id=&quot;assetbundleprofiler&quot;&gt;一个字体打包到AssetBundle中，加载后在profiler中看到两份&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;通常TTF文件会包含一个字体的多个字型，如可能包含正常字型、加粗字型、斜体字型等。而在Unity中会将其分为不同的Font资源，且他们之间会相互依赖。所以，如果项目中确实需要加粗字型的话，内存里出现两个Font是正常的，但如果实际上不需要加粗，那么可以尝试寻找一个不包含加粗字型的字体文件来替换该TTF文件。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;profileriphone-appuifontcachefontfortext2siphone52srendertexture&quot;&gt;在用Profiler真机查看iPhone App时，发现第一次打开某些UI时，Font.CacheFontForText占用时间超过2s，这块主要是由什么影响的?若iPhone5在这个接口消耗2s多，是不是问题很大？这个消耗和已经生成的RenderTexture的大小有关吗？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Font.CacheFontForText主要是指生成动态字体Font Texture的开销, 一次性打开UI界面中的文字越多，其开销越大。&lt;/li&gt;
  &lt;li&gt;这个消耗也与已经生成的Font Texture有关系。简单来说，它主要是看目前Font Texture中是否有地方可以容下接下来的文字，如果容不下才会进行一步扩大Font Texture，从而造成了性能开销。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;texture&quot;&gt;Texture&lt;/h2&gt;
&lt;h4 id=&quot;assetbundletexture&quot;&gt;游戏里重复的特效较多，有些只是图案相同但改变了颜色参数，如果都打成独立AssetBundle，则内存里面会有多份Texture。关于这样的打包一般有什么推荐的方法呢？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;只保留一份初始纹理资源，并通过Shader在运行时改变其整体配色，从而达到不同的效果。&lt;/li&gt;
  &lt;li&gt;如果是局部配色不同，那么可以在原始纹理的基础上加一种或几种Mask纹理，用来负责颜色的自适应调配，然后再通过Shader来达到不同的展示效果。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ui&quot;&gt;UI&lt;/h2&gt;
&lt;h4 id=&quot;gameobjectdeactivate&quot;&gt;GameObject.Deactivate消耗大&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;GameObject.Activate/Deactivate本身通常不会产生很高的开销，产生高开销的是其OnEnable/OnDisable操作。&lt;/li&gt;
  &lt;li&gt;如果是自定义脚本，可以考虑优化OnEnable/OnDisable函数中的操作。&lt;/li&gt;
  &lt;li&gt;如果是UI可以考虑通过移出屏幕或者改摄像机的culling layer来实现隐藏。前面有讲过相关的内容。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;canvascanvas&quot;&gt;动静分离或者多Canvas带来性能提升的理论基础是什么呢？如果静态部分不变动，整个Canvas就不刷新了？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;在UGUI中，网格的更新或重建（为了尽可能合并UI部分的DrawCall）是以Canvas为单位的，且只在其中的UI元素发生变动（位置、颜色等）时才会进行。因此，将动态UI元素与静态UI元素分离后，可以将动态UI元素的变化所引起的网格更新或重建所涉及到的范围变小，从而降低一定的开销。而静态UI元素所在的Canvas则不会出现网格更新和重建的开销。&lt;/li&gt;
  &lt;li&gt;PS：位置和颜色变化应该会造成更新，如果出现血条那样的会造成mesh变化从而重建。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;ui-1&quot;&gt;UI优化&lt;/h3&gt;
&lt;h4 id=&quot;ugui&quot;&gt;UGUI参考的函数&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;1、Canvas.SendWillRenderCanvases()
该API为UI元素自身发生变化（比如被Enable或者被缩放，移动并不算）时所产生的调用。发生在canvas被渲染之前。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;2、Canvas.BuildBatch
该API为UI元素合并的Mesh需要改变时所产生的调用。通常之前所提到的Canvas.SendWillRenderCanvases()的调用都会引起Canvas.BuildBatch的调用。另外，Canvas中的UI元素发生移动也会引起Canvas.BuildBatch的调用。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;ngui&quot;&gt;NGUI参考的函数&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;UICamera.Update()
该函数通常在点击时出现开销。因此，当该函数的CPU开销较高时，通常都是因为调用了其他的较为耗时的函数引起。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;UIRect.Update()
该函数通常在需要更新锚点位置时出现开销。因此，当该函数的CPU开销持续较高时，通常是因为当前场景中有较多的UI元素绑定了OnUpdate模式的锚点。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;UIPanel.LateUpdate()
该函数为NGUI最主要的CPU开销，包含了对所有UI界面包括其下UI元素的状态更新、网格重建、DrawCall合并等操作。大量的UI变动或者不合理的UIPanel布局都有可能导致该函数出现较高的峰值。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;UIRect.Start()
该函数主要涉及到UI元素的初始化操作，通常在UI界面被实例化时出现并产生一定的CPU开销。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;优化建议：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;动静分离，动的频率不同也分离，减少Mask组件的使用，使用Mask不仅会增加GPU端渲染的压力，同时也会造成CPU端DrawCall的明显上升。可尝试用RectMask2D来进行替换。&lt;/li&gt;
  &lt;li&gt;减少OnEnable和OnDisable，通过移动位置、改变摄像机culling mask。&lt;strong&gt;后者可能会一定程度地提高内存的开销（UIDrawCall中存储的Mesh）&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;ngui-1&quot;&gt;NGUI的图集在内存里存了多份，求问怎么清理？&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2FTechSharing_31%2F1.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;游戏运行中，UI Mesh出现多份不同内存的情况，是正常的，因为随着UI widget使用的增加或减少，创建的UI Mesh是会随着变化的。&lt;/li&gt;
  &lt;li&gt;同时，如果不同UIPanel中存在相同Atlas的Widgets，则也会出现上图中的情况。因此，建议大家遇到这种情况时，查看单帧中NGUI UI Mesh重名的是否有多份重名资源。如果存在，则说明相同Atlas中的资源被多个不同的UIPanel所使用，这种情况是需要尽可能避免的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;工具&lt;/h2&gt;
&lt;h4 id=&quot;profilerothersystemexecutableanddlls&quot;&gt;Profiler中Other下System.ExecutableAndDlls的内存很大&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;一般来说，在移动游戏中，该选项经常在iOS真机运行时会看到，System.ExecutableAndDlls该项显示的是执行文件和所调用的库（物理、渲染、IO等系统库）的总和。&lt;/li&gt;
  &lt;li&gt;开发团队不用太担心该选项的数值，因为很多应用均在共用这些库，并且它对于真实项目的内存压力非常小，几乎没有影响，而且OS也不会因为该内存而杀掉游戏或应用。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;loadingupdatepreloading&quot;&gt;Loading.UpdatePreloading&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;这是Unity引擎最主要的加载函数。该项一般在切换场景时或主动动态加载资源时较大。 一般来说，加载资源越多、越复杂，则其反映的Loading.UpdatePreloading耗时则越大。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;profilernot-saved&quot;&gt;Profiler中Not Saved是指什么？&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2FTechSharing_31%2F3.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Profiler中的Not Saved指的是项目中通过代码生成的各种资源记录。如上图所示，其Mesh均为NGUI插件通过脚本生成的UI界面Mesh资源。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;脚本&lt;/h2&gt;
&lt;h4 id=&quot;section-3&quot;&gt;判断怪物是否在相机视野范围有没有什么好方法？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;可以在脚本中添加 OnWillRenderObject 或者 OnBecameVisible/OnBecameInvisible 的回调函数，这些函数分别会在对应的Renderer可见或者变为可见/不可见时被调用。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;amonobehaviourb-monobehaviourdestroybgameobjectabnullinspectormissinggcbagcnullgc&quot;&gt;我们测试了下发现，在名为A的MonoBehaviour中，有个数组来存放名为B的 MonoBehaviour对象的引用。当我们其他的逻辑去Destroy了B对象所在的GameObject后，在A对象中的数组里，遍历打印，它们（B的引用）都为Null，在Inspector面板上看是missing。而这时候进行GC，堆内存其实并未释放这些B对象。只有当A对象中的数组被清空后，再调用GC，才可释放这些对象所占内存。这种现象是否正常？为什么值为Null但却还是被引用着，无法通过GC释放呢？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;首先这种现象是正常的。这是Unity中对Null的检测做了特殊的处理所致，在Unity中MonoBehaviour对象除了存在于Managed Heap中（作为“壳”），在Native内存中还会有一个相对应的“实体”，在调用Destroy时，真正被释放的正是这个“实体”。而在判断一个MonoBehaviour对象是否为Null时，Unity会首先检测“实体”是否已经被销毁，如果是则返回为true，但此时Managed Heap中的“壳”实际上依然是被引用的，从而就会出现对象的Null判断为true，但实际上还是被引用着，无法被GC释放的问题。
.&lt;/li&gt;
  &lt;li&gt;相关的细节可见官方blog对Unity中Null判断的解释：
http://blogs.unity3d.com/2014/05/16/custom-operator-should-we-keep-it/&lt;/li&gt;
  &lt;li&gt;PS：本周最佳收获。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-4&quot;&gt;粒子&lt;/h2&gt;
&lt;h4 id=&quot;fbxreadwrite-enablecrasheditor&quot;&gt;真机下关闭粒子使用的FBX的Read/Write Enable属性后crash，Editor模式下没有。&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;将FBX上的Read/Write Enabled关闭后，内存中便不再保存其Mesh的副本（只存在显存中），因此其属性就不可再被访问和修改。&lt;/li&gt;
  &lt;li&gt;粒子系统通常需要动态地修改其粒子的顶点属性。因此，理论上来说，供粒子系统使用的Mesh是需要开启Read/Write Enabled的，而在Editor下Mesh和Texture都是强制开启的，所以在真机上就会出现问题。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-5&quot;&gt;粒子的优化&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;减量。总的来说就是减少粒子的数量，减少粒子的范围，如果离摄像机远可以考虑不显示粒子。最后升级到5.3之后，因为粒子系统有优化。&lt;/li&gt;
  &lt;li&gt;粒子系统拼合。是指引擎会将若干个材质相同且深度相同的粒子系统在渲染前进行合批（Batch），从而通过一个Draw Call来对其粒子系统进行渲染，进而降低粒子系统的渲染开销。至于合并机制之前也写到过。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;spritepacking-tag&quot;&gt;粒子系统所使用的纹理并不是Sprite类型的，因此不需要设置Packing Tag。&lt;/h4&gt;

&lt;h2 id=&quot;section-6&quot;&gt;模型&amp;amp;动画&lt;/h2&gt;
&lt;h4 id=&quot;skinnedmeshrendererbakemeshinstantiate&quot;&gt;SkinnedMeshRenderer.BakeMesh这个函数一般是什么时候调用呢?在Instantiate后调用么？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;SkinnedMeshRenderer.BakeMesh 的作用在于：将一个蒙皮动画的某个时间点上的动作，Bake成一个不带蒙皮的Mesh，从而可以通过自定义的采样间隔，将一段动画转成一组Mesh序列帧。而后在播放动画时只需选择最近的采样点（即一个Mesh）进行赋值即可，从而省去了骨骼更新与蒙皮计算的时间。&lt;/li&gt;
  &lt;li&gt;该方法的优点是用内存换计算时间，在场景中大量出现同一个带动画的模型时，效果会非常明显。该方法的缺点是内存的占用极大地受到模型顶点数、动画总时长及采样间隔的限制。因此，该方法只适用于顶点数较少，且动画总时长较短的模型。同时，Bake的时间较长，因此需要在加载场景时完成。比较经典的适用场景为MOBA游戏中的小兵。&lt;/li&gt;
  &lt;li&gt;PS：关于skinnedmesh转mesh这个问题比较大，可以参考网上的资源。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;mecanim&quot;&gt;为什么尽可能使用Mecanim&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Mecanim动画系统的多线程计算性能较之老版本的单线程计算性能要高；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Mecanim动画系统可以对GameObject开启 “Optimize Game Object” 选项。该选项为Unity引擎在4.3版本中加入的新功能，旨在优化Mecanim动画系统的底层计算开销。开启该选项，Animator.Update和MeshSkinning.Update的CPU占用均存在一定程度的降低；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Mecanim动画系统的Retargeting功能可以让多个不同的角色使用同一套的AnimationClip资源，比如主城中的NPC角色，其大部分共性动画可尝试使用一套Idle、Wave等动画片段，从而进一步降低动画资源的内存开销；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Unity引擎已经不再对老版本动画系统进行维护。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-7&quot;&gt;动画的优化&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;动画模块的开销主要来自于MeshSkinning.Update（蒙皮网格每帧更新）和Animation.Update and Animator.Update（骨骼动画的更新开销）两个函数。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;研发团队在尽可能保证动画效果的同时，对模型的网格进行简化，建议尝试使用Unity Asset Store中的SimpleLOD插件来对骨骼蒙皮网格进行简化；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;关于MeshSkinning.Update， 一般来说该值的大小取决于蒙皮网格（Skinned Mesh）的面片数和骨骼数。所以如果该值过高，我们的建议是减面。同时我们建议开发团队勾选“GameObject.Optimize”，该方法是将fbx生成的GameObject的层级关系移除，使动画系统不用每帧再去更新这些骨骼节点（GameObject）的Transform，因此能一定程度上降低CPU开销，此优化选项默认是关闭的），该方法特别适合于在配置较低的手机上运用骨骼角色多的情况。&lt;/li&gt;
  &lt;li&gt;开启Optimize GameObject默认情况下会将动画网格下的所有骨骼结点隐藏，但是，可以通过“Extra Transform to Expose”查看想通过脚本获取的骨骼结点，这样既可以提升该角色的动画模块性能，又可以达到获取某个关键结点的需求。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Optimize Game Objects对于老版本的Animation无效。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用SkinnedMeshRenderer.BakeMesh&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;控制场景中具有Animator Controller组件的GameObject。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-8&quot;&gt;材质实例数量过多有何影响&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Material的内存占用一般很小，所以大量的Material资源对于内存的压力其实很小的。&lt;/li&gt;
  &lt;li&gt;它本身对于场景的切换时间是有影响的，即资源冗余得越多，切换场景时，UnloadUnusedAssets的开销越大，进而增加了场景的切换时间。&lt;/li&gt;
  &lt;li&gt;会影响DrawCall的拼合。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-9&quot;&gt;物理&lt;/h2&gt;
&lt;h4 id=&quot;profilerstatic-collidermoveexpensive-delay-cost&quot;&gt;Profiler中会碰到Static Collider.Move(Expensive delay cost)，有什么办法可以优化掉呢？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;建议给需要移动的静态Collider加上RigidBody并勾选is Kinematic复选框，从而将其变为动态碰撞体。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;physicssimulate-&quot;&gt;引起 Physics.Simulate 开销较大的几个因素&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Rigidibody。
    &lt;ul&gt;
      &lt;li&gt;该组件可使得游戏对象在物理系统的控制下运动。&lt;/li&gt;
      &lt;li&gt;对于移动设备而言，建议Rigidibody数量控制在50以下。同时需要注意的是，大家常常会用Rigidbody组件配合CapsuleCollider，通过RigidBody.velocity来移动。这些会造成物理计算，特别是网格有很多Mesh Colider的时候，物理计算相当高。&lt;/li&gt;
      &lt;li&gt;因此，建议尽量用Transform.Position代替物理计算。如果大家的地形是凹凸不平又要有重力的表示，也可以用Navmesh去做，它所引起的工作量在于烘焙Navmesh，并且尽可能地贴合地表 ，但是可以完全不用物理计算。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Contacts &amp;amp; Colider
    &lt;ul&gt;
      &lt;li&gt;Contacts数量为碰撞对（Contact Pair）数量。任意两个发生碰撞的碰撞体都会产生一个“碰撞对”。&lt;/li&gt;
      &lt;li&gt;一般来说，Contacts数量越大，则表明碰撞物体的数量越多，即物理系统的CPU开销越大。&lt;/li&gt;
      &lt;li&gt;碰撞体数量（静态碰撞体和动态碰撞体两者）均控制在100以下，当然越低越好。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;PS：动态碰撞体是指带有RigidBody的Collider，而静态碰撞体指不带有RigidBody的Collider。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;ngui-2&quot;&gt;NGUI减少物理计算&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;在NGUI界面打开后，往往会有Physics一下涨高的情况。这是因为NGUI为了实现点击事件的检测，在每个UI上都设有Rigidbody，所以当UI Widgets摆在同一深度并存在相互叠加的情况时，会造成较多不必要的Contacts。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;ontriggerxxxontriggerenter&quot;&gt;定位到OntriggerXXX（如OntriggerEnter）消耗高&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;这种情况一般是在脚本中触发了其他的逻辑调用，例如在主角被碰撞从而受到伤害时，创建一个伤害数字的UI，这些均有些实例化的逻辑计算，当然这些也会算到Physics开销中。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-10&quot;&gt;渲染&lt;/h2&gt;
&lt;h4 id=&quot;shadershader1zwrite&quot;&gt;我用内建的Shader渲染场景，深度图里有内容。而用自己的Shader，取到的深度图什么都没有，都是1，什么原因导致的呢？我已经打开ZWrite了。&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;4.x中是靠depth buffer直接获取或者通过shader replacement来实现。&lt;/li&gt;
  &lt;li&gt;5.x后统一考ShadowCaster来实现。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;shaderparse--shadercreategpuprogram-&quot;&gt;Shader.Parse 和 Shader.CreateGpuProgram 到底是做什么的？他们什么时候执行？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Shader.Parse体现的是Shader的加载和解析， Shader.CreateGpuProgram 是将Shader传入GPU的一次提交，GPU驱动会对其进行编译，以适应于特定的设备或平台。在Unity 5.x版本中，Shader.Parse在Shader资源加载时进行执行，而 Shader.CreateGpuProgram在所在GameObject第一渲染时进行执行。&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Mon, 04 Sep 2017 23:36:59 +0800</pubDate>
        <link>https://caihua.tech/2017/09/04/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E5%85%AD%E5%91%A8/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/09/04/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E5%85%AD%E5%91%A8/</guid>
        
        <category>UWA</category>
        
        
      </item>
    
      <item>
        <title>游戏设计模式读书笔记：组件模式</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;为什么是组件&lt;/h2&gt;
&lt;h4 id=&quot;section-1&quot;&gt;意图&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;允许单一的实体跨越多个领域而不会导致这些领域彼此耦合。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;ecs&quot;&gt;实体-组件-系统(ECS)&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;组件模式在游戏中常见的体现就是&lt;a href=&quot;https://zh.wikipedia.org/wiki/User:Lijinyu25775/%E5%AE%9E%E4%BD%93-%E7%BB%84%E4%BB%B6-%E7%B3%BB%E7%BB%9F(ECS)&quot;&gt;ECS&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-2&quot;&gt;为什么是组件&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;在游戏开发中一个实体会有多个不同的功能，比如音频的播放、动画功能、渲染、物理、输入等等，如果所有的功能都按照类的形式写到一个类文件中会非常的庞大且不易维护。&lt;/li&gt;
  &lt;li&gt;将不同类型的功能切分成不同的组件，既是对结构的优化也是实现了功能的复用。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-3&quot;&gt;为什么不是类的继承&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;因为可能一个实体的在继承多个父类（C++，但是C#这样的语言在语法上就不行）时出现重复继承的问题。比如实体的父类的父类出现重复的问题。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-4&quot;&gt;模式&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;单一实体跨越了多个领域&lt;/strong&gt;。为了保持领域之间相互分离，将每部分代码放入&lt;strong&gt;各自的组件类&lt;/strong&gt;中。实体被简化为&lt;strong&gt;组件的容器。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-5&quot;&gt;何时使用&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;组件通常在定义游戏实体的核心部分中使用。&lt;/li&gt;
  &lt;li&gt;有一个涉及了多个领域的类，而你想保持这些领域互相隔离。&lt;/li&gt;
  &lt;li&gt;一个类正在变大而且越来越难以使用。&lt;/li&gt;
  &lt;li&gt;想要能定义一系列分享不同能力的类，但是使用继承无法让你精确选取要重用的部分。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-6&quot;&gt;一些问题&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;组件之间的通信问题&lt;/li&gt;
  &lt;li&gt;组件的获得需要先获取实体，才能获得组件对象。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-7&quot;&gt;实现&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;建议直接看原书代码。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-8&quot;&gt;进化过程&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;1.先将不同的功能模块分为不同的组件，实体类本身只是调用组件中的方法（作为容器），参数为自身。&lt;/li&gt;
  &lt;li&gt;2.对组件类进行接口化，最后变成实体类中只要使用继承自接口的类即可。对于接口的不同实现就可以实现不同的功能。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-9&quot;&gt;设计决策&lt;/h2&gt;

&lt;h4 id=&quot;section-10&quot;&gt;对象如何获得组件&lt;/h4&gt;
&lt;h5 id=&quot;section-11&quot;&gt;对象创建组件&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;自己创建所以一定能拿到需要的组件&lt;/li&gt;
  &lt;li&gt;组件模式的优势在于自由的将不同的组件赋予一个对象，从而让对象获得不同的能力，或者说变成了某个特定的游戏对象。但是如果用硬编码的方式获得组件，那么这个对象就定型了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-12&quot;&gt;外部提供组件&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;对象更加灵活。&lt;/strong&gt;我们可以提供不同的组件，这样就能改变对象的行为。 通过共用组件，对象变成了组件容器，我们可以为不同目的一遍又一遍重用它。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;对象可以与具体的组件类型解耦。&lt;/strong&gt; 如果我们允许外部代码提供组件，好处是也可以传递派生的组件类型。 这样，对象只知道组件接口而不知道组件的具体类型。这是一个很好的封装结构。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;PS：细细体会unity的组件实现。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-13&quot;&gt;组件之间如何通信&lt;/h4&gt;
&lt;h5 id=&quot;section-14&quot;&gt;通过修改容器对象的状态：&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;这个可以参考unity的实现。在unity中每个GameObject都必须有transform组件，以为位置、角度和缩放信息算是所有对象都必须有的，而且在物理组件、渲染组件中都需要用到。&lt;/li&gt;
  &lt;li&gt;但是这个方案的问题就在于，如果一个GameObject使用了多个组件，而这些组件在修改数据时可能需要一定的顺序才行，比如计算移动的组件需要限制性，在执行物理相关和渲染相关的，因为可能一个对象在一帧中已经离开了摄像机范围而不需要渲染了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-15&quot;&gt;互相引用&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;这个没什么好多解释的，掌握了对象的引用自然可以获得其数据和方法。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;但是这个是一种倒退，因为耦合了。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-16&quot;&gt;消息机制&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;恩恩，尤其是使用订阅发布模式的消息系统。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-17&quot;&gt;参考&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://gpp.tkchu.me/component.html&quot;&gt;原文&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;一个不错的&lt;a href=&quot;https://github.com/EllanJiang/GameFramework&quot;&gt;框架&lt;/a&gt;，我是先学习了这个框架在看这个文章的，醍醐灌顶之感。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 28 Aug 2017 14:11:13 +0800</pubDate>
        <link>https://caihua.tech/2017/08/28/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%BB%84%E4%BB%B6%E6%A8%A1%E5%BC%8F/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/08/28/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%BB%84%E4%BB%B6%E6%A8%A1%E5%BC%8F/</guid>
        
        <category>游戏设计模式读书笔记</category>
        
        
      </item>
    
      <item>
        <title>每天一点UWA：第五周</title>
        <description>&lt;h2 id=&quot;assetbundle&quot;&gt;AssetBundle&lt;/h2&gt;
&lt;h4 id=&quot;shader&quot;&gt;shader加载&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;首先 Shader. WarmupAllShaders 并不影响 Shader 的加载，因为该函数的作用是将所有已加载的 Shader 都做一次快速渲染(渲染单个像素，GPU 在首次使用某一个 Shader 时会有额外开销，Warm 相当于是将这部分开销提前)。&lt;/li&gt;
  &lt;li&gt;可以通过AssetBundle.LoadAll等接口预加载 AssetBundle 中的 Shader。而对于 Always Included Shaders 中的 Shader 则可以通过 Shader. Find 来预加载。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;streamingassetpath--persistantdatapathloadassetbundle&quot;&gt;StreamingAssetPath 和 PersistantDataPath直接load非AssetBundle资源？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;可以但是只能用WWW这样的有限的API.&lt;/li&gt;
  &lt;li&gt;如果load MP3、JPG这样的非内部资源格式效率低，尤其是JPG还要软解码，效率更低。&lt;/li&gt;
  &lt;li&gt;还是推荐AssetBundle。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;unity-5x--fbx--mesh--animationclip--assetbundle-name&quot;&gt;在Unity 5.x 的打包机制下确实无法手动为 FBX 下的 Mesh 或 AnimationClip 单独资源设置 AssetBundle Name。&lt;/h4&gt;

&lt;h4 id=&quot;animatorfbxfbxfbxassetbundle&quot;&gt;如果Animator是直接引用了FBX里的动画文件，而不是复制了FBX的动画文件出来再引用，那么打包的时候不会把FBX打进AssetBundle。&lt;/h4&gt;

&lt;h4 id=&quot;resourcesunloadunusedassetsassetbundleloadassetbundleunloadfalse&quot;&gt;Resources.UnloadUnusedAssets同样可以卸载由AssetBundle.Load加载的资源，只是前提是其对应的AssetBundle已经调用Unload(false)，且并没有被引用。&lt;/h4&gt;

&lt;h3 id=&quot;assetbundle-1&quot;&gt;总结一下AssetBundle的加载和卸载&lt;/h3&gt;
&lt;h4 id=&quot;section&quot;&gt;加载&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;AssetBundle的各种创建函数可以从本地文件(LoadFromXXX)或者内存中将AssetBundle加载到一块内存区域（use from memory or unitywebrequest）或者只是建立一个序列化引用(use loadformfile)。&lt;/li&gt;
  &lt;li&gt;AssetBundle的各种load函数会将真正的asset从AssetBundle中加载出来到内存中。&lt;/li&gt;
  &lt;li&gt;instantiate函数创建GameObject实例&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-1&quot;&gt;卸载&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;AssetBundle的实例函数unload（false）会卸载内存中的AssetBundle（虽然函数的说明中是Unloads all assets in the bundle.），参数是true的话删除AssetBundle和用它创建的asset。&lt;/li&gt;
  &lt;li&gt;上面的函数针对的单个AssetBundle，而UnloadAllAssetBundles这个静态函数就是针对所有当前已经load的AssetBundle了。&lt;/li&gt;
  &lt;li&gt;对于一个具体的asset可以使用Resources.UnloadAsset来卸载，或者使用Resources.UnloadUnusedAssets将多有没有引用的asset卸载。前提就是调用过AssetBundle的Unload（不论参数是false还是true）。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;build&quot;&gt;Build&lt;/h2&gt;
&lt;h4 id=&quot;optimize-mesh-data&quot;&gt;Optimize Mesh Data选项&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;build时我们在player setting里面有这个选项，它只针对Build Player或者Bundle 时才生效的，所以提前做的AssetBundle是无效的。&lt;/li&gt;
  &lt;li&gt;模型导入时也有个Optimize Mesh选项，是调整面片排序的，和build时的是两回事。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ui&quot;&gt;UI&lt;/h2&gt;
&lt;h4 id=&quot;ugui-resourcesunloadunusedassets&quot;&gt;UGUI做的一个界面中有一个背景图片，关闭销毁这个界面后调用 Resources.UnloadUnusedAssets，图片还在内存中&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;在使用 Resources.Load 加载 UI 界面的情况下，即使“关闭销毁这个界面”后，Resources.UnloadUnusedAssets 确实还是无法卸载对应的图集的。因为此时该图集依然被 Resources.Load 加载出来的 Prefab 引用。&lt;/li&gt;
  &lt;li&gt;建议是手动调用 Resources.UnloadAssets 来手动释放图集（可以通过 Sprite.texture 来找到对应的图集），在重新实例化该 UI 界面时，图集也会自动进行 Reload 的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;模型&lt;/h2&gt;
&lt;h4 id=&quot;meshbaker-meshprefabfbxmodelgenerate-lightmap-uvs-&quot;&gt;MeshBaker 烘焙的Mesh可以保存到Prefab中，但是不能像FBX一样，设置Model导入设置中的Generate Lightmap UVs 等信息，请问有没有大招可以处理此情况？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;首先从理论上说，一个 Mesh 只能有一个 LightmapIndex 和 LightmapOffset 属性，这就决定了 Mesh 的合并必须在 Lightmap 的烘焙之前。&lt;/li&gt;
  &lt;li&gt;做Mesh合并时，需要注意到UV2对于一个Mesh而言，其所有三角面的UV区域都必须是互不重叠的，所以不能简单直接地合并。
考虑到合并前每一个Mesh的UV2区域都应该是在[0,1]x[0,1]的区间中，在合并时可以给每一个UV2区域做一个缩小和平移，从而可以把每个区间在互不重叠的情况下，放到同一个[0,1]x[0,1]的区间中。
在UV2也正确拼合后，重新进行Lightmap的烘焙即可得到正确的效果。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;batch&quot;&gt;关于静态batch&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;勾选Static的GameObject下的Mesh都会被合入CombineMesh（无论什么材质），且每个Mesh都作为SubMesh存在。&lt;/li&gt;
  &lt;li&gt;在Unity 5.3之前，对于渲染顺序相邻且材质相同的SubMesh则会动态将其索引数组拼合，从而合成一个Draw Call。&lt;/li&gt;
  &lt;li&gt;而Unity 5.3之后（还是在同材质，渲染顺序相邻的前提下）则不再拼合索引数组，因为在不切换材质时产生多个Draw Call的开销并不大，而这多个Draw Call会被统计为一个Batch。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;staticbatchingutilitycombinecombined-mesh&quot;&gt;如何删除StaticBatchingUtility.Combine会产生Combined Mesh的内存&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;通过某个使用了该Combined Mesh的MeshFilter来获取其引用（MeshFilter.sharedMesh），然后通过Destroy接口来将其卸载。因为Combined Mesh不属于真正的Assets（在Deep Memory中不属于Assets下，而是在Scene Memory下），所以不能用Resources.UnloadAsset来卸载。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-3&quot;&gt;内存&lt;/h2&gt;
&lt;h4 id=&quot;assetbundle-2&quot;&gt;AssetBundle内存占用问题&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;在webStream仍旧存在时（似乎是5.4之前），一个AssetBundle（1mb）解压到websream后如果是2mb，那么这个AssetBundle最终所占的内存就是2mb，因为webstream中已经包含了AssetBundle。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;assetbundle-3&quot;&gt;AssetBundle资源卸载&lt;/h4&gt;
&lt;p&gt;AssetBundle加载好以后立刻通过Instantiate实例化一个对象，然后通过Resources.UnloadAsset和Resources.UnloadUnusedAssets来进行卸载，如果无法卸载，则该资源一定被缓存了。&lt;/p&gt;

</description>
        <pubDate>Sun, 27 Aug 2017 18:27:46 +0800</pubDate>
        <link>https://caihua.tech/2017/08/27/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E4%BA%94%E5%91%A8/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/08/27/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E4%BA%94%E5%91%A8/</guid>
        
        <category>UWA</category>
        
        
      </item>
    
      <item>
        <title>bat学习</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;概念&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;批处理的本质，是一堆DOS和cmd命令按一定顺序排列而形成的集合。&lt;/li&gt;
  &lt;li&gt;熟悉DOS语法，然后按照正确的顺序来进行指令的运行。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-1&quot;&gt;系统教程&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;使用/?查看if的功能，使用与很多指令，&lt;code class=&quot;highlighter-rouge&quot;&gt;%&lt;/code&gt;似乎不行。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if /?
pause

--------------------------------------------

C:\Users\Administrator\Desktop&amp;gt;
执行批处理程序中的条件处理。

IF [NOT] ERRORLEVEL number command
IF [NOT] string1==string2 command
IF [NOT] EXIST filename command

  NOT               指定只有条件为 false 的情况下，Windows 才
                    应该执行该命令。

  ERRORLEVEL number 如果最后运行的程序返回一个等于或大于
                    指定数字的退出代码，指定条件为 true。

  string1==string2  如果指定的文字字符串匹配，指定条件为 true。

  EXIST filename    如果指定的文件名存在，指定条件为 true。

  command           如果符合条件，指定要执行的命令。如果指定的
                    条件为 FALSE，命令后可跟 ELSE 命令，该命令将
                    在 ELSE 关键字之后执行该命令。

ELSE 子句必须出现在同一行上的 IF 之后。例如:

    IF EXIST filename. (
请按任意键继续. . .
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;demo&quot;&gt;从一个demo中学习&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;这个demo的作用是用来更新游戏客户端的。一般来说我们的端游客户端会有一个launcher来启动真正的游戏，它还要负责来更新游戏。同时，它还要更新自己，以前WOW中的做法是有个专门的update.exe来做更新（不过现在是靠battle.net来更新了），我觉得bat文件一样可以做，因此写了这个demo。下面代码中TL代表launcher，TC代码client。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@echo on
cls

:: 当前程序所在目录
set LocalPath=%~dp0
:: TL更新包完全路径名,不带后缀，同时也是解压缩后的文件夹名称
set  TLZipFile=%~dp0TLUpgradeData\TL_%1
:: TL更新包解压路径
set  TLDecompressPath=%~dp0TLUpgradeData\

echo 执行更新，请稍后...

echo ----1.关闭客户端进程----
tasklist /nh|find /i &quot;TL.exe&quot;
if ERRORLEVEL 1 (echo TL客户端进程已经结束) else (taskkill /f /im TL.exe)
tasklist /nh|find /i &quot;TC.exe&quot;
if ERRORLEVEL 1 (echo TC客户端进程已经结束) else (taskkill /f /im TC.exe)

echo ----2.开始解压缩安装包----
if exist %TLZipFile%.zip   %LocalPath%7z x %TLZipFile%.zip -o%TLDecompressPath% -aoa

echo ----3.开始复制文件----
xcopy %TLZipFile%  %LocalPath% /e /f /k /y
:: xcopy switch说明：
:: /E           复制目录和子目录，包括空目录。
:: /F           复制时显示完整的源文件名和目标文件名。
:: /K           复制属性。一般的 Xcopy 会重置只读属性。
:: /Y           取消提示以确认要覆盖

echo ----4.删除临时文件----
del %TLZipFile%.zip
rmdir %TLZipFile% /s /q
:: 删除当文件夹和里面的所有文件，/s 表示包含子文件夹，/q 表示不需要确实提示 
pause

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-2&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;@&lt;/code&gt;&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;它的作用是让执行窗口中不显示它后面这一行的命令本身。行首有了它的话，这一行的命令就不显示了。首行的@echo off中，@的作用就是让脚本在执行时不显示后面的echo off部分。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-3&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;::&lt;/code&gt; -双冒号&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;类似注释符号&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-4&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&amp;gt;&lt;/code&gt;&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&lt;/code&gt;指示将内容写入某个文件&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&amp;gt;&lt;/code&gt;的作用，和&amp;gt;的相同，区别是把结果追加到前一行得出的结果的后面，类似写文件时的append。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;echo&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;echo&lt;/code&gt;的三个用法&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;命令显示与否的开关，有off和on两个选项。设置为off后，后续所有的命令都不会显示命令本身，只显示命令的结果。&lt;/li&gt;
  &lt;li&gt;类似于print，用于输出信息。&lt;/li&gt;
  &lt;li&gt;可以直接编辑文本文件。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;pause-&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;pause &lt;/code&gt;&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;就是字面意思&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;goto&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;goto&lt;/code&gt;&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;goto用于与其它语言是一样的，就是跳转到一个指定的标签&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:&lt;/code&gt;是定义一个标签&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;if&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;if&lt;/code&gt;&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@echo off

if &quot;%1&quot; == &quot;1&quot; goto goto1
if &quot;%1&quot; == &quot;2&quot; goto goto2

:goto1
echo 参数是goto1

:goto2
echo 参数是goto2
pause
exit
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;就是条件判断，只不过跟着不同的命令产生不同的功能&lt;/li&gt;
  &lt;li&gt;if exist判定存在&lt;/li&gt;
  &lt;li&gt;结果判断&lt;/li&gt;
  &lt;li&gt;if not 否定判定&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-5&quot;&gt;变量&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;使用set来进行变量设置，set还有几个switch。当变量的来源是输入内容时用&lt;code class=&quot;highlighter-rouge&quot;&gt;set /p&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;set variable=value&lt;/code&gt;注意这个语句中等号前后没有空格，我发现有空格的话变量赋值有问题。&lt;/li&gt;
  &lt;li&gt;使用变量时用&lt;code class=&quot;highlighter-rouge&quot;&gt;%variable%&lt;/code&gt;的形式，即两个百分号夹住变量名。&lt;/li&gt;
  &lt;li&gt;与传统的编程语言不同，bat中变量不能连接使用，比如下面这样是不行的。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;set a=1
set b=%a%2
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-6&quot;&gt;外部参数&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;%（0-9）来表示参数，其中%0代表自己，demo中只有一个参数是当前最新的版本号，用的是%1。&lt;/li&gt;
  &lt;li&gt;bat中参数有很多用法，具体不描述了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;cmd&quot;&gt;其它的cmd命令&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;demo中还是有tasklist、taskkill、del、rmdir这样的命令，这些就不一一解释了。其实这些全部都是cmd的命令，这样验证了开始时说的，其实bat就是顺序执行一些dos和cmd命令。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-7&quot;&gt;资源&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;这个demo的完整资源在GitHub的&lt;a href=&quot;https://github.com/klkucan/UpgradeByBat&quot;&gt;这个&lt;/a&gt;位置。&lt;/li&gt;
  &lt;li&gt;另外推荐一篇&lt;a href=&quot;http://www.cnblogs.com/s1ihome/archive/2009/01/15/batTutorial.html&quot;&gt;bat学习的文章&lt;/a&gt;，写的很不错。&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sun, 27 Aug 2017 18:22:24 +0800</pubDate>
        <link>https://caihua.tech/2017/08/27/bat%E5%AD%A6%E4%B9%A0/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/08/27/bat%E5%AD%A6%E4%B9%A0/</guid>
        
        <category>杂记</category>
        
        
      </item>
    
      <item>
        <title>每天一点UWA：加载模块深度解析</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;专题&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;因为UWA上会对一些技术进行系列的专题讲解，而且文章并不连续，如果按照每周的形式就会割裂这些内容，因此针对这样的情况统一写成专题形式。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;概述&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;载模块中最为耗时的性能开销可以归结为以下几类：资源加载、资源卸载、Object的实例化和代码的序列化等。&lt;/li&gt;
  &lt;li&gt;资源加载是加载模块中最为耗时的部分，其CPU开销在Unity引擎中主要体现在Loading.UpdatePreloading和Loading.ReadObject两项中。&lt;/li&gt;
  &lt;li&gt;Loading.UpdatePreloading，这一项仅在调用类似LoadLevel（Async）的接口处出现，主要负责卸载当前场景的资源，并且加载下一场景中的相关资源和序列化信息等。下一场景中，自身所拥有的GameObject和资源越多，其加载开销越大。&lt;/li&gt;
  &lt;li&gt;Loading.ReadObject，这一项记录的则是资源加载时的真正资源读取性能开销，基本上引擎的主流资源（纹理资源、网格资源、动画片段等等）读取均是通过该项来进行体现。可以说，这一项很大程度上决定了项目场景的切换效率。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;纹理篇&lt;/h2&gt;
&lt;h3 id=&quot;section-3&quot;&gt;只给出结论&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;同一的格式下（ETC1（Android）和PVRTC（iOS）、且关闭Mipmap功能），图片分辨率越大加载越慢，但是在Android上中（红米NOTE2）高（S6）端机在加载效率上差不多。&lt;/li&gt;
  &lt;li&gt;同一分辨率（1024x1024）上
  -不同格式（对于Android平台，使用ETC1、ETC2、RGBA16和RGBA32四种格式，对于iOS平台，使用PVRTC 4BPP、RGBA16和RGBA32三种格式）
    &lt;ul&gt;
      &lt;li&gt;所占的内容首先是有差异的（三组纹理的内存占用分别为1MB、1MB、4MB 和 8MB（Android平台）/1MB、4MB 和 8MB（iOS平台））。&lt;/li&gt;
      &lt;li&gt;加载效率上，ETC1、ETC2、RGBA16基本一致；PVRTC 4BPP、RGBA16基本一致。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;开启Mipmap功能会导致资源加载更为耗时，且设备性能越差，其加载效率影响越大。&lt;strong&gt;打破了Android上同一分辨率下ETC1、ETC2、RGBA16基本一致的情况，需要慎用。&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;PS：压缩后的文件大小，和解压缩的效率与纹理的内容相关，这是因为图片的压缩本质是用矩阵对图片数据进行变换，最终得到一个较小的数据。解压缩也是一样，数据的内容影响了反向计算的效率。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;uwa&quot;&gt;UWA给出的建议&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;严格控制RGBA32和ARGB32纹理的使用，在保证视觉效果的前提下，尽可能采用“够用就好”的原则，降低纹理资源的分辨率，以及使用硬件支持的纹理格式。&lt;/li&gt;
  &lt;li&gt;在硬件格式（ETC、PVRTC）无法满足视觉效果时，RGBA16格式是一种较为理想的折中选择，既可以增加视觉效果，又可以保持较低的加载耗时。&lt;/li&gt;
  &lt;li&gt;严格检查纹理资源的Mipmap功能，特别注意UI纹理的Mipmap是否开启。在UWA测评过的项目中，有不少项目的UI纹理均开启了Mipmap功能，不仅造成了内存占用上的浪费，同时也增加了不小的加载时间。&lt;/li&gt;
  &lt;li&gt;ETC2对于支持OpenGL ES3.0的Android移动设备来说，是一个很好的处理半透明的纹理格式。但是，如果你的游戏需要在大量OpenGL ES2.0的设备上进行运行，那么我们不建议使用ETC2格式纹理。因为不仅会造成大量的内存占用（ETC2转成RGBA32），同时也增加一定的加载时间。下图为测试2中所用的测试纹理在三星S3和S4设备上加载性能表现。可以看出，在OpenGL ES2.0设备上，ETC2格式纹理的加载要明显高于ETC1格式，且略高于RGBA16格式纹理。因此，建议研发团队在项目中谨慎使用ETC2格式纹理。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-4&quot;&gt;网格篇&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;总结一下：网格的加载效率的影响因素在于网格面数、顶点信息（tangent、color）数和read/write是否开启。&lt;/li&gt;
  &lt;li&gt;结论很简单，面数多、信息多、开启会造成内存的变大和加载的变慢。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-5&quot;&gt;建议&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;在保证视觉效果的前提下，尽可能采用“够用就好”的原则，即降低网格资源的顶点数量和面片数量；&lt;/li&gt;
  &lt;li&gt;研发团队对于顶点属性的使用需谨慎处理。通过以上分析可以看出，顶点属性越多，则内存占用越高，加载时间越长；&lt;/li&gt;
  &lt;li&gt;如果在项目运行过程中对网格资源数据不进行读写操作（比如Morphing动画等），那么建议将Read/Write功能关闭，既可以提升加载效率，又可以大幅度降低内存占用。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;shader&quot;&gt;Shader篇&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Shader资源的效率加载瓶颈并不在其自身大小的加载上，而是在Shader内容的解析上。&lt;/li&gt;
  &lt;li&gt;总结一下：，Mobile-Bumped Diffuse、Mobile-Diffuse、Mobile-VertexLit和Mobile-Particles Additive加载耗时依次减少，对于的normal版本也是一样。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;shader-1&quot;&gt;影响shader解析的因素&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;一般情况下，Shader加载的CPU耗时与其Keyword数量有关，Keyword数量越多，则加载开销也越大。&lt;a href=&quot;https://blog.uwa4d.com/archives/LoadingPerformance_Shader.html&quot;&gt;（具体数据看原文）&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Shader的Keyword数量是会随着场景设置的不同而变化的。在Unity 5.x中，Unity默认会根据场景设置、Shader Pass等来调整Shader的Keyword，比如如果存在Lightmap的使用，则会默认将对应的Keyword打开，而对于没有使用Fog的项目，则会直接将相关Keyword关闭。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-6&quot;&gt;如何提高解析速度&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;就是减少keyword数量。&lt;/li&gt;
  &lt;li&gt;首先可以使用skip variant来减少
&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/UWALab%2FLoadingPerformance%2FShader_SkipVariantsCode.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;其次去掉Fallback选项，因为文中认为目前不支持Mobile/Diffuse和Mobile/Bumped Diffuse的设备已经相当少，没有必要做这层保险了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-7&quot;&gt;避免重复解析&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;因为一个游戏内用到的shader的数量不会太多，如果shader打包到场景或者模型的AssetBundle中，那么在资源加载卸载的过程中会出现同一个shader多次加载解析的问题。因此建议shader单独打包。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;注意：对于Unity4.x版本，Shader的AssetBundle加载后只需LoadAll即可完成所有Shader的加载和解析，但对于Unity5.x版本，除执行LoadAllAssets操作外，还需要进行Shader.WarmupAllShaders操作，因为在Unity5.x版本中，Shader的解析和CreateGPUProgram操作是分离的。&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对于Unity 5.x版本且正在使用Resources.Load来加载资源的研发团队，可以尝试使用ShaderVariantCollection来对Shader进行Preload，同样也可以达到避免相同Shader重复加载的效果。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;注意：对于Unity5.x版本，如果可以通过AssetBundle来加载和解析Shader，则不建议通过ShaderVariantCollection来处理Shader的加载。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-8&quot;&gt;总结&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;综上所述，shader的处理就是减少keyword、对于简单的渲染去掉Fallback、尽量对shader进行单独打包。&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sun, 27 Aug 2017 18:20:55 +0800</pubDate>
        <link>https://caihua.tech/2017/08/27/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9D%97%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/08/27/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9D%97%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/</guid>
        
        <category>UWA</category>
        
        
      </item>
    
      <item>
        <title>每天一点UWA：第四周</title>
        <description>&lt;h2 id=&quot;assetbundle&quot;&gt;AssetBundle&lt;/h2&gt;
&lt;h4 id=&quot;resourcesunloadassetgameobjectcomponenttexturemeshprefabobjectcomponent&quot;&gt;Resources.UnloadAsset仅能释放非GameObject和Component的资源，比如Texture、Mesh等真正的资源。对于由Prefab加载出来的Object或Component，则不能通过该函数来进行释放。&lt;/h4&gt;

&lt;h4 id=&quot;resourceprefab-load&quot;&gt;用的是Resource的加载方式，并且已经预加载好了材质所在的Prefab ，但是为什么在第一次显示材质的时候还要Load这个材质？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;我的理解是prefab只是个资源GUID的合集，并不包含真正的资源。所以要使用真正的资源（mesh\texture等时要加载。）&lt;/li&gt;
  &lt;li&gt;通过 Resources 加载和通过 AssetBundle 加载是有所区别的。Resources.Load 和 Instantiate 操作都不会立刻加载其依赖的材质，因此在loadPrefab = Resources.Load之后，其依赖的材质（包括相关的 Shader 和纹理）实际并没有被加载到内存中，在实例化后也是一样，直到某个 Camera 需要对其进行渲染时（调用了 Material.SetPastFast），才发现该材质还没进内存，此时才开始进行加载。&lt;/li&gt;
  &lt;li&gt;因此，在使用 Resources 加载的情况下，如果希望提前加载该 Material 以及相关的 Shader 和纹理，可以尝试通过调用 Resources.Load 直接加载该材质和纹理，并通过 Shader.Find 来加载 Shader。也可以尝试通过 Player Settings 中的 Preload Shaders（配合 Graphics Settings 下的 Preloaded Shaders） 和 Preloaded Assets 来批量预加载。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;build&quot;&gt;Build&lt;/h2&gt;
&lt;h4 id=&quot;editoronly-tag&quot;&gt;EditorOnly tag&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;prefab打上EditorOnly tag，但是放到了Resources文件夹下一样会打包进入，因为理论上只对场景中的GameObject有效。- 不放到Resources文件夹下，然后在使用EditorOnly tag，打包时就会认为没有场景中的物件引用prefab，就不会打包了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;shader&quot;&gt;内置的shader怎么打包？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;通常有两种方式对内置的Shader进行打包：&lt;/li&gt;
  &lt;li&gt;将其添加到Graphics Settings中的Always Included Shaders 中，此时添加后的内置Shader就不会被打入AssetBundle包中；&lt;/li&gt;
  &lt;li&gt;在http://unity3d.com/cn/get-unity/download/archive下载内置的 Shader，将其导入项目，并替换成非内置的材质球，从而可以直接通过脚本来控制其打包的方式。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;gcmarkdependenciescpuresourcesunloadunusedassets-&quot;&gt;GC.MarkDependencies的CPU消耗有过高，虽然在退出战斗的时候调用了Resources.UnloadUnusedAssets(); 可是卡顿还是很明显&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;GC.MarkDependencies的消耗是由Resources.UnloadUnusedAssets引起的。该函数的主要作用是查找并卸载不再使用的资源。游戏场景越复杂、资源越多，该函数的开销越大，一般在300~2000 ms范围内。&lt;/li&gt;
  &lt;li&gt;对于该函数的优化，我们建议一方面控制场景中不必要的资源量，同时通过UnloadAsset来及时卸载不再使用的资源，以减少Resources.UnloadUnusedAssets的耗时压力。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;assetbundlemd5&quot;&gt;打包时候AssetBundle的md5总变化(被打包的东西没变)&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;对于Unity 4.x版本的AssetBundle文件，其md5值在某些情况下确实会前后不一致（哪怕是完全一样的内容进行打包）。对于该系列版本，仅能建议开发团队建立配置文件来对AssetBundle进行管理。&lt;/li&gt;
  &lt;li&gt;而对于Unity 5.x版本，则可以在打包时开启 AppendHashToAssetBundleName 选项，这样Unity引擎会在每个AssetBundle文件后生成一个唯一的HashID（显示地放在文件名后），开发团队可以通过该ID来判断对应的AssetBundle文件是否发生改变。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;cpu&quot;&gt;CPU&lt;/h2&gt;
&lt;h4 id=&quot;gameobjectinstantiate&quot;&gt;第一次执行GameObject.Instantiate一些资源的时候会卡&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Instantiate的卡顿与三部分开销相关：相关资源加载、脚本组件的序列化和构造函数的执行，并且绝大部分原因均是相关资源加载导致。所以，我们的建议如下：
    &lt;ul&gt;
      &lt;li&gt;通过 Profiler 查看 Instantiate 具体的CPU分配情况；&lt;/li&gt;
      &lt;li&gt;如果是资源加载导致的性能瓶颈，则一方面通过简化资源来缓解CPU耗时压力，另一方面通过 AssetBundle 依赖关系打包将资源预先加载，即将此处 Instantiate 的总体耗时拆分，平摊到之前帧进行执行（比如切换场景处等），从而让 Instantiate 实例化操作的局部耗时更加平滑；&lt;/li&gt;
      &lt;li&gt;如果是脚本组件序列化导致的性能瓶颈，则可尝试减少脚本中的序列化信息；
  -如果是构造函数的执行导致的性能瓶颈，一般只能在策略上进行规避，比如降低 Instantiate 的调用频率等。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ui&quot;&gt;UI&lt;/h2&gt;
&lt;h4 id=&quot;ui-1&quot;&gt;本周的UI有很多不错的技术知识&lt;/h4&gt;

&lt;h4 id=&quot;ngui&quot;&gt;能否对提升NGUI的渲染效率提供一些思路？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;开发团队可以从以下几点入手：
    &lt;ul&gt;
      &lt;li&gt;通常一个Panel会产生1个或多个Draw Call，以一个Panel为单位，Draw Call 的数量通常由当前 Panel 中使用的Atlas、Font的数量所决定。&lt;/li&gt;
      &lt;li&gt;要降低UI渲染时的 Draw Call数量则需要对 Atlas 的制作进行合理的规划，即在保证使用较少的 Atlas 的同时，还需要保证 Atlas之间不会存在交叉遮挡。&lt;/li&gt;
      &lt;li&gt;要注意UI Texture的使用，每个UITexture自身会占用一个Draw Call，同时如果其Depth值穿插在了其他来自相同Atlas的UISprite中，还会导致Draw Call的打断，造成不必要的额外Draw Call。&lt;/li&gt;
      &lt;li&gt;另外还可以借助Panel Tool和Draw Call Tool来对UI部分的Draw Call进行分析，前者可以显示每个UIPanel包含了多少个Draw Call，而后者可以显示每个Draw Call由哪些UIWidget组成。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;rebuild-batch-memory-profiler&quot;&gt;如何查看每次Rebuild Batch影响的顶点数， Memory Profiler是个办法但是不好定位。&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;5.2后开始使用Shared UI Mesh来存储UI Mesh，所以很难查看每次Rebuild的UI顶点数。可以尝试通过Frame Debugger工具对UI界面进行进一步的查看。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;uiuipanellateupdatecpusetactive&quot;&gt;通过移动位置来隐藏UI界面，会使得被隐藏的UIPanel继续执行更新（LateUpdate有持续开销），那么如果打开的界面比较多，CPU的持续开销是否就会超过一次SetActive所带来的开销？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;通过移动的方式“隐藏”的UI界面只适用于几个切换频率最高的界面&lt;/li&gt;
  &lt;li&gt;一般来说在没有UI元素变化的情况下，持续的 Update 开销是不太明显的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;uiuiui-setactivefalse-setactivetrue--gcalloc--batches--gc-alloc-&quot;&gt;游戏中出现UI界面重叠，该怎么处理较好？比如当前有一个全屏显示的UI界面，点其中一个按钮会再起一个全屏界面，并把第一个UI界面盖住。我现在的做法是把被覆盖的界面 SetActive(False)，但发现后续 SetActive(True) 的时候会有 GC.Alloc 产生。这种情况下，希望既降低 Batches 又降低 GC Alloc 的话，有什么推荐的方案吗？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;可以尝试通过添加一个 Layer 如 OutUI， 且在 Camera 的 Culling Mask 中将其取消勾选（即不渲染该 Layer）。从而在 UI 界面切换时，直接通过修改 Canvas 的 Layer 来实现“隐藏”。但需要注意事件的屏蔽，禁用动态的 UI 元素等等。
这种做法的优点在于切换时基本没有开销，也不会产生多余的 Draw Call，但缺点在于“隐藏时”依然还会有一定的持续开销（通常不太大），而其对应的 Mesh 也会始终存在于内存中（通常也不太大）。&lt;/li&gt;
  &lt;li&gt;PS：一个经典的场景，一个非常巧妙的答案。学到了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;uicanvasrecttransform&quot;&gt;在UI界面中，用Canvas还是用RectTransform做根节点更好？哪种方法效率更高？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;简单来说，因为一个Canvas下的所有UI元素都是合在一个Mesh中的，过大的Mesh在更新时开销很大，所以一般建议每个较复杂的UI界面，都自成一个Canvas(可以是子Canvas)，在UI界面很复杂时，甚至要划分更多的子Canvas。&lt;/li&gt;
  &lt;li&gt;同时还要注意动态元素和静态元素的分离，因为动态元素会导致Canvas的mesh的更新。最后，Canvas又不能细分的太多，因为会导致Draw Call的上升。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;PS：总结来说就是不分子Canvas会导致mesh过大，分的太多dc过高，在于平衡。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;filebytes512x512rgba322mb&quot;&gt;使用File类来读取图片的bytes流，512x512的RGBA32格式图片使用了2MB内存&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;首先正常的512x512的RGBA32图片的大小为4byte * 512 * 512 / 1024 / 1024 = 1MB，这个2MB是因为内存和显存各需要一份。file read的时候本身会产出一份，在向GPU发送的时候会备份一份，推测是这样。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;一般来说，比较建议通过AssetBundle来动态加载资源，而非通过bytes流来进行加载。如果你的项目正在使用这种方式来加载纹理，我们建议从策略上考虑将其更改。&lt;/li&gt;
  &lt;li&gt;在我们目前来看，通过bytes流来生成资源，绝大部分原因是想对其进行加密，从而让资源难于破解。但其实这种加密方式用处不大，因为据我们所知，现在有很多工具可以直接通过底层显卡层来直接查看各种纹理、Mesh资源，比如Mali Graphics Debugger、Qualcomn Profiler等。因此，如果是从加密的角度来通过bytes流生成资源，那么我们建议通过AssetBundle这种直接的方式进行加载。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;动画&lt;/h2&gt;
&lt;h4 id=&quot;cullcompletely&quot;&gt;CullCompletely&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;使用 CullCompletely 在开启 RootMotion 时是需要注意的，比如人物有一个巡逻动画是通过 RootMotion 制作的，那么在人物走出屏幕后，其动画就停止了，即不会再走回屏幕中。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;渲染&lt;/h2&gt;

&lt;h4 id=&quot;section-2&quot;&gt;场景中一个点光源，烘焙前暗，后亮是为何？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;简单来说，这就是实时的直接光照和全局光照的差别。
在渲染时前者只能处理光源和单个物件之间的直接光照，而后者在烘焙时是通过光线跟踪或者辐射度等复杂算法，计算出所有物体各个表面之间相互反射的光照信息，这也是烘焙Lightmap需要较久的时间的原因 。可以发现在全局光照下，即使是物体的背面也会因为其它表面的反射而被照亮，这在直接光线下就无法实现这样的效果。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;shader--vf-surface&quot;&gt;相同效果前提下，就性能而言，Shader 是用 V&amp;amp;F 还是Surface好？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;V&amp;amp;F，Surface生成的V&amp;amp;F比较庞杂，分支较多，如果不注意 #pragma surface 参数的选择，容易出现不必要的开销。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;baked-gi&quot;&gt;大面积的面片会导致baked GI时间过久，拆分大面积的面片对渲染性能也会有所提升&lt;/h4&gt;

&lt;h4 id=&quot;handheldplayfullscreenmovie&quot;&gt;Handheld.PlayFullScreenMovie&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;首先这天放在这里似乎不合适。&lt;/li&gt;
  &lt;li&gt;Android上PlayFullScreenMovie 的实现实际上是通过Android原生的接口直接播放的，播放过程中Unity也是停止更新的，因此这部分的内存理论上并不会记录在 Unity 中，同样也不影响mono。&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sun, 27 Aug 2017 18:19:29 +0800</pubDate>
        <link>https://caihua.tech/2017/08/27/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E5%9B%9B%E5%91%A8/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/08/27/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E5%9B%9B%E5%91%A8/</guid>
        
        <category>UWA</category>
        
        
      </item>
    
      <item>
        <title>Lua学习笔记：迭代和闭包</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;关系&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;迭代是一种遍历一种集合中所有元素的机制，在遍历的过程中需要在每次成功之间保持一些状态，比如当前变量的index等。而闭包的机制恰好很适合迭代，因为闭包是一种可以访问外部嵌套环境中的变量的函数，而这个变量可以用来保持状态。在lua中闭包结构通常由&lt;strong&gt;闭包函数本身&lt;/strong&gt;和一个&lt;strong&gt;创建该闭包函数的工厂函数&lt;/strong&gt;组成。&lt;/li&gt;
  &lt;li&gt;以下面代码为例，GetValue就是个工厂，它生产出一个闭包，这个闭包将状态保持在t和i这两个变量中。其实在我看来主要是i中。在循环中每次调用闭包（迭代器）都是在更新它的状态i。这段代码完美的展示了迭代器的概念，看完之后对于迭代的理解更近了一步。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;tt = {10,20,30}

function GetValue(t)
	local i =0
	return function ()
		i=i+1
		return t[i]
	end
end

iterator = GetValue(tt)

while true do
	local v = iterator()
	if v == nil then
		break
	end
	print(v)
end
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;for&quot;&gt;泛型for&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;泛型for在内部保存了3个值，分别是一个迭代器函数、一个恒定状态和一个控制变量。其形态如下，其中var-list是变量列表，exp-list表达式列表。var-list第一个原始就是控制变量，在循环中它不会是nil，如果是nil了循环就结束了。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for &amp;lt;var-list&amp;gt; in &amp;lt;exp-list&amp;gt; do
    &amp;lt;body&amp;gt;
end
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;迭代器是for中内部保存的，恒定状态应该是你需要循环的数据，比如一个table，控制变量是返回值变量列表的第一个变量，同时它也是用恒定状态和控制变量调用迭代器后得到的结果。假设迭代器函数是f，恒定状态是s，控制变量初始是a0，那么有&lt;code class=&quot;highlighter-rouge&quot;&gt;a1 = f(s,a0) a2 = f(s,a1)...&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;lua中将for的迭代器返回值固定为了3个，因此得到的是next\t\nil.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-1&quot;&gt;无状态迭代器&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;不保存任何状态的迭代器，可以在多个循环中使用同一个迭代器。例子：ipairs。准确说ipairs是个工厂，它生产了一个简单的迭代器。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;一个简单的迭代器&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;local function getNext(list, node)
	if not node then
		return list
	else
		return node.next
	end
end

function tra(list)
	return getNext,list,nil
end

list = nil
for line in io.lines() do
	list  = {val = line, next = list}
end

for node in list do
	print(tra(node.val))
end
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-2&quot;&gt;关于迭代的的一些理解&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;在lua中for迭代的迭代器其实主要是个生成器，它生成了iterator，然后依靠for来循环调用。注意生成迭代的函数的返回值必须是函数、恒定状态、控制变量这个顺序。&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Mon, 14 Aug 2017 22:57:15 +0800</pubDate>
        <link>https://caihua.tech/2017/08/14/Lua%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%BF%AD%E4%BB%A3%E5%92%8C%E9%97%AD%E5%8C%85/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/08/14/Lua%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%BF%AD%E4%BB%A3%E5%92%8C%E9%97%AD%E5%8C%85/</guid>
        
        <category>Lua</category>
        
        
      </item>
    
  </channel>
</rss>
