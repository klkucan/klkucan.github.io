<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>蔡华的博客</title>
    <description>Be publicly useful and privately happy.</description>
    <link>https://caihua.tech/</link>
    <atom:link href="https://caihua.tech/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Mon, 04 Sep 2017 23:47:38 +0800</pubDate>
    <lastBuildDate>Mon, 04 Sep 2017 23:47:38 +0800</lastBuildDate>
    <generator>Jekyll v3.2.1</generator>
    
      <item>
        <title>每天一点UWA：第六周</title>
        <description>&lt;h2 id=&quot;assetbundle&quot;&gt;AssetBundle&lt;/h2&gt;
&lt;h4 id=&quot;section&quot;&gt;这是一个很长的问题：&lt;/h4&gt;
&lt;h4 id=&quot;assetbundle-aabbb&quot;&gt;字体作为多个资源的依赖包，会在游戏中被加载多次。我们现在有个问题，AssetBundle A资源依赖于这个字体，加载A的时候加载了一份字体，然后B资源也依赖这字体，而后加载B的时候我们没有去重复加载字体，这时候发现B资源上出现了字体丢失的现象。&lt;/h4&gt;

&lt;h4 id=&quot;unityb&quot;&gt;请问加载资源的时候，Unity会自动去识别内存里是否有它的资源依赖包吗？如果有的话，为什么B加载的时候找不到已经存在内存中的字体？这里需要手动去做些什么处理吗？&lt;/h4&gt;

&lt;h4 id=&quot;bundlemassetbundleunloadfalseassetbundleunloadfalse&quot;&gt;同时我发现依赖包资源如果进行了bundle.m_AssetBundle.Unload(false)以后，其他依赖于这个包的资源就引用不到了。我们流程上对于每个读进来的AssetBundle，都会加载完后马上进行Unload(false)，请问如果是依赖包的话，是不是不能对其进行这步操作？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;这个问题其实是典型的一个AssetBundle使用的问题，其中牵扯的细节在unity的文档中都有。&lt;/li&gt;
  &lt;li&gt;总结来说就是对于公共资源的字体，在A和B加载前要提前加载好，这样unity根据依赖关系会自动的找到字体asset。&lt;/li&gt;
  &lt;li&gt;但是如果加载A完成后直接卸载了字体的AssetBundle，那么加载B时肯定会出错。此时字体asset虽然还在（因为用的是Unload(false)），但是unity已经无法依靠依赖关系来作用在B上了。同时如果测试再次加载字体AssetBundle，则原有的字体asset出现内存泄漏问题。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;shaderbuildin&quot;&gt;自己下载了shader包，如何替换buildin资源？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;需要完全的替换，shader自己不会关联，而且很多时候用的是buildin的material，测试用的就是buildin的shader。&lt;/li&gt;
  &lt;li&gt;还有一个情况是prefab中用的shader的GUID和自己导入的不同，可以用通过如下脚本进行替换。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;using UnityEngine;
using System.Collections;
using UnityEditor;
using System.IO;

public class BuildScript {

    [MenuItem(&quot;Build/RefreshMat&quot;, false, 501)]
    static void RefreshMat() {
        var guids = AssetDatabase.FindAssets(&quot;t:Material&quot;);
        foreach (var guid in guids) {
            var path = AssetDatabase.GUIDToAssetPath(guid);
            if (path.ToLower().EndsWith(&quot;mat&quot;)) {
                var mat = AssetDatabase.LoadAssetAtPath&amp;lt;Material&amp;gt;(path);
                if (mat &amp;amp;&amp;amp; mat.shader) {
                    Debugger.Log(&quot;{0}\n{1}\n{2}\n{3}\n&quot;, path, mat.shader.name,
                        mat.shader.GetInstanceID(),
                        Shader.Find(mat.shader.name).GetInstanceID());
                    mat.shader = Shader.Find(mat.shader.name);
                }
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;font&quot;&gt;Font&lt;/h2&gt;
&lt;h4 id=&quot;assetbundleprofiler&quot;&gt;一个字体打包到AssetBundle中，加载后在profiler中看到两份&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;通常TTF文件会包含一个字体的多个字型，如可能包含正常字型、加粗字型、斜体字型等。而在Unity中会将其分为不同的Font资源，且他们之间会相互依赖。所以，如果项目中确实需要加粗字型的话，内存里出现两个Font是正常的，但如果实际上不需要加粗，那么可以尝试寻找一个不包含加粗字型的字体文件来替换该TTF文件。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;profileriphone-appuifontcachefontfortext2siphone52srendertexture&quot;&gt;在用Profiler真机查看iPhone App时，发现第一次打开某些UI时，Font.CacheFontForText占用时间超过2s，这块主要是由什么影响的?若iPhone5在这个接口消耗2s多，是不是问题很大？这个消耗和已经生成的RenderTexture的大小有关吗？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Font.CacheFontForText主要是指生成动态字体Font Texture的开销, 一次性打开UI界面中的文字越多，其开销越大。&lt;/li&gt;
  &lt;li&gt;这个消耗也与已经生成的Font Texture有关系。简单来说，它主要是看目前Font Texture中是否有地方可以容下接下来的文字，如果容不下才会进行一步扩大Font Texture，从而造成了性能开销。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;texture&quot;&gt;Texture&lt;/h2&gt;
&lt;h4 id=&quot;assetbundletexture&quot;&gt;游戏里重复的特效较多，有些只是图案相同但改变了颜色参数，如果都打成独立AssetBundle，则内存里面会有多份Texture。关于这样的打包一般有什么推荐的方法呢？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;只保留一份初始纹理资源，并通过Shader在运行时改变其整体配色，从而达到不同的效果。&lt;/li&gt;
  &lt;li&gt;如果是局部配色不同，那么可以在原始纹理的基础上加一种或几种Mask纹理，用来负责颜色的自适应调配，然后再通过Shader来达到不同的展示效果。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ui&quot;&gt;UI&lt;/h2&gt;
&lt;h4 id=&quot;gameobjectdeactivate&quot;&gt;GameObject.Deactivate消耗大&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;GameObject.Activate/Deactivate本身通常不会产生很高的开销，产生高开销的是其OnEnable/OnDisable操作。&lt;/li&gt;
  &lt;li&gt;如果是自定义脚本，可以考虑优化OnEnable/OnDisable函数中的操作。&lt;/li&gt;
  &lt;li&gt;如果是UI可以考虑通过移出屏幕或者改摄像机的culling layer来实现隐藏。前面有讲过相关的内容。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;canvascanvas&quot;&gt;动静分离或者多Canvas带来性能提升的理论基础是什么呢？如果静态部分不变动，整个Canvas就不刷新了？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;在UGUI中，网格的更新或重建（为了尽可能合并UI部分的DrawCall）是以Canvas为单位的，且只在其中的UI元素发生变动（位置、颜色等）时才会进行。因此，将动态UI元素与静态UI元素分离后，可以将动态UI元素的变化所引起的网格更新或重建所涉及到的范围变小，从而降低一定的开销。而静态UI元素所在的Canvas则不会出现网格更新和重建的开销。&lt;/li&gt;
  &lt;li&gt;PS：位置和颜色变化应该会造成更新，如果出现血条那样的会造成mesh变化从而重建。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;ui-1&quot;&gt;UI优化&lt;/h3&gt;
&lt;h4 id=&quot;ugui&quot;&gt;UGUI参考的函数&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;1、Canvas.SendWillRenderCanvases()
该API为UI元素自身发生变化（比如被Enable或者被缩放，移动并不算）时所产生的调用。发生在canvas被渲染之前。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;2、Canvas.BuildBatch
该API为UI元素合并的Mesh需要改变时所产生的调用。通常之前所提到的Canvas.SendWillRenderCanvases()的调用都会引起Canvas.BuildBatch的调用。另外，Canvas中的UI元素发生移动也会引起Canvas.BuildBatch的调用。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;ngui&quot;&gt;NGUI参考的函数&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;UICamera.Update()
该函数通常在点击时出现开销。因此，当该函数的CPU开销较高时，通常都是因为调用了其他的较为耗时的函数引起。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;UIRect.Update()
该函数通常在需要更新锚点位置时出现开销。因此，当该函数的CPU开销持续较高时，通常是因为当前场景中有较多的UI元素绑定了OnUpdate模式的锚点。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;UIPanel.LateUpdate()
该函数为NGUI最主要的CPU开销，包含了对所有UI界面包括其下UI元素的状态更新、网格重建、DrawCall合并等操作。大量的UI变动或者不合理的UIPanel布局都有可能导致该函数出现较高的峰值。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;UIRect.Start()
该函数主要涉及到UI元素的初始化操作，通常在UI界面被实例化时出现并产生一定的CPU开销。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;优化建议：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;动静分离，动的频率不同也分离，减少Mask组件的使用，使用Mask不仅会增加GPU端渲染的压力，同时也会造成CPU端DrawCall的明显上升。可尝试用RectMask2D来进行替换。&lt;/li&gt;
  &lt;li&gt;减少OnEnable和OnDisable，通过移动位置、改变摄像机culling mask。&lt;strong&gt;后者可能会一定程度地提高内存的开销（UIDrawCall中存储的Mesh）&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;ngui-1&quot;&gt;NGUI的图集在内存里存了多份，求问怎么清理？&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2FTechSharing_31%2F1.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;游戏运行中，UI Mesh出现多份不同内存的情况，是正常的，因为随着UI widget使用的增加或减少，创建的UI Mesh是会随着变化的。&lt;/li&gt;
  &lt;li&gt;同时，如果不同UIPanel中存在相同Atlas的Widgets，则也会出现上图中的情况。因此，建议大家遇到这种情况时，查看单帧中NGUI UI Mesh重名的是否有多份重名资源。如果存在，则说明相同Atlas中的资源被多个不同的UIPanel所使用，这种情况是需要尽可能避免的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;工具&lt;/h2&gt;
&lt;h4 id=&quot;profilerothersystemexecutableanddlls&quot;&gt;Profiler中Other下System.ExecutableAndDlls的内存很大&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;一般来说，在移动游戏中，该选项经常在iOS真机运行时会看到，System.ExecutableAndDlls该项显示的是执行文件和所调用的库（物理、渲染、IO等系统库）的总和。&lt;/li&gt;
  &lt;li&gt;开发团队不用太担心该选项的数值，因为很多应用均在共用这些库，并且它对于真实项目的内存压力非常小，几乎没有影响，而且OS也不会因为该内存而杀掉游戏或应用。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;loadingupdatepreloading&quot;&gt;Loading.UpdatePreloading&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;这是Unity引擎最主要的加载函数。该项一般在切换场景时或主动动态加载资源时较大。 一般来说，加载资源越多、越复杂，则其反映的Loading.UpdatePreloading耗时则越大。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;profilernot-saved&quot;&gt;Profiler中Not Saved是指什么？&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2FTechSharing_31%2F3.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Profiler中的Not Saved指的是项目中通过代码生成的各种资源记录。如上图所示，其Mesh均为NGUI插件通过脚本生成的UI界面Mesh资源。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;脚本&lt;/h2&gt;
&lt;h4 id=&quot;section-3&quot;&gt;判断怪物是否在相机视野范围有没有什么好方法？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;可以在脚本中添加 OnWillRenderObject 或者 OnBecameVisible/OnBecameInvisible 的回调函数，这些函数分别会在对应的Renderer可见或者变为可见/不可见时被调用。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;amonobehaviourb-monobehaviourdestroybgameobjectabnullinspectormissinggcbagcnullgc&quot;&gt;我们测试了下发现，在名为A的MonoBehaviour中，有个数组来存放名为B的 MonoBehaviour对象的引用。当我们其他的逻辑去Destroy了B对象所在的GameObject后，在A对象中的数组里，遍历打印，它们（B的引用）都为Null，在Inspector面板上看是missing。而这时候进行GC，堆内存其实并未释放这些B对象。只有当A对象中的数组被清空后，再调用GC，才可释放这些对象所占内存。这种现象是否正常？为什么值为Null但却还是被引用着，无法通过GC释放呢？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;首先这种现象是正常的。这是Unity中对Null的检测做了特殊的处理所致，在Unity中MonoBehaviour对象除了存在于Managed Heap中（作为“壳”），在Native内存中还会有一个相对应的“实体”，在调用Destroy时，真正被释放的正是这个“实体”。而在判断一个MonoBehaviour对象是否为Null时，Unity会首先检测“实体”是否已经被销毁，如果是则返回为true，但此时Managed Heap中的“壳”实际上依然是被引用的，从而就会出现对象的Null判断为true，但实际上还是被引用着，无法被GC释放的问题。
.&lt;/li&gt;
  &lt;li&gt;相关的细节可见官方blog对Unity中Null判断的解释：
http://blogs.unity3d.com/2014/05/16/custom-operator-should-we-keep-it/&lt;/li&gt;
  &lt;li&gt;PS：本周最佳收获。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-4&quot;&gt;粒子&lt;/h2&gt;
&lt;h4 id=&quot;fbxreadwrite-enablecrasheditor&quot;&gt;真机下关闭粒子使用的FBX的Read/Write Enable属性后crash，Editor模式下没有。&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;将FBX上的Read/Write Enabled关闭后，内存中便不再保存其Mesh的副本（只存在显存中），因此其属性就不可再被访问和修改。&lt;/li&gt;
  &lt;li&gt;粒子系统通常需要动态地修改其粒子的顶点属性。因此，理论上来说，供粒子系统使用的Mesh是需要开启Read/Write Enabled的，而在Editor下Mesh和Texture都是强制开启的，所以在真机上就会出现问题。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-5&quot;&gt;粒子的优化&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;减量。总的来说就是减少粒子的数量，减少粒子的范围，如果离摄像机远可以考虑不显示粒子。最后升级到5.3之后，因为粒子系统有优化。&lt;/li&gt;
  &lt;li&gt;粒子系统拼合。是指引擎会将若干个材质相同且深度相同的粒子系统在渲染前进行合批（Batch），从而通过一个Draw Call来对其粒子系统进行渲染，进而降低粒子系统的渲染开销。至于合并机制之前也写到过。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;spritepacking-tag&quot;&gt;粒子系统所使用的纹理并不是Sprite类型的，因此不需要设置Packing Tag。&lt;/h4&gt;

&lt;h2 id=&quot;section-6&quot;&gt;模型&amp;amp;动画&lt;/h2&gt;
&lt;h4 id=&quot;skinnedmeshrendererbakemeshinstantiate&quot;&gt;SkinnedMeshRenderer.BakeMesh这个函数一般是什么时候调用呢?在Instantiate后调用么？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;SkinnedMeshRenderer.BakeMesh 的作用在于：将一个蒙皮动画的某个时间点上的动作，Bake成一个不带蒙皮的Mesh，从而可以通过自定义的采样间隔，将一段动画转成一组Mesh序列帧。而后在播放动画时只需选择最近的采样点（即一个Mesh）进行赋值即可，从而省去了骨骼更新与蒙皮计算的时间。&lt;/li&gt;
  &lt;li&gt;该方法的优点是用内存换计算时间，在场景中大量出现同一个带动画的模型时，效果会非常明显。该方法的缺点是内存的占用极大地受到模型顶点数、动画总时长及采样间隔的限制。因此，该方法只适用于顶点数较少，且动画总时长较短的模型。同时，Bake的时间较长，因此需要在加载场景时完成。比较经典的适用场景为MOBA游戏中的小兵。&lt;/li&gt;
  &lt;li&gt;PS：关于skinnedmesh转mesh这个问题比较大，可以参考网上的资源。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;mecanim&quot;&gt;为什么尽可能使用Mecanim&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Mecanim动画系统的多线程计算性能较之老版本的单线程计算性能要高；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Mecanim动画系统可以对GameObject开启 “Optimize Game Object” 选项。该选项为Unity引擎在4.3版本中加入的新功能，旨在优化Mecanim动画系统的底层计算开销。开启该选项，Animator.Update和MeshSkinning.Update的CPU占用均存在一定程度的降低；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Mecanim动画系统的Retargeting功能可以让多个不同的角色使用同一套的AnimationClip资源，比如主城中的NPC角色，其大部分共性动画可尝试使用一套Idle、Wave等动画片段，从而进一步降低动画资源的内存开销；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Unity引擎已经不再对老版本动画系统进行维护。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-7&quot;&gt;动画的优化&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;动画模块的开销主要来自于MeshSkinning.Update（蒙皮网格每帧更新）和Animation.Update and Animator.Update（骨骼动画的更新开销）两个函数。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;研发团队在尽可能保证动画效果的同时，对模型的网格进行简化，建议尝试使用Unity Asset Store中的SimpleLOD插件来对骨骼蒙皮网格进行简化；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;关于MeshSkinning.Update， 一般来说该值的大小取决于蒙皮网格（Skinned Mesh）的面片数和骨骼数。所以如果该值过高，我们的建议是减面。同时我们建议开发团队勾选“GameObject.Optimize”，该方法是将fbx生成的GameObject的层级关系移除，使动画系统不用每帧再去更新这些骨骼节点（GameObject）的Transform，因此能一定程度上降低CPU开销，此优化选项默认是关闭的），该方法特别适合于在配置较低的手机上运用骨骼角色多的情况。&lt;/li&gt;
  &lt;li&gt;开启Optimize GameObject默认情况下会将动画网格下的所有骨骼结点隐藏，但是，可以通过“Extra Transform to Expose”查看想通过脚本获取的骨骼结点，这样既可以提升该角色的动画模块性能，又可以达到获取某个关键结点的需求。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Optimize Game Objects对于老版本的Animation无效。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用SkinnedMeshRenderer.BakeMesh&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;控制场景中具有Animator Controller组件的GameObject。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-8&quot;&gt;材质实例数量过多有何影响&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Material的内存占用一般很小，所以大量的Material资源对于内存的压力其实很小的。&lt;/li&gt;
  &lt;li&gt;它本身对于场景的切换时间是有影响的，即资源冗余得越多，切换场景时，UnloadUnusedAssets的开销越大，进而增加了场景的切换时间。&lt;/li&gt;
  &lt;li&gt;会影响DrawCall的拼合。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-9&quot;&gt;物理&lt;/h2&gt;
&lt;h4 id=&quot;profilerstatic-collidermoveexpensive-delay-cost&quot;&gt;Profiler中会碰到Static Collider.Move(Expensive delay cost)，有什么办法可以优化掉呢？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;建议给需要移动的静态Collider加上RigidBody并勾选is Kinematic复选框，从而将其变为动态碰撞体。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;physicssimulate-&quot;&gt;引起 Physics.Simulate 开销较大的几个因素&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Rigidibody。
    &lt;ul&gt;
      &lt;li&gt;该组件可使得游戏对象在物理系统的控制下运动。&lt;/li&gt;
      &lt;li&gt;对于移动设备而言，建议Rigidibody数量控制在50以下。同时需要注意的是，大家常常会用Rigidbody组件配合CapsuleCollider，通过RigidBody.velocity来移动。这些会造成物理计算，特别是网格有很多Mesh Colider的时候，物理计算相当高。&lt;/li&gt;
      &lt;li&gt;因此，建议尽量用Transform.Position代替物理计算。如果大家的地形是凹凸不平又要有重力的表示，也可以用Navmesh去做，它所引起的工作量在于烘焙Navmesh，并且尽可能地贴合地表 ，但是可以完全不用物理计算。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Contacts &amp;amp; Colider
    &lt;ul&gt;
      &lt;li&gt;Contacts数量为碰撞对（Contact Pair）数量。任意两个发生碰撞的碰撞体都会产生一个“碰撞对”。&lt;/li&gt;
      &lt;li&gt;一般来说，Contacts数量越大，则表明碰撞物体的数量越多，即物理系统的CPU开销越大。&lt;/li&gt;
      &lt;li&gt;碰撞体数量（静态碰撞体和动态碰撞体两者）均控制在100以下，当然越低越好。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;PS：动态碰撞体是指带有RigidBody的Collider，而静态碰撞体指不带有RigidBody的Collider。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;ngui-2&quot;&gt;NGUI减少物理计算&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;在NGUI界面打开后，往往会有Physics一下涨高的情况。这是因为NGUI为了实现点击事件的检测，在每个UI上都设有Rigidbody，所以当UI Widgets摆在同一深度并存在相互叠加的情况时，会造成较多不必要的Contacts。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;ontriggerxxxontriggerenter&quot;&gt;定位到OntriggerXXX（如OntriggerEnter）消耗高&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;这种情况一般是在脚本中触发了其他的逻辑调用，例如在主角被碰撞从而受到伤害时，创建一个伤害数字的UI，这些均有些实例化的逻辑计算，当然这些也会算到Physics开销中。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-10&quot;&gt;渲染&lt;/h2&gt;
&lt;h4 id=&quot;shadershader1zwrite&quot;&gt;我用内建的Shader渲染场景，深度图里有内容。而用自己的Shader，取到的深度图什么都没有，都是1，什么原因导致的呢？我已经打开ZWrite了。&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;4.x中是靠depth buffer直接获取或者通过shader replacement来实现。&lt;/li&gt;
  &lt;li&gt;5.x后统一考ShadowCaster来实现。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;shaderparse--shadercreategpuprogram-&quot;&gt;Shader.Parse 和 Shader.CreateGpuProgram 到底是做什么的？他们什么时候执行？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Shader.Parse体现的是Shader的加载和解析， Shader.CreateGpuProgram 是将Shader传入GPU的一次提交，GPU驱动会对其进行编译，以适应于特定的设备或平台。在Unity 5.x版本中，Shader.Parse在Shader资源加载时进行执行，而 Shader.CreateGpuProgram在所在GameObject第一渲染时进行执行。&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Mon, 04 Sep 2017 23:36:59 +0800</pubDate>
        <link>https://caihua.tech/2017/09/04/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E5%85%AD%E5%91%A8/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/09/04/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E5%85%AD%E5%91%A8/</guid>
        
        <category>UWA</category>
        
        
      </item>
    
      <item>
        <title>游戏设计模式读书笔记：组件模式</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;为什么是组件&lt;/h2&gt;
&lt;h4 id=&quot;section-1&quot;&gt;意图&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;允许单一的实体跨越多个领域而不会导致这些领域彼此耦合。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;ecs&quot;&gt;实体-组件-系统(ECS)&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;组件模式在游戏中常见的体现就是&lt;a href=&quot;https://zh.wikipedia.org/wiki/User:Lijinyu25775/%E5%AE%9E%E4%BD%93-%E7%BB%84%E4%BB%B6-%E7%B3%BB%E7%BB%9F(ECS)&quot;&gt;ECS&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-2&quot;&gt;为什么是组件&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;在游戏开发中一个实体会有多个不同的功能，比如音频的播放、动画功能、渲染、物理、输入等等，如果所有的功能都按照类的形式写到一个类文件中会非常的庞大且不易维护。&lt;/li&gt;
  &lt;li&gt;将不同类型的功能切分成不同的组件，既是对结构的优化也是实现了功能的复用。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-3&quot;&gt;为什么不是类的继承&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;因为可能一个实体的在继承多个父类（C++，但是C#这样的语言在语法上就不行）时出现重复继承的问题。比如实体的父类的父类出现重复的问题。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-4&quot;&gt;模式&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;单一实体跨越了多个领域&lt;/strong&gt;。为了保持领域之间相互分离，将每部分代码放入&lt;strong&gt;各自的组件类&lt;/strong&gt;中。实体被简化为&lt;strong&gt;组件的容器。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-5&quot;&gt;何时使用&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;组件通常在定义游戏实体的核心部分中使用。&lt;/li&gt;
  &lt;li&gt;有一个涉及了多个领域的类，而你想保持这些领域互相隔离。&lt;/li&gt;
  &lt;li&gt;一个类正在变大而且越来越难以使用。&lt;/li&gt;
  &lt;li&gt;想要能定义一系列分享不同能力的类，但是使用继承无法让你精确选取要重用的部分。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-6&quot;&gt;一些问题&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;组件之间的通信问题&lt;/li&gt;
  &lt;li&gt;组件的获得需要先获取实体，才能获得组件对象。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-7&quot;&gt;实现&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;建议直接看原书代码。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-8&quot;&gt;进化过程&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;1.先将不同的功能模块分为不同的组件，实体类本身只是调用组件中的方法（作为容器），参数为自身。&lt;/li&gt;
  &lt;li&gt;2.对组件类进行接口化，最后变成实体类中只要使用继承自接口的类即可。对于接口的不同实现就可以实现不同的功能。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-9&quot;&gt;设计决策&lt;/h2&gt;

&lt;h4 id=&quot;section-10&quot;&gt;对象如何获得组件&lt;/h4&gt;
&lt;h5 id=&quot;section-11&quot;&gt;对象创建组件&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;自己创建所以一定能拿到需要的组件&lt;/li&gt;
  &lt;li&gt;组件模式的优势在于自由的将不同的组件赋予一个对象，从而让对象获得不同的能力，或者说变成了某个特定的游戏对象。但是如果用硬编码的方式获得组件，那么这个对象就定型了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-12&quot;&gt;外部提供组件&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;对象更加灵活。&lt;/strong&gt;我们可以提供不同的组件，这样就能改变对象的行为。 通过共用组件，对象变成了组件容器，我们可以为不同目的一遍又一遍重用它。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;对象可以与具体的组件类型解耦。&lt;/strong&gt; 如果我们允许外部代码提供组件，好处是也可以传递派生的组件类型。 这样，对象只知道组件接口而不知道组件的具体类型。这是一个很好的封装结构。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;PS：细细体会unity的组件实现。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-13&quot;&gt;组件之间如何通信&lt;/h4&gt;
&lt;h5 id=&quot;section-14&quot;&gt;通过修改容器对象的状态：&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;这个可以参考unity的实现。在unity中每个GameObject都必须有transform组件，以为位置、角度和缩放信息算是所有对象都必须有的，而且在物理组件、渲染组件中都需要用到。&lt;/li&gt;
  &lt;li&gt;但是这个方案的问题就在于，如果一个GameObject使用了多个组件，而这些组件在修改数据时可能需要一定的顺序才行，比如计算移动的组件需要限制性，在执行物理相关和渲染相关的，因为可能一个对象在一帧中已经离开了摄像机范围而不需要渲染了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-15&quot;&gt;互相引用&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;这个没什么好多解释的，掌握了对象的引用自然可以获得其数据和方法。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;但是这个是一种倒退，因为耦合了。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-16&quot;&gt;消息机制&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;恩恩，尤其是使用订阅发布模式的消息系统。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-17&quot;&gt;参考&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://gpp.tkchu.me/component.html&quot;&gt;原文&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;一个不错的&lt;a href=&quot;https://github.com/EllanJiang/GameFramework&quot;&gt;框架&lt;/a&gt;，我是先学习了这个框架在看这个文章的，醍醐灌顶之感。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 28 Aug 2017 14:11:13 +0800</pubDate>
        <link>https://caihua.tech/2017/08/28/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%BB%84%E4%BB%B6%E6%A8%A1%E5%BC%8F/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/08/28/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%BB%84%E4%BB%B6%E6%A8%A1%E5%BC%8F/</guid>
        
        <category>游戏设计模式读书笔记</category>
        
        
      </item>
    
      <item>
        <title>每天一点UWA：第五周</title>
        <description>&lt;h2 id=&quot;assetbundle&quot;&gt;AssetBundle&lt;/h2&gt;
&lt;h4 id=&quot;shader&quot;&gt;shader加载&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;首先 Shader. WarmupAllShaders 并不影响 Shader 的加载，因为该函数的作用是将所有已加载的 Shader 都做一次快速渲染(渲染单个像素，GPU 在首次使用某一个 Shader 时会有额外开销，Warm 相当于是将这部分开销提前)。&lt;/li&gt;
  &lt;li&gt;可以通过AssetBundle.LoadAll等接口预加载 AssetBundle 中的 Shader。而对于 Always Included Shaders 中的 Shader 则可以通过 Shader. Find 来预加载。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;streamingassetpath--persistantdatapathloadassetbundle&quot;&gt;StreamingAssetPath 和 PersistantDataPath直接load非AssetBundle资源？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;可以但是只能用WWW这样的有限的API.&lt;/li&gt;
  &lt;li&gt;如果load MP3、JPG这样的非内部资源格式效率低，尤其是JPG还要软解码，效率更低。&lt;/li&gt;
  &lt;li&gt;还是推荐AssetBundle。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;unity-5x--fbx--mesh--animationclip--assetbundle-name&quot;&gt;在Unity 5.x 的打包机制下确实无法手动为 FBX 下的 Mesh 或 AnimationClip 单独资源设置 AssetBundle Name。&lt;/h4&gt;

&lt;h4 id=&quot;animatorfbxfbxfbxassetbundle&quot;&gt;如果Animator是直接引用了FBX里的动画文件，而不是复制了FBX的动画文件出来再引用，那么打包的时候不会把FBX打进AssetBundle。&lt;/h4&gt;

&lt;h4 id=&quot;resourcesunloadunusedassetsassetbundleloadassetbundleunloadfalse&quot;&gt;Resources.UnloadUnusedAssets同样可以卸载由AssetBundle.Load加载的资源，只是前提是其对应的AssetBundle已经调用Unload(false)，且并没有被引用。&lt;/h4&gt;

&lt;h3 id=&quot;assetbundle-1&quot;&gt;总结一下AssetBundle的加载和卸载&lt;/h3&gt;
&lt;h4 id=&quot;section&quot;&gt;加载&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;AssetBundle的各种创建函数可以从本地文件(LoadFromXXX)或者内存中将AssetBundle加载到一块内存区域（use from memory or unitywebrequest）或者只是建立一个序列化引用(use loadformfile)。&lt;/li&gt;
  &lt;li&gt;AssetBundle的各种load函数会将真正的asset从AssetBundle中加载出来到内存中。&lt;/li&gt;
  &lt;li&gt;instantiate函数创建GameObject实例&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-1&quot;&gt;卸载&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;AssetBundle的实例函数unload（false）会卸载内存中的AssetBundle（虽然函数的说明中是Unloads all assets in the bundle.），参数是true的话删除AssetBundle和用它创建的asset。&lt;/li&gt;
  &lt;li&gt;上面的函数针对的单个AssetBundle，而UnloadAllAssetBundles这个静态函数就是针对所有当前已经load的AssetBundle了。&lt;/li&gt;
  &lt;li&gt;对于一个具体的asset可以使用Resources.UnloadAsset来卸载，或者使用Resources.UnloadUnusedAssets将多有没有引用的asset卸载。前提就是调用过AssetBundle的Unload（不论参数是false还是true）。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;build&quot;&gt;Build&lt;/h2&gt;
&lt;h4 id=&quot;optimize-mesh-data&quot;&gt;Optimize Mesh Data选项&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;build时我们在player setting里面有这个选项，它只针对Build Player或者Bundle 时才生效的，所以提前做的AssetBundle是无效的。&lt;/li&gt;
  &lt;li&gt;模型导入时也有个Optimize Mesh选项，是调整面片排序的，和build时的是两回事。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ui&quot;&gt;UI&lt;/h2&gt;
&lt;h4 id=&quot;ugui-resourcesunloadunusedassets&quot;&gt;UGUI做的一个界面中有一个背景图片，关闭销毁这个界面后调用 Resources.UnloadUnusedAssets，图片还在内存中&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;在使用 Resources.Load 加载 UI 界面的情况下，即使“关闭销毁这个界面”后，Resources.UnloadUnusedAssets 确实还是无法卸载对应的图集的。因为此时该图集依然被 Resources.Load 加载出来的 Prefab 引用。&lt;/li&gt;
  &lt;li&gt;建议是手动调用 Resources.UnloadAssets 来手动释放图集（可以通过 Sprite.texture 来找到对应的图集），在重新实例化该 UI 界面时，图集也会自动进行 Reload 的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;模型&lt;/h2&gt;
&lt;h4 id=&quot;meshbaker-meshprefabfbxmodelgenerate-lightmap-uvs-&quot;&gt;MeshBaker 烘焙的Mesh可以保存到Prefab中，但是不能像FBX一样，设置Model导入设置中的Generate Lightmap UVs 等信息，请问有没有大招可以处理此情况？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;首先从理论上说，一个 Mesh 只能有一个 LightmapIndex 和 LightmapOffset 属性，这就决定了 Mesh 的合并必须在 Lightmap 的烘焙之前。&lt;/li&gt;
  &lt;li&gt;做Mesh合并时，需要注意到UV2对于一个Mesh而言，其所有三角面的UV区域都必须是互不重叠的，所以不能简单直接地合并。
考虑到合并前每一个Mesh的UV2区域都应该是在[0,1]x[0,1]的区间中，在合并时可以给每一个UV2区域做一个缩小和平移，从而可以把每个区间在互不重叠的情况下，放到同一个[0,1]x[0,1]的区间中。
在UV2也正确拼合后，重新进行Lightmap的烘焙即可得到正确的效果。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;batch&quot;&gt;关于静态batch&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;勾选Static的GameObject下的Mesh都会被合入CombineMesh（无论什么材质），且每个Mesh都作为SubMesh存在。&lt;/li&gt;
  &lt;li&gt;在Unity 5.3之前，对于渲染顺序相邻且材质相同的SubMesh则会动态将其索引数组拼合，从而合成一个Draw Call。&lt;/li&gt;
  &lt;li&gt;而Unity 5.3之后（还是在同材质，渲染顺序相邻的前提下）则不再拼合索引数组，因为在不切换材质时产生多个Draw Call的开销并不大，而这多个Draw Call会被统计为一个Batch。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;staticbatchingutilitycombinecombined-mesh&quot;&gt;如何删除StaticBatchingUtility.Combine会产生Combined Mesh的内存&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;通过某个使用了该Combined Mesh的MeshFilter来获取其引用（MeshFilter.sharedMesh），然后通过Destroy接口来将其卸载。因为Combined Mesh不属于真正的Assets（在Deep Memory中不属于Assets下，而是在Scene Memory下），所以不能用Resources.UnloadAsset来卸载。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-3&quot;&gt;内存&lt;/h2&gt;
&lt;h4 id=&quot;assetbundle-2&quot;&gt;AssetBundle内存占用问题&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;在webStream仍旧存在时（似乎是5.4之前），一个AssetBundle（1mb）解压到websream后如果是2mb，那么这个AssetBundle最终所占的内存就是2mb，因为webstream中已经包含了AssetBundle。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;assetbundle-3&quot;&gt;AssetBundle资源卸载&lt;/h4&gt;
&lt;p&gt;AssetBundle加载好以后立刻通过Instantiate实例化一个对象，然后通过Resources.UnloadAsset和Resources.UnloadUnusedAssets来进行卸载，如果无法卸载，则该资源一定被缓存了。&lt;/p&gt;

</description>
        <pubDate>Sun, 27 Aug 2017 18:27:46 +0800</pubDate>
        <link>https://caihua.tech/2017/08/27/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E4%BA%94%E5%91%A8/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/08/27/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E4%BA%94%E5%91%A8/</guid>
        
        <category>UWA</category>
        
        
      </item>
    
      <item>
        <title>bat学习</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;概念&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;批处理的本质，是一堆DOS和cmd命令按一定顺序排列而形成的集合。&lt;/li&gt;
  &lt;li&gt;熟悉DOS语法，然后按照正确的顺序来进行指令的运行。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-1&quot;&gt;系统教程&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;使用/?查看if的功能，使用与很多指令，&lt;code class=&quot;highlighter-rouge&quot;&gt;%&lt;/code&gt;似乎不行。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if /?
pause

--------------------------------------------

C:\Users\Administrator\Desktop&amp;gt;
执行批处理程序中的条件处理。

IF [NOT] ERRORLEVEL number command
IF [NOT] string1==string2 command
IF [NOT] EXIST filename command

  NOT               指定只有条件为 false 的情况下，Windows 才
                    应该执行该命令。

  ERRORLEVEL number 如果最后运行的程序返回一个等于或大于
                    指定数字的退出代码，指定条件为 true。

  string1==string2  如果指定的文字字符串匹配，指定条件为 true。

  EXIST filename    如果指定的文件名存在，指定条件为 true。

  command           如果符合条件，指定要执行的命令。如果指定的
                    条件为 FALSE，命令后可跟 ELSE 命令，该命令将
                    在 ELSE 关键字之后执行该命令。

ELSE 子句必须出现在同一行上的 IF 之后。例如:

    IF EXIST filename. (
请按任意键继续. . .
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;demo&quot;&gt;从一个demo中学习&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;这个demo的作用是用来更新游戏客户端的。一般来说我们的端游客户端会有一个launcher来启动真正的游戏，它还要负责来更新游戏。同时，它还要更新自己，以前WOW中的做法是有个专门的update.exe来做更新（不过现在是靠battle.net来更新了），我觉得bat文件一样可以做，因此写了这个demo。下面代码中TL代表launcher，TC代码client。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@echo on
cls

:: 当前程序所在目录
set LocalPath=%~dp0
:: TL更新包完全路径名,不带后缀，同时也是解压缩后的文件夹名称
set  TLZipFile=%~dp0TLUpgradeData\TL_%1
:: TL更新包解压路径
set  TLDecompressPath=%~dp0TLUpgradeData\

echo 执行更新，请稍后...

echo ----1.关闭客户端进程----
tasklist /nh|find /i &quot;TL.exe&quot;
if ERRORLEVEL 1 (echo TL客户端进程已经结束) else (taskkill /f /im TL.exe)
tasklist /nh|find /i &quot;TC.exe&quot;
if ERRORLEVEL 1 (echo TC客户端进程已经结束) else (taskkill /f /im TC.exe)

echo ----2.开始解压缩安装包----
if exist %TLZipFile%.zip   %LocalPath%7z x %TLZipFile%.zip -o%TLDecompressPath% -aoa

echo ----3.开始复制文件----
xcopy %TLZipFile%  %LocalPath% /e /f /k /y
:: xcopy switch说明：
:: /E           复制目录和子目录，包括空目录。
:: /F           复制时显示完整的源文件名和目标文件名。
:: /K           复制属性。一般的 Xcopy 会重置只读属性。
:: /Y           取消提示以确认要覆盖

echo ----4.删除临时文件----
del %TLZipFile%.zip
rmdir %TLZipFile% /s /q
:: 删除当文件夹和里面的所有文件，/s 表示包含子文件夹，/q 表示不需要确实提示 
pause

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-2&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;@&lt;/code&gt;&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;它的作用是让执行窗口中不显示它后面这一行的命令本身。行首有了它的话，这一行的命令就不显示了。首行的@echo off中，@的作用就是让脚本在执行时不显示后面的echo off部分。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-3&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;::&lt;/code&gt; -双冒号&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;类似注释符号&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-4&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&amp;gt;&lt;/code&gt;&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&lt;/code&gt;指示将内容写入某个文件&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&amp;gt;&lt;/code&gt;的作用，和&amp;gt;的相同，区别是把结果追加到前一行得出的结果的后面，类似写文件时的append。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;echo&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;echo&lt;/code&gt;的三个用法&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;命令显示与否的开关，有off和on两个选项。设置为off后，后续所有的命令都不会显示命令本身，只显示命令的结果。&lt;/li&gt;
  &lt;li&gt;类似于print，用于输出信息。&lt;/li&gt;
  &lt;li&gt;可以直接编辑文本文件。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;pause-&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;pause &lt;/code&gt;&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;就是字面意思&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;goto&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;goto&lt;/code&gt;&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;goto用于与其它语言是一样的，就是跳转到一个指定的标签&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:&lt;/code&gt;是定义一个标签&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;if&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;if&lt;/code&gt;&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@echo off

if &quot;%1&quot; == &quot;1&quot; goto goto1
if &quot;%1&quot; == &quot;2&quot; goto goto2

:goto1
echo 参数是goto1

:goto2
echo 参数是goto2
pause
exit
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;就是条件判断，只不过跟着不同的命令产生不同的功能&lt;/li&gt;
  &lt;li&gt;if exist判定存在&lt;/li&gt;
  &lt;li&gt;结果判断&lt;/li&gt;
  &lt;li&gt;if not 否定判定&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-5&quot;&gt;变量&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;使用set来进行变量设置，set还有几个switch。当变量的来源是输入内容时用&lt;code class=&quot;highlighter-rouge&quot;&gt;set /p&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;set variable=value&lt;/code&gt;注意这个语句中等号前后没有空格，我发现有空格的话变量赋值有问题。&lt;/li&gt;
  &lt;li&gt;使用变量时用&lt;code class=&quot;highlighter-rouge&quot;&gt;%variable%&lt;/code&gt;的形式，即两个百分号夹住变量名。&lt;/li&gt;
  &lt;li&gt;与传统的编程语言不同，bat中变量不能连接使用，比如下面这样是不行的。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;set a=1
set b=%a%2
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-6&quot;&gt;外部参数&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;%（0-9）来表示参数，其中%0代表自己，demo中只有一个参数是当前最新的版本号，用的是%1。&lt;/li&gt;
  &lt;li&gt;bat中参数有很多用法，具体不描述了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;cmd&quot;&gt;其它的cmd命令&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;demo中还是有tasklist、taskkill、del、rmdir这样的命令，这些就不一一解释了。其实这些全部都是cmd的命令，这样验证了开始时说的，其实bat就是顺序执行一些dos和cmd命令。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-7&quot;&gt;资源&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;这个demo的完整资源在GitHub的&lt;a href=&quot;https://github.com/klkucan/UpgradeByBat&quot;&gt;这个&lt;/a&gt;位置。&lt;/li&gt;
  &lt;li&gt;另外推荐一篇&lt;a href=&quot;http://www.cnblogs.com/s1ihome/archive/2009/01/15/batTutorial.html&quot;&gt;bat学习的文章&lt;/a&gt;，写的很不错。&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sun, 27 Aug 2017 18:22:24 +0800</pubDate>
        <link>https://caihua.tech/2017/08/27/bat%E5%AD%A6%E4%B9%A0/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/08/27/bat%E5%AD%A6%E4%B9%A0/</guid>
        
        <category>杂记</category>
        
        
      </item>
    
      <item>
        <title>每天一点UWA：加载模块深度解析</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;专题&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;因为UWA上会对一些技术进行系列的专题讲解，而且文章并不连续，如果按照每周的形式就会割裂这些内容，因此针对这样的情况统一写成专题形式。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;概述&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;载模块中最为耗时的性能开销可以归结为以下几类：资源加载、资源卸载、Object的实例化和代码的序列化等。&lt;/li&gt;
  &lt;li&gt;资源加载是加载模块中最为耗时的部分，其CPU开销在Unity引擎中主要体现在Loading.UpdatePreloading和Loading.ReadObject两项中。&lt;/li&gt;
  &lt;li&gt;Loading.UpdatePreloading，这一项仅在调用类似LoadLevel（Async）的接口处出现，主要负责卸载当前场景的资源，并且加载下一场景中的相关资源和序列化信息等。下一场景中，自身所拥有的GameObject和资源越多，其加载开销越大。&lt;/li&gt;
  &lt;li&gt;Loading.ReadObject，这一项记录的则是资源加载时的真正资源读取性能开销，基本上引擎的主流资源（纹理资源、网格资源、动画片段等等）读取均是通过该项来进行体现。可以说，这一项很大程度上决定了项目场景的切换效率。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;纹理篇&lt;/h2&gt;
&lt;h3 id=&quot;section-3&quot;&gt;只给出结论&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;同一的格式下（ETC1（Android）和PVRTC（iOS）、且关闭Mipmap功能），图片分辨率越大加载越慢，但是在Android上中（红米NOTE2）高（S6）端机在加载效率上差不多。&lt;/li&gt;
  &lt;li&gt;同一分辨率（1024x1024）上
  -不同格式（对于Android平台，使用ETC1、ETC2、RGBA16和RGBA32四种格式，对于iOS平台，使用PVRTC 4BPP、RGBA16和RGBA32三种格式）
    &lt;ul&gt;
      &lt;li&gt;所占的内容首先是有差异的（三组纹理的内存占用分别为1MB、1MB、4MB 和 8MB（Android平台）/1MB、4MB 和 8MB（iOS平台））。&lt;/li&gt;
      &lt;li&gt;加载效率上，ETC1、ETC2、RGBA16基本一致；PVRTC 4BPP、RGBA16基本一致。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;开启Mipmap功能会导致资源加载更为耗时，且设备性能越差，其加载效率影响越大。&lt;strong&gt;打破了Android上同一分辨率下ETC1、ETC2、RGBA16基本一致的情况，需要慎用。&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;PS：压缩后的文件大小，和解压缩的效率与纹理的内容相关，这是因为图片的压缩本质是用矩阵对图片数据进行变换，最终得到一个较小的数据。解压缩也是一样，数据的内容影响了反向计算的效率。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;uwa&quot;&gt;UWA给出的建议&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;严格控制RGBA32和ARGB32纹理的使用，在保证视觉效果的前提下，尽可能采用“够用就好”的原则，降低纹理资源的分辨率，以及使用硬件支持的纹理格式。&lt;/li&gt;
  &lt;li&gt;在硬件格式（ETC、PVRTC）无法满足视觉效果时，RGBA16格式是一种较为理想的折中选择，既可以增加视觉效果，又可以保持较低的加载耗时。&lt;/li&gt;
  &lt;li&gt;严格检查纹理资源的Mipmap功能，特别注意UI纹理的Mipmap是否开启。在UWA测评过的项目中，有不少项目的UI纹理均开启了Mipmap功能，不仅造成了内存占用上的浪费，同时也增加了不小的加载时间。&lt;/li&gt;
  &lt;li&gt;ETC2对于支持OpenGL ES3.0的Android移动设备来说，是一个很好的处理半透明的纹理格式。但是，如果你的游戏需要在大量OpenGL ES2.0的设备上进行运行，那么我们不建议使用ETC2格式纹理。因为不仅会造成大量的内存占用（ETC2转成RGBA32），同时也增加一定的加载时间。下图为测试2中所用的测试纹理在三星S3和S4设备上加载性能表现。可以看出，在OpenGL ES2.0设备上，ETC2格式纹理的加载要明显高于ETC1格式，且略高于RGBA16格式纹理。因此，建议研发团队在项目中谨慎使用ETC2格式纹理。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-4&quot;&gt;网格篇&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;总结一下：网格的加载效率的影响因素在于网格面数、顶点信息（tangent、color）数和read/write是否开启。&lt;/li&gt;
  &lt;li&gt;结论很简单，面数多、信息多、开启会造成内存的变大和加载的变慢。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-5&quot;&gt;建议&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;在保证视觉效果的前提下，尽可能采用“够用就好”的原则，即降低网格资源的顶点数量和面片数量；&lt;/li&gt;
  &lt;li&gt;研发团队对于顶点属性的使用需谨慎处理。通过以上分析可以看出，顶点属性越多，则内存占用越高，加载时间越长；&lt;/li&gt;
  &lt;li&gt;如果在项目运行过程中对网格资源数据不进行读写操作（比如Morphing动画等），那么建议将Read/Write功能关闭，既可以提升加载效率，又可以大幅度降低内存占用。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;shader&quot;&gt;Shader篇&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Shader资源的效率加载瓶颈并不在其自身大小的加载上，而是在Shader内容的解析上。&lt;/li&gt;
  &lt;li&gt;总结一下：，Mobile-Bumped Diffuse、Mobile-Diffuse、Mobile-VertexLit和Mobile-Particles Additive加载耗时依次减少，对于的normal版本也是一样。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;shader-1&quot;&gt;影响shader解析的因素&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;一般情况下，Shader加载的CPU耗时与其Keyword数量有关，Keyword数量越多，则加载开销也越大。&lt;a href=&quot;https://blog.uwa4d.com/archives/LoadingPerformance_Shader.html&quot;&gt;（具体数据看原文）&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Shader的Keyword数量是会随着场景设置的不同而变化的。在Unity 5.x中，Unity默认会根据场景设置、Shader Pass等来调整Shader的Keyword，比如如果存在Lightmap的使用，则会默认将对应的Keyword打开，而对于没有使用Fog的项目，则会直接将相关Keyword关闭。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-6&quot;&gt;如何提高解析速度&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;就是减少keyword数量。&lt;/li&gt;
  &lt;li&gt;首先可以使用skip variant来减少
&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/UWALab%2FLoadingPerformance%2FShader_SkipVariantsCode.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;其次去掉Fallback选项，因为文中认为目前不支持Mobile/Diffuse和Mobile/Bumped Diffuse的设备已经相当少，没有必要做这层保险了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-7&quot;&gt;避免重复解析&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;因为一个游戏内用到的shader的数量不会太多，如果shader打包到场景或者模型的AssetBundle中，那么在资源加载卸载的过程中会出现同一个shader多次加载解析的问题。因此建议shader单独打包。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;注意：对于Unity4.x版本，Shader的AssetBundle加载后只需LoadAll即可完成所有Shader的加载和解析，但对于Unity5.x版本，除执行LoadAllAssets操作外，还需要进行Shader.WarmupAllShaders操作，因为在Unity5.x版本中，Shader的解析和CreateGPUProgram操作是分离的。&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对于Unity 5.x版本且正在使用Resources.Load来加载资源的研发团队，可以尝试使用ShaderVariantCollection来对Shader进行Preload，同样也可以达到避免相同Shader重复加载的效果。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;注意：对于Unity5.x版本，如果可以通过AssetBundle来加载和解析Shader，则不建议通过ShaderVariantCollection来处理Shader的加载。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-8&quot;&gt;总结&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;综上所述，shader的处理就是减少keyword、对于简单的渲染去掉Fallback、尽量对shader进行单独打包。&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sun, 27 Aug 2017 18:20:55 +0800</pubDate>
        <link>https://caihua.tech/2017/08/27/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9D%97%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/08/27/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9D%97%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/</guid>
        
        <category>UWA</category>
        
        
      </item>
    
      <item>
        <title>每天一点UWA：第四周</title>
        <description>&lt;h2 id=&quot;assetbundle&quot;&gt;AssetBundle&lt;/h2&gt;
&lt;h4 id=&quot;resourcesunloadassetgameobjectcomponenttexturemeshprefabobjectcomponent&quot;&gt;Resources.UnloadAsset仅能释放非GameObject和Component的资源，比如Texture、Mesh等真正的资源。对于由Prefab加载出来的Object或Component，则不能通过该函数来进行释放。&lt;/h4&gt;

&lt;h4 id=&quot;resourceprefab-load&quot;&gt;用的是Resource的加载方式，并且已经预加载好了材质所在的Prefab ，但是为什么在第一次显示材质的时候还要Load这个材质？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;我的理解是prefab只是个资源GUID的合集，并不包含真正的资源。所以要使用真正的资源（mesh\texture等时要加载。）&lt;/li&gt;
  &lt;li&gt;通过 Resources 加载和通过 AssetBundle 加载是有所区别的。Resources.Load 和 Instantiate 操作都不会立刻加载其依赖的材质，因此在loadPrefab = Resources.Load之后，其依赖的材质（包括相关的 Shader 和纹理）实际并没有被加载到内存中，在实例化后也是一样，直到某个 Camera 需要对其进行渲染时（调用了 Material.SetPastFast），才发现该材质还没进内存，此时才开始进行加载。&lt;/li&gt;
  &lt;li&gt;因此，在使用 Resources 加载的情况下，如果希望提前加载该 Material 以及相关的 Shader 和纹理，可以尝试通过调用 Resources.Load 直接加载该材质和纹理，并通过 Shader.Find 来加载 Shader。也可以尝试通过 Player Settings 中的 Preload Shaders（配合 Graphics Settings 下的 Preloaded Shaders） 和 Preloaded Assets 来批量预加载。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;build&quot;&gt;Build&lt;/h2&gt;
&lt;h4 id=&quot;editoronly-tag&quot;&gt;EditorOnly tag&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;prefab打上EditorOnly tag，但是放到了Resources文件夹下一样会打包进入，因为理论上只对场景中的GameObject有效。- 不放到Resources文件夹下，然后在使用EditorOnly tag，打包时就会认为没有场景中的物件引用prefab，就不会打包了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;shader&quot;&gt;内置的shader怎么打包？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;通常有两种方式对内置的Shader进行打包：&lt;/li&gt;
  &lt;li&gt;将其添加到Graphics Settings中的Always Included Shaders 中，此时添加后的内置Shader就不会被打入AssetBundle包中；&lt;/li&gt;
  &lt;li&gt;在http://unity3d.com/cn/get-unity/download/archive下载内置的 Shader，将其导入项目，并替换成非内置的材质球，从而可以直接通过脚本来控制其打包的方式。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;gcmarkdependenciescpuresourcesunloadunusedassets-&quot;&gt;GC.MarkDependencies的CPU消耗有过高，虽然在退出战斗的时候调用了Resources.UnloadUnusedAssets(); 可是卡顿还是很明显&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;GC.MarkDependencies的消耗是由Resources.UnloadUnusedAssets引起的。该函数的主要作用是查找并卸载不再使用的资源。游戏场景越复杂、资源越多，该函数的开销越大，一般在300~2000 ms范围内。&lt;/li&gt;
  &lt;li&gt;对于该函数的优化，我们建议一方面控制场景中不必要的资源量，同时通过UnloadAsset来及时卸载不再使用的资源，以减少Resources.UnloadUnusedAssets的耗时压力。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;assetbundlemd5&quot;&gt;打包时候AssetBundle的md5总变化(被打包的东西没变)&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;对于Unity 4.x版本的AssetBundle文件，其md5值在某些情况下确实会前后不一致（哪怕是完全一样的内容进行打包）。对于该系列版本，仅能建议开发团队建立配置文件来对AssetBundle进行管理。&lt;/li&gt;
  &lt;li&gt;而对于Unity 5.x版本，则可以在打包时开启 AppendHashToAssetBundleName 选项，这样Unity引擎会在每个AssetBundle文件后生成一个唯一的HashID（显示地放在文件名后），开发团队可以通过该ID来判断对应的AssetBundle文件是否发生改变。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;cpu&quot;&gt;CPU&lt;/h2&gt;
&lt;h4 id=&quot;gameobjectinstantiate&quot;&gt;第一次执行GameObject.Instantiate一些资源的时候会卡&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Instantiate的卡顿与三部分开销相关：相关资源加载、脚本组件的序列化和构造函数的执行，并且绝大部分原因均是相关资源加载导致。所以，我们的建议如下：
    &lt;ul&gt;
      &lt;li&gt;通过 Profiler 查看 Instantiate 具体的CPU分配情况；&lt;/li&gt;
      &lt;li&gt;如果是资源加载导致的性能瓶颈，则一方面通过简化资源来缓解CPU耗时压力，另一方面通过 AssetBundle 依赖关系打包将资源预先加载，即将此处 Instantiate 的总体耗时拆分，平摊到之前帧进行执行（比如切换场景处等），从而让 Instantiate 实例化操作的局部耗时更加平滑；&lt;/li&gt;
      &lt;li&gt;如果是脚本组件序列化导致的性能瓶颈，则可尝试减少脚本中的序列化信息；
  -如果是构造函数的执行导致的性能瓶颈，一般只能在策略上进行规避，比如降低 Instantiate 的调用频率等。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ui&quot;&gt;UI&lt;/h2&gt;
&lt;h4 id=&quot;ui-1&quot;&gt;本周的UI有很多不错的技术知识&lt;/h4&gt;

&lt;h4 id=&quot;ngui&quot;&gt;能否对提升NGUI的渲染效率提供一些思路？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;开发团队可以从以下几点入手：
    &lt;ul&gt;
      &lt;li&gt;通常一个Panel会产生1个或多个Draw Call，以一个Panel为单位，Draw Call 的数量通常由当前 Panel 中使用的Atlas、Font的数量所决定。&lt;/li&gt;
      &lt;li&gt;要降低UI渲染时的 Draw Call数量则需要对 Atlas 的制作进行合理的规划，即在保证使用较少的 Atlas 的同时，还需要保证 Atlas之间不会存在交叉遮挡。&lt;/li&gt;
      &lt;li&gt;要注意UI Texture的使用，每个UITexture自身会占用一个Draw Call，同时如果其Depth值穿插在了其他来自相同Atlas的UISprite中，还会导致Draw Call的打断，造成不必要的额外Draw Call。&lt;/li&gt;
      &lt;li&gt;另外还可以借助Panel Tool和Draw Call Tool来对UI部分的Draw Call进行分析，前者可以显示每个UIPanel包含了多少个Draw Call，而后者可以显示每个Draw Call由哪些UIWidget组成。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;rebuild-batch-memory-profiler&quot;&gt;如何查看每次Rebuild Batch影响的顶点数， Memory Profiler是个办法但是不好定位。&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;5.2后开始使用Shared UI Mesh来存储UI Mesh，所以很难查看每次Rebuild的UI顶点数。可以尝试通过Frame Debugger工具对UI界面进行进一步的查看。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;uiuipanellateupdatecpusetactive&quot;&gt;通过移动位置来隐藏UI界面，会使得被隐藏的UIPanel继续执行更新（LateUpdate有持续开销），那么如果打开的界面比较多，CPU的持续开销是否就会超过一次SetActive所带来的开销？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;通过移动的方式“隐藏”的UI界面只适用于几个切换频率最高的界面&lt;/li&gt;
  &lt;li&gt;一般来说在没有UI元素变化的情况下，持续的 Update 开销是不太明显的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;uiuiui-setactivefalse-setactivetrue--gcalloc--batches--gc-alloc-&quot;&gt;游戏中出现UI界面重叠，该怎么处理较好？比如当前有一个全屏显示的UI界面，点其中一个按钮会再起一个全屏界面，并把第一个UI界面盖住。我现在的做法是把被覆盖的界面 SetActive(False)，但发现后续 SetActive(True) 的时候会有 GC.Alloc 产生。这种情况下，希望既降低 Batches 又降低 GC Alloc 的话，有什么推荐的方案吗？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;可以尝试通过添加一个 Layer 如 OutUI， 且在 Camera 的 Culling Mask 中将其取消勾选（即不渲染该 Layer）。从而在 UI 界面切换时，直接通过修改 Canvas 的 Layer 来实现“隐藏”。但需要注意事件的屏蔽，禁用动态的 UI 元素等等。
这种做法的优点在于切换时基本没有开销，也不会产生多余的 Draw Call，但缺点在于“隐藏时”依然还会有一定的持续开销（通常不太大），而其对应的 Mesh 也会始终存在于内存中（通常也不太大）。&lt;/li&gt;
  &lt;li&gt;PS：一个经典的场景，一个非常巧妙的答案。学到了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;uicanvasrecttransform&quot;&gt;在UI界面中，用Canvas还是用RectTransform做根节点更好？哪种方法效率更高？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;简单来说，因为一个Canvas下的所有UI元素都是合在一个Mesh中的，过大的Mesh在更新时开销很大，所以一般建议每个较复杂的UI界面，都自成一个Canvas(可以是子Canvas)，在UI界面很复杂时，甚至要划分更多的子Canvas。&lt;/li&gt;
  &lt;li&gt;同时还要注意动态元素和静态元素的分离，因为动态元素会导致Canvas的mesh的更新。最后，Canvas又不能细分的太多，因为会导致Draw Call的上升。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;PS：总结来说就是不分子Canvas会导致mesh过大，分的太多dc过高，在于平衡。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;filebytes512x512rgba322mb&quot;&gt;使用File类来读取图片的bytes流，512x512的RGBA32格式图片使用了2MB内存&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;首先正常的512x512的RGBA32图片的大小为4byte * 512 * 512 / 1024 / 1024 = 1MB，这个2MB是因为内存和显存各需要一份。file read的时候本身会产出一份，在向GPU发送的时候会备份一份，推测是这样。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;一般来说，比较建议通过AssetBundle来动态加载资源，而非通过bytes流来进行加载。如果你的项目正在使用这种方式来加载纹理，我们建议从策略上考虑将其更改。&lt;/li&gt;
  &lt;li&gt;在我们目前来看，通过bytes流来生成资源，绝大部分原因是想对其进行加密，从而让资源难于破解。但其实这种加密方式用处不大，因为据我们所知，现在有很多工具可以直接通过底层显卡层来直接查看各种纹理、Mesh资源，比如Mali Graphics Debugger、Qualcomn Profiler等。因此，如果是从加密的角度来通过bytes流生成资源，那么我们建议通过AssetBundle这种直接的方式进行加载。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;动画&lt;/h2&gt;
&lt;h4 id=&quot;cullcompletely&quot;&gt;CullCompletely&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;使用 CullCompletely 在开启 RootMotion 时是需要注意的，比如人物有一个巡逻动画是通过 RootMotion 制作的，那么在人物走出屏幕后，其动画就停止了，即不会再走回屏幕中。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;渲染&lt;/h2&gt;

&lt;h4 id=&quot;section-2&quot;&gt;场景中一个点光源，烘焙前暗，后亮是为何？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;简单来说，这就是实时的直接光照和全局光照的差别。
在渲染时前者只能处理光源和单个物件之间的直接光照，而后者在烘焙时是通过光线跟踪或者辐射度等复杂算法，计算出所有物体各个表面之间相互反射的光照信息，这也是烘焙Lightmap需要较久的时间的原因 。可以发现在全局光照下，即使是物体的背面也会因为其它表面的反射而被照亮，这在直接光线下就无法实现这样的效果。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;shader--vf-surface&quot;&gt;相同效果前提下，就性能而言，Shader 是用 V&amp;amp;F 还是Surface好？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;V&amp;amp;F，Surface生成的V&amp;amp;F比较庞杂，分支较多，如果不注意 #pragma surface 参数的选择，容易出现不必要的开销。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;baked-gi&quot;&gt;大面积的面片会导致baked GI时间过久，拆分大面积的面片对渲染性能也会有所提升&lt;/h4&gt;

&lt;h4 id=&quot;handheldplayfullscreenmovie&quot;&gt;Handheld.PlayFullScreenMovie&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;首先这天放在这里似乎不合适。&lt;/li&gt;
  &lt;li&gt;Android上PlayFullScreenMovie 的实现实际上是通过Android原生的接口直接播放的，播放过程中Unity也是停止更新的，因此这部分的内存理论上并不会记录在 Unity 中，同样也不影响mono。&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sun, 27 Aug 2017 18:19:29 +0800</pubDate>
        <link>https://caihua.tech/2017/08/27/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E5%9B%9B%E5%91%A8/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/08/27/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E5%9B%9B%E5%91%A8/</guid>
        
        <category>UWA</category>
        
        
      </item>
    
      <item>
        <title>Lua学习笔记：迭代和闭包</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;关系&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;迭代是一种遍历一种集合中所有元素的机制，在遍历的过程中需要在每次成功之间保持一些状态，比如当前变量的index等。而闭包的机制恰好很适合迭代，因为闭包是一种可以访问外部嵌套环境中的变量的函数，而这个变量可以用来保持状态。在lua中闭包结构通常由&lt;strong&gt;闭包函数本身&lt;/strong&gt;和一个&lt;strong&gt;创建该闭包函数的工厂函数&lt;/strong&gt;组成。&lt;/li&gt;
  &lt;li&gt;以下面代码为例，GetValue就是个工厂，它生产出一个闭包，这个闭包将状态保持在t和i这两个变量中。其实在我看来主要是i中。在循环中每次调用闭包（迭代器）都是在更新它的状态i。这段代码完美的展示了迭代器的概念，看完之后对于迭代的理解更近了一步。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;tt = {10,20,30}

function GetValue(t)
	local i =0
	return function ()
		i=i+1
		return t[i]
	end
end

iterator = GetValue(tt)

while true do
	local v = iterator()
	if v == nil then
		break
	end
	print(v)
end
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;for&quot;&gt;泛型for&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;泛型for在内部保存了3个值，分别是一个迭代器函数、一个恒定状态和一个控制变量。其形态如下，其中var-list是变量列表，exp-list表达式列表。var-list第一个原始就是控制变量，在循环中它不会是nil，如果是nil了循环就结束了。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for &amp;lt;var-list&amp;gt; in &amp;lt;exp-list&amp;gt; do
    &amp;lt;body&amp;gt;
end
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;迭代器是for中内部保存的，恒定状态应该是你需要循环的数据，比如一个table，控制变量是返回值变量列表的第一个变量，同时它也是用恒定状态和控制变量调用迭代器后得到的结果。假设迭代器函数是f，恒定状态是s，控制变量初始是a0，那么有&lt;code class=&quot;highlighter-rouge&quot;&gt;a1 = f(s,a0) a2 = f(s,a1)...&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;lua中将for的迭代器返回值固定为了3个，因此得到的是next\t\nil.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-1&quot;&gt;无状态迭代器&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;不保存任何状态的迭代器，可以在多个循环中使用同一个迭代器。例子：ipairs。准确说ipairs是个工厂，它生产了一个简单的迭代器。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;一个简单的迭代器&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;local function getNext(list, node)
	if not node then
		return list
	else
		return node.next
	end
end

function tra(list)
	return getNext,list,nil
end

list = nil
for line in io.lines() do
	list  = {val = line, next = list}
end

for node in list do
	print(tra(node.val))
end
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-2&quot;&gt;关于迭代的的一些理解&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;在lua中for迭代的迭代器其实主要是个生成器，它生成了iterator，然后依靠for来循环调用。注意生成迭代的函数的返回值必须是函数、恒定状态、控制变量这个顺序。&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Mon, 14 Aug 2017 22:57:15 +0800</pubDate>
        <link>https://caihua.tech/2017/08/14/Lua%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%BF%AD%E4%BB%A3%E5%92%8C%E9%97%AD%E5%8C%85/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/08/14/Lua%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%BF%AD%E4%BB%A3%E5%92%8C%E9%97%AD%E5%8C%85/</guid>
        
        <category>Lua</category>
        
        
      </item>
    
      <item>
        <title>Lua学习笔记：函数深入</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;闭包&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;lua中的函数都可以认为是闭包，只不过为了便于理解还是用了函数的概念。&lt;/li&gt;
  &lt;li&gt;lua中函数的返回值可以是匿名函数，也就是闭包。以下面的代码为例，提出一个概念：非局部的变量。在下面的代码中，匿名函数访问了一个变量i，它对于newCount来说是局部变量，对于匿名函数来说是既不是局部变量也不是全局变量，在lua中这个称谓&lt;em&gt;非局部的变量&lt;/em&gt;。&lt;/li&gt;
  &lt;li&gt;在lua中一个闭包指的是一个函数和该函数所需要访问的非局部的变量。lua会把它们看做是一个整体，因此在下面的代码中多次允许c1和c2，会发现变量i是在递增的。这是因为&lt;code class=&quot;highlighter-rouge&quot;&gt;c1 = newCount()&lt;/code&gt;这句代码相当于给c1赋值了一个闭包，它包含了i这个变量。因此多次执行相当于就是在反复执行一个对象，这样i就一直是原来那个i。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function newCount()
	local i =0
	return function ()
		i=i+1
		print(i)
	end
end

c1 = newCount()
print(c1())
print(c1())

c2 = newCount()
print(c2())
print(c2())
print(c1())

-- 结果
1
2
1
2
3
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-1&quot;&gt;利用闭包的沙盒&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;下面这段代码中，修改了math库的sin方法。类似的还可以用来处理一些不安全的代码，这样的方式类似沙盒，将不安全包装了起来。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;print(math.sin(45))

oldSin = math.sin
math.sin = function (x)
	return oldSin(x*math.pi/180)
end

print(math.sin(45))
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-2&quot;&gt;直接使用非全局函数做递归会报错&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;当你尝试调用下面的代码时，会提示&lt;code class=&quot;highlighter-rouge&quot;&gt;attempt to call global 'foo' (a nil value)
&lt;/code&gt;，很奇怪对吧，明明定义的foo是个local的，怎么会提示是global呢？这个是因为在调用foo(x-1)时，这个foo函数还没有定义完，因此表达式在尝试调用一个全局的函数foo，但是显然这个全局函数是不存在的。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;local foo = function (x)
	if x == 1 then
		return 1
	else return x*foo(x-1)
	end
end

print(foo(3))
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;正确的递归函数姿势，第二种&lt;code class=&quot;highlighter-rouge&quot;&gt;local function foo(x)&lt;/code&gt;其实是第一个方法的语法糖。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;local foo
foo = function (x)
	if x == 1 then
		return 1
	else return x*foo(x-1)
	end
end

print(foo(3))

-- 相当于
local function foo(x)
...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-3&quot;&gt;正确的尾调用&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;本质是为了不记录函数的返回位置，这样在栈中就可以无限的调用函数。在lua中只有&lt;code class=&quot;highlighter-rouge&quot;&gt;return  &amp;lt;func&amp;gt;(&amp;lt;args&amp;gt;)&lt;/code&gt;这样的形式才是尾调用。&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Mon, 14 Aug 2017 22:56:11 +0800</pubDate>
        <link>https://caihua.tech/2017/08/14/Lua%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%87%BD%E6%95%B0%E6%B7%B1%E5%85%A5/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/08/14/Lua%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%87%BD%E6%95%B0%E6%B7%B1%E5%85%A5/</guid>
        
        <category>Lua</category>
        
        
      </item>
    
      <item>
        <title>每天一点UWA：第三周</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;内存&lt;/h2&gt;
&lt;h4 id=&quot;section-1&quot;&gt;资源复用&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;如果一个prefab被简单的多复制几次，里面的mesh、Texture、AnimationClip、Material这些都是被复用的，在profile中可以看到。但是如果prefab从AssetBundle中获取，并且多次的加载、实例化、卸载可能造成内存泄漏，因为unload(false)并没有真正卸载内存中的已经实例化的prefab，再次load时PersistentManager会认为是一个新的对象。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;uiprofile&quot;&gt;UI在多次开关后出现profile中资源重复&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;刚进游戏时获取的图中出现的“重复”资源可能并不是冗余，因为 Atlas的一个 Group 中可能包含多张一样大小的Page（即纹理），而这几个Page在内存中的名字是一样的。&lt;/li&gt;
  &lt;li&gt;但是，如果同一UI界面多次开启后，内存中出现了更多同样的资源，则说明UI的管理方式存在一定问题。对于频繁使用的UI，我们建议在加载之后通过缓冲池对其进行缓存，后续使用时，直接通过缓冲池获取即可。而不要每次均通过AssetBundle进行加载，这种做法既会造成更大的CPU占用，同样会很大几率造成资源的冗余。&lt;/li&gt;
  &lt;li&gt;同时，如果多次开启的是不同UI界面，并且造成内存中同种资源的增加，则很有可能是UI在AssetBundle打包时形成了冗余（这种情况在目前的UGUI系统中较为常见）。对此，如果开发团队使用的是UGUI，那么我们的建议如下：
    &lt;ul&gt;
      &lt;li&gt;对于使用Unity 5.x的新AssetBundle打包系统，则打包时尽可能将同种Atlas的UI界面打成一个AssetBundle文件，否则将很有可能出现资源冗余的情况；&lt;/li&gt;
      &lt;li&gt;对于使用Unity 4.x的老AssetBundle打包系统，则可以将一个含有Atlas的Prefab（或其他Object）先打包，其他UI元素对其进行依赖即可。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;物理&lt;/h2&gt;
&lt;h4 id=&quot;rigidbody--capsulecollidercharactercontroller&quot;&gt;RigidBody + CapsuleCollider替换CharacterController&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;高效一些，因为 move 函数本身会进行较复杂的模拟运算。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;static-collidermove-expensive-delayed-cost&quot;&gt;Static Collider.Move (Expensive Delayed cost)警告&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Static Collider.Move (Expensive Delayed cost) 意味着场景中有静态碰撞体（不带有RigidBody的Collider）发生了移动，而该操作在Unity 4.x版本的PhysX 中会在后续的模拟中产生较高的开销，但在 5.x 中理论上开销并不明显。如果要消除该问题，只需定位到发生位移的Collider并挂上RigidBody 组件，打开其is kinematic 选项即可。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-3&quot;&gt;渲染&lt;/h2&gt;
&lt;h4 id=&quot;lightmap&quot;&gt;什么在影响lightmap尺寸&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;首先确认下Lightmap的类型，Single类型只生成一张，而Dual和Directional会生成两张。&lt;/li&gt;
  &lt;li&gt;其次，确认下当前的发布平台，Android下的Lightmap会比Standalone更小。因为不同平台采用的压缩格式不同。此外，Lightmapping中的Lock Atlas，Resolution，Padding等选项也会影响最后烘焙光照图的大小。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;lightmapmesh&quot;&gt;原先的Lightmap不再影响合并后的Mesh&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;总结一句就是不要讲使用了多个lightmap的mesh进行合并。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;bloom&quot;&gt;关于抗锯齿和BLOOM，有什么好的优化方案或者优秀插件推荐？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;通常在中低端的设备上，抗锯齿并没有比较高效的方案；而对于中高端的设备，可尝试直接使用 Unity 内置的 MSAA 功能，但也只推荐使用 2x。
关于Bloom效果，以下是适用于移动端，且评价较好的一款插件：BloomPro&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;assetbundle&quot;&gt;AssetBundle&lt;/h2&gt;
&lt;h4 id=&quot;xassetbundle-name&quot;&gt;5.x后设置好AssetBundle Name就可以实现依赖资源的独立打包&lt;/h4&gt;

&lt;h4 id=&quot;xassetbundle&quot;&gt;4.x时代不同版本之间的AssetBundle不能通用&lt;/h4&gt;

&lt;h4 id=&quot;unload&quot;&gt;unload顺序&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;在 Resources.UnloadUnusedAssets() 时，如果还没有进行AssetBunlde的Unload 操作，那么从AssetBunlde中加载的资源依然会因为被AssetBunlde引用而无法被卸载。&lt;/li&gt;
  &lt;li&gt;开发团队可以尝试 Destory 后做 AssetBunlde的Unload，最后进行 Resources.UnloadUnusedAssets()。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;assetbundlemanifestassetbundle&quot;&gt;生成AssetBundle的时候每个文件会多生成一个Manifest文件，这个文件也需要一起随着AssetBundle上传吗，在资源加载的时候具体怎么用呢？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;每个文件多生成的Manifest 文件是不需要上传的，其作用就是供开发人员查看AssetBundle 中的依赖关系等信息。&lt;/li&gt;
  &lt;li&gt;但除了每个文件多生成的 Manifest 以外，根目录下还会有一个与根目录同名的AssetBundle 以及 Manifest 文件，通过运行时加载这个AssetBundle，可以得到一个 AssetBundleManifest 对象，然后就可以通过这个对象得到AssetBundle直接的依赖关系。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;editorshader&quot;&gt;选择移动平台后，editor下shader显示错误&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;是Unity已知的一个问题，Android 和 iOS 的部分Shader在打包后，在Editor 下无法正常显示。 主要原因是在打包时，只会把对应平台的Shader预编译代码（如 gles ）打入包中，因此在 Editor 下会执行失败（通常 Editor 是 d3d 驱动）。 因此，目前只能尝试在Editor下重新指定Shader来绕过这个问题。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;texture&quot;&gt;Texture&lt;/h2&gt;
&lt;h4 id=&quot;iosastc&quot;&gt;ios上的ASTC格式&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;ASTC在 iOS 的高端机上是被支持的，因此理论上在 Editor 下不会强制把 ASTC 转为 RGBA32，建议尝试设置为 ASTC 后打包，从 Editor.log 中或者直接从包体大小上可以看出是否确实使用了ASTC。&lt;/li&gt;
  &lt;li&gt;一般来说，如果 RGBA16 的效果可以接受的话，建议使用 RGBA16，虽然打包时相对大一些，但是内存中相比 RGBA32 能够减半，但使用 ASTC 的话，虽然打包时比较小，但是在普通机型上会被处理成 RGBA32，导致过大的内存开销。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ui&quot;&gt;UI&lt;/h2&gt;
&lt;h4 id=&quot;shared-ui-mesh&quot;&gt;Shared UI Mesh&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Shared UI Mesh是在Unity 5.2 版本后UGUI系统维护的UI Mesh。在以前的版本中，UGUI会为每一个Canvas维护一个Mesh（名为BatchedMesh，其中再按材质分为不同的SubMesh）。而在Unity 5.2版本后，UGUI底层引入了多线程机制，而其Mesh的维护也发生了改变，目前Shared UI Mesh作为静态全局变量，由底层直接维护，其大小与当前场景中所有激活的UI元素所生成的网格数相关。&lt;/li&gt;
  &lt;li&gt;一般来说当界面上UI元素较多，或者文字较多时该值都会较高，在使用UI/Effect/shadow和UI/Effect/Outline时需要注意该值，因为这两个Effect会明显增加文字所带来的网格数。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;build&quot;&gt;Build&lt;/h2&gt;
&lt;h4 id=&quot;section-4&quot;&gt;打包注意&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;打包的时候Resources文件夹下所有的内容都会被打入resources.assets，要想包体小就删除不要的资源。而且Resources目录下所以资源启动时参与persistentmanager的初始化，内容多了会卡。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;static&quot;&gt;static选项&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;如果在Editor中进行勾选，则会在项目中生成一个较大的VBO，Runtime时通过该VBO来进行渲染，优点是有效减少了Draw Call，缺点是增大了发布游戏包的体积。&lt;/li&gt;
  &lt;li&gt;如果在Runtime通过脚本来进行Batching，则相当于把拼合的时间由Editor中搬到了Runtime，所以加载时间（一般在场景加载时执行Batching）会稍有增加，但游戏包的体积将相应减少。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-5&quot;&gt;动画&lt;/h2&gt;
&lt;h4 id=&quot;optimize-gameobject&quot;&gt;Optimize GameObject&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;在选择Optimize GameObjects后，可在Extra Transforms中加入你想挂载特效的骨骼结点，这样该骨骼结点将不会进行优化处理，即其Transfrom将不会消失。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-6&quot;&gt;工具&lt;/h2&gt;
&lt;h4 id=&quot;waitfortargetfps&quot;&gt;WaitForTargetFPS&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;该参数一般出现在CPU开销过低，且通过设定了目标帧率的情况下（Application.targetFrameRate）。当上一帧低于目标帧率时，将会在本帧产生一个WaitForTargetFPS的空闲等待耗时，以维持目标帧率。&lt;/li&gt;
  &lt;li&gt;该项在Unity引擎的主循环中其实是最早执行的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;gfxwaitforpresent--graphicspresentandsync&quot;&gt;Gfx.WaitForPresent &amp;amp; Graphics.PresentAndSync&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;这两个参数在Profiler中经常出现CPU占用较高的情况，其实是CPU和GPU之间的垂直同步（VSync）导致的，之所以会有两种参数，主要是与项目是否开启多线程渲染有关。当项目开启多线程渲染时，你看到的则是Gfx.WaitForPresent；当项目未开启多线程渲染时，看到的则是Graphics.PresentAndSync。&lt;/li&gt;
  &lt;li&gt;Gfx.WaitForPresent其真实的意思应该是为了在渲染子线程（Rendering Thread）中进行Present，当前主线程（MainThread）需要等待的时间。&lt;/li&gt;
  &lt;li&gt;最后，如何优化并降低这两个参数的CPU占用呢？ 那就是，忽略Gfx.WaitForPresent 和 Graphics.PresentAndSync这两个参数，优化其他你能优化的一切！WTF！&lt;/li&gt;
  &lt;li&gt;PS：这篇内容相当不错，建议看&lt;a href=&quot;https://blog.uwa4d.com/archives/presentandsync.html&quot;&gt;原文&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;editorassetdatabase&quot;&gt;editor下出现AssetDatabase内存过高可以无视&lt;/h4&gt;

&lt;h4 id=&quot;canvassendwillrendercanvases&quot;&gt;Canvas.SendWillRenderCanvases&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Canvas.SendWillRenderCanvases为UGUI中非常重要的接口，经常会出现较高的性能开销。当Canvas中的UI元素出现了长、宽或Alpha变化时，UGUI会更新其所在Canvas中所有UI元素的Transform、状态等等。Canvas中UI Mesh顶点较多的话，则该项将会出现较高的CPU开销。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;loadingupdatepreloading&quot;&gt;Loading.UpdatePreloading&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Loading.UpdatePreloading为Unity引擎的主要加载函数。场景中的资源加载（包括Texture、Mesh、Shader、AnimationClip等）和相关序列化操作均在其中体现。因此，如果该值开销较高，建议研发团队对资源进行进一步的优化和控制。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-7&quot;&gt;脚本&lt;/h2&gt;
&lt;h4 id=&quot;gameobjectgameobject&quot;&gt;如果脚本引用了GameObject，那转换场景的时候脚本和GameObject都没了，还会产生堆内存的吗？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;如果脚本是MonoBehaviour，而且在切换场景后所挂的Game Object被释放了，那么这个脚本对象所引用的堆内存就会在GC的时候被释放。 但有一种例外，如果是通过Static变量引用的堆内存，那么依然是释放不掉的，除非手动解开引用，比如变量置Null，数组Clear等等。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-8&quot;&gt;粒子&lt;/h2&gt;
&lt;h4 id=&quot;section-9&quot;&gt;粒子动态合并&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;del&gt;粒子系统的Draw Call动态拼合与半透明物体的动态拼合机制相当（粒子基本都是半透明材质）。而对半透明物体，由于其渲染顺序的限制（必须从后向前渲染，以保证渲染结果的正确性），动态拼合只能对渲染顺序相邻且材质相同的物体有效。而在决定半透明物体的渲染顺序时，Unity首先会按Shader中的RenderQueue进行排序；其次（相同RenderQueue时），会根据每个半透明物件到屏幕的距离，距离大的优先渲染。&lt;/del&gt;&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;因此，需要尽可能地将相同材质的粒子系统放在比较接近的深度下，才能更多地使动态拼合生效。但通常由于相机的运动、粒子系统的分散分布等原因造成粒子系统之间的穿插，能够动态拼合的数量往往都是很少的。&lt;/del&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;目前粒子系统已经不再进行 Draw Call 的拼合，因为在新版本5.3 中已通过多线程进行更新，暂时无法支持拼合，但性能已经得到提升。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Mon, 14 Aug 2017 22:54:29 +0800</pubDate>
        <link>https://caihua.tech/2017/08/14/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E4%B8%89%E5%91%A8/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/08/14/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E4%B8%89%E5%91%A8/</guid>
        
        <category>UWA</category>
        
        
      </item>
    
      <item>
        <title>每天一点UWA：第二周</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;内存&lt;/h2&gt;

&lt;h3 id=&quot;section-1&quot;&gt;概述&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;内存的开销无外乎以下三大部分：1.资源内存占用；2.引擎模块自身内存占用；3.托管堆内存占用。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-2&quot;&gt;资源内存&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;大头在纹理，其次在网格、动画片段和音频。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-3&quot;&gt;纹理&lt;/h4&gt;

&lt;h5 id=&quot;section-4&quot;&gt;从格式解决内存占用问题&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;选择正确的格式，比如Android上是ETC，ios的PVRTC，PC上DXT。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-5&quot;&gt;不同格式可能出现的问题：&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;因为ETC、PVRTC都是有损压缩因此可能出现色阶问题，如果用RGB32这样的格式虽然能解决问题但是内存占用太大。好的办法是在做纹理的时候减少色差范围，必要做出高对比度的阶梯式的图。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;比如，同样一张1024x1024的纹理，如果不开启Mipmap，并且为PVRTC格式，则其内存占用为512KB，而如果转换为RGBA32位，则很可能占用达到4MB。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;OpenGL ES2的设备只支持ETC1，但是ETC1不支持alpha通道。解决办法是将透明图分成两张，一个RGB24的保存RGB通道，一个alpha8的保存A通道，然后在使用时使用定制的shader去分别读取两个纹理图。&lt;/li&gt;
  &lt;li&gt;PS：OpenGL ES 3.0支持ETC2甚至ASTC，都是很好的支持透明通道的压缩格式。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-6&quot;&gt;选择合适的纹理设置&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;能512解决的事情别用1024&lt;/li&gt;
  &lt;li&gt;选择性的使用mipmap，对于UI这样的纹理使用完全没有必要用mipmap。&lt;/li&gt;
  &lt;li&gt;Read &amp;amp; Write选项会使得纹理的内存使用量增加一倍。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-7&quot;&gt;网格&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;mesh中顶点信息可以进行相关的优化，比如Normal、Color和Tangent这些数据要按照需要来做，不用的就不要做。而且顶点信息超多900还不能动态批处理。不需要就计算发现的时候就可以不用tangent数据了，有贴图的话color数据也不需要。&lt;/li&gt;
  &lt;li&gt;Color数据和Normal数据主要为3DMax、Maya等建模软件导出时设置所生成，而Tangent一般为导入引擎时生成。&lt;/li&gt;
  &lt;li&gt;如果项目对Mesh进行Draw Call Batching操作的话，那么将很有可能进一步增大总体内存的占用。比如，100个Mesh进行拼合，其中99个Mesh均没有Color、Tangent等属性，剩下一个则包含有Color、Normal和Tangent属性，那么Mesh拼合后，CombinedMesh中将为每个Mesh来添加上此三个顶点属性，进而造成很大的内存开销。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-8&quot;&gt;引擎模块自身占用内存&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;引擎自身中存在内存开销的部分纷繁复杂，可以说是由巨量的“微小”内存所累积起来的，比如GameObject及其各种Component（最大量的Component应该算是Transform了）、ParticleSystem、MonoScript以及各种各样的模块Manager（SceneManager、CanvasManager、PersistentManager等)…&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;一般情况下，上面所指出的引擎各组成部分的内存开销均比较小，真正占据较大内存开销的是这两处：WebStream 和 SerializedFile。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;PS：5.4以后没有webStream的概念了，不过还是要考虑WWW和LoadFromMemory中会保存AssetBundle原始数据的问题，参见&lt;a href=&quot;https://docs.unity3d.com/550/Documentation/Manual/AssetBundleCompression.html&quot;&gt;Asset Bundle Compression&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;AssetBundle所占的内存也需要考虑，尽可能做到按需加载，用完后及时的清理。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;mono&quot;&gt;托管堆内存占用/无效的Mono堆内存开销&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Mono的堆内存一旦分配，就不会返还给系统。这意味着Mono的堆内存是只升不降的。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-9&quot;&gt;不必要的堆内存分配主要来自于以下几个方面：&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;高频率地 New Class/Container/Array等。不要再update占用的函数中实例化对象。&lt;/li&gt;
  &lt;li&gt;Log输出，需要适当的减少log，只保留最关键的。&lt;/li&gt;
  &lt;li&gt;UIPanel.LateUpdate。这是NGUI中CPU和堆内存开销最大的函数,是由UI网格的重建造成。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-10&quot;&gt;一些推荐的办法&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;不要一次加载一个过大的资源，比如配置文件、纹理图等。这样会造成一次性申请过多的内存，但是还不回去了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-11&quot;&gt;内存泄漏&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;首先通过工具发现场景切换开始和结束时内存使用没有一致，这个现象不能说明内存就一定有泄漏。比如资源加载后常驻内存以备后续使用、Mono堆内存的只升不降等等，这些均可造成内存无法完全回落。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-12&quot;&gt;检查资源的使用情况，特别是纹理、网格等资源的使用&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;这段主要介绍了如何使用UWA的工具对纹理和网格进行检查，查看是否出现资源的内存泄漏。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;profilerwebstreamserializedfile&quot;&gt;通过Profiler来检测WebStream或SerializedFile的使用情况&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;直接通过Profiler Memory中的Take Sample来对其进行检测，通过直接查看WebStream或SerializedFile中的AssetBundle名称，即可判断是否存在“泄露”情况。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-13&quot;&gt;资源冗余&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;是指在某一时刻内存中存在两份甚至多份同样的资源。导致这种情况的出现主要有两种原因：&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;assetbundle&quot;&gt;AssetBundle打包机制出现问题&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;显而易见，对于公用资源需要进行合理的划分打包。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-14&quot;&gt;资源的实例化所致&lt;/h5&gt;

&lt;blockquote&gt;
  &lt;p&gt;在Unity引擎中，当我们修改了一些特定GameObject的资源属性时，引擎会为该GameObject自动实例化一份资源供其使用，比如Material、Mesh等。以Material为例，我们在研发时经常会有这样的做法：在角色被攻击时，改变其Material中的属性来得到特定的受击效果。这种做法则会导致引擎为特定的GameObject重新实例化一个Material，后缀会加上（instance）字样。其本身没有特别大的问题，但是当有改变Material属性需求的GameObject越来越多时（比如ARPG、MMORPG、MOBA等游戏类型），其内存中的冗余数量则会大量增长。虽然Material的内存占用不大，但是过多的冗余资源却为Resources.UnloadUnusedAssets API的调用效率增加了相当大的压力。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;上面描述的material的问题是个常见的问题。如果是直接改变还好说，会产生一个material instance，但是如果是在一段时间内线性的改变某个属性，那么后果很难说。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;建议&lt;/p&gt;
    &lt;blockquote&gt;
      &lt;p&gt;一般情况下，资源属性的改变情况都是固定的，并非随机出现。比如，假设GameObject受到攻击时，其Material属性改变随攻击类型的不同而有三种不同的参数设置。那么，对于这种需求，我们建议你直接制作三种不同的Material，在Runtime情况下通过代码直接替换对应GameObject的Material，而非改变其Material的属性。这样，你会发现，成百上千的instance Material在内存中消失了，取而代之的，则是这三个不同的Material资源。其中的益处，对于能够阅读到这里的你来说，应该已经不需要我多说了。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-15&quot;&gt;粒子&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Navmesh是不支持动态加载的目前的，办法是将多个场景做成prefab，然后用LoadLevelAdditive的方式加载，去拼接。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;assetbundle-1&quot;&gt;AssetBundle&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;本周第一篇关于AssetBundle的文章可以说有点陈旧了，在5.3以后解决了一些功能，比如AssetBundle.LoadFromFile加载LZMA文件的失败的问题。&lt;/li&gt;
  &lt;li&gt;还有就是在5.4以后已经没有webstream的概念了。&lt;/li&gt;
  &lt;li&gt;最后开始使用UnityWebRequest&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;lightmapsnapshotassetlightmap&quot;&gt;热更新打包时LightmapSnapshot.asset无法导出，导致场景丢失lightmap&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;LightmapSnapshot.asset是editor模式下的无法打包。解决办法是整个scene打包，lightmap信息会打包进去。或者在运行时调用Lightmapsettings.Lightmaps来设置，但是5.x后lightmap信息不会保存在prefab中，因此需要重设Prefab的Lightmap信息（Lightmapindex和Lightmapscaleoffset）。&lt;/li&gt;
  &lt;li&gt;还有一种可能是因为打包场景的时候shader会根据当前场景的使用情况来打包，如果打包是在一个空场景中那么bundle中的shader会失去lightmap和fog的支持。这个&lt;/li&gt;
  &lt;li&gt;PS: 这个问题在5.5.2中也存在，而且打包的时候是按照场景打包的，但是是不是shader丢失确实需要测试。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;prefab&quot;&gt;prefab打包&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;如果有一个Prefab，它的Dependencies都在Resources文件夹中，那么，当我在AssetBundle打包时，只打包这个Prefab（不指定BuildAssetBundleOptions.CompleteAssets和BuildAssetBundleOptionsCollectDependencies）是不能正确实例化的，因为AssetBundle中的资源和Resource文件夹下资源是不会建立依赖关系的（脚本除外，因为开启BuildAssetBundleOptionsCollectDependencies 时，脚本依然不会打包到AssetBundle中）。所以会出现Mesh、Material等的丢失。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;assetbundle-2&quot;&gt;卸载依赖AssetBundle的问题&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;比如prefabA和prefabB依赖于AtlasC，那么分别打包的话首先肯定是要先加载AtlasC的AssetBundle的。&lt;/li&gt;
  &lt;li&gt;但是如果先从AtlasC的AssetBundle中load了AtlasC，然后unload这个AssetBundle，此后加载或实例化A和B时，引擎将无法自动将C绑定给A和B进行使用。这个需要注意。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-16&quot;&gt;纹理格式&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;目前来讲，并不存在一个所有GPU平台都支持硬件解压的压缩格式。&lt;/li&gt;
  &lt;li&gt;ETC1 和 PVRTC 分别是Android和iOS上我们最推荐的格式。 但对于透明纹理，ETC1不支持，而 PVRTC 则可能有较大失真，因此更推荐使用 RGBA 16。&lt;/li&gt;
  &lt;li&gt;一般来说建议直接使用 Unity 默认的压缩格式（即选择 Compressed 即可，不需要做特殊设置），Unity 会做如下处理：
    &lt;ul&gt;
      &lt;li&gt;Android 上不带Alpha通道的图片采用 ETC1，带Alpha通道的图片采用True Color中的RGB16，TrueColor中的 RGBA16 会&amp;gt;比 RGBA32 更节省空间，但图像的显示质量会差一些；&lt;/li&gt;
      &lt;li&gt;iOS 上使用 PVRTC，但PVRTC格式要求纹理的长宽相等，且都是2的幂次（即POT，在ImportSettings中可以将NPOT的纹理自动转换成POT）。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;同时，我们不建议直接使用 RGBA32 格式的纹理，因为它占用了很大的内存。一般建议使用 RGBA16 和 ETC 格式的纹理来进行加载。 如果转换到 RGBA16 格式时出现了类似“色阶”的颜色问题，则建议尽可能避免大量的过渡色使用。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-17&quot;&gt;工具&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;unity的分析工具中的Reserved Total 和 Used Total为Unity引擎在内存方面的总体分配量和总体使用量。 一般来说，引擎在分配内存时并不是向操作系统 “即拿即用”，而是首先获取一定量的连续内存，然后供自己内部使用，待空余内存不够时，引擎才会向系统再次申请一定量的连续内存进行使用。&lt;/li&gt;
  &lt;li&gt;Overhead：
    &lt;ul&gt;
      &lt;li&gt;Overhead的计算方法是：Profiler当前帧统计的总耗时时间减去所有已知选项的累加时间，即引擎当前还无法识别模块的耗时时间。&lt;/li&gt;
      &lt;li&gt;Overhead数值理论上是趋向于0的，但是由于目前市面上的硬件设备、系统框架过于丰富，所以引擎可能无法识别所有模块的CPU开销。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Unity Profiler反馈的则是引擎的真实物理使用内存，有时内存使用数值比原生的分析工具小是正常的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Profiler中ManagedHeap.UsedSize是项目逻辑代码在运行时申请的堆内存， 
ManagedHeap.UsedSize过大，一方面可能会影响一次GC的耗时；另一方面也可能反映出脚本中不合理的GC Alloc。该选项只能通过优化代码来进行降低。 优化方法一般如下：
    &lt;ul&gt;
      &lt;li&gt;尽可能地复用变量，减少new的次数；&lt;/li&gt;
      &lt;li&gt;使用StringBuilder代替String连接，使用for代替foreach；&lt;/li&gt;
      &lt;li&gt;对于局部变量或非常驻变量，尽可能使用Struct来代替Class。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;本周读到的所有关于内存监控的部分都提到了一个概念就是Profiler所监控到的数据和Android上的PSS或者ios上检测到的会不一致，这                                                   个是因为Unity Profiler反馈的是引擎的真实分配的物理内存，而PSS中记录的则包括系统的部分缓存。一般情况下，Android或iOS并不会及时将所有App卸载数据进行清理，为了保证下次使用时的流畅性，OS会将部分数据放入到缓存，待自身内存不足时，OS Kernel会启动类似LowMemoryKiller的机制来查询缓存甚至杀死一些进程来释放内存。因此，并不能通过一两次的PSS内存没有完全回落来说明内存泄露问题。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Reserved GFX 中的内存，主要是纹理和网格资源。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-18&quot;&gt;渲染&lt;/h2&gt;
&lt;h4 id=&quot;lightmappcandroid&quot;&gt;Lightmap在PC上显示正常，但是转到Android平台上存在色差，颜色普遍偏暗的问题&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Unity烘焙的Lightmap是32bit的HDR图，而移动设备通常不支持HDR图(32bit per channel)，会按照LDR图(8bit per channel)的形式进行处理，因此会出现色偏问题。因此需要如下的处理：
    &lt;ul&gt;
      &lt;li&gt;在移动平台下使用Mobile/Diffuse材质，可载入Standard Assets(Mobile) package获得。&lt;/li&gt;
      &lt;li&gt;如果要获得更合适的效果，需要自行修改Lightmap的DecodeLightmap函数，该函数可在Unity\Editor\Data\CGIncludes\UnityCG.cginc文件中找到。需要说明的是，这种方法也不能达到与PC端完全一致的效果。&lt;/li&gt;
      &lt;li&gt;如果需要PC和移动平台的显示效果一致，可以用图像编辑软体修改Lightmap為LDR格式，例如PNG(8bit per channel)。&lt;/li&gt;
      &lt;li&gt;为了避免类似问题，请不要使用过于强烈的Light进行烘焙，因為Light的强度(Intensity)越高，色偏问题会越严重。若有阴影丢失时，可以尝试检查一下模型的Lightmapindex、Lightmapscaleoffset、UV2等影响Lightmap采样的一些参数。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;另一种可能是存在过曝现象，可以尝试将playersettings -&amp;gt; use direct3d 11关闭，看问题是否解决。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;lightmap&quot;&gt;lightmap动态加载&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Lightmap的动态加载，需要通过脚本将烘焙时每个物件的Lightmapindex和Lightmapscaleoffset记录下，并在运行时动态加载后设置回去的方式来实现。因为目前Lightmapindex和Lightmapscaleoffset信息是和场景绑定在一起，储存在Lightmapsnap.assets 中，发布时也是放在场景信息中，因此不会记录在Prefab 上。&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Mon, 07 Aug 2017 22:17:31 +0800</pubDate>
        <link>https://caihua.tech/2017/08/07/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E4%BA%8C%E5%91%A8/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/08/07/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E4%BA%8C%E5%91%A8/</guid>
        
        <category>UWA</category>
        
        
      </item>
    
  </channel>
</rss>
