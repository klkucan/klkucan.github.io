<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>蔡华的博客</title>
    <description>Be publicly useful and privately happy.</description>
    <link>https://caihua.tech/</link>
    <atom:link href="https://caihua.tech/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Thu, 05 Oct 2017 14:34:55 +0800</pubDate>
    <lastBuildDate>Thu, 05 Oct 2017 14:34:55 +0800</lastBuildDate>
    <generator>Jekyll v3.2.1</generator>
    
      <item>
        <title>Xlua摘要</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;加载机制&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;xlua在加载lua文件时会使用多个loader，LuaEnv的构造函数中有这么一段代码:&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;AddSearcher(StaticLuaCallbacks.LoadBuiltinLib, 2); // just after the preload searcher
AddSearcher(StaticLuaCallbacks.LoadFromCustomLoaders, 3);
#if !XLUA_GENERAL
AddSearcher(StaticLuaCallbacks.LoadFromResource, 4);
AddSearcher(StaticLuaCallbacks.LoadFromStreamingAssetsPath, -1);
#endif
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;从这段代码可以看出xlua主要的4个加载器分别是内置的lua的&lt;code class=&quot;highlighter-rouge&quot;&gt;LoadBuiltinLib&lt;/code&gt;，已经lua可能存在的两个目录，一个是Resources、另一个是StreamingAssets，通常来说我们也很有可能会把lua代码放到这两个里面。尤其是当用lua做热更新的时候，StreamingAssets是一个很好的选择。&lt;/li&gt;
  &lt;li&gt;当LuaEnv遇到一个&lt;code class=&quot;highlighter-rouge&quot;&gt;require&lt;/code&gt;的时候，就开始从这四个文件夹找&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;luac&quot;&gt;lua调用C#代码&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;unity中C#类分为两种，一种是继承了MonoBehaviour的，一种是一般的C#类。这两种都可以在lua中调用，但是调用方式不同。但是都需要给&lt;code class=&quot;highlighter-rouge&quot;&gt;LuaCallCSharp&lt;/code&gt;这个attribute。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对于一般的C#类型，可以使用这样的方式&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;local testClass = CS.Test
local test = testClass()
test.foo()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;对于继承MonoBehaviour的类是不能用上述方法的，因为在实例化的时候会报错。xlua在生wrap的时候没有考虑是否继承自mono，继承自mono的类不能用new，所以会报错。只能用下面的方法，注意第一个是已经在某个游戏对象上挂了脚本的情况，第二个是用lua动态添加脚本。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;self:GetComponent(&quot;MainUI&quot;):LoadScene(&quot;class1/class1&quot;)	

-- 或者

local mainui = self.gameObject:AddComponent(typeof(CS.MainUI))
mainui:LoadScene(&quot;class1/class1&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;需要注意一下对于静态方法是用&lt;code class=&quot;highlighter-rouge&quot;&gt;.&lt;/code&gt;，非静态是用&lt;code class=&quot;highlighter-rouge&quot;&gt;:&lt;/code&gt;，其实也可以用&lt;code class=&quot;highlighter-rouge&quot;&gt;.&lt;/code&gt;但是需要在函数定义的时候带自己self参数。对于unity中的一些函数这里尤为重要，比如&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-- 因为Find是静态方法所以用.
local cubes = GameObject.Find(&quot;Cubes&quot;)
-- 而Transform.Find其实是依赖于一个具体的GameObject的所以要用:
cube1 = cubes.transform:Find(&quot;Cube1&quot;).gameObject
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;luac-1&quot;&gt;lua与C#代码结合&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;如果想使用xlua的LuaBehaviour这个脚本，需要注意的是不能用加载器加载lua代码，而是dostring，否则不能使用self、注入的对象。但是awake方法是可以用的。需要注意要使用GetInPath，get方法我没成功过。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; // 用对象名字作为加载脚本的查询名字
 string luaname = GameRoot.Instance.GlobleUtil.NameDeleteClone(gameObject.name);

 // 直接用byte[] dostring
 AssetBundle bundle = AssetBundle.LoadFromFile(&quot;Assets/StreamingAssets/main/lua&quot;);
 TextAsset lua = bundle.LoadAsset(&quot;MainUI.lua&quot;, typeof(TextAsset)) as TextAsset;
 luaEnv.DoString(lua.bytes, luaname, scriptEnv);

 // 用 custom loader加载 但是无法使用self，也无法获取luaAwake这类的方法
 //luaEnv.DoString(&quot;require  '&quot; + luaname + &quot;'&quot;, luaname, scriptEnv);

 Action luaAwake = scriptEnv.GetInPath&amp;lt;Action&amp;gt;(&quot;MainUI.awake&quot;);
 luaStart = scriptEnv.GetInPath&amp;lt;Action&amp;gt;(&quot;MainUI.start&quot;);
 luaUpdate = scriptEnv.GetInPath&amp;lt;Action&amp;gt;(&quot;MainUI.update&quot;);
 luaOnDestroy = scriptEnv.GetInPath&amp;lt;Action&amp;gt;(&quot;MainUI.ondestroy&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;refout&quot;&gt;关于ref和out修饰符&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;一开始我测试的时候是本以为lua调用ref传入的参数，也会返回出修改的结果，但出乎我的意料，并没能修改，经过作者提示，lua是通过返回值返回的ref参数，如果函数本身就有返回值，那么最后一个参数是返回的ref或者out参数，如果是一个没有返回值的函数（C#中），在lua中同样可以让它给变量赋值，赋的值就是ref的结果。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 05 Oct 2017 14:28:20 +0800</pubDate>
        <link>https://caihua.tech/2017/10/05/Xlua%E6%91%98%E8%A6%81/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/10/05/Xlua%E6%91%98%E8%A6%81/</guid>
        
        <category>Lua</category>
        
        
      </item>
    
      <item>
        <title>每天一点UWA：第十周</title>
        <description>&lt;h2 id=&quot;assetbundle&quot;&gt;AssetBundle&lt;/h2&gt;
&lt;h4 id=&quot;assetbundle-1&quot;&gt;AssetBundle中的脚本&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;首先，需要说明的是，脚本本身的内容是不会被打包到AssetBundle文件中的，AssetBundle文件储存的仅是脚本的索引信息。因此，即便有多个AssetBundle中都存在UIAtlas这一脚本索引，对堆内存也几乎是不产生影响的，且不会产生冗余问题。&lt;/li&gt;
  &lt;li&gt;其次，脚本被当做资源且会产生依赖这一现象，仅在Unity 4.x版本中出现，而在Unity 5.0以后，脚本之间将不会产生依赖关系。因此，如果你目前还在使用Unity 4.x版本进行开发，那么依赖关系打包时确实需要注意这个问题，即依次Push A和B进行打包时，如果AssetBundle之间存在相同脚本，那么B会对A的脚本产生依赖。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;wwwassetbundlewebstreamassetbundlewwwdisposewebstream&quot;&gt;如果我用WWW加载了一个AssetBundle，创建了一块WebStream内存。这时候我用另一个东西保存这个AssetBundle的引用，然后用WWW给Dispose了，那么这块WebStream内存会释放掉么？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;如果仅是www.dispose，但是AssetBundle引用依然保留的话，那么WebStream是不会释放的。WebStream存在两个引用，一个是www对象，一个是加载出来的AssetBundle。仅这两个引用全部消除时，WebStream才会被Unity引擎回收，具体说明可见之前的技术文章：Unity AssetBundle内存管理机制详解。&lt;/li&gt;
  &lt;li&gt;5.4之后似乎没有webstream的概念了。因为很多方法现在都是直接从disk读取，或者先保存在读取。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;unloadunusedassetsinstantiateresoucesunloadassetgameobject-&quot;&gt;我发现如果不调用UnloadUnUsedAssets这个函数，则无法销毁通过Instantiate实例化出来的材质（包括纹理）。如果我尝试用Resouces.UnloadAsset来卸载挂在GameObject上的实例化材质, 则会闪退，请问这种情况该如何解决呢？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;如果想要直接销毁通过Instantiate实例化出来的材质、纹理等资源，则只能使用DestroyImmediate来进行销毁。研发团队可以参考NGUI中UI Draw Call组件里对动态材质的处理，来加深对动态创建以及销毁的理解。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;脚本&lt;/h2&gt;
&lt;h4 id=&quot;section-1&quot;&gt;关于字符串驻留导致的内存占用&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;https://blog.uwa4d.com/archives/USparkle_String-interning.html&lt;/li&gt;
  &lt;li&gt;https://gist.github.com/klkucan/6c51468ca6f92933356477745f0a50e0&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;androidassetbundleloadfromfileapplicationstreamingassetspathassetbundle&quot;&gt;Android用AssetBundle.LoadFromFile读取Application.streamingAssetsPath目录下的AssetBundle文件，用什么样的地址？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Unity 5.3之前，直接使用 Application.streamingAssetsPath 作为目录路径。&lt;/li&gt;
  &lt;li&gt;Unity 5.3之后，通过新增的LoadFromFile接口加载AssetBundle时，则需要改为 Application.dataPath+”!assets。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;nguiuieventlisteneronpressuibuttonpressuibuttonpressbuttonuibuttonnormaluieventlisteneronpresspress&quot;&gt;准确说这个不是一个优化的问题：NGUI的UIEventListener中的OnPress与UIButton的Press状态不能对应上。具体情况是我点击某个按钮并且按住不放，UIButton处于Press状态，然后移出了Button的范围，UIButton的状态变回了Normal，而UIEventListener中的OnPress并没有监听到，必须松开点击才能监听到。它们的Press状态切换有什么不一样呢？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;理论上UIButton的OnPress和UIEventListener的OnPress是在相同时间点触发的，即手指按下和手指抬起这两个时间点上。&lt;/li&gt;
  &lt;li&gt;而手指在按住状态下移开按钮时， UIButton的状态会变为Normal，这是因为其响应了OnHover的消息。因此如果要模拟UIButton的行为，至少要配合使用OnPress和OnHover两个消息。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;模型&amp;amp;动画&lt;/h2&gt;
&lt;h4 id=&quot;meshuv3uv4uvuv2&quot;&gt;求教Mesh导入后这里的uv3和uv4是怎么回事？有的模型只有uv和uv2，有的有四套。&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;如果在模型导入时就存在 uv2，uv3，uv4，那么这是因为在建模软件中添加了这些顶点属性。一般来说uv3和uv4的使用较为少见，通常是用来配合特殊的Shader实现特殊的效果。而uv2通常被用于Lightmap，uv2可以在建模软件中添加，也可以在Unity中通过Generate Lightmap UVs的选项来生成。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-3&quot;&gt;物理&lt;/h2&gt;
&lt;h4 id=&quot;section-4&quot;&gt;伤害检测、还有靠近采集物品时触发可以采集的提示箭头等，我们都使用了碰撞，请问如果不使用碰撞，可以用什么方法代替呢？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;使用Trigger也是较为合理的做法，如果想替代，可尝试根据距离、动画运行的时间点来进行判断。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-5&quot;&gt;性能综合&lt;/h2&gt;
&lt;h4 id=&quot;prefab&quot;&gt;prefab加载时依赖图片何时加载&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;首先说明一下，如果AssetBundle B和AssetBundle A产生依赖，那么在仅仅加载AssetBunde B中的Prefab B_prefab时，其本身开销仅为B_prefab的加载开销，对于AssetBundle A中的依赖资源并无影响。&lt;/li&gt;
  &lt;li&gt;但是在实例化B_prefab时，Unity引擎会去检查AssetBundle A中的依赖资源是否已经被加载好，如果没有加载好，则先加载AssetBundle A中相关资源，然后再实例化B_prefab。这其实就是大家经常遇到的初次实例化一个技能、角色时出现卡顿的主要原因。&lt;/li&gt;
  &lt;li&gt;因此，如果大家想加快B_prefab的实例化效率，那么对于其依赖关系AssetBundle A中的相关资源，可提前进行预加载，从而减少B_prefab实例化时的相关资源加载时间。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;unloadunusedassetsgc&quot;&gt;手动调用UnloadUnusedAssets+GC的问题&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;通过LoadLevel等API来切换场景时，Unity会自动触发Resources.UnloadUnusedAssets的操作，但在切换完成后再次调用Resources.UnloadUnusedAssets来确保卸载完全的做法也是较为常见的。但是在其它时间点不要调用。&lt;/li&gt;
  &lt;li&gt;对于大场景的MMO类型的游戏，因为切换场景的频率较低，也可以考虑每隔几分钟来手动触发一次Resources.UnloadUnusedAssets来降低内存。而GC的话，则不建议手动调用，即使是在切换场景时。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;resources&quot;&gt;Resources目录下的所有内容都会加载到内存里吗？如果里面东西多，是不是会导致占用内存过高？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;不会，Resources.Load也是即用即加载，但就目前我们统计的结果来看，Resources文件下的资源越多，其生成的ResourceManager内存占用也越大。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;font-texture-&quot;&gt;Font Texture 资源是如何生成的，因为我发现好像有重复的出现，如何优化呢？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;这是Unity为动态字体自动产生的纹理，一般来说不用特别关注。即使重复出现，里面的内容一般也是不一样的（内容即屏幕上显示的文字）。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;meshunitygpumeshcreatevbomeshdrawvbo&quot;&gt;重建的Mesh，Unity引擎会将其重新传入GPU端进行渲染，这部分开销主要体现在Mesh.CreateVBO和Mesh.DrawVBO中。&lt;/h4&gt;

&lt;h4 id=&quot;fk--statemachine-&quot;&gt;FK &amp;amp; Statemachine 状态机占用时间比较高，是否有优化的方法呢？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;影响该项的因素较多，一般为：
    &lt;ul&gt;
      &lt;li&gt;是否开启Optimize GameObjects选项，如果没有，建议开启；&lt;/li&gt;
      &lt;li&gt;场景中Active的GameObject（使用并开启了Animator组件的）是否较多，数量越多，则该项目开销越高；&lt;/li&gt;
      &lt;li&gt;GameObject的骨骼数越多、AnimationClip的采样次数越多，则该项开销也越高。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;因此，建议研发团队可从以上三种情况入手来优化FK &amp;amp; Statemachine的开销。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;prefabresourcesunloadassetxxxprefabprefab--destroy--resoucesunloadunused&quot;&gt;对Prefab资源的卸载、预览英雄模块、需要卸载英雄角色的资源、动画和材质都可以通过Resources.UnloadAsset(xxx)来顶点清除，而Prefab不行，Prefab 只能用 Destroy + Resouces.UnloadUnused()卸载吗？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Prefab如果想要单独卸载，只能使用DestroyImmediate来实现。同时，考虑到Prefab本身已经是很小的一个壳了，对内存的影响非常小，一般情况下是在切换场景的时候一起释放的。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 05 Oct 2017 14:25:20 +0800</pubDate>
        <link>https://caihua.tech/2017/10/05/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E5%8D%81%E5%91%A8/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/10/05/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E5%8D%81%E5%91%A8/</guid>
        
        <category>UWA</category>
        
        
      </item>
    
      <item>
        <title>每天一点UWA：第九周</title>
        <description>&lt;h2 id=&quot;assetbundle&quot;&gt;AssetBundle&lt;/h2&gt;
&lt;h4 id=&quot;assetbundle-1&quot;&gt;关于AssetBundle依赖的问题&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;如果Panel A和Panel B，它们均依赖一个共享Atlas C。如果在加载完AtlasC后卸载它所在的AssetBundle，再创建A和B，此时会失败。因为他们的依赖关系在AssetBundle上。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;serializedfileassetbundle&quot;&gt;请教一下，SerializedFile的卸载规则是什么呢？会跟随这AssetBundle一起卸载么？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;绝大部分的SerializedFile均由AssetBundle产生，当AssetBundle被卸载时，与其对应的SerializedFile也将销毁。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;wwwloadfromcacheordownloadwwwassetbundle-assetbundleassetbundle&quot;&gt;WWW.LoadFromCacheOrDownload只是在内存中有个引用，没有实际加载资源，调用WWW.assetbundle后也是么？ 那么依赖此AssetBundle的资源加载的时候，会自动触发此AssetBundle从磁盘加载对应的引用资源么？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;在调用WWW.assetBundle之后，内存中也只是存在较小的SerializedFile（不包含资源数据）。“那么依赖此AB的资源加载的时候”确实会触发该AssetBundle通过磁盘IO加载资源。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;build&quot;&gt;Build&lt;/h2&gt;
&lt;h4 id=&quot;optimize-mesh-data&quot;&gt;细谈Optimize Mesh Data选项&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;第五周的时候说过Optimize Mesh Data选项的问题，但是只是说了和模型上的optimize的区别和一些问题，下面详细说说这个选项，以下内容来自&lt;a href=&quot;http://www.cnblogs.com/yaukey/p/unity-build-setting-optimize-mesh-data.html&quot;&gt;这里&lt;/a&gt;。&lt;/li&gt;
  &lt;li&gt;Unity 在底层默认希望为你做尽可能多的优化，降低使用门槛，比如 BuildSetting 中的 Optimize Mesh Data 选项就是一个典型的例子。这个选项到底有什么用呢？文档描述为：&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Optimize Mesh Data	Remove any data from meshes that is not required by the material applied to them (tangents, normals, colors, UV).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;即是说：如果开启了此选项，将会在 Build 过程中根据场景中 Mesh 所使用的材质（或者说 shader）进行静态分析，来去掉 Mesh 中“无用”的数据（材质不使用的数据），比如：切线，发现，定点色，多余的 uv 等，以此减少数据量和最终构建的游戏包的大小。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;这是一个非常好的功能，如果 unity 不提供自己写插件恐怕还是比较麻烦的，但是在使用过程中有没有“坑”呢？有没有要注意的地方呢？答案当然是：有！&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果你在场景中有动态切换材质（主要是 shader 的改变），比如原始模型中带有法线，默认的材质没有使用法线，但是动态切换的材质却需要使用法线，那么你得注意很可能在编辑器中运行正常，一旦发布到真机就会出现很怪异的现象，会让人以为是 shader 在不同平台的兼容性或者数据精度等问题。譬如描边效果就是一个很好的例子。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;结论：如果使用此选项，请务必注意自己动态切换材质的游戏对象是否在场景中以静态的形式存在，shader 使用了哪些模型的数据，并根据实际情况做相应的调整。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;unity&quot;&gt;有没有什么办法可以提升Unity编辑器中代码的编译速度？我们现在每修改一次代码，等待的编译时间都将近半分钟。&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;对于大型项目来说，这确实是大家经常遇到的情况。一般来说，Unity Editor会按照脚本的依赖关系编译代码，其主要分为以下四个步骤：
    &lt;ul&gt;
      &lt;li&gt;编译Standard Assets、Pro Standard Assets和Plugins文件夹中的Runtime Script；&lt;/li&gt;
      &lt;li&gt;编译以上三个文件夹中Editor文件夹下的Script；&lt;/li&gt;
      &lt;li&gt;编译项目中所有剩余的Runtime Script（Editor文件夹以外Script；&lt;/li&gt;
      &lt;li&gt;编译剩余Script（即Editor文件夹中Script）。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;建议研发团队可以将一些长时间不需要改动的脚本代码（比如各种插件代码）放入到Standard Assets、Pro Standard Assets或Plugins文件夹中，这样这些代码只需要编译一次，后续的时间就都能节省下来。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;纹理&lt;/h2&gt;
&lt;h4 id=&quot;pvrtcios2&quot;&gt;如果纹理尺寸长宽不相等，那么即便是2的幂次，也不会被压缩成PVRTC格式纹理。建议在iOS平台中，尽可能保证纹理尺寸为2的幂次且长宽相等。&lt;/h4&gt;

&lt;h2 id=&quot;ui&quot;&gt;UI&lt;/h2&gt;
&lt;h4 id=&quot;nguipanelwidgetsatlasdcprofilemeshnguiwidgetsmeshatlas&quot;&gt;NGUI中不同panel下的Widgets使用同一个Atlas，会导致DC比较多，而且从profile中会有多个同名的mesh，以为NGUI中这些widgets的mesh是动态生成的，名字采用的就是Atlas的名字。&lt;/h4&gt;

&lt;h4 id=&quot;ngui&quot;&gt;对于NGUI而言，如果界面元素的坐标是非整数的数值，会导致界面元素模糊么？还有哪些原因会造成界面元素模糊？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;导致界面元素模糊的原因主要分为两个，
    &lt;ul&gt;
      &lt;li&gt;一是像素未对齐（通常就是因为坐标非整数造成），在相邻像素色差较大的情况下容易出现模糊，特别是文字部分；&lt;/li&gt;
      &lt;li&gt;二是纹理分辨率相对于屏幕的分辨率被缩小或放大，纹理被缩小通常会表现出锯齿感，而纹理被放大则会表现出模糊。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;而对于动态字体，通常只需要确保像素对齐即可使其不模糊，但需要注意的是，UGUI与NGUI都有全局缩放的功能(分别在Canvas Scaler和UIRoot组件上)，是为了确保不同分辨率下布局相同，也会使动态字体出现缩放，从而造成模糊的问题。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;工具&lt;/h2&gt;
&lt;h4 id=&quot;draw-callsetpass-callsetpass-calluwadraw-call&quot;&gt;Draw Call和Setpass Call，这两个指标主要是看哪一个？关于这点众说纷纭，很多地方都是说看SetPass Call，但是在UWA的性能测试中，还是把Draw Call当成唯一指标。&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;在 Unity 5.x 中，SetPass Call与 Draw Call相比，SetPass Call的指标与性能相关性更大（比如Static Batching的开启不影响Draw Call数，而SetPass Call通常会明显下降）。&lt;/li&gt;
  &lt;li&gt;但 SetPass Call在某些情况下也同样存在问题，比如往一个场景中添加任意个相邻且材质相同的大网格物体（使Dynamic Batching失效）时，SetPass Call并不会变化。因此在UWA中，我们所使用的是类似Profiler 中 Total Batches 这一项指标，通常该数值与 Frame Debugger 中的数值基本一致，因此可以通过该工具来查看每个Batch的内容，从而更有针对性地进行优化。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;shaderparse--shadercreategpuprogram-&quot;&gt;Shader.Parse 和 Shader.CreateGpuProgram 到底是做什么的？它们什么时候执行？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Shader.Parse体现的是Shader的加载和解析， Shader.CreateGpuProgram 是将Shader传入GPU的一次提交，GPU驱动会对其进行编译，以适应于特定的设备或平台。&lt;/li&gt;
  &lt;li&gt;在Unity 5.x版本中，Shader.Parse在Shader资源加载时进行执行，而 Shader.CreateGpuProgram在所在GameObject第一渲染时进行执行。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;模型&amp;amp;动画&lt;/p&gt;
&lt;h3 id=&quot;mesh&quot;&gt;关于Mesh合并的问题&lt;/h3&gt;
&lt;h4 id=&quot;static&quot;&gt;勾选了static的对象&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;只要是勾选的static的对象都会合并mesh，而不考虑材质使用问题。每个对象会变成submesh。&lt;/li&gt;
  &lt;li&gt;Unity 5.3之前，对于渲染顺序相邻且材质相同的SubMesh则会动态将其索引数组拼合，从而合成一个Draw Call。而Unity 5.3之后则不再拼合索引数组，因为在不切换材质时产生多个Draw Call的开销并不大，而这多个Draw Call会被统计为一个Batch。
    &lt;h4 id=&quot;section-2&quot;&gt;对于动态合并的对象&lt;/h4&gt;
  &lt;/li&gt;
  &lt;li&gt;Unity对于任何Mesh的面片都有65536的个数限制，拼合后的面片数也是如此。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;skinned-mesh-renderdraw-call&quot;&gt;请教，角色分部件换装可行吗？比如衣服裤子分开，都是用Skinned Mesh Render，有没有办法合并降低Draw Call？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;可以通过合并网格的方式来达到降低Draw Call的效果，具体可查看Asset Store中的换装例子：Character Customization。但是，在角色换装时需要注意以下几点：
    &lt;ul&gt;
      &lt;li&gt;装备与角色必须是共用一套骨骼的；&lt;/li&gt;
      &lt;li&gt;各装备之间所用的材质必须相同。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;开发者需要注意，只有同时满足以上两个条件时，才能达到只使用少量Draw Call来进行动态换装的效果。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-3&quot;&gt;渲染&lt;/h2&gt;
&lt;h4 id=&quot;shader&quot;&gt;要达到后续Shader都不出现加载开销，需要满足以下两个条件：&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;包含Shader的AssetBundle文件常驻内存；&lt;/li&gt;
  &lt;li&gt;Shader已经全Load加载好；&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 25 Sep 2017 10:58:00 +0800</pubDate>
        <link>https://caihua.tech/2017/09/25/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E4%B9%9D%E5%91%A8/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/09/25/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E4%B9%9D%E5%91%A8/</guid>
        
        <category>UWA</category>
        
        
      </item>
    
      <item>
        <title>每天一点UWA：第八周</title>
        <description>&lt;h2 id=&quot;assetbundle&quot;&gt;AssetBundle&lt;/h2&gt;
&lt;h4 id=&quot;assetbundleassetbundlehash&quot;&gt;打包AssetBundle的时候，我发现切换场景时，即使打同一个场景的AssetBundle，它们的Hash值都是不一样的，可能是什么原因造成的呢？&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;目前很可能是Shader Stripping造成的，其原理可见&lt;a href=&quot;https://docs.unity3d.com/Manual/class-GraphicsSettings.html&quot;&gt;文档&lt;/a&gt;。&lt;/li&gt;
  &lt;li&gt;简单来说就是根据当前场景对Shader进行简化，因此如果打包时包含的场景的Lightmap或Fog设置不同，打出来的AssetBundle包也有可能是不同的。可以尝试通过把Graphics Settings中的Shader Stripping设置进行修改来避免这个问题。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;prefabunloadtrueresourcesunloadunusedassets&quot;&gt;Prefab目前，只能通过Unload(True)和Resources.UnloadUnusedAssets卸载。&lt;/h4&gt;

&lt;h4 id=&quot;nguiatlasassetbudleresourcesunloadunusedassets1&quot;&gt;请教一下，为什么NGUI的Atlas通过AssetBudle载入之后，使用Resources.UnloadUnusedAssets()不能够释放呢？分析器里面引用是1，但是又找不到哪里引用了。&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;如果Unity Profiler中看到了资源的引用计数不为0，则说明该Atlas资源还在被索引，这样使用Resources.UnloadUnusedAssets()是无法进行卸载的。只有将其索引消除，该资源才会被认为是UnUsed资源，这样才能被Resources.UnloadUnusedAssets()卸载。该资源的引用计数不为0的原因可能有以下几种：
    &lt;ul&gt;
      &lt;li&gt;它被缓存在某些Container中，即它从AssetBundle或Resources中加载后，被直接缓存到某个容器中，从而产生了索引，只要它没有被清除出容器，那么索引将一直存在；&lt;/li&gt;
      &lt;li&gt;它被其他Material、Prefab等索引，而这些资源被缓存在某些容器中，即间接被容器缓存，只要索引它的资源不被清楚，那么它的索引页将一直存在。
就目前我们遇到的泄露问题来看，上述两点为最为主要的原因。因此，如果你的项目中也存在类似情况，建议首先以此为基础对容器的使用进行排查。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ui&quot;&gt;UI&lt;/h2&gt;
&lt;h4 id=&quot;uguisrcollview-mask&quot;&gt;UGUI的SrcollView Mask遮挡不住特效，这个有没有可行的解决方案？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;UGUI的Scrollview Mask组件使用的是Stencil Buffer，需要严格确保渲染顺序的正确性，这对于粒子系统或是其他的模型较难控制，因此可以尝试通过其他的方式，如实现一个四边形Alpha 裁剪的Shader，将ScrollView的裁剪区域传入Shader，从而模拟一个特效被“遮罩”的效果。以下是宣雨松博客中提出的一种方式，可以作为参考：
http://www.xuanyusong.com/archives/3518&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;spinenguiscrollviewspinespineshader&quot;&gt;Spine动画在NGUI的ScrollView滚动区域的层级也会出现问题，请问怎么裁剪Spine动画呢，Spine是骨骼，这不就等于给特效换Shader了吗？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;同上&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;uitextureuwa&quot;&gt;我们图标现在是制作成图集后再使用的，但是当图标数量很多的时候，图集的膨胀就很厉害了。对此我们的做法有两种：1）拆为多个图集；2）不再使用图集转而使用UITexture来使用。请问UWA有什么建议呢？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;使用图集的主要缺点在于内存较大，且管理不便；而使用UITexture的主要缺点在于产生的Draw Call较多（每个UITexture都会产生一个Draw Call且无法拼合），影响运行效率。&lt;/li&gt;
  &lt;li&gt;一切在于平衡，dc换内存或者内存换dc。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;uidraw-callenabledui-scrollrectenabled&quot;&gt;我发现当把UI挪到屏幕外时，Draw Call不会减少，只有设置Enabled去掉才能减少。UI是没有遮罩剔除这类功能吗？ 那是否意味着ScrollRect只能自己做动态加载或者动态设置Enabled之类的优化了？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;del&gt;因为UGUI合并网格时是以Canvas为单位的，所以只把一部分UI元素移除屏幕并不能降低Draw Call，在Unity 5.2版本以前需要满足两点：&lt;/del&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;del&gt;1． 使用Screen Space – Camera 的 Render Mode；&lt;/del&gt;&lt;/li&gt;
      &lt;li&gt;&lt;del&gt;2． 需要将移出的UI元素放在独立的Canvas中，然后整体移出屏幕。&lt;/del&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;但在Unity 5.2版本之后，上述方法也已经失效。&lt;/li&gt;
  &lt;li&gt;因此我们建议，在移出后，通过将Canvas的Layer修改为相机Culling Mask中未选中的Layer来去除这部分多余的Draw Call， &lt;strong&gt;但这种方法同样需要将移出的UI元素放在独立的Canvas中&lt;/strong&gt;。这种方法，相比Enabled的设置，可以减少一定的CPU开销。而对于ScrollRect，如果包含的UI元素较多，确实需要自己做动态加载和动态设置Enabled来进行优化。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;uimaskui-&quot;&gt;UI展示动画时，使用Mask做和使用UI本身做 ，哪个效率会更高些?&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;一般来说建议尽可能少用Mask组件，该组件的使用对于Draw Call会有较大的影响，也可尝试用 Rect2D Mask来代替。而如果直接通过改变UI元素本身来做动画，当涉及的UI元素数量较大时，容易引起较高的网格重建开销。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;工具&lt;/h2&gt;
&lt;h4 id=&quot;uwa-profilermanagedstaticreferencesstatic-classaclassbclassb&quot;&gt;关于定位游戏中冗余资源引用的问题。UWA的报告中能定位到具体的引用代码么？ 在Profiler只能看到ManagedStaticReferences但是具体不到引用的位置。比如Static ClassA引用一个ClassB，ClassB上引用了一个资源，就定位不出这个引用的过程。请问这种情况下有没有比较好的方法找到引用关系呢？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;该问题在Unity 5.3 之前的版本中都没有方式来进行定位，只能由研发团队根据对代码的推测了进行定位；而在Unity 5.3之后的版本则可以借助Memory Profiler来尝试定位，而Memory Profiler尚未原生集成在Unity Editor中，需要在以下网址进行下载：
https://bitbucket.org/Unity-Technologies/memoryprofiler&lt;/li&gt;
  &lt;li&gt;只是记一下有这么个工具。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;粒子&lt;/h2&gt;
&lt;h4 id=&quot;prewarm&quot;&gt;粒子系统的Prewarm主要用来做什么的，这个怎么优化呢？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;ParticleSystem.Prewarm的出现表示当前加载、激活或者首次渲染的粒子系统开启了”Prewarm”选项，而开启该选项的粒子系统在加载后会立即执行一次完整的模拟。以“火焰”为例，Prewarm开启时，加载后第一帧即能看到“大火”，而不是从“火苗”开始逐渐变大。但Prewarm的操作通常都有一定的耗时，建议在可以不用的情况下，将其关闭。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;模型&amp;amp;动画&lt;/h2&gt;
&lt;h4 id=&quot;profileranimatorinitializeanimatorinstance-animator&quot;&gt;我在Profiler中看到Animator.Initialize这个耗时很大，这个有什么建议么?Animator.Instance 是因为Animator过多造成的吗？&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2FTechSharing_40%2F1.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;由图中可知，Animator.Initialize主要是在Instantiate实例化时引起（实际上，GameObject.Active操作也会引起Animator.Initialize），而其具体的耗时原因是相关资源（主要是AnimationClip资源）的加载所致。因此，我们的建议如下：
    &lt;ul&gt;
      &lt;li&gt;对GameObject的Instantiate实例化操作进行检测，对于频繁Instantiate的GameObject尝试进行缓存；&lt;/li&gt;
      &lt;li&gt;对Animator Controller中的AnimationClip资源进行精简，可尝试动态加载和替换Animator Controller中的AnimationClip；&lt;/li&gt;
      &lt;li&gt;由（1）引申出来，对于已经在缓存池中通过GameObject.Active操作造成的Animator.Initialize开销，建议通过Active/Deactive Animator组件来代替Active/Deactive GameObject，这种操作可以避免Animator.Initialize时内部组织结构创建的开销，进而降低Animator.Initialize时的CPU开销。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-3&quot;&gt;性能综合&lt;/h2&gt;
&lt;h4 id=&quot;gameobjectinstantiategameobject&quot;&gt;GameObject.Instantiate()每实例化一个GameObject到场景中，会造成卡顿，有什么办法可以优化吗？就算我采用了异步加载，仍然会有稍许的卡顿感。除了缓存池，是否还有别的方法？&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;建议研发团队先通过Unity Profiler来确定该性能卡顿的位置。如果只是一个空的GameObject，Instantiate实例化是很快的。一般来说，Instantiate实例化时间较长，主要由以下三个原因：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;与资源的加载有关：对于这种情况，研发团度需要精简资源，或者预加载资源来降低实例化的开销；&lt;/li&gt;
      &lt;li&gt;序列化信息比较多：当GameObject上的Component比较多时，其Instantiate实例化性能会受到影响，比如说粒子系统，这种情况就只能通过分帧实例化，或者通过缓存池来避免；&lt;/li&gt;
      &lt;li&gt;自定义组件的Awake：在Instantiate实例化时，其GameObject上挂载脚本的Awake函数也会被触发，其中产生的CPU占用，也会被计算在Instantiate实例化内。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;inspectortransformfind&quot;&gt;预设中的变量，拖拽到Inspector面板和Transform.find这两种方法对加载影响是一样的吗？&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;对加载性能有微小的不同。Transform.Find 是可以灵活控制调用时机的，可以真正要用的时候再进行Transform.Find，这样GameObject被实例化时效率会更高一些 。但如果拖上去，GameObject被实例化时，该变量就需要进行序列化。因此，加载和实例化时两者的性能会存在一些微小的变化。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;assetbundlecreatefrommemory&quot;&gt;我有一个关于AssetBundle资源加密问题。CreateFromMemory这里不推荐大规模使用，那是不是我们要放弃对一部分资源的加密？还是说有其它的解决办法？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;由于CreateFromMemory的加载速度相较其他的接口而言，耗时明显增大，因此我们确实不建议大规模使用。&lt;/li&gt;
  &lt;li&gt;就目前而言，除了使用CreateFromMemory，并没有其他高效直接的方法进行资源加密，因此，确实需要放弃对一部分资源的加密。同时，目前存在一些工具可以从更底层的方式来获取和导出渲染相关的资源，如纹理、网格等，因此，对于这部分的资源加密并没有十分的必要性。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 25 Sep 2017 10:54:00 +0800</pubDate>
        <link>https://caihua.tech/2017/09/25/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E5%85%AB%E5%91%A8/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/09/25/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E5%85%AB%E5%91%A8/</guid>
        
        <category>UWA</category>
        
        
      </item>
    
      <item>
        <title>每天一点UWA：UI优化小结</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;说明&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;经过一个半月的学习，对UI的优化有了一些心得，同时也希望把零散的知识点总结到一起，因此有了这个专题。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;那些需要关注的性能指标函数&lt;/h2&gt;
&lt;h4 id=&quot;ugui&quot;&gt;UGUI参考的函数&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;1、Canvas.SendWillRenderCanvases()
该API为UI元素自身发生变化（比如被Enable或者被缩放，移动并不算）时所产生的调用。发生在canvas被渲染之前。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;2、Canvas.BuildBatch
该API为UI元素合并的Mesh需要改变时所产生的调用。通常之前所提到的Canvas.SendWillRenderCanvases()的调用都会引起Canvas.BuildBatch的调用。另外，Canvas中的UI元素发生移动也会引起Canvas.BuildBatch的调用。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;ngui&quot;&gt;NGUI参考的函数&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;UICamera.Update()
该函数通常在点击时出现开销。因此，当该函数的CPU开销较高时，通常都是因为调用了其他的较为耗时的函数引起。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;UIRect.Update()
该函数通常在需要更新锚点位置时出现开销。因此，当该函数的CPU开销持续较高时，通常是因为当前场景中有较多的UI元素绑定了OnUpdate模式的锚点。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;UIPanel.LateUpdate()
该函数为NGUI最主要的CPU开销，包含了对所有UI界面包括其下UI元素的状态更新、网格重建、DrawCall合并等操作。大量的UI变动或者不合理的UIPanel布局都有可能导致该函数出现较高的峰值。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;UIRect.Start()
该函数主要涉及到UI元素的初始化操作，通常在UI界面被实例化时出现并产生一定的CPU开销。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ui&quot;&gt;一些需要知道的UI原理&lt;/h2&gt;

&lt;h4 id=&quot;mesh&quot;&gt;mesh合并&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;一个Canvas下的所有UI元素都是合在一个Mesh中的。&lt;/li&gt;
  &lt;li&gt;而在Batch前，UGUI会根据这些UI元素的材质（通常就是Atlas）以及渲染顺序进行重排，在不改变渲染结果的前提下，尽可能将相同材质的UI元素合并在同一个SubMesh中。所以同一Canvas下不同的材质的UI可能会合并为多个SubMesh。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;ui-1&quot;&gt;UI重建&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;关于UI重建的说明。UI其实是一些3D的quad，这一下就能够理解为什么存在UI的减少少drawcall了，这个和模型的减dc完全一个原理。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;在UGUI中，网格的更新或重建（为了尽可能合并UI部分的DrawCall）是以Canvas为单位的，且只在其中的UI元素发生变动（位置、颜色等）时才会进行。因此，将动态UI元素与静态UI元素分离后，可以将动态UI元素的变化所引起的网格更新或重建所涉及到的范围变小，从而降低一定的开销。而静态UI元素所在的Canvas则不会出现网格更新和重建的开销。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在这再次对更新和重建进行一些详细的说明：&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;更新指的是UI元素本身的某些属性发生变化，从而需要重新生成，或者更新顶点属性。比如颜色变了，在UGUI中颜色的变化是通过修改顶点色实现的，所以就需要更新UI元素对应的每个顶点的顶点色属性（可以认为就是修改下某个数组里的数值）。位置移动一般是不会造成顶点属性的变化的。所以总的来说，“网格更新”更新的是顶点属性。&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;blockquote&gt;
      &lt;p&gt;UI元素和别的网格不同点在于，UI的网格是需要进行合并的，并且在UGUI中是以Canvas为单位的，在提交GPU之前，同一Canvas下的所有UI元素都会被合入一个Mesh中（但包含多个SubMesh）。所以位置的移动，顶点属性的变化，都会导致这个Mesh要重新合并，也就是网格重建。这也是为什么说要“动静分离”的原因，完全静态的Canvas是不需要重建的，但只要里面有一个UI元素在动，就会引起Canvas的重建。&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;blockquote&gt;
      &lt;p&gt;在UGUI里更改了Image的Color属性，其原理是修改顶点色，因此是会引起网格的Rebuild的（即Canvas.BuildBatch操作，同时也会有Canvas.SendWillRenderCanvases的开销）。通过修改顶点色来实现UI元素变色的好处在于，修改顶点色可以保证其材质不变，因此不会产生额外的Draw Call。&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;blockquote&gt;
      &lt;p&gt;Unity自带的UI Shader处理颜色时，改 _Color属性不会触发顶点重建吗？&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;blockquote&gt;
      &lt;p&gt;在UI的默认Shader中存在一个Tint Color的变量，正常情况下，该值为常数(1,1,1)，且并不会被修改。如果是用脚本访问Image的Material，并修改其上的Tint Color属性时，对UI元素产生的网格信息并没有影响，因此就不会引起网格的Rebuild。但这样做因为修改了材质，所以会增加一个Draw Call。&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;blockquote&gt;
      &lt;p&gt;综上所述，移动不一定会更新，但是会重建。而颜色变化或者大小变化带来的都是重建。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;优化建议：&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;动静分离，动的频率不同也分离，减少Mask组件的使用，使用Mask不仅会增加GPU端渲染的压力，同时也会造成CPU端DrawCall的明显上升。可尝试用RectMask2D来进行替换。&lt;/li&gt;
  &lt;li&gt;减少OnEnable和OnDisable，通过移动位置、改变摄像机culling mask。&lt;strong&gt;后者可能会一定程度地提高内存的开销（UIDrawCall中存储的Mesh）&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;修改material改颜色和直接改color属性在性能消耗要权衡。一个加drawcall一个会重建，要根据测试结果来。&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sun, 10 Sep 2017 01:02:01 +0800</pubDate>
        <link>https://caihua.tech/2017/09/10/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-UI%E4%BC%98%E5%8C%96%E5%B0%8F%E7%BB%93/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/09/10/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-UI%E4%BC%98%E5%8C%96%E5%B0%8F%E7%BB%93/</guid>
        
        <category>UWA</category>
        
        
      </item>
    
      <item>
        <title>每天一点UWA：第七周</title>
        <description>&lt;h2 id=&quot;ui&quot;&gt;UI&lt;/h2&gt;
&lt;h4 id=&quot;npot-tolarger-potuipixel-perfect&quot;&gt;NPOT采用 ToLarger 的模式拉成POT，如果是UI界面（开启Pixel Perfect）的话，可能显示时会有较大视觉损失。&lt;/h4&gt;

&lt;h4 id=&quot;unity-5xugui&quot;&gt;在Unity 5.x版本下，我们在用UGUI的过程中发现它把图集都打进了包里，这样就不能自动更新了，请问图集怎么做自动更新呢？&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;在Unity 5.x中UGUI使用的Atlas确实是不可见的，因此无法直接将其独立打包。&lt;/li&gt;
  &lt;li&gt;建议，可以把Packing Tag相同的源纹理文件，打到同一个AssetBundle中（设置一样的AssetBundle Name），从而避免Atlas的冗余。同时这样打包可以让依赖它的Canvas的打包更加自由，即不需要把依赖它的Canvas都打在一个AssetBundle中，在更新时直接更新Atlas所在的AssetBundle即可。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;scrollrectcanvassendwillrendercanvases&quot;&gt;ScrollRect在滚动的时候，会产生Canvas.SendwillRenderCanvases，有办法消除吗？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;ScrollRect在滚动时，会产生OnTransformChanged的开销，这是UI元素在移动时触发的，但通常这不会触发Canvas.SendWillRenderCanvases。&lt;/li&gt;
  &lt;li&gt;如果观察到Canvas.SendWillRenderCanvases耗时较高，可以检查下ScrollRect所在的Canvas是否开启了Pixel Perfect的选项，该选项的开启会导致UI元素在发生位移时，其长宽会被进行微调（为了对其像素），而ScrollRect中通常有较多的UI元素，从而产生较高的Canvas.SendWillRenderCanvases开销。因此可以尝试关闭Pixel Perfect看效果是否可以接受，或者尝试在滚动过程中暂时关闭Pixel Perfect等方式来消除其开销。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;ngui&quot;&gt;对NGUI字体错乱有什么好的解决方案吗？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;有这么几种可能：
    &lt;ul&gt;
      &lt;li&gt;一次展开文字太多了。这种情况在部分高通机型和Unity早期版本上都经常出现，现在也偶尔有，究其原理是FontTexture的扩容操作做得不够快或者收到了硬件驱动的限制。&lt;/li&gt;
      &lt;li&gt;一般来说有两种方法可以解决：（1）减少面板中的字体内容；（2）一开始就用超大量的字体去扩容，将动态字体的FontTexture扩大到足够大；文字渲染与开发团队编写的多线程渲染发生了冲突。这种情况也常有发生，特别是通过GL.IssuePluginEvent方式来开启多线程渲染的项目，就会容易出现问题。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;就我们的优化经验来看，第一种情况发生的可能性比较大。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;工具&lt;/h2&gt;
&lt;h4 id=&quot;draw-callsetpass-callsetpass-calluwadraw-call&quot;&gt;Draw Call和Setpass Call，这两个指标主要是看哪一个？关于这点众说纷纭，很多地方都是说看SetPass Call，但是在UWA的性能测试中，还是把Draw Call当成唯一指标。&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;在 Unity 5.x 中，SetPass Call与 Draw Call相比，SetPass Call的指标与性能相关性更大（比如Static Batching的开启不影响Draw Call数，而SetPass Call通常会明显下降）。但 SetPass Call在某些情况下也同样存在问题，比如往一个场景中添加任意个相邻且材质相同的大网格物体（使Dynamic Batching失效）时，SetPass Call并不会变化。因此在UWA中，我们所使用的是类似Profiler 中 Total Batches 这一项指标，通常该数值与 Frame Debugger 中的数值基本一致，因此可以通过该工具来查看每个Batch的内容，从而更有针对性地进行优化。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;脚本&lt;/h2&gt;
&lt;h4 id=&quot;editor-getcomponent--tgameobject-gc-alloc&quot;&gt;Editor 下，当调用GetComponent() 且 T组件并不在当前的GameObject 上时，确实会出现GC Alloc。&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;首先在发布后是不会出现的。&lt;/li&gt;
  &lt;li&gt;这是因为在Editor下，Unity的MissingComponentException实现所致，在出现以上情况时，Unity 并不是直接返回一个 NULL，而是返回一个代理 Object用来储存一些相关信息，在后续被访问时可以给出更详细的报错信息。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;eventsystemupdate&quot;&gt;EventSystem.Update()占用过高怎么优化？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;EventSystem.Update 的开销分为两个部分：
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;来自被触发的响应事件，这部分的开销实际上并不属于事件系统本身，比如：某次点击触发了一个开销很高的逻辑函数，尤其是涉及到资源的加载和实例化。对于这类开销，我们建议通过Profiler.Begin/EndSample或者UWA提供的UWA API，对这些逻辑函数进行进一步的分析。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;事件检测的开销，在默认情况下所有的UI元素都是事件检测的目标，因此当界面上UI元素数量很多，且长时间接触屏幕时，会有较高的持续开销。对于这类开销，我们建议通过以下几种方式来优化：&lt;/p&gt;
        &lt;ul&gt;
          &lt;li&gt;合理划分子Canvas，只有需要检测事件的界面才需要挂上GraphicRaycaster组件。&lt;/li&gt;
          &lt;li&gt;在Unity5.2之后的版本中，尽可能将不需要参与事件检测的UI元素的 Raycast Target 属性的勾选去掉。而对于Unity 4.x的版本，则可以尝试对UI部分的源码来进行修改以达到类似的效果。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;模型&amp;amp;动画&lt;/h2&gt;
&lt;h4 id=&quot;animator-controlleranimator-controller&quot;&gt;动态替换Animator Controller后删除旧的Animator Controller，但是其中的动画片段资源没有被删除。&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;销毁Animator Controller并不会释放其内所引用的AnimationClip资源的，所以内存没有明显下降是正常的。建议按照以下方式做个试验：&lt;/li&gt;
  &lt;li&gt;销毁Animator Controller 后，通过Unity Profiler立刻真机Take Sample，查看Animation Clip的Ref count是否为0；&lt;/li&gt;
  &lt;li&gt;如果不是，则需要进一步查看这些资源的索引出处；如果为0，则可以通过UnloadUnusedAssets或UnloadAsset来将其从内存中去除。&lt;/li&gt;
  &lt;li&gt;PS:在unity中很多对象只是个包装器，或者只是包含了其它资源的引用，因此消耗这些包装器并不会真正的销毁资源对象。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-3&quot;&gt;渲染&lt;/h2&gt;
&lt;h4 id=&quot;shaderwarmupallshaderscreategpuprogramshaderassetbundleshadervariantcollectionshader&quot;&gt;我使用Shader.WarmupAllShaders操作，在后续加载资源还是有CreateGPUProgram出现。(Shader都在一个AssetBundle文件中，都是常驻内存的，不会删掉)是必须使用ShaderVariantCollection来加载Shader吗？&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;WarmupAllShaders仅能对当前内存中的Shader进行warm up。后续如果又有Shader加载进来，则仍然会出现CreateGPUProgram操作。&lt;/li&gt;
  &lt;li&gt;所以如果出现问题中的现象应该还是有shader打包到别的AssetBundle中了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;materialsetpassfast&quot;&gt;Material.SetPassFast占用很高，这是在第一次实例化一个特效，但是第二次实例化就不会出现高值了，请问能怎么优化吗？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;该过程是在处理Shader，Unity 5.3以后在第一次显示时才会将Shader进行Warmup，所以就会造成一次峰值卡顿。&lt;/li&gt;
  &lt;li&gt;上面那个问题就很好的解决了这个问题，加载完shader后可以主动调用一次Shader.WarmupAllShaders函数。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;unity-3dshader&quot;&gt;在Unity 3D中，shader是何时编译的，在何时加载入显存中的（本条来自知乎）？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Editor中：修改shader并保存时立即编译。&lt;/li&gt;
  &lt;li&gt;Runtime下，无论哪个平台，都是在进入场景时加载shader object内容到内存，但是首次实际调用渲染时才编译，编译完成之后会cache下来。&lt;/li&gt;
  &lt;li&gt;有两种优化方法：
    &lt;ul&gt;
      &lt;li&gt;
        &lt;ol&gt;
          &lt;li&gt;调用Shader.WarmupAllShaders()，自动编译该场景中用到的所有shader。该方法在Unity5中已经废弃。&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;ol&gt;
          &lt;li&gt;在项目设置的GraphicsSettings中，可以导出ShaderVariantCollection，并在Preloaded Shader中导入，这样的话就可以在载入场景时一并编译需要预加载的shader，这样的优化在移动平台上用得比较多。&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//docs.unity3d.com/Manual/OptimizingShaderLoadTime.html&quot;&gt;具体见&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sun, 10 Sep 2017 00:55:48 +0800</pubDate>
        <link>https://caihua.tech/2017/09/10/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E4%B8%83%E5%91%A8/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/09/10/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E4%B8%83%E5%91%A8/</guid>
        
        <category>UWA</category>
        
        
      </item>
    
      <item>
        <title>从零开始开发一款AR应用</title>
        <description>&lt;h2 id=&quot;vuforia&quot;&gt;Vuforia&lt;/h2&gt;

&lt;h3 id=&quot;vuforia-1&quot;&gt;什么是vuforia&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;我没有自己看过它的概念，但是在使用的过程中它的作用实现图片、模型的识别，识别后就可以显示我们预设好的内容了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section&quot;&gt;怎么使用&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;进入&lt;a href=&quot;https://developer.vuforia.com/&quot;&gt;Vuforia&lt;/a&gt;，右上角注册。&lt;/li&gt;
  &lt;li&gt;点击Develop进入下图&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://imglf.nosdn.127.net/img/Nld0N0tacnNuUG5VNXRRdFoySzlrcHh6WnF5VExXYmU3dStWRlRPak9URkhDR1RnVjNzTmN3PT0.png?imageView&amp;amp;thumbnail=500x0&amp;amp;quality=96&amp;amp;stripmeta=0&amp;amp;type=jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;License Manager：管理你的授权，其实和其它一些SDK一样就是管理一下APP key（就是一串字符串）。在使用vuforia的SDK的时候需要用到。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Target Manager：target就是你扫描的图片或者模型或者其它什么的东西，当你扫描完成后如果匹配上了，就会在手机上显示相关的内容。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;license&quot;&gt;生成License&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;点击add按钮→选择类型（我选的是Development，因为只是用来学习）→输入APP name→点击Confirm&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;完成上述内容后你会得到下图的内容
&lt;img src=&quot;http://imglf1.nosdn.127.net/img/Nld0N0tacnNuUG5VNXRRdFoySzlraDRYN3lNcWlBbW0zTkowTnp6YVBuaGI0a0NPUmtJYmpRPT0.png?imageView&amp;amp;thumbnail=500x0&amp;amp;quality=96&amp;amp;stripmeta=0&amp;amp;type=jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;点击ddd这个license，会进入下图。这个license key在程序开发中需要用到。
&lt;img src=&quot;http://imglf2.nosdn.127.net/img/Nld0N0tacnNuUG5VNXRRdFoySzlra2I4dDJiZmpTWG9DSDQxdFk1b05BLy9GZS9ldVBSUGVnPT0.png?imageView&amp;amp;thumbnail=500x0&amp;amp;quality=96&amp;amp;stripmeta=0&amp;amp;type=jpg&quot; alt=&quot;image&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;target&quot;&gt;生成Target&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;选择Target Manager tab&lt;/li&gt;
  &lt;li&gt;点击add database。其实这里用database是很准确的，因为生成的target就像一个数据库，而我们摄像头扫描到的内容就是数据，通过查询如果在DB中找到了相同的数据就认为是匹配到了。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;选择类型（我用的是Device），输入名字，点击Create。结果如下：
&lt;img src=&quot;http://imglf1.nosdn.127.net/img/Nld0N0tacnNuUG5VNXRRdFoySzlrcVJJdDRQMERyam9NaXI0Ujd0TFUrZy9FWml1Y2xjeTNRPT0.png?imageView&amp;amp;thumbnail=500x0&amp;amp;quality=96&amp;amp;stripmeta=0&amp;amp;type=jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;点击target（ddd）进入
&lt;img src=&quot;http://imglf.nosdn.127.net/img/Nld0N0tacnNuUG5VNXRRdFoySzlrcWtSdVlGMXFzY1pUd3E1dTl5bzRDYm9CWXhpTUlMN0Z3PT0.png?imageView&amp;amp;thumbnail=500x0&amp;amp;quality=96&amp;amp;stripmeta=0&amp;amp;type=jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;点击add target。这个里面有多种target类型。我们选择最简单的single image。这个也是市面上很多AR应用使用的，也就是手机扫描一个图片，然后显示一个对应的模型。在这个页面中，file是选择你要上传的图片。width设置和场景中虚拟内容大小一致即可。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://imglf2.nosdn.127.net/img/Nld0N0tacnNuUG5VNXRRdFoySzlraXhkS2c3eGFqaWh4RUNTZURzYWg3R0lrREhnbjdJaWVnPT0.png?imageView&amp;amp;thumbnail=500x0&amp;amp;quality=96&amp;amp;stripmeta=0&amp;amp;type=jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;输入名字然后点击add，下图是我之前设置好的一些target。
&lt;img src=&quot;http://imglf0.nosdn.127.net/img/Nld0N0tacnNuUG5VNXRRdFoySzlrdnJueVZWd0Z3MlJaNVdpY0FjS2ZHSHp4cmdsR29NbkZnPT0.png?imageView&amp;amp;thumbnail=500x0&amp;amp;quality=96&amp;amp;stripmeta=0&amp;amp;type=jpg&quot; alt=&quot;image&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;-这里如果点击一个target，会进入下图。注意两个红色框，点击下面那个【Show Features】按钮后图片上会出现黄色区域，这个有点像做了个卷积识别色块的边缘。黄色部分越多说明在摄像头识别时越容易。而Augmentable指数对于了这个数值，也是越高越好。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://imglf2.nosdn.127.net/img/Nld0N0tacnNuUG5VNXRRdFoySzlra1FkWEV5T0lHUjRmTjViOVc1TDlFVWVFeDJvOUNoWUF3PT0.png?imageView&amp;amp;thumbnail=500x0&amp;amp;quality=96&amp;amp;stripmeta=0&amp;amp;type=jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;add target页面有个download database按钮，可以选择要下载什么数据。注意对于target的理解完全可以用数据库的概念套入。你下载了什么数据，在应用中才能对下载数据进行使用和比对。点击download后出现
&lt;img src=&quot;http://imglf2.nosdn.127.net/img/Nld0N0tacnNuUG5VNXRRdFoySzlrdVUvSjRUWnVxbDkrYjdlYUwvSmNobTlobjc0VnpqanlBPT0.png?imageView&amp;amp;thumbnail=500x0&amp;amp;quality=96&amp;amp;stripmeta=0&amp;amp;type=jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;选unity editor，然后点击download按钮。会得到一个unitypackage文件，然后导入到工程中。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;unity&quot;&gt;Unity部分的开发&lt;/h2&gt;

&lt;h4 id=&quot;vuforia-sdk&quot;&gt;导入vuforia sdk&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;可以在vuforia官网下载unity对应的sdk，也可以通过asset store下载Vuforia AR Starter Kit来直接使用，我两个都试过在设置上是一样的。后者有很多自带的demo很不错。&lt;/li&gt;
  &lt;li&gt;导入刚才获得的target package。&lt;/li&gt;
  &lt;li&gt;从asset store上随便下载个免费的模型。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-1&quot;&gt;场景设置&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;创建新场景&lt;/li&gt;
  &lt;li&gt;找到ARCamera和ImageTarget的prefab拖入场景。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;arcamera&quot;&gt;ARCamera设置&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://imglf0.nosdn.127.net/img/Nld0N0tacnNuUG5VNXRRdFoySzlrcktNS08wRXdURko4YWZYTDByT1ZQWXFSOWtOT2I0Z0pRPT0.png?imageView&amp;amp;thumbnail=500x0&amp;amp;quality=96&amp;amp;stripmeta=0&amp;amp;type=jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;点击ARCamera，再点击图中按钮进行设置。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://imglf1.nosdn.127.net/img/Nld0N0tacnNuUG5VNXRRdFoySzlrb3BUNkIxc0JZQXhiMCtrR2sxMUoxRWdjUHZrbTFHY0R3PT0.png?imageView&amp;amp;thumbnail=500x0&amp;amp;quality=96&amp;amp;stripmeta=0&amp;amp;type=jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;上图中第一个框就是之前申请的APP key&lt;/li&gt;
  &lt;li&gt;第二个框是它们导入的target，我在这个demo中导入的target的名字就是【target_images】,注意这两个复选框一定要都选。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;imagetarget-&quot;&gt;ImageTarget 设置&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://imglf1.nosdn.127.net/img/Nld0N0tacnNuUG5VNXRRdFoySzlraFhSQVBGbWwzU0xJa0pkYTBXUXAvRU05MnY2MDkzVlZBPT0.png?imageView&amp;amp;thumbnail=500x0&amp;amp;quality=96&amp;amp;stripmeta=0&amp;amp;type=jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;红框部分Type需要选择图中的&lt;/li&gt;
  &lt;li&gt;db选择我们导入的target_images。如果是导入了Vuforia AR Starter Kit会有几个自带的target。&lt;/li&gt;
  &lt;li&gt;image target选择你要用的图片。在一个场景中可以有多个ImageTarget对象，不同的对象选择不同的图片即可。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://imglf.nosdn.127.net/img/Nld0N0tacnNuUG5VNXRRdFoySzlrdkhac0hzOG11MDlKeVYyZ2JEZ3Z5SmR3NE9jSjMyQXNnPT0.png?imageView&amp;amp;thumbnail=500x0&amp;amp;quality=96&amp;amp;stripmeta=0&amp;amp;type=jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;上图中的马就是要显示的模型，注意要作为ImageTarget的子对象。马下面的那个白色就是ImageTarget。&lt;/li&gt;
  &lt;li&gt;对于要显示模型的位置和角度，只要记住手机摄像头面向的方向是白色方块的方向，只要要怎么显示模型就有了参考。我图中的设置是因为我要用摄像头扫描显示器上的图片，所以马是这样放置的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-2&quot;&gt;测试&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;如果你用的笔记本电脑带摄像头的，可以直接运行测试了。没有的，找个webcam就行了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-3&quot;&gt;有用的事件代码&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;DefaultTrackableEventHandler类的OnTrackingFound函数是match到了图片后调用的函数，在这个里面可以做一些逻辑功能。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;apk&quot;&gt;打包apk&lt;/h2&gt;

&lt;h4 id=&quot;keystore&quot;&gt;生成keystore&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;build里面选择Android&lt;/li&gt;
  &lt;li&gt;在player setting里面的publishing setting中可以生成keystore，方法看最后的附录。&lt;/li&gt;
  &lt;li&gt;至于jdk和SDK都可以在网上下载到。NDK比较尴尬，unity在Android上的IL2CPP需要r10e，这个版本已经有点难下到了。我最后没用这个。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-4&quot;&gt;结束语&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;到此为止一个最简单的AR应用就做完了，整个过程浪费时间在注册和下载Android SDK。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-5&quot;&gt;附录&lt;/h2&gt;
&lt;h4 id=&quot;keystore-1&quot;&gt;keystore生成&lt;/h4&gt;
&lt;p&gt;The keystore is a signature file that is used to sign your apk. When you create development builds Unity will not sign the apk.&lt;/p&gt;

&lt;p&gt;You only need one Keystore file for your projects. The file is your signature. To create one do this:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;In the publishing settings check the “Create New Keystore” box.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Click browse and choose a location where you want to store the file. It should be somewhere central since it’s not really related to your project.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Set a protection password for the file and confirm it.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Select “Create a new key” from the “Key Alias” dropdown.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;-PS:此处注意，选择了create a new key后最上面会自动勾选use existing keystore，无视即可。在弹出的窗口里面输入相关内容。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;A window should open which you have to fill with your personal data about your organisation / person. The alias at the top is just a name of the keystore. If you have multiple identities make sure you choose a meaningful name. You need to set a keystore password. Note this is not the same as the protection password above. As far as i know they can be the same, but for security you should use two different. If you haven’t write the passwords onto a sheet of paper ;)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Click “Create Key” to generate your keystore file.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;To use a keystore for signing you have to:&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Check the “Use Existing Keystore” box.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Click browse and select your keystore file.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;enter your protection key.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;select your desired identity from the alias dropdown.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;enter the alias password in the field below&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Make sure you have set your Android Market Licensing RSA Public Key at the bottom of the publishing settings. The public key has to be acquired from your Google market account.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Now create your APK file and it will be signed with your identity.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Note: You can create multiple Keys / Identities in one Keystore file. The first protection password will protect the file itself. When you select an identity from the file in the alias dropdown you have to type in the password for the identity.&lt;/p&gt;

</description>
        <pubDate>Sat, 09 Sep 2017 22:57:20 +0800</pubDate>
        <link>https://caihua.tech/2017/09/09/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%BC%80%E5%8F%91%E4%B8%80%E6%AC%BEAR%E5%BA%94%E7%94%A8/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/09/09/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%BC%80%E5%8F%91%E4%B8%80%E6%AC%BEAR%E5%BA%94%E7%94%A8/</guid>
        
        <category>杂</category>
        
        
      </item>
    
      <item>
        <title>每天一点UWA：第六周</title>
        <description>&lt;h2 id=&quot;assetbundle&quot;&gt;AssetBundle&lt;/h2&gt;
&lt;h4 id=&quot;section&quot;&gt;这是一个很长的问题：&lt;/h4&gt;
&lt;h4 id=&quot;assetbundle-aabbb&quot;&gt;字体作为多个资源的依赖包，会在游戏中被加载多次。我们现在有个问题，AssetBundle A资源依赖于这个字体，加载A的时候加载了一份字体，然后B资源也依赖这字体，而后加载B的时候我们没有去重复加载字体，这时候发现B资源上出现了字体丢失的现象。&lt;/h4&gt;

&lt;h4 id=&quot;unityb&quot;&gt;请问加载资源的时候，Unity会自动去识别内存里是否有它的资源依赖包吗？如果有的话，为什么B加载的时候找不到已经存在内存中的字体？这里需要手动去做些什么处理吗？&lt;/h4&gt;

&lt;h4 id=&quot;bundlemassetbundleunloadfalseassetbundleunloadfalse&quot;&gt;同时我发现依赖包资源如果进行了bundle.m_AssetBundle.Unload(false)以后，其他依赖于这个包的资源就引用不到了。我们流程上对于每个读进来的AssetBundle，都会加载完后马上进行Unload(false)，请问如果是依赖包的话，是不是不能对其进行这步操作？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;这个问题其实是典型的一个AssetBundle使用的问题，其中牵扯的细节在unity的文档中都有。&lt;/li&gt;
  &lt;li&gt;总结来说就是对于公共资源的字体，在A和B加载前要提前加载好，这样unity根据依赖关系会自动的找到字体asset。&lt;/li&gt;
  &lt;li&gt;但是如果加载A完成后直接卸载了字体的AssetBundle，那么加载B时肯定会出错。此时字体asset虽然还在（因为用的是Unload(false)），但是unity已经无法依靠依赖关系来作用在B上了。同时如果测试再次加载字体AssetBundle，则原有的字体asset出现内存泄漏问题。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;shaderbuildin&quot;&gt;自己下载了shader包，如何替换buildin资源？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;需要完全的替换，shader自己不会关联，而且很多时候用的是buildin的material，测试用的就是buildin的shader。&lt;/li&gt;
  &lt;li&gt;还有一个情况是prefab中用的shader的GUID和自己导入的不同，可以用通过如下脚本进行替换。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;using UnityEngine;
using System.Collections;
using UnityEditor;
using System.IO;

public class BuildScript {

    [MenuItem(&quot;Build/RefreshMat&quot;, false, 501)]
    static void RefreshMat() {
        var guids = AssetDatabase.FindAssets(&quot;t:Material&quot;);
        foreach (var guid in guids) {
            var path = AssetDatabase.GUIDToAssetPath(guid);
            if (path.ToLower().EndsWith(&quot;mat&quot;)) {
                var mat = AssetDatabase.LoadAssetAtPath&amp;lt;Material&amp;gt;(path);
                if (mat &amp;amp;&amp;amp; mat.shader) {
                    Debugger.Log(&quot;{0}\n{1}\n{2}\n{3}\n&quot;, path, mat.shader.name,
                        mat.shader.GetInstanceID(),
                        Shader.Find(mat.shader.name).GetInstanceID());
                    mat.shader = Shader.Find(mat.shader.name);
                }
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;font&quot;&gt;Font&lt;/h2&gt;
&lt;h4 id=&quot;assetbundleprofiler&quot;&gt;一个字体打包到AssetBundle中，加载后在profiler中看到两份&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;通常TTF文件会包含一个字体的多个字型，如可能包含正常字型、加粗字型、斜体字型等。而在Unity中会将其分为不同的Font资源，且他们之间会相互依赖。所以，如果项目中确实需要加粗字型的话，内存里出现两个Font是正常的，但如果实际上不需要加粗，那么可以尝试寻找一个不包含加粗字型的字体文件来替换该TTF文件。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;profileriphone-appuifontcachefontfortext2siphone52srendertexture&quot;&gt;在用Profiler真机查看iPhone App时，发现第一次打开某些UI时，Font.CacheFontForText占用时间超过2s，这块主要是由什么影响的?若iPhone5在这个接口消耗2s多，是不是问题很大？这个消耗和已经生成的RenderTexture的大小有关吗？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Font.CacheFontForText主要是指生成动态字体Font Texture的开销, 一次性打开UI界面中的文字越多，其开销越大。&lt;/li&gt;
  &lt;li&gt;这个消耗也与已经生成的Font Texture有关系。简单来说，它主要是看目前Font Texture中是否有地方可以容下接下来的文字，如果容不下才会进行一步扩大Font Texture，从而造成了性能开销。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;texture&quot;&gt;Texture&lt;/h2&gt;
&lt;h4 id=&quot;assetbundletexture&quot;&gt;游戏里重复的特效较多，有些只是图案相同但改变了颜色参数，如果都打成独立AssetBundle，则内存里面会有多份Texture。关于这样的打包一般有什么推荐的方法呢？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;只保留一份初始纹理资源，并通过Shader在运行时改变其整体配色，从而达到不同的效果。&lt;/li&gt;
  &lt;li&gt;如果是局部配色不同，那么可以在原始纹理的基础上加一种或几种Mask纹理，用来负责颜色的自适应调配，然后再通过Shader来达到不同的展示效果。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ui&quot;&gt;UI&lt;/h2&gt;
&lt;h4 id=&quot;gameobjectdeactivate&quot;&gt;GameObject.Deactivate消耗大&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;GameObject.Activate/Deactivate本身通常不会产生很高的开销，产生高开销的是其OnEnable/OnDisable操作。&lt;/li&gt;
  &lt;li&gt;如果是自定义脚本，可以考虑优化OnEnable/OnDisable函数中的操作。&lt;/li&gt;
  &lt;li&gt;如果是UI可以考虑通过移出屏幕或者改摄像机的culling layer来实现隐藏。前面有讲过相关的内容。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;canvascanvas&quot;&gt;动静分离或者多Canvas带来性能提升的理论基础是什么呢？如果静态部分不变动，整个Canvas就不刷新了？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;在UGUI中，网格的更新或重建（为了尽可能合并UI部分的DrawCall）是以Canvas为单位的，且只在其中的UI元素发生变动（位置、颜色等）时才会进行。因此，将动态UI元素与静态UI元素分离后，可以将动态UI元素的变化所引起的网格更新或重建所涉及到的范围变小，从而降低一定的开销。而静态UI元素所在的Canvas则不会出现网格更新和重建的开销。&lt;/li&gt;
  &lt;li&gt;PS：位置和颜色变化应该会造成更新，如果出现血条那样的会造成mesh变化从而重建。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;ui-1&quot;&gt;UI优化&lt;/h3&gt;
&lt;h4 id=&quot;ugui&quot;&gt;UGUI参考的函数&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;1、Canvas.SendWillRenderCanvases()
该API为UI元素自身发生变化（比如被Enable或者被缩放，移动并不算）时所产生的调用。发生在canvas被渲染之前。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;2、Canvas.BuildBatch
该API为UI元素合并的Mesh需要改变时所产生的调用。通常之前所提到的Canvas.SendWillRenderCanvases()的调用都会引起Canvas.BuildBatch的调用。另外，Canvas中的UI元素发生移动也会引起Canvas.BuildBatch的调用。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;ngui&quot;&gt;NGUI参考的函数&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;UICamera.Update()
该函数通常在点击时出现开销。因此，当该函数的CPU开销较高时，通常都是因为调用了其他的较为耗时的函数引起。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;UIRect.Update()
该函数通常在需要更新锚点位置时出现开销。因此，当该函数的CPU开销持续较高时，通常是因为当前场景中有较多的UI元素绑定了OnUpdate模式的锚点。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;UIPanel.LateUpdate()
该函数为NGUI最主要的CPU开销，包含了对所有UI界面包括其下UI元素的状态更新、网格重建、DrawCall合并等操作。大量的UI变动或者不合理的UIPanel布局都有可能导致该函数出现较高的峰值。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;UIRect.Start()
该函数主要涉及到UI元素的初始化操作，通常在UI界面被实例化时出现并产生一定的CPU开销。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;优化建议：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;动静分离，动的频率不同也分离，减少Mask组件的使用，使用Mask不仅会增加GPU端渲染的压力，同时也会造成CPU端DrawCall的明显上升。可尝试用RectMask2D来进行替换。&lt;/li&gt;
  &lt;li&gt;减少OnEnable和OnDisable，通过移动位置、改变摄像机culling mask。&lt;strong&gt;后者可能会一定程度地提高内存的开销（UIDrawCall中存储的Mesh）&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;ngui-1&quot;&gt;NGUI的图集在内存里存了多份，求问怎么清理？&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2FTechSharing_31%2F1.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;游戏运行中，UI Mesh出现多份不同内存的情况，是正常的，因为随着UI widget使用的增加或减少，创建的UI Mesh是会随着变化的。&lt;/li&gt;
  &lt;li&gt;同时，如果不同UIPanel中存在相同Atlas的Widgets，则也会出现上图中的情况。因此，建议大家遇到这种情况时，查看单帧中NGUI UI Mesh重名的是否有多份重名资源。如果存在，则说明相同Atlas中的资源被多个不同的UIPanel所使用，这种情况是需要尽可能避免的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;工具&lt;/h2&gt;
&lt;h4 id=&quot;profilerothersystemexecutableanddlls&quot;&gt;Profiler中Other下System.ExecutableAndDlls的内存很大&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;一般来说，在移动游戏中，该选项经常在iOS真机运行时会看到，System.ExecutableAndDlls该项显示的是执行文件和所调用的库（物理、渲染、IO等系统库）的总和。&lt;/li&gt;
  &lt;li&gt;开发团队不用太担心该选项的数值，因为很多应用均在共用这些库，并且它对于真实项目的内存压力非常小，几乎没有影响，而且OS也不会因为该内存而杀掉游戏或应用。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;loadingupdatepreloading&quot;&gt;Loading.UpdatePreloading&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;这是Unity引擎最主要的加载函数。该项一般在切换场景时或主动动态加载资源时较大。 一般来说，加载资源越多、越复杂，则其反映的Loading.UpdatePreloading耗时则越大。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;profilernot-saved&quot;&gt;Profiler中Not Saved是指什么？&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2FTechSharing_31%2F3.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Profiler中的Not Saved指的是项目中通过代码生成的各种资源记录。如上图所示，其Mesh均为NGUI插件通过脚本生成的UI界面Mesh资源。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;脚本&lt;/h2&gt;
&lt;h4 id=&quot;section-3&quot;&gt;判断怪物是否在相机视野范围有没有什么好方法？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;可以在脚本中添加 OnWillRenderObject 或者 OnBecameVisible/OnBecameInvisible 的回调函数，这些函数分别会在对应的Renderer可见或者变为可见/不可见时被调用。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;amonobehaviourb-monobehaviourdestroybgameobjectabnullinspectormissinggcbagcnullgc&quot;&gt;我们测试了下发现，在名为A的MonoBehaviour中，有个数组来存放名为B的 MonoBehaviour对象的引用。当我们其他的逻辑去Destroy了B对象所在的GameObject后，在A对象中的数组里，遍历打印，它们（B的引用）都为Null，在Inspector面板上看是missing。而这时候进行GC，堆内存其实并未释放这些B对象。只有当A对象中的数组被清空后，再调用GC，才可释放这些对象所占内存。这种现象是否正常？为什么值为Null但却还是被引用着，无法通过GC释放呢？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;首先这种现象是正常的。这是Unity中对Null的检测做了特殊的处理所致，在Unity中MonoBehaviour对象除了存在于Managed Heap中（作为“壳”），在Native内存中还会有一个相对应的“实体”，在调用Destroy时，真正被释放的正是这个“实体”。而在判断一个MonoBehaviour对象是否为Null时，Unity会首先检测“实体”是否已经被销毁，如果是则返回为true，但此时Managed Heap中的“壳”实际上依然是被引用的，从而就会出现对象的Null判断为true，但实际上还是被引用着，无法被GC释放的问题。
.&lt;/li&gt;
  &lt;li&gt;相关的细节可见官方blog对Unity中Null判断的解释：
http://blogs.unity3d.com/2014/05/16/custom-operator-should-we-keep-it/&lt;/li&gt;
  &lt;li&gt;PS：本周最佳收获。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-4&quot;&gt;粒子&lt;/h2&gt;
&lt;h4 id=&quot;fbxreadwrite-enablecrasheditor&quot;&gt;真机下关闭粒子使用的FBX的Read/Write Enable属性后crash，Editor模式下没有。&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;将FBX上的Read/Write Enabled关闭后，内存中便不再保存其Mesh的副本（只存在显存中），因此其属性就不可再被访问和修改。&lt;/li&gt;
  &lt;li&gt;粒子系统通常需要动态地修改其粒子的顶点属性。因此，理论上来说，供粒子系统使用的Mesh是需要开启Read/Write Enabled的，而在Editor下Mesh和Texture都是强制开启的，所以在真机上就会出现问题。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-5&quot;&gt;粒子的优化&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;减量。总的来说就是减少粒子的数量，减少粒子的范围，如果离摄像机远可以考虑不显示粒子。最后升级到5.3之后，因为粒子系统有优化。&lt;/li&gt;
  &lt;li&gt;粒子系统拼合。是指引擎会将若干个材质相同且深度相同的粒子系统在渲染前进行合批（Batch），从而通过一个Draw Call来对其粒子系统进行渲染，进而降低粒子系统的渲染开销。至于合并机制之前也写到过。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;spritepacking-tag&quot;&gt;粒子系统所使用的纹理并不是Sprite类型的，因此不需要设置Packing Tag。&lt;/h4&gt;

&lt;h2 id=&quot;section-6&quot;&gt;模型&amp;amp;动画&lt;/h2&gt;
&lt;h4 id=&quot;skinnedmeshrendererbakemeshinstantiate&quot;&gt;SkinnedMeshRenderer.BakeMesh这个函数一般是什么时候调用呢?在Instantiate后调用么？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;SkinnedMeshRenderer.BakeMesh 的作用在于：将一个蒙皮动画的某个时间点上的动作，Bake成一个不带蒙皮的Mesh，从而可以通过自定义的采样间隔，将一段动画转成一组Mesh序列帧。而后在播放动画时只需选择最近的采样点（即一个Mesh）进行赋值即可，从而省去了骨骼更新与蒙皮计算的时间。&lt;/li&gt;
  &lt;li&gt;该方法的优点是用内存换计算时间，在场景中大量出现同一个带动画的模型时，效果会非常明显。该方法的缺点是内存的占用极大地受到模型顶点数、动画总时长及采样间隔的限制。因此，该方法只适用于顶点数较少，且动画总时长较短的模型。同时，Bake的时间较长，因此需要在加载场景时完成。比较经典的适用场景为MOBA游戏中的小兵。&lt;/li&gt;
  &lt;li&gt;PS：关于skinnedmesh转mesh这个问题比较大，可以参考网上的资源。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;mecanim&quot;&gt;为什么尽可能使用Mecanim&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Mecanim动画系统的多线程计算性能较之老版本的单线程计算性能要高；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Mecanim动画系统可以对GameObject开启 “Optimize Game Object” 选项。该选项为Unity引擎在4.3版本中加入的新功能，旨在优化Mecanim动画系统的底层计算开销。开启该选项，Animator.Update和MeshSkinning.Update的CPU占用均存在一定程度的降低；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Mecanim动画系统的Retargeting功能可以让多个不同的角色使用同一套的AnimationClip资源，比如主城中的NPC角色，其大部分共性动画可尝试使用一套Idle、Wave等动画片段，从而进一步降低动画资源的内存开销；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Unity引擎已经不再对老版本动画系统进行维护。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-7&quot;&gt;动画的优化&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;动画模块的开销主要来自于MeshSkinning.Update（蒙皮网格每帧更新）和Animation.Update and Animator.Update（骨骼动画的更新开销）两个函数。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;研发团队在尽可能保证动画效果的同时，对模型的网格进行简化，建议尝试使用Unity Asset Store中的SimpleLOD插件来对骨骼蒙皮网格进行简化；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;关于MeshSkinning.Update， 一般来说该值的大小取决于蒙皮网格（Skinned Mesh）的面片数和骨骼数。所以如果该值过高，我们的建议是减面。同时我们建议开发团队勾选“GameObject.Optimize”，该方法是将fbx生成的GameObject的层级关系移除，使动画系统不用每帧再去更新这些骨骼节点（GameObject）的Transform，因此能一定程度上降低CPU开销，此优化选项默认是关闭的），该方法特别适合于在配置较低的手机上运用骨骼角色多的情况。&lt;/li&gt;
  &lt;li&gt;开启Optimize GameObject默认情况下会将动画网格下的所有骨骼结点隐藏，但是，可以通过“Extra Transform to Expose”查看想通过脚本获取的骨骼结点，这样既可以提升该角色的动画模块性能，又可以达到获取某个关键结点的需求。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Optimize Game Objects对于老版本的Animation无效。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用SkinnedMeshRenderer.BakeMesh&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;控制场景中具有Animator Controller组件的GameObject。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-8&quot;&gt;材质实例数量过多有何影响&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Material的内存占用一般很小，所以大量的Material资源对于内存的压力其实很小的。&lt;/li&gt;
  &lt;li&gt;它本身对于场景的切换时间是有影响的，即资源冗余得越多，切换场景时，UnloadUnusedAssets的开销越大，进而增加了场景的切换时间。&lt;/li&gt;
  &lt;li&gt;会影响DrawCall的拼合。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-9&quot;&gt;物理&lt;/h2&gt;
&lt;h4 id=&quot;profilerstatic-collidermoveexpensive-delay-cost&quot;&gt;Profiler中会碰到Static Collider.Move(Expensive delay cost)，有什么办法可以优化掉呢？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;建议给需要移动的静态Collider加上RigidBody并勾选is Kinematic复选框，从而将其变为动态碰撞体。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;physicssimulate-&quot;&gt;引起 Physics.Simulate 开销较大的几个因素&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Rigidibody。
    &lt;ul&gt;
      &lt;li&gt;该组件可使得游戏对象在物理系统的控制下运动。&lt;/li&gt;
      &lt;li&gt;对于移动设备而言，建议Rigidibody数量控制在50以下。同时需要注意的是，大家常常会用Rigidbody组件配合CapsuleCollider，通过RigidBody.velocity来移动。这些会造成物理计算，特别是网格有很多Mesh Colider的时候，物理计算相当高。&lt;/li&gt;
      &lt;li&gt;因此，建议尽量用Transform.Position代替物理计算。如果大家的地形是凹凸不平又要有重力的表示，也可以用Navmesh去做，它所引起的工作量在于烘焙Navmesh，并且尽可能地贴合地表 ，但是可以完全不用物理计算。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Contacts &amp;amp; Colider
    &lt;ul&gt;
      &lt;li&gt;Contacts数量为碰撞对（Contact Pair）数量。任意两个发生碰撞的碰撞体都会产生一个“碰撞对”。&lt;/li&gt;
      &lt;li&gt;一般来说，Contacts数量越大，则表明碰撞物体的数量越多，即物理系统的CPU开销越大。&lt;/li&gt;
      &lt;li&gt;碰撞体数量（静态碰撞体和动态碰撞体两者）均控制在100以下，当然越低越好。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;PS：动态碰撞体是指带有RigidBody的Collider，而静态碰撞体指不带有RigidBody的Collider。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;ngui-2&quot;&gt;NGUI减少物理计算&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;在NGUI界面打开后，往往会有Physics一下涨高的情况。这是因为NGUI为了实现点击事件的检测，在每个UI上都设有Rigidbody，所以当UI Widgets摆在同一深度并存在相互叠加的情况时，会造成较多不必要的Contacts。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;ontriggerxxxontriggerenter&quot;&gt;定位到OntriggerXXX（如OntriggerEnter）消耗高&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;这种情况一般是在脚本中触发了其他的逻辑调用，例如在主角被碰撞从而受到伤害时，创建一个伤害数字的UI，这些均有些实例化的逻辑计算，当然这些也会算到Physics开销中。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-10&quot;&gt;渲染&lt;/h2&gt;
&lt;h4 id=&quot;shadershader1zwrite&quot;&gt;我用内建的Shader渲染场景，深度图里有内容。而用自己的Shader，取到的深度图什么都没有，都是1，什么原因导致的呢？我已经打开ZWrite了。&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;4.x中是靠depth buffer直接获取或者通过shader replacement来实现。&lt;/li&gt;
  &lt;li&gt;5.x后统一考ShadowCaster来实现。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;shaderparse--shadercreategpuprogram-&quot;&gt;Shader.Parse 和 Shader.CreateGpuProgram 到底是做什么的？他们什么时候执行？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Shader.Parse体现的是Shader的加载和解析， Shader.CreateGpuProgram 是将Shader传入GPU的一次提交，GPU驱动会对其进行编译，以适应于特定的设备或平台。在Unity 5.x版本中，Shader.Parse在Shader资源加载时进行执行，而 Shader.CreateGpuProgram在所在GameObject第一渲染时进行执行。&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Mon, 04 Sep 2017 23:36:59 +0800</pubDate>
        <link>https://caihua.tech/2017/09/04/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E5%85%AD%E5%91%A8/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/09/04/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E5%85%AD%E5%91%A8/</guid>
        
        <category>UWA</category>
        
        
      </item>
    
      <item>
        <title>游戏设计模式读书笔记：组件模式</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;为什么是组件&lt;/h2&gt;
&lt;h4 id=&quot;section-1&quot;&gt;意图&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;允许单一的实体跨越多个领域而不会导致这些领域彼此耦合。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;ecs&quot;&gt;实体-组件-系统(ECS)&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;组件模式在游戏中常见的体现就是&lt;a href=&quot;https://zh.wikipedia.org/wiki/User:Lijinyu25775/%E5%AE%9E%E4%BD%93-%E7%BB%84%E4%BB%B6-%E7%B3%BB%E7%BB%9F(ECS)&quot;&gt;ECS&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-2&quot;&gt;为什么是组件&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;在游戏开发中一个实体会有多个不同的功能，比如音频的播放、动画功能、渲染、物理、输入等等，如果所有的功能都按照类的形式写到一个类文件中会非常的庞大且不易维护。&lt;/li&gt;
  &lt;li&gt;将不同类型的功能切分成不同的组件，既是对结构的优化也是实现了功能的复用。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-3&quot;&gt;为什么不是类的继承&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;因为可能一个实体的在继承多个父类（C++，但是C#这样的语言在语法上就不行）时出现重复继承的问题。比如实体的父类的父类出现重复的问题。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-4&quot;&gt;模式&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;单一实体跨越了多个领域&lt;/strong&gt;。为了保持领域之间相互分离，将每部分代码放入&lt;strong&gt;各自的组件类&lt;/strong&gt;中。实体被简化为&lt;strong&gt;组件的容器。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-5&quot;&gt;何时使用&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;组件通常在定义游戏实体的核心部分中使用。&lt;/li&gt;
  &lt;li&gt;有一个涉及了多个领域的类，而你想保持这些领域互相隔离。&lt;/li&gt;
  &lt;li&gt;一个类正在变大而且越来越难以使用。&lt;/li&gt;
  &lt;li&gt;想要能定义一系列分享不同能力的类，但是使用继承无法让你精确选取要重用的部分。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-6&quot;&gt;一些问题&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;组件之间的通信问题&lt;/li&gt;
  &lt;li&gt;组件的获得需要先获取实体，才能获得组件对象。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-7&quot;&gt;实现&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;建议直接看原书代码。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-8&quot;&gt;进化过程&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;1.先将不同的功能模块分为不同的组件，实体类本身只是调用组件中的方法（作为容器），参数为自身。&lt;/li&gt;
  &lt;li&gt;2.对组件类进行接口化，最后变成实体类中只要使用继承自接口的类即可。对于接口的不同实现就可以实现不同的功能。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-9&quot;&gt;设计决策&lt;/h2&gt;

&lt;h4 id=&quot;section-10&quot;&gt;对象如何获得组件&lt;/h4&gt;
&lt;h5 id=&quot;section-11&quot;&gt;对象创建组件&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;自己创建所以一定能拿到需要的组件&lt;/li&gt;
  &lt;li&gt;组件模式的优势在于自由的将不同的组件赋予一个对象，从而让对象获得不同的能力，或者说变成了某个特定的游戏对象。但是如果用硬编码的方式获得组件，那么这个对象就定型了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-12&quot;&gt;外部提供组件&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;对象更加灵活。&lt;/strong&gt;我们可以提供不同的组件，这样就能改变对象的行为。 通过共用组件，对象变成了组件容器，我们可以为不同目的一遍又一遍重用它。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;对象可以与具体的组件类型解耦。&lt;/strong&gt; 如果我们允许外部代码提供组件，好处是也可以传递派生的组件类型。 这样，对象只知道组件接口而不知道组件的具体类型。这是一个很好的封装结构。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;PS：细细体会unity的组件实现。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-13&quot;&gt;组件之间如何通信&lt;/h4&gt;
&lt;h5 id=&quot;section-14&quot;&gt;通过修改容器对象的状态：&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;这个可以参考unity的实现。在unity中每个GameObject都必须有transform组件，以为位置、角度和缩放信息算是所有对象都必须有的，而且在物理组件、渲染组件中都需要用到。&lt;/li&gt;
  &lt;li&gt;但是这个方案的问题就在于，如果一个GameObject使用了多个组件，而这些组件在修改数据时可能需要一定的顺序才行，比如计算移动的组件需要限制性，在执行物理相关和渲染相关的，因为可能一个对象在一帧中已经离开了摄像机范围而不需要渲染了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-15&quot;&gt;互相引用&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;这个没什么好多解释的，掌握了对象的引用自然可以获得其数据和方法。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;但是这个是一种倒退，因为耦合了。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-16&quot;&gt;消息机制&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;恩恩，尤其是使用订阅发布模式的消息系统。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-17&quot;&gt;参考&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://gpp.tkchu.me/component.html&quot;&gt;原文&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;一个不错的&lt;a href=&quot;https://github.com/EllanJiang/GameFramework&quot;&gt;框架&lt;/a&gt;，我是先学习了这个框架在看这个文章的，醍醐灌顶之感。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 28 Aug 2017 14:11:13 +0800</pubDate>
        <link>https://caihua.tech/2017/08/28/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%BB%84%E4%BB%B6%E6%A8%A1%E5%BC%8F/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/08/28/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%BB%84%E4%BB%B6%E6%A8%A1%E5%BC%8F/</guid>
        
        <category>游戏设计模式读书笔记</category>
        
        
      </item>
    
      <item>
        <title>每天一点UWA：第五周</title>
        <description>&lt;h2 id=&quot;assetbundle&quot;&gt;AssetBundle&lt;/h2&gt;
&lt;h4 id=&quot;shader&quot;&gt;shader加载&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;首先 Shader. WarmupAllShaders 并不影响 Shader 的加载，因为该函数的作用是将所有已加载的 Shader 都做一次快速渲染(渲染单个像素，GPU 在首次使用某一个 Shader 时会有额外开销，Warm 相当于是将这部分开销提前)。&lt;/li&gt;
  &lt;li&gt;可以通过AssetBundle.LoadAll等接口预加载 AssetBundle 中的 Shader。而对于 Always Included Shaders 中的 Shader 则可以通过 Shader. Find 来预加载。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;streamingassetpath--persistantdatapathloadassetbundle&quot;&gt;StreamingAssetPath 和 PersistantDataPath直接load非AssetBundle资源？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;可以但是只能用WWW这样的有限的API.&lt;/li&gt;
  &lt;li&gt;如果load MP3、JPG这样的非内部资源格式效率低，尤其是JPG还要软解码，效率更低。&lt;/li&gt;
  &lt;li&gt;还是推荐AssetBundle。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;unity-5x--fbx--mesh--animationclip--assetbundle-name&quot;&gt;在Unity 5.x 的打包机制下确实无法手动为 FBX 下的 Mesh 或 AnimationClip 单独资源设置 AssetBundle Name。&lt;/h4&gt;

&lt;h4 id=&quot;animatorfbxfbxfbxassetbundle&quot;&gt;如果Animator是直接引用了FBX里的动画文件，而不是复制了FBX的动画文件出来再引用，那么打包的时候不会把FBX打进AssetBundle。&lt;/h4&gt;

&lt;h4 id=&quot;resourcesunloadunusedassetsassetbundleloadassetbundleunloadfalse&quot;&gt;Resources.UnloadUnusedAssets同样可以卸载由AssetBundle.Load加载的资源，只是前提是其对应的AssetBundle已经调用Unload(false)，且并没有被引用。&lt;/h4&gt;

&lt;h3 id=&quot;assetbundle-1&quot;&gt;总结一下AssetBundle的加载和卸载&lt;/h3&gt;
&lt;h4 id=&quot;section&quot;&gt;加载&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;AssetBundle的各种创建函数可以从本地文件(LoadFromXXX)或者内存中将AssetBundle加载到一块内存区域（use from memory or unitywebrequest）或者只是建立一个序列化引用(use loadformfile)。&lt;/li&gt;
  &lt;li&gt;AssetBundle的各种load函数会将真正的asset从AssetBundle中加载出来到内存中。&lt;/li&gt;
  &lt;li&gt;instantiate函数创建GameObject实例&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-1&quot;&gt;卸载&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;AssetBundle的实例函数unload（false）会卸载内存中的AssetBundle（虽然函数的说明中是Unloads all assets in the bundle.），参数是true的话删除AssetBundle和用它创建的asset。&lt;/li&gt;
  &lt;li&gt;上面的函数针对的单个AssetBundle，而UnloadAllAssetBundles这个静态函数就是针对所有当前已经load的AssetBundle了。&lt;/li&gt;
  &lt;li&gt;对于一个具体的asset可以使用Resources.UnloadAsset来卸载，或者使用Resources.UnloadUnusedAssets将多有没有引用的asset卸载。前提就是调用过AssetBundle的Unload（不论参数是false还是true）。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;build&quot;&gt;Build&lt;/h2&gt;
&lt;h4 id=&quot;optimize-mesh-data&quot;&gt;Optimize Mesh Data选项&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;build时我们在player setting里面有这个选项，它只针对Build Player或者Bundle 时才生效的，所以提前做的AssetBundle是无效的。&lt;/li&gt;
  &lt;li&gt;模型导入时也有个Optimize Mesh选项，是调整面片排序的，和build时的是两回事。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ui&quot;&gt;UI&lt;/h2&gt;
&lt;h4 id=&quot;ugui-resourcesunloadunusedassets&quot;&gt;UGUI做的一个界面中有一个背景图片，关闭销毁这个界面后调用 Resources.UnloadUnusedAssets，图片还在内存中&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;在使用 Resources.Load 加载 UI 界面的情况下，即使“关闭销毁这个界面”后，Resources.UnloadUnusedAssets 确实还是无法卸载对应的图集的。因为此时该图集依然被 Resources.Load 加载出来的 Prefab 引用。&lt;/li&gt;
  &lt;li&gt;建议是手动调用 Resources.UnloadAssets 来手动释放图集（可以通过 Sprite.texture 来找到对应的图集），在重新实例化该 UI 界面时，图集也会自动进行 Reload 的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;模型&lt;/h2&gt;
&lt;h4 id=&quot;meshbaker-meshprefabfbxmodelgenerate-lightmap-uvs-&quot;&gt;MeshBaker 烘焙的Mesh可以保存到Prefab中，但是不能像FBX一样，设置Model导入设置中的Generate Lightmap UVs 等信息，请问有没有大招可以处理此情况？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;首先从理论上说，一个 Mesh 只能有一个 LightmapIndex 和 LightmapOffset 属性，这就决定了 Mesh 的合并必须在 Lightmap 的烘焙之前。&lt;/li&gt;
  &lt;li&gt;做Mesh合并时，需要注意到UV2对于一个Mesh而言，其所有三角面的UV区域都必须是互不重叠的，所以不能简单直接地合并。
考虑到合并前每一个Mesh的UV2区域都应该是在[0,1]x[0,1]的区间中，在合并时可以给每一个UV2区域做一个缩小和平移，从而可以把每个区间在互不重叠的情况下，放到同一个[0,1]x[0,1]的区间中。
在UV2也正确拼合后，重新进行Lightmap的烘焙即可得到正确的效果。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;batch&quot;&gt;关于静态batch&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;勾选Static的GameObject下的Mesh都会被合入CombineMesh（无论什么材质），且每个Mesh都作为SubMesh存在。&lt;/li&gt;
  &lt;li&gt;在Unity 5.3之前，对于渲染顺序相邻且材质相同的SubMesh则会动态将其索引数组拼合，从而合成一个Draw Call。&lt;/li&gt;
  &lt;li&gt;而Unity 5.3之后（还是在同材质，渲染顺序相邻的前提下）则不再拼合索引数组，因为在不切换材质时产生多个Draw Call的开销并不大，而这多个Draw Call会被统计为一个Batch。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;staticbatchingutilitycombinecombined-mesh&quot;&gt;如何删除StaticBatchingUtility.Combine会产生Combined Mesh的内存&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;通过某个使用了该Combined Mesh的MeshFilter来获取其引用（MeshFilter.sharedMesh），然后通过Destroy接口来将其卸载。因为Combined Mesh不属于真正的Assets（在Deep Memory中不属于Assets下，而是在Scene Memory下），所以不能用Resources.UnloadAsset来卸载。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-3&quot;&gt;内存&lt;/h2&gt;
&lt;h4 id=&quot;assetbundle-2&quot;&gt;AssetBundle内存占用问题&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;在webStream仍旧存在时（似乎是5.4之前），一个AssetBundle（1mb）解压到websream后如果是2mb，那么这个AssetBundle最终所占的内存就是2mb，因为webstream中已经包含了AssetBundle。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;assetbundle-3&quot;&gt;AssetBundle资源卸载&lt;/h4&gt;
&lt;p&gt;AssetBundle加载好以后立刻通过Instantiate实例化一个对象，然后通过Resources.UnloadAsset和Resources.UnloadUnusedAssets来进行卸载，如果无法卸载，则该资源一定被缓存了。&lt;/p&gt;

</description>
        <pubDate>Sun, 27 Aug 2017 18:27:46 +0800</pubDate>
        <link>https://caihua.tech/2017/08/27/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E4%BA%94%E5%91%A8/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/08/27/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E4%BA%94%E5%91%A8/</guid>
        
        <category>UWA</category>
        
        
      </item>
    
  </channel>
</rss>
