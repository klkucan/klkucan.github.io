<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>蔡华的博客</title>
    <description>Be publicly useful and privately happy.</description>
    <link>https://caihua.tech/</link>
    <atom:link href="https://caihua.tech/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Mon, 14 Aug 2017 23:22:33 +0800</pubDate>
    <lastBuildDate>Mon, 14 Aug 2017 23:22:33 +0800</lastBuildDate>
    <generator>Jekyll v3.2.1</generator>
    
      <item>
        <title>Lua学习笔记：迭代和闭包</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;关系&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;迭代是一种遍历一种集合中所有元素的机制，在遍历的过程中需要在每次成功之间保持一些状态，比如当前变量的index等。而闭包的机制恰好很适合迭代，因为闭包是一种可以访问外部嵌套环境中的变量的函数，而这个变量可以用来保持状态。在lua中闭包结构通常由&lt;strong&gt;闭包函数本身&lt;/strong&gt;和一个&lt;strong&gt;创建该闭包函数的工厂函数&lt;/strong&gt;组成。&lt;/li&gt;
  &lt;li&gt;以下面代码为例，GetValue就是个工厂，它生产出一个闭包，这个闭包将状态保持在t和i这两个变量中。其实在我看来主要是i中。在循环中每次调用闭包（迭代器）都是在更新它的状态i。这段代码完美的展示了迭代器的概念，看完之后对于迭代的理解更近了一步。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;tt = {10,20,30}

function GetValue(t)
	local i =0
	return function ()
		i=i+1
		return t[i]
	end
end

iterator = GetValue(tt)

while true do
	local v = iterator()
	if v == nil then
		break
	end
	print(v)
end
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;for&quot;&gt;泛型for&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;泛型for在内部保存了3个值，分别是一个迭代器函数、一个恒定状态和一个控制变量。其形态如下，其中var-list是变量列表，exp-list表达式列表。var-list第一个原始就是控制变量，在循环中它不会是nil，如果是nil了循环就结束了。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for &amp;lt;var-list&amp;gt; in &amp;lt;exp-list&amp;gt; do
    &amp;lt;body&amp;gt;
end
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;迭代器是for中内部保存的，恒定状态应该是你需要循环的数据，比如一个table，控制变量是返回值变量列表的第一个变量，同时它也是用恒定状态和控制变量调用迭代器后得到的结果。假设迭代器函数是f，恒定状态是s，控制变量初始是a0，那么有&lt;code class=&quot;highlighter-rouge&quot;&gt;a1 = f(s,a0) a2 = f(s,a1)...&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;lua中将for的迭代器返回值固定为了3个，因此得到的是next\t\nil.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-1&quot;&gt;无状态迭代器&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;不保存任何状态的迭代器，可以在多个循环中使用同一个迭代器。例子：ipairs。准确说ipairs是个工厂，它生产了一个简单的迭代器。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;一个简单的迭代器&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;local function getNext(list, node)
	if not node then
		return list
	else
		return node.next
	end
end

function tra(list)
	return getNext,list,nil
end

list = nil
for line in io.lines() do
	list  = {val = line, next = list}
end

for node in list do
	print(tra(node.val))
end
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-2&quot;&gt;关于迭代的的一些理解&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;在lua中for迭代的迭代器其实主要是个生成器，它生成了iterator，然后依靠for来循环调用。注意生成迭代的函数的返回值必须是函数、恒定状态、控制变量这个顺序。&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Mon, 14 Aug 2017 22:57:15 +0800</pubDate>
        <link>https://caihua.tech/2017/08/14/Lua%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%BF%AD%E4%BB%A3%E5%92%8C%E9%97%AD%E5%8C%85/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/08/14/Lua%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%BF%AD%E4%BB%A3%E5%92%8C%E9%97%AD%E5%8C%85/</guid>
        
        <category>Lua</category>
        
        
      </item>
    
      <item>
        <title>Lua学习笔记：函数深入</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;闭包&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;lua中的函数都可以认为是闭包，只不过为了便于理解还是用了函数的概念。&lt;/li&gt;
  &lt;li&gt;lua中函数的返回值可以是匿名函数，也就是闭包。以下面的代码为例，提出一个概念：非局部的变量。在下面的代码中，匿名函数访问了一个变量i，它对于newCount来说是局部变量，对于匿名函数来说是既不是局部变量也不是全局变量，在lua中这个称谓&lt;em&gt;非局部的变量&lt;/em&gt;。&lt;/li&gt;
  &lt;li&gt;在lua中一个闭包指的是一个函数和该函数所需要访问的非局部的变量。lua会把它们看做是一个整体，因此在下面的代码中多次允许c1和c2，会发现变量i是在递增的。这是因为&lt;code class=&quot;highlighter-rouge&quot;&gt;c1 = newCount()&lt;/code&gt;这句代码相当于给c1赋值了一个闭包，它包含了i这个变量。因此多次执行相当于就是在反复执行一个对象，这样i就一直是原来那个i。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function newCount()
	local i =0
	return function ()
		i=i+1
		print(i)
	end
end

c1 = newCount()
print(c1())
print(c1())

c2 = newCount()
print(c2())
print(c2())
print(c1())

-- 结果
1
2
1
2
3
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-1&quot;&gt;利用闭包的沙盒&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;下面这段代码中，修改了math库的sin方法。类似的还可以用来处理一些不安全的代码，这样的方式类似沙盒，将不安全包装了起来。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;print(math.sin(45))

oldSin = math.sin
math.sin = function (x)
	return oldSin(x*math.pi/180)
end

print(math.sin(45))
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-2&quot;&gt;直接使用非全局函数做递归会报错&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;当你尝试调用下面的代码时，会提示&lt;code class=&quot;highlighter-rouge&quot;&gt;attempt to call global 'foo' (a nil value)
&lt;/code&gt;，很奇怪对吧，明明定义的foo是个local的，怎么会提示是global呢？这个是因为在调用foo(x-1)时，这个foo函数还没有定义完，因此表达式在尝试调用一个全局的函数foo，但是显然这个全局函数是不存在的。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;local foo = function (x)
	if x == 1 then
		return 1
	else return x*foo(x-1)
	end
end

print(foo(3))
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;正确的递归函数姿势，第二种&lt;code class=&quot;highlighter-rouge&quot;&gt;local function foo(x)&lt;/code&gt;其实是第一个方法的语法糖。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;local foo
foo = function (x)
	if x == 1 then
		return 1
	else return x*foo(x-1)
	end
end

print(foo(3))

-- 相当于
local function foo(x)
...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-3&quot;&gt;正确的尾调用&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;本质是为了不记录函数的返回位置，这样在栈中就可以无限的调用函数。在lua中只有&lt;code class=&quot;highlighter-rouge&quot;&gt;return  &amp;lt;func&amp;gt;(&amp;lt;args&amp;gt;)&lt;/code&gt;这样的形式才是尾调用。&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Mon, 14 Aug 2017 22:56:11 +0800</pubDate>
        <link>https://caihua.tech/2017/08/14/Lua%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%87%BD%E6%95%B0%E6%B7%B1%E5%85%A5/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/08/14/Lua%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%87%BD%E6%95%B0%E6%B7%B1%E5%85%A5/</guid>
        
        <category>Lua</category>
        
        
      </item>
    
      <item>
        <title>每天一点UWA：第三周</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;内存&lt;/h2&gt;
&lt;h4 id=&quot;section-1&quot;&gt;资源复用&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;如果一个prefab被简单的多复制几次，里面的mesh、Texture、AnimationClip、Material这些都是被复用的，在profile中可以看到。但是如果prefab从AssetBundle中获取，并且多次的加载、实例化、卸载可能造成内存泄漏，因为unload(false)并没有真正卸载内存中的已经实例化的prefab，再次load时PersistentManager会认为是一个新的对象。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;uiprofile&quot;&gt;UI在多次开关后出现profile中资源重复&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;刚进游戏时获取的图中出现的“重复”资源可能并不是冗余，因为 Atlas的一个 Group 中可能包含多张一样大小的Page（即纹理），而这几个Page在内存中的名字是一样的。&lt;/li&gt;
  &lt;li&gt;但是，如果同一UI界面多次开启后，内存中出现了更多同样的资源，则说明UI的管理方式存在一定问题。对于频繁使用的UI，我们建议在加载之后通过缓冲池对其进行缓存，后续使用时，直接通过缓冲池获取即可。而不要每次均通过AssetBundle进行加载，这种做法既会造成更大的CPU占用，同样会很大几率造成资源的冗余。&lt;/li&gt;
  &lt;li&gt;同时，如果多次开启的是不同UI界面，并且造成内存中同种资源的增加，则很有可能是UI在AssetBundle打包时形成了冗余（这种情况在目前的UGUI系统中较为常见）。对此，如果开发团队使用的是UGUI，那么我们的建议如下：
    &lt;ul&gt;
      &lt;li&gt;对于使用Unity 5.x的新AssetBundle打包系统，则打包时尽可能将同种Atlas的UI界面打成一个AssetBundle文件，否则将很有可能出现资源冗余的情况；&lt;/li&gt;
      &lt;li&gt;对于使用Unity 4.x的老AssetBundle打包系统，则可以将一个含有Atlas的Prefab（或其他Object）先打包，其他UI元素对其进行依赖即可。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;物理&lt;/h2&gt;
&lt;h4 id=&quot;rigidbody--capsulecollidercharactercontroller&quot;&gt;RigidBody + CapsuleCollider替换CharacterController&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;高效一些，因为 move 函数本身会进行较复杂的模拟运算。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;static-collidermove-expensive-delayed-cost&quot;&gt;Static Collider.Move (Expensive Delayed cost)警告&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Static Collider.Move (Expensive Delayed cost) 意味着场景中有静态碰撞体（不带有RigidBody的Collider）发生了移动，而该操作在Unity 4.x版本的PhysX 中会在后续的模拟中产生较高的开销，但在 5.x 中理论上开销并不明显。如果要消除该问题，只需定位到发生位移的Collider并挂上RigidBody 组件，打开其is kinematic 选项即可。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-3&quot;&gt;渲染&lt;/h2&gt;
&lt;h4 id=&quot;lightmap&quot;&gt;什么在影响lightmap尺寸&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;首先确认下Lightmap的类型，Single类型只生成一张，而Dual和Directional会生成两张。&lt;/li&gt;
  &lt;li&gt;其次，确认下当前的发布平台，Android下的Lightmap会比Standalone更小。因为不同平台采用的压缩格式不同。此外，Lightmapping中的Lock Atlas，Resolution，Padding等选项也会影响最后烘焙光照图的大小。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;lightmapmesh&quot;&gt;原先的Lightmap不再影响合并后的Mesh&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;总结一句就是不要讲使用了多个lightmap的mesh进行合并。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;bloom&quot;&gt;关于抗锯齿和BLOOM，有什么好的优化方案或者优秀插件推荐？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;通常在中低端的设备上，抗锯齿并没有比较高效的方案；而对于中高端的设备，可尝试直接使用 Unity 内置的 MSAA 功能，但也只推荐使用 2x。
关于Bloom效果，以下是适用于移动端，且评价较好的一款插件：BloomPro&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;assetbundle&quot;&gt;AssetBundle&lt;/h2&gt;
&lt;h4 id=&quot;xassetbundle-name&quot;&gt;5.x后设置好AssetBundle Name就可以实现依赖资源的独立打包&lt;/h4&gt;

&lt;h4 id=&quot;xassetbundle&quot;&gt;4.x时代不同版本之间的AssetBundle不能通用&lt;/h4&gt;

&lt;h4 id=&quot;unload&quot;&gt;unload顺序&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;在 Resources.UnloadUnusedAssets() 时，如果还没有进行AssetBunlde的Unload 操作，那么从AssetBunlde中加载的资源依然会因为被AssetBunlde引用而无法被卸载。&lt;/li&gt;
  &lt;li&gt;开发团队可以尝试 Destory 后做 AssetBunlde的Unload，最后进行 Resources.UnloadUnusedAssets()。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;assetbundlemanifestassetbundle&quot;&gt;生成AssetBundle的时候每个文件会多生成一个Manifest文件，这个文件也需要一起随着AssetBundle上传吗，在资源加载的时候具体怎么用呢？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;每个文件多生成的Manifest 文件是不需要上传的，其作用就是供开发人员查看AssetBundle 中的依赖关系等信息。&lt;/li&gt;
  &lt;li&gt;但除了每个文件多生成的 Manifest 以外，根目录下还会有一个与根目录同名的AssetBundle 以及 Manifest 文件，通过运行时加载这个AssetBundle，可以得到一个 AssetBundleManifest 对象，然后就可以通过这个对象得到AssetBundle直接的依赖关系。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;editorshader&quot;&gt;选择移动平台后，editor下shader显示错误&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;是Unity已知的一个问题，Android 和 iOS 的部分Shader在打包后，在Editor 下无法正常显示。 主要原因是在打包时，只会把对应平台的Shader预编译代码（如 gles ）打入包中，因此在 Editor 下会执行失败（通常 Editor 是 d3d 驱动）。 因此，目前只能尝试在Editor下重新指定Shader来绕过这个问题。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;texture&quot;&gt;Texture&lt;/h2&gt;
&lt;h4 id=&quot;iosastc&quot;&gt;ios上的ASTC格式&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;ASTC在 iOS 的高端机上是被支持的，因此理论上在 Editor 下不会强制把 ASTC 转为 RGBA32，建议尝试设置为 ASTC 后打包，从 Editor.log 中或者直接从包体大小上可以看出是否确实使用了ASTC。&lt;/li&gt;
  &lt;li&gt;一般来说，如果 RGBA16 的效果可以接受的话，建议使用 RGBA16，虽然打包时相对大一些，但是内存中相比 RGBA32 能够减半，但使用 ASTC 的话，虽然打包时比较小，但是在普通机型上会被处理成 RGBA32，导致过大的内存开销。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ui&quot;&gt;UI&lt;/h2&gt;
&lt;h4 id=&quot;shared-ui-mesh&quot;&gt;Shared UI Mesh&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Shared UI Mesh是在Unity 5.2 版本后UGUI系统维护的UI Mesh。在以前的版本中，UGUI会为每一个Canvas维护一个Mesh（名为BatchedMesh，其中再按材质分为不同的SubMesh）。而在Unity 5.2版本后，UGUI底层引入了多线程机制，而其Mesh的维护也发生了改变，目前Shared UI Mesh作为静态全局变量，由底层直接维护，其大小与当前场景中所有激活的UI元素所生成的网格数相关。&lt;/li&gt;
  &lt;li&gt;一般来说当界面上UI元素较多，或者文字较多时该值都会较高，在使用UI/Effect/shadow和UI/Effect/Outline时需要注意该值，因为这两个Effect会明显增加文字所带来的网格数。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;build&quot;&gt;Build&lt;/h2&gt;
&lt;h4 id=&quot;section-4&quot;&gt;打包注意&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;打包的时候Resources文件夹下所有的内容都会被打入resources.assets，要想包体小就删除不要的资源。而且Resources目录下所以资源启动时参与persistentmanager的初始化，内容多了会卡。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;static&quot;&gt;static选项&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;如果在Editor中进行勾选，则会在项目中生成一个较大的VBO，Runtime时通过该VBO来进行渲染，优点是有效减少了Draw Call，缺点是增大了发布游戏包的体积。&lt;/li&gt;
  &lt;li&gt;如果在Runtime通过脚本来进行Batching，则相当于把拼合的时间由Editor中搬到了Runtime，所以加载时间（一般在场景加载时执行Batching）会稍有增加，但游戏包的体积将相应减少。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-5&quot;&gt;动画&lt;/h2&gt;
&lt;h4 id=&quot;optimize-gameobject&quot;&gt;Optimize GameObject&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;在选择Optimize GameObjects后，可在Extra Transforms中加入你想挂载特效的骨骼结点，这样该骨骼结点将不会进行优化处理，即其Transfrom将不会消失。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-6&quot;&gt;工具&lt;/h2&gt;
&lt;h4 id=&quot;waitfortargetfps&quot;&gt;WaitForTargetFPS&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;该参数一般出现在CPU开销过低，且通过设定了目标帧率的情况下（Application.targetFrameRate）。当上一帧低于目标帧率时，将会在本帧产生一个WaitForTargetFPS的空闲等待耗时，以维持目标帧率。&lt;/li&gt;
  &lt;li&gt;该项在Unity引擎的主循环中其实是最早执行的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;gfxwaitforpresent--graphicspresentandsync&quot;&gt;Gfx.WaitForPresent &amp;amp; Graphics.PresentAndSync&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;这两个参数在Profiler中经常出现CPU占用较高的情况，其实是CPU和GPU之间的垂直同步（VSync）导致的，之所以会有两种参数，主要是与项目是否开启多线程渲染有关。当项目开启多线程渲染时，你看到的则是Gfx.WaitForPresent；当项目未开启多线程渲染时，看到的则是Graphics.PresentAndSync。&lt;/li&gt;
  &lt;li&gt;Gfx.WaitForPresent其真实的意思应该是为了在渲染子线程（Rendering Thread）中进行Present，当前主线程（MainThread）需要等待的时间。&lt;/li&gt;
  &lt;li&gt;最后，如何优化并降低这两个参数的CPU占用呢？ 那就是，忽略Gfx.WaitForPresent 和 Graphics.PresentAndSync这两个参数，优化其他你能优化的一切！WTF！&lt;/li&gt;
  &lt;li&gt;PS：这篇内容相当不错，建议看&lt;a href=&quot;https://blog.uwa4d.com/archives/presentandsync.html&quot;&gt;原文&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;editorassetdatabase&quot;&gt;editor下出现AssetDatabase内存过高可以无视&lt;/h4&gt;

&lt;h4 id=&quot;canvassendwillrendercanvases&quot;&gt;Canvas.SendWillRenderCanvases&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Canvas.SendWillRenderCanvases为UGUI中非常重要的接口，经常会出现较高的性能开销。当Canvas中的UI元素出现了长、宽或Alpha变化时，UGUI会更新其所在Canvas中所有UI元素的Transform、状态等等。Canvas中UI Mesh顶点较多的话，则该项将会出现较高的CPU开销。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;loadingupdatepreloading&quot;&gt;Loading.UpdatePreloading&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Loading.UpdatePreloading为Unity引擎的主要加载函数。场景中的资源加载（包括Texture、Mesh、Shader、AnimationClip等）和相关序列化操作均在其中体现。因此，如果该值开销较高，建议研发团队对资源进行进一步的优化和控制。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-7&quot;&gt;脚本&lt;/h2&gt;
&lt;h4 id=&quot;gameobjectgameobject&quot;&gt;如果脚本引用了GameObject，那转换场景的时候脚本和GameObject都没了，还会产生堆内存的吗？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;如果脚本是MonoBehaviour，而且在切换场景后所挂的Game Object被释放了，那么这个脚本对象所引用的堆内存就会在GC的时候被释放。 但有一种例外，如果是通过Static变量引用的堆内存，那么依然是释放不掉的，除非手动解开引用，比如变量置Null，数组Clear等等。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-8&quot;&gt;粒子&lt;/h2&gt;
&lt;h4 id=&quot;section-9&quot;&gt;粒子动态合并&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;del&gt;粒子系统的Draw Call动态拼合与半透明物体的动态拼合机制相当（粒子基本都是半透明材质）。而对半透明物体，由于其渲染顺序的限制（必须从后向前渲染，以保证渲染结果的正确性），动态拼合只能对渲染顺序相邻且材质相同的物体有效。而在决定半透明物体的渲染顺序时，Unity首先会按Shader中的RenderQueue进行排序；其次（相同RenderQueue时），会根据每个半透明物件到屏幕的距离，距离大的优先渲染。&lt;/del&gt;&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;因此，需要尽可能地将相同材质的粒子系统放在比较接近的深度下，才能更多地使动态拼合生效。但通常由于相机的运动、粒子系统的分散分布等原因造成粒子系统之间的穿插，能够动态拼合的数量往往都是很少的。&lt;/del&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;目前粒子系统已经不再进行 Draw Call 的拼合，因为在新版本5.3 中已通过多线程进行更新，暂时无法支持拼合，但性能已经得到提升。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Mon, 14 Aug 2017 22:54:29 +0800</pubDate>
        <link>https://caihua.tech/2017/08/14/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E4%B8%89%E5%91%A8/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/08/14/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E4%B8%89%E5%91%A8/</guid>
        
        <category>UWA</category>
        
        
      </item>
    
      <item>
        <title>每天一点UWA：第二周</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;内存&lt;/h2&gt;

&lt;h3 id=&quot;section-1&quot;&gt;概述&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;内存的开销无外乎以下三大部分：1.资源内存占用；2.引擎模块自身内存占用；3.托管堆内存占用。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-2&quot;&gt;资源内存&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;大头在纹理，其次在网格、动画片段和音频。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-3&quot;&gt;纹理&lt;/h4&gt;

&lt;h5 id=&quot;section-4&quot;&gt;从格式解决内存占用问题&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;选择正确的格式，比如Android上是ETC，ios的PVRTC，PC上DXT。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-5&quot;&gt;不同格式可能出现的问题：&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;因为ETC、PVRTC都是有损压缩因此可能出现色阶问题，如果用RGB32这样的格式虽然能解决问题但是内存占用太大。好的办法是在做纹理的时候减少色差范围，必要做出高对比度的阶梯式的图。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;比如，同样一张1024x1024的纹理，如果不开启Mipmap，并且为PVRTC格式，则其内存占用为512KB，而如果转换为RGBA32位，则很可能占用达到4MB。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;OpenGL ES2的设备只支持ETC1，但是ETC1不支持alpha通道。解决办法是将透明图分成两张，一个RGB24的保存RGB通道，一个alpha8的保存A通道，然后在使用时使用定制的shader去分别读取两个纹理图。&lt;/li&gt;
  &lt;li&gt;PS：OpenGL ES 3.0支持ETC2甚至ASTC，都是很好的支持透明通道的压缩格式。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-6&quot;&gt;选择合适的纹理设置&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;能512解决的事情别用1024&lt;/li&gt;
  &lt;li&gt;选择性的使用mipmap，对于UI这样的纹理使用完全没有必要用mipmap。&lt;/li&gt;
  &lt;li&gt;Read &amp;amp; Write选项会使得纹理的内存使用量增加一倍。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-7&quot;&gt;网格&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;mesh中顶点信息可以进行相关的优化，比如Normal、Color和Tangent这些数据要按照需要来做，不用的就不要做。而且顶点信息超多900还不能动态批处理。不需要就计算发现的时候就可以不用tangent数据了，有贴图的话color数据也不需要。&lt;/li&gt;
  &lt;li&gt;Color数据和Normal数据主要为3DMax、Maya等建模软件导出时设置所生成，而Tangent一般为导入引擎时生成。&lt;/li&gt;
  &lt;li&gt;如果项目对Mesh进行Draw Call Batching操作的话，那么将很有可能进一步增大总体内存的占用。比如，100个Mesh进行拼合，其中99个Mesh均没有Color、Tangent等属性，剩下一个则包含有Color、Normal和Tangent属性，那么Mesh拼合后，CombinedMesh中将为每个Mesh来添加上此三个顶点属性，进而造成很大的内存开销。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-8&quot;&gt;引擎模块自身占用内存&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;引擎自身中存在内存开销的部分纷繁复杂，可以说是由巨量的“微小”内存所累积起来的，比如GameObject及其各种Component（最大量的Component应该算是Transform了）、ParticleSystem、MonoScript以及各种各样的模块Manager（SceneManager、CanvasManager、PersistentManager等)…&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;一般情况下，上面所指出的引擎各组成部分的内存开销均比较小，真正占据较大内存开销的是这两处：WebStream 和 SerializedFile。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;PS：5.4以后没有webStream的概念了，不过还是要考虑WWW和LoadFromMemory中会保存AssetBundle原始数据的问题，参见&lt;a href=&quot;https://docs.unity3d.com/550/Documentation/Manual/AssetBundleCompression.html&quot;&gt;Asset Bundle Compression&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;AssetBundle所占的内存也需要考虑，尽可能做到按需加载，用完后及时的清理。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;mono&quot;&gt;托管堆内存占用/无效的Mono堆内存开销&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Mono的堆内存一旦分配，就不会返还给系统。这意味着Mono的堆内存是只升不降的。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-9&quot;&gt;不必要的堆内存分配主要来自于以下几个方面：&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;高频率地 New Class/Container/Array等。不要再update占用的函数中实例化对象。&lt;/li&gt;
  &lt;li&gt;Log输出，需要适当的减少log，只保留最关键的。&lt;/li&gt;
  &lt;li&gt;UIPanel.LateUpdate。这是NGUI中CPU和堆内存开销最大的函数,是由UI网格的重建造成。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-10&quot;&gt;一些推荐的办法&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;不要一次加载一个过大的资源，比如配置文件、纹理图等。这样会造成一次性申请过多的内存，但是还不回去了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-11&quot;&gt;内存泄漏&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;首先通过工具发现场景切换开始和结束时内存使用没有一致，这个现象不能说明内存就一定有泄漏。比如资源加载后常驻内存以备后续使用、Mono堆内存的只升不降等等，这些均可造成内存无法完全回落。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-12&quot;&gt;检查资源的使用情况，特别是纹理、网格等资源的使用&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;这段主要介绍了如何使用UWA的工具对纹理和网格进行检查，查看是否出现资源的内存泄漏。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;profilerwebstreamserializedfile&quot;&gt;通过Profiler来检测WebStream或SerializedFile的使用情况&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;直接通过Profiler Memory中的Take Sample来对其进行检测，通过直接查看WebStream或SerializedFile中的AssetBundle名称，即可判断是否存在“泄露”情况。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-13&quot;&gt;资源冗余&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;是指在某一时刻内存中存在两份甚至多份同样的资源。导致这种情况的出现主要有两种原因：&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;assetbundle&quot;&gt;AssetBundle打包机制出现问题&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;显而易见，对于公用资源需要进行合理的划分打包。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-14&quot;&gt;资源的实例化所致&lt;/h5&gt;

&lt;blockquote&gt;
  &lt;p&gt;在Unity引擎中，当我们修改了一些特定GameObject的资源属性时，引擎会为该GameObject自动实例化一份资源供其使用，比如Material、Mesh等。以Material为例，我们在研发时经常会有这样的做法：在角色被攻击时，改变其Material中的属性来得到特定的受击效果。这种做法则会导致引擎为特定的GameObject重新实例化一个Material，后缀会加上（instance）字样。其本身没有特别大的问题，但是当有改变Material属性需求的GameObject越来越多时（比如ARPG、MMORPG、MOBA等游戏类型），其内存中的冗余数量则会大量增长。虽然Material的内存占用不大，但是过多的冗余资源却为Resources.UnloadUnusedAssets API的调用效率增加了相当大的压力。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;上面描述的material的问题是个常见的问题。如果是直接改变还好说，会产生一个material instance，但是如果是在一段时间内线性的改变某个属性，那么后果很难说。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;建议&lt;/p&gt;
    &lt;blockquote&gt;
      &lt;p&gt;一般情况下，资源属性的改变情况都是固定的，并非随机出现。比如，假设GameObject受到攻击时，其Material属性改变随攻击类型的不同而有三种不同的参数设置。那么，对于这种需求，我们建议你直接制作三种不同的Material，在Runtime情况下通过代码直接替换对应GameObject的Material，而非改变其Material的属性。这样，你会发现，成百上千的instance Material在内存中消失了，取而代之的，则是这三个不同的Material资源。其中的益处，对于能够阅读到这里的你来说，应该已经不需要我多说了。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-15&quot;&gt;粒子&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Navmesh是不支持动态加载的目前的，办法是将多个场景做成prefab，然后用LoadLevelAdditive的方式加载，去拼接。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;assetbundle-1&quot;&gt;AssetBundle&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;本周第一篇关于AssetBundle的文章可以说有点陈旧了，在5.3以后解决了一些功能，比如AssetBundle.LoadFromFile加载LZMA文件的失败的问题。&lt;/li&gt;
  &lt;li&gt;还有就是在5.4以后已经没有webstream的概念了。&lt;/li&gt;
  &lt;li&gt;最后开始使用UnityWebRequest&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;lightmapsnapshotassetlightmap&quot;&gt;热更新打包时LightmapSnapshot.asset无法导出，导致场景丢失lightmap&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;LightmapSnapshot.asset是editor模式下的无法打包。解决办法是整个scene打包，lightmap信息会打包进去。或者在运行时调用Lightmapsettings.Lightmaps来设置，但是5.x后lightmap信息不会保存在prefab中，因此需要重设Prefab的Lightmap信息（Lightmapindex和Lightmapscaleoffset）。&lt;/li&gt;
  &lt;li&gt;还有一种可能是因为打包场景的时候shader会根据当前场景的使用情况来打包，如果打包是在一个空场景中那么bundle中的shader会失去lightmap和fog的支持。这个&lt;/li&gt;
  &lt;li&gt;PS: 这个问题在5.5.2中也存在，而且打包的时候是按照场景打包的，但是是不是shader丢失确实需要测试。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;prefab&quot;&gt;prefab打包&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;如果有一个Prefab，它的Dependencies都在Resources文件夹中，那么，当我在AssetBundle打包时，只打包这个Prefab（不指定BuildAssetBundleOptions.CompleteAssets和BuildAssetBundleOptionsCollectDependencies）是不能正确实例化的，因为AssetBundle中的资源和Resource文件夹下资源是不会建立依赖关系的（脚本除外，因为开启BuildAssetBundleOptionsCollectDependencies 时，脚本依然不会打包到AssetBundle中）。所以会出现Mesh、Material等的丢失。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;assetbundle-2&quot;&gt;卸载依赖AssetBundle的问题&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;比如prefabA和prefabB依赖于AtlasC，那么分别打包的话首先肯定是要先加载AtlasC的AssetBundle的。&lt;/li&gt;
  &lt;li&gt;但是如果先从AtlasC的AssetBundle中load了AtlasC，然后unload这个AssetBundle，此后加载或实例化A和B时，引擎将无法自动将C绑定给A和B进行使用。这个需要注意。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-16&quot;&gt;纹理格式&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;目前来讲，并不存在一个所有GPU平台都支持硬件解压的压缩格式。&lt;/li&gt;
  &lt;li&gt;ETC1 和 PVRTC 分别是Android和iOS上我们最推荐的格式。 但对于透明纹理，ETC1不支持，而 PVRTC 则可能有较大失真，因此更推荐使用 RGBA 16。&lt;/li&gt;
  &lt;li&gt;一般来说建议直接使用 Unity 默认的压缩格式（即选择 Compressed 即可，不需要做特殊设置），Unity 会做如下处理：
    &lt;ul&gt;
      &lt;li&gt;Android 上不带Alpha通道的图片采用 ETC1，带Alpha通道的图片采用True Color中的RGB16，TrueColor中的 RGBA16 会&amp;gt;比 RGBA32 更节省空间，但图像的显示质量会差一些；&lt;/li&gt;
      &lt;li&gt;iOS 上使用 PVRTC，但PVRTC格式要求纹理的长宽相等，且都是2的幂次（即POT，在ImportSettings中可以将NPOT的纹理自动转换成POT）。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;同时，我们不建议直接使用 RGBA32 格式的纹理，因为它占用了很大的内存。一般建议使用 RGBA16 和 ETC 格式的纹理来进行加载。 如果转换到 RGBA16 格式时出现了类似“色阶”的颜色问题，则建议尽可能避免大量的过渡色使用。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-17&quot;&gt;工具&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;unity的分析工具中的Reserved Total 和 Used Total为Unity引擎在内存方面的总体分配量和总体使用量。 一般来说，引擎在分配内存时并不是向操作系统 “即拿即用”，而是首先获取一定量的连续内存，然后供自己内部使用，待空余内存不够时，引擎才会向系统再次申请一定量的连续内存进行使用。&lt;/li&gt;
  &lt;li&gt;Overhead：
    &lt;ul&gt;
      &lt;li&gt;Overhead的计算方法是：Profiler当前帧统计的总耗时时间减去所有已知选项的累加时间，即引擎当前还无法识别模块的耗时时间。&lt;/li&gt;
      &lt;li&gt;Overhead数值理论上是趋向于0的，但是由于目前市面上的硬件设备、系统框架过于丰富，所以引擎可能无法识别所有模块的CPU开销。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Unity Profiler反馈的则是引擎的真实物理使用内存，有时内存使用数值比原生的分析工具小是正常的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Profiler中ManagedHeap.UsedSize是项目逻辑代码在运行时申请的堆内存， 
ManagedHeap.UsedSize过大，一方面可能会影响一次GC的耗时；另一方面也可能反映出脚本中不合理的GC Alloc。该选项只能通过优化代码来进行降低。 优化方法一般如下：
    &lt;ul&gt;
      &lt;li&gt;尽可能地复用变量，减少new的次数；&lt;/li&gt;
      &lt;li&gt;使用StringBuilder代替String连接，使用for代替foreach；&lt;/li&gt;
      &lt;li&gt;对于局部变量或非常驻变量，尽可能使用Struct来代替Class。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;本周读到的所有关于内存监控的部分都提到了一个概念就是Profiler所监控到的数据和Android上的PSS或者ios上检测到的会不一致，这                                                   个是因为Unity Profiler反馈的是引擎的真实分配的物理内存，而PSS中记录的则包括系统的部分缓存。一般情况下，Android或iOS并不会及时将所有App卸载数据进行清理，为了保证下次使用时的流畅性，OS会将部分数据放入到缓存，待自身内存不足时，OS Kernel会启动类似LowMemoryKiller的机制来查询缓存甚至杀死一些进程来释放内存。因此，并不能通过一两次的PSS内存没有完全回落来说明内存泄露问题。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Reserved GFX 中的内存，主要是纹理和网格资源。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-18&quot;&gt;渲染&lt;/h2&gt;
&lt;h4 id=&quot;lightmappcandroid&quot;&gt;Lightmap在PC上显示正常，但是转到Android平台上存在色差，颜色普遍偏暗的问题&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Unity烘焙的Lightmap是32bit的HDR图，而移动设备通常不支持HDR图(32bit per channel)，会按照LDR图(8bit per channel)的形式进行处理，因此会出现色偏问题。因此需要如下的处理：
    &lt;ul&gt;
      &lt;li&gt;在移动平台下使用Mobile/Diffuse材质，可载入Standard Assets(Mobile) package获得。&lt;/li&gt;
      &lt;li&gt;如果要获得更合适的效果，需要自行修改Lightmap的DecodeLightmap函数，该函数可在Unity\Editor\Data\CGIncludes\UnityCG.cginc文件中找到。需要说明的是，这种方法也不能达到与PC端完全一致的效果。&lt;/li&gt;
      &lt;li&gt;如果需要PC和移动平台的显示效果一致，可以用图像编辑软体修改Lightmap為LDR格式，例如PNG(8bit per channel)。&lt;/li&gt;
      &lt;li&gt;为了避免类似问题，请不要使用过于强烈的Light进行烘焙，因為Light的强度(Intensity)越高，色偏问题会越严重。若有阴影丢失时，可以尝试检查一下模型的Lightmapindex、Lightmapscaleoffset、UV2等影响Lightmap采样的一些参数。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;另一种可能是存在过曝现象，可以尝试将playersettings -&amp;gt; use direct3d 11关闭，看问题是否解决。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;lightmap&quot;&gt;lightmap动态加载&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Lightmap的动态加载，需要通过脚本将烘焙时每个物件的Lightmapindex和Lightmapscaleoffset记录下，并在运行时动态加载后设置回去的方式来实现。因为目前Lightmapindex和Lightmapscaleoffset信息是和场景绑定在一起，储存在Lightmapsnap.assets 中，发布时也是放在场景信息中，因此不会记录在Prefab 上。&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Mon, 07 Aug 2017 22:17:31 +0800</pubDate>
        <link>https://caihua.tech/2017/08/07/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E4%BA%8C%E5%91%A8/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/08/07/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E4%BA%8C%E5%91%A8/</guid>
        
        <category>UWA</category>
        
        
      </item>
    
      <item>
        <title>Lua学习笔记：高级概念</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;高级概念&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;这部分中会记录一些lua语言中的高级概念和技术。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-1&quot;&gt;模块&lt;/h3&gt;

&lt;h4 id=&quot;section-2&quot;&gt;概念&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;从我的理解看，模块更像是一个类。但是因为lua中没有类的概念，模块的实现是依赖于table。&lt;/li&gt;
  &lt;li&gt;一些公共或者私有的变量+函数组成了模块的主体，最后一个return module完成了基本的构造。其实这个return就是返回了这个table。&lt;/li&gt;
  &lt;li&gt;具体实现看教程&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-3&quot;&gt;使用&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-- 创建一个叫Class的模块
Class = {}

Class.Name = &quot;name&quot;

Class.Grades =
{
  &quot;Grade1&quot;,
  &quot;Grade2&quot;,
  &quot;Grade3&quot;
}

temp = &quot;a&quot;
local temp2 = &quot;b&quot;
Class.temp3 = &quot;c&quot;

function Class.FindGrade(key)
   return Class.Grades[key]
end

return Class
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-- temp = &quot;local temp1&quot;

-- 导入模块
require(&quot;Class&quot;)

-- temp = &quot;local temp1&quot;

print(temp)
print(Class.temp2)
print(Class.temp3)

-- 调用模块函数
print(Class.FindGrade(1))

-- 结果
a
nil
c
Grade1-abc
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;分析一下模块的变量，从例子中可以总结，模块中的以模块名+&lt;code class=&quot;highlighter-rouge&quot;&gt;.&lt;/code&gt;形成的变量（Class.temp3）是全局变量，而且即使在模块内部调用用也要用模块名+&lt;code class=&quot;highlighter-rouge&quot;&gt;.&lt;/code&gt;的形式使用。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;没有加模块名的变量其实也是全局变量，外部代码也可以直接访问。注意代码中在require的前后分别定义了一个和模块中名字相同的变量，这里有一个很有意思的事情，就是如果是之前定义的，那么在print时是模块中的值，如果在之后定义那么就是本地定义的值。这说明require这种过程实际上等于在本地定义了一些变量。所以最终输出的值可以按照后定义的输出。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;显示标记为local的变量是本地变量，在模块内部使用是没有问题的，但是外部代码无法访问。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-4&quot;&gt;加载机制&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;基本上遵循C的加载机制，也就是先找同一目录下的文件，然后会找全局变量中path里面定义的文件。&lt;/li&gt;
  &lt;li&gt;通常我们在编写代码的时候肯定是会有物理的文件夹结构的，此时如果我们不去改package.path的值，那么可以在引用时加速文件夹名字，比如我把class和student放到了Module文件夹下，那么代码中写&lt;code class=&quot;highlighter-rouge&quot;&gt;require(&quot;Module/Class&quot;)&lt;/code&gt;即可正常调用。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-5&quot;&gt;协程&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;首先是真的多线程，并非unity的那种主线程内部的线程。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;require(&quot;MyCoroutine&quot;)
cor1 = MyCoroutine.CreatCor()
print(cor1)
for i = 1,  10 do
	MyCoroutine.RunCor(cor1)
end


cor2 = MyCoroutine.CreatCor()
print(cor2)
for i = 1,  10 do
	MyCoroutine.RunCor(cor2)
end

-- 结果
thread: 0089D628
1
2
3
running
thread: 0089D628
4
5
6
7
8
9
10
thread: 00897D60
1
2
3
running
thread: 00897D60
4
5
6
7
8
9
10

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;用法比较繁琐，但是可以明确的控制协程的执行步骤。有点类似python。&lt;/li&gt;
  &lt;li&gt;建议直接看教程。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;metatable&quot;&gt;元表（MetaTable）&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;metatable更像是lua为table提供的依赖倒置的接口&lt;/strong&gt;，以&lt;code class=&quot;highlighter-rouge&quot;&gt;__index&lt;/code&gt;这个函数为例，本身如果lua提供了固定的函数，那么我们在取值时候只能遵从lua的规定。但是现在提供了一个&lt;code class=&quot;highlighter-rouge&quot;&gt;__index&lt;/code&gt;，你可以自定义这个&lt;code class=&quot;highlighter-rouge&quot;&gt;__index&lt;/code&gt;的行为，而lua在运行期间遇到了需要用到&lt;code class=&quot;highlighter-rouge&quot;&gt;__index&lt;/code&gt;的时候就会按照你所规定的准则行事了。这个思维是很好的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;下面是&lt;code class=&quot;highlighter-rouge&quot;&gt;__index&lt;/code&gt;的用法，metatable。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Lua查找一个表元素时的规则，其实就是如下3个步骤:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;1.在表中查找，如果找到，返回该元素，找不到则继续&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;2.判断该表是否有元表，如果没有元表，返回nil，有元表则继续。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;3.判断元表有没有__index方法，如果__index方法为nil，则返回nil；如果__index方法是一个表，则重复1、2、3；如果__index方法是一个函数，则返回该函数的返回值。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;代码示例：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mt = {}

mt.__index =
function (t,key)
	if key == &quot;key3&quot; then
		return 5
	elseif key == &quot;key4&quot;  then
		return 6
	else
		return 0
	end
	
end

mt.__newindex =
function (t,key,value)
	t.key = value
end

mt.__tostring = function (t)
	local tempTable = {}
	local index = 0
	for i,v in pairs(t) do
		index = index + 1
		tempTable[index] = v
		print(i..&quot;/&quot;..v)
	end
	return '{' .. table.concat(tempTable, ', ') .. '}'
end

-- 一旦定义了__metatable，就代表getmetatable只能得到这个函数的值，
-- 而不能再次赋值,否则会报错“cannot change a protected metatable”
mt.__metatable = &quot;不能看啊不能看&quot;


local t = {1, 2, 3, key1 = 3,key2 = 4}
setmetatable(t, mt)
print(t)

print(getmetatable(t))

print(t[&quot;key4&quot;])


mt2 = {}

-- 下面的代码会报错
--setmetatable(t,mt2)


&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;这个东西有个好处，如果我写的key不存在，那么我是可以自定义它的行为的。我可以返回一个数值，也可以执行一段代码。但是一般来说还是提前预置好数据比较好。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;PS：元表本身是一个table，如果按照table就是类这个概念来看的话，元表对应了类类型，而实际的使用中它也是起了这样的作用。元表中以&lt;code class=&quot;highlighter-rouge&quot;&gt;__&lt;/code&gt;开头的方法们算是它保留的方法，我们可以给一个元表定义这些方法实际是一个什么样的行为。比如&lt;code class=&quot;highlighter-rouge&quot;&gt;__tostring&lt;/code&gt;方法，我们可以在一个元表中重新定义它的实现，有点像C#中override ToString方法。&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-6&quot;&gt;面向对象&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;lua的oop是基于table的，table中可以设置全局或局部的变量、方法等。&lt;/li&gt;
  &lt;li&gt;继承通过子类调用父类的构造函数（其实lua没有构造函数一说，只是我们人为的在代码中创造出来了一个创建对象的函数）来创建，然后在扩展，从而实现了继承。&lt;/li&gt;
  &lt;li&gt;从本质上说，lua的继承和C的继承是一样的，依赖的是table嵌套table，而C中是结构体嵌套结构体。&lt;/li&gt;
  &lt;li&gt;具体看下链接里教程的例子吧。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-7&quot;&gt;一些体会&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;其实只要学过一个脚本语言，lua就不算陌生，还算是上手比较快。&lt;/li&gt;
  &lt;li&gt;所有语言的核心在api的使用，所以熟悉标准库是关键。&lt;/li&gt;
  &lt;li&gt;lua与C/C++的交互也是大头，不过目前暂时不用就先不学了，等后续学了再填坑。&lt;/li&gt;
  &lt;li&gt;多写，多写，多写。&lt;/li&gt;
  &lt;li&gt;一个学习lua编程的方法是看WOW的插件源码。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-8&quot;&gt;调试&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;因为用的是LuaStudio，在调试的过程中也遇到了很多的问题。首先正常的自己写的代码都可以require成功，os\io\math这样的库也都没有问题，但是用到socket库的时候怎么都无法require。最后发现在LuaStudio中必须这样设置才行&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://imglf1.nosdn.127.net/img/Nld0N0tacnNuUG45bFJFdFZwNEVuU216QnRPaEtaaHcwTFU3MW1PS2tuUWl2cWkwZE1EWC9RPT0.png?imageView&amp;amp;thumbnail=500x0&amp;amp;quality=96&amp;amp;stripmeta=0&amp;amp;type=jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-9&quot;&gt;参考&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/booirror/article/details/7881820&quot;&gt;table参考&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.runoob.com/lua/lua-tutorial.html&quot;&gt;lua教程&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/klkucan/LuaStudy&quot;&gt;我在学习中写的所有代码&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.jb51.net/list/list_245_3.htm&quot;&gt;脚本之家-lua&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Mon, 07 Aug 2017 22:10:24 +0800</pubDate>
        <link>https://caihua.tech/2017/08/07/Lua%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%AB%98%E7%BA%A7%E6%A6%82%E5%BF%B5/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/08/07/Lua%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%AB%98%E7%BA%A7%E6%A6%82%E5%BF%B5/</guid>
        
        <category>Lua</category>
        
        
      </item>
    
      <item>
        <title>每天一点UWA：第一周</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;初衷&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;首先&lt;a href=&quot;https://www.uwa4d.com&quot;&gt;UWA&lt;/a&gt;一直以来都是一个我很喜欢的网站，因为他们在unity的优化方面是非常专业的，而且他们对于技术的分享也是毫不吝啬的。在他们的网站上有很多的技术文章，很久以来都想系统的阅读一遍，但是一直没有去做。这周开始下定决心要从第一篇开始，把UWA所有的技术分享文章读完，这个系列的文章会对每周读到的技术做一个总结，但是因为文章涉及的方向比较杂，因此会简单的用技术进行一个分类。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;cpu&quot;&gt;CPU方面的优化（很有用）&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;就目前的Unity移动游戏而言，CPU方面的性能开销主要可归结为两大类：引擎模块性能开销和自身代码性能开销。其中，引擎模块中又可细致划分为渲染模块、动画模块、物理模块、UI模块、粒子系统、加载模块和GC调用等等。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-1&quot;&gt;渲染模块&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;减少draw call。减少dc的核心办法在unity里面就是减少材质球。因为如果多个物体共用一个材质球（共同的贴图和shader）那么对于一次draw call来说就是传递顶点数多少的问题。&lt;/li&gt;
  &lt;li&gt;顶点数的多少引出了另一个问题，传输渲染数据的总线带宽。当大量GameObject满足批处理条件时（900个数据值），unity会合并mesh，但是一个超大的mesh数据传输起来也有瓶颈。因此关于draw call的优化不能是无脑的，需要平衡dc次数和总线带宽。&lt;/li&gt;
  &lt;li&gt;简化资源&lt;/li&gt;
  &lt;li&gt;渲染模块在CPU方面的优化方法还有很多，比如LOD、Occlusion Culling和Culling Distance等等&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;ui&quot;&gt;UI模块&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;文中以NGUI为例进行了函数的分析，但是UGUI应该也有借鉴的意义。&lt;/li&gt;
  &lt;li&gt;在NGUI的优化方面，UIPanel.LateUpdate为性能优化的重中之重，它是NGUI中CPU开销最大的函数，没有之一。对于UIPanel.LateUpdate的优化，主要着眼于UIPanel的布局，其原则如下：
    &lt;ul&gt;
      &lt;li&gt;尽可能将动态UI元素和静态UI元素分离到不同的UIPanel中（UI的重建以UIPanel为单位），从而尽可能将因为变动的UI元素引起的重构控制在较小的范围内；&lt;/li&gt;
      &lt;li&gt;尽可能让动态UI元素按照同步性进行划分，即运动频率不同的UI元素尽可能分离放在不同的UIPanel中；&lt;/li&gt;
      &lt;li&gt;控制同一个UIPanel中动态UI元素的数量，数量越多，所创建的Mesh越大，从而使得重构的开销显著增加。比如，战斗过程中的HUD运动血条可能会出现较多，此时，建议研发团队将运动血条分离成不同的UIPanel，每组UIPanel下5~10个动态UI为宜。这种做法，其本质是从概率上尽可能降低单帧中UIPanel的重建开销。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;PS：结合之前关于UI优化的文章，UI优化的核心在于拆分UI元素。始终不变的归为一类，动态变化的归为一类。对于UGUI来说就是拆分Canvas。&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;PS2：关于UI重建的说明。UI其实是一些3D的quad，这一下就能够理解为什么存在UI的减少drawcall了，这个和模型的减dc完全一个原理。多个UI在一个Canvas下就存在多个UI的mesh合并问题（批处理），但是像血条这样的UI一般用的是progress，它的原理就是默认模式下改变quad的顶点数据来实现进度大小的改变，fxxx模式下是顶点和UV一起变，只要改变了顶点位置，那么mesh必要每次dc的时候都要重新计算。和它一起的那些不变的UI的计算是浪费的。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-2&quot;&gt;加载模块&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;目前加载模块性能开销主要在场景切换，分为前一场景的场景卸载和下一场景的场景加载。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;场景卸载：主要是Destroy和Resources.UnloadUnusedAssets两个函数，前者的消耗多少主要取决于事件函数中代码的功能多少。后者耗时开销主要取决于场景中Asset和Object的数量，数量越多，则耗时越慢。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;场景加载：主要是资源加载和Instantiate实例化。
    &lt;ul&gt;
      &lt;li&gt;资源加载几乎占据了整个加载过程的90%时间以上，其加载效率主要取决于资源的加载方式（Resource.Load或AssetBundle加载）、加载量（纹理、网格、材质等资源数据的大小）和资源格式（纹理格式、音频格式等）等等。不同的加载方式、不同的资源格式，其加载效率可谓千差万别。&lt;/li&gt;
      &lt;li&gt;在场景加载过程中，往往伴随着大量的Instantiate实例化操作，比如UI界面实例化、角色/怪物实例化、场景建筑实例化等等。在Instantiate实例化时，引擎底层会查看其相关的资源是否已经被加载，如果没有，则会先加载其相关资源，再进行实例化，这其实是大家遇到的大多数“Instantiate耗时问题”的根本原因，这也是为什么我们在之前的AssetBundle文章中所提倡的资源依赖关系打包并进行预加载，从而来缓解Instantiate实例化时的压力。&lt;/li&gt;
      &lt;li&gt;另一方面，Instantiate实例化的性能开销还体现在脚本代码的序列化上，如果脚本中需要序列化的信息很多，则Instantiate实例化时的时间亦会很长。最直接的例子就是NGUI，其代码中存在很多SerializedField标识，从而在实例化时带来了较多的代码序列化开销。因此，在大家为代码增加序列化信息时，这一点是需要大家时刻关注的。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;以上是游戏项目中性能开销最大的三个模块，当然，游戏类型的不同、设计的不同，其他模块仍然会有较大的CPU占用。比如，ARPG游戏中的动画系统和物理系统，音乐休闲类游戏中的音频系统和粒子系统等。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;PS：关于场景加载在之前的文章中也有讲到，尤其是AssetBundle系列文章中。根据unity对资源的管理方式，Resources文件夹里面的asset会全部加载到PersistentManager，当然这个过程只是建立InstanceID的过程，但是仍旧消耗了时间。&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;代码效率&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;一图胜千言
&lt;img src=&quot;http://uwa-ducument-img.oss-cn-beijing.aliyuncs.com/Blog%2Foptimzation_cpu%2FDoc1_09.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;assetbundle&quot;&gt;AssetBundle&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;4.x的内容就不考虑写出来了。&lt;/li&gt;
  &lt;li&gt;AssetBundle5.x怎么制作我在之前的一个blog中写过,可以说5.x极大的简化了AssetBundle的打包流程。&lt;/li&gt;
  &lt;li&gt;不考虑5.3前的情况，之后的版本建议使用LZ4打包，因为是按需解压加载的。&lt;/li&gt;
  &lt;li&gt;新增的AppendHashToAssetBundleName选项很不错，可以在生成AssetBundle时加入hash值，便于判定是否有更新，AssetBundleBrowser中支持。&lt;/li&gt;
  &lt;li&gt;几个注意的点：
    &lt;ul&gt;
      &lt;li&gt;新机制打包无法指定Assetbundle.mainAsset，因此无法再通过mainAsset来直接获取资源。&lt;/li&gt;
      &lt;li&gt;开启DisableWriteTypeTree可能造成AssetBundle对Unity版本的兼容问题，但会使Bundle更小，同时也会略微提高加载速度。&lt;/li&gt;
      &lt;li&gt;abName可通过脚本进行设置和清除，也可以通过构造一个AssetBundleBuild数组来打包。&lt;/li&gt;
      &lt;li&gt;Prefab之间不会建立依赖，即如果Prefab-A和Prefab-B引用了同一张纹理，而他们设置了不同的abName，而共享的纹理并未设置abName，那么Prefab-A和Prefab-B可视为分别打包，各自Bundle中都包含共享的纹理。因此在使用UGUI，开启Sprite Packer时，由于Atlas无法标记abName，在设置UI界面Prefab的abName时就需要注意这个问题。&lt;/li&gt;
      &lt;li&gt;5.x中加入了Shader stripping功能,在打包时，默认情况下会根据当前场景的Lightmap及Fog设置对资源中的Shader进行代码剥离。这意味着，如果在一个空场景下进行打包，则Bundle中的Shader会失去对Lightmap和Fog的支持，从而出现运行时Lightmap和Fog丢失的情况.而通过将Edit-&amp;gt;Project Settings-&amp;gt;Graphics下shader Stripping中的modes改为Manual，并勾选相应的mode即可避免这一问题。&lt;/li&gt;
      &lt;li&gt;Shader被打包到不同AssetBundle中了，WarmupAllShaders仅能对当前内存中的Shader进行warm up。后续如果又有Shader加载进来，则仍然会出现CreateGPUProgram操作。&lt;/li&gt;
      &lt;li&gt;PS:这一条在2017中发现custom选项中是全选的。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-4&quot;&gt;纹理&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;对于图片如果可以的话，建议直接将其制作成POT（ power of two，即图片的size是2次幂，这个也是unity建议的）图片，而非进行二次转换。ToLarger确实可以将纹理拉伸成POT纹理，但如果是UI界面（开启Pixel Perfect）的话，可能显示时会有较大视觉损失。&lt;/li&gt;
  &lt;li&gt;Texture占用内存总是双倍：出现这种情况的原因有两种：一种是在真机运行时开启了Read&amp;amp;Write。另一种可能是Unity的Bug，目前的Unity 5.2.3 release note如下 ：
(735644) - OpenGL: Fixed texture memory usage reporting in profiler, was twice the actual size for most textures.&lt;/li&gt;
  &lt;li&gt;纹理Atlas是合成一张2048（尺寸）的纹理还是四张1024的纹理在其他设置一致的情况下，这两种方式无论在加载还是渲染方面其实并没有实质上的差别。在我们接触到的大多数案例中，纹理资源方面的问题除了尺寸外，&lt;strong&gt;纹理格式、Mipmap设置和Read&amp;amp;Write功能&lt;/strong&gt;同样是需要研发团队时刻关注的。&lt;/li&gt;
  &lt;li&gt;PS:看来纹理的Read&amp;amp;Write选项很重要&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;unity&quot;&gt;unity的工具&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Overhead：
    &lt;ul&gt;
      &lt;li&gt;Overhead的计算方法是：Profiler当前帧统计的总耗时时间减去所有已知选项的累加时间，即引擎当前还无法识别模块的耗时时间。&lt;/li&gt;
      &lt;li&gt;Overhead数值理论上是趋向于0的，但是由于目前市面上的硬件设备、系统框架过于丰富，所以引擎可能无法识别所有模块的CPU开销。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;unity的分析工具中的Reserved Total 和 Used Total为Unity引擎在内存方面的总体分配量和总体使用量。 一般来说，引擎在分配内存时并不是向操作系统 “即拿即用”，而是首先获取一定量的连续内存，然后供自己内部使用，待空余内存不够时，引擎才会向系统再次申请一定量的连续内存进行使用。&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sat, 29 Jul 2017 23:18:54 +0800</pubDate>
        <link>https://caihua.tech/2017/07/29/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E4%B8%80%E5%91%A8/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/07/29/%E6%AF%8F%E5%A4%A9%E4%B8%80%E7%82%B9UWA-%E7%AC%AC%E4%B8%80%E5%91%A8/</guid>
        
        <category>UWA</category>
        
        
      </item>
    
      <item>
        <title>Lua学习笔记：基本语法</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;初步印象&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;语法和python、js这些很像，解释型语言、弱类型等等。写着舒服是真的。&lt;/li&gt;
  &lt;li&gt;while do\repeat until这样的语法其实真心不舒服，感觉在语法上有些累赘。大多数语言都是do while，但是它非要是repeat until，也是无语。&lt;/li&gt;
  &lt;li&gt;我个人认为语法中的then和do设计的很混淆。比如if是和then，for是和do。从我对语言的理解上感觉可以统一用do或者then。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;基本语法&lt;/h2&gt;

&lt;h3 id=&quot;section-2&quot;&gt;变量&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;只有布尔、字符串、数字、table和nil。但是没有一个明确的类型定义，完全按照赋值来进行推断。&lt;/li&gt;
  &lt;li&gt;默认是public，如果想private需要变量前加local。&lt;/li&gt;
  &lt;li&gt;可以一次性多复制，如果变量和值不对称，没有复制的变量为nil。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a,b,c = 1,2
print(a)
print(b)
print(c)

--结果

1
2
nil

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h4 id=&quot;section-3&quot;&gt;作用域&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;在lua中一个local变量的作用域可以是在一个循环中或者在一段if代码中。也可以是贯穿整个的table中（感觉table在某种角度完全可以看做是一个类）。但是如果你想控制一个local变量的值作用域某个区间，那么可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;do  end&lt;/code&gt;来明确划分一个block。下面这个例子的结果是nil，因为x在作用域只在&lt;code class=&quot;highlighter-rouge&quot;&gt;do end&lt;/code&gt;之间。但是这个不适用于全局变量，需要注意。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;do
	local x = 10
end
print(x)

-- 结果

nil
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;对比一下下面两段代码的不同结果。其实尽可能的不要出现变量同名的情况，尤其是第二段代码的行为可能不是我们想要的。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;x = 1
do
	local x = 10
	print(x)
end
print(x)

-- 结果
10
1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;x = 1

local x = 10
print(x)

print(x)

-- 结果
1
1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;关于&lt;code class=&quot;highlighter-rouge&quot;&gt;do  end&lt;/code&gt;还有个用法，在lua中return和break需要在end\else\until之前（发现在print之前也可以），否则编译会出错。此时就需要&lt;code class=&quot;highlighter-rouge&quot;&gt;do  end&lt;/code&gt;来包住return了。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function boo()
	local x = 10
	do
		return
	end
	local i = 10
	print(1)
end
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-4&quot;&gt;循环&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;for\while do\repeat until，最后一个对象do while。&lt;/li&gt;
  &lt;li&gt;for分为数值型和泛型：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-- var从exp1变化到exp2，每次变化以exp3为步长递增var，并执行一次&quot;执行体&quot;。exp3是可选的，如果不指定，默认为1。
for var=exp1,exp2,exp3 do  
    &amp;lt;执行体&amp;gt;  
end  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for i,v in ipairs(a) 
	do print(v) 
end  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;for的循环中没有continue，这样导致了在for中可能出现if嵌套if的情况，因为没办法通过拆解if来实现简练的代码。不爽！！另外lua的&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-5&quot;&gt;迭代&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;需要注意pairs 和 ipairs异同
同：都是能遍历集合（表、数组）
异：ipairs 仅仅遍历值，按照索引升序遍历，索引中断停止遍历。即不能返回 nil,只能返回数字 0，如果遇到 nil 则退出。它只能遍历到集合中出现的第一个不是整数的 key。
pairs 能遍历集合的所有元素。即 pairs 可以遍历集合中所有的 key，并且除了迭代器本身以及遍历表本身还可以返回 nil。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Demo1：
local tabFiles = {
        [1] = &quot;test2&quot;,
        [6] = &quot;test3&quot;,
        [4] = &quot;test1&quot;
    }

for k, v in ipairs(tabFiles) do    --输出&quot;test2&quot;,在key等于2处断开
    print(k, v)
end

Demo2：
local tabFiles = {
    [2] = &quot;test2&quot;,
    [6] = &quot;test3&quot;,
    [4] = &quot;test1&quot;
}

for k, v in ipairs(tabFiles) do  --[[什么都没输出，为什么？因为控制变量初始值是按升序来遍历的，当key为1时，value为nil，此时便停止了遍历， 所有什么结果都没输出]]--
    print(k, v)
end

Demo3：
local tabFiles = {
    [2] = &quot;test2&quot;,
    [6] = &quot;test3&quot;,
    [4] = &quot;test1&quot;
}

for k, v in pairs(tabFiles) do  --输出2 test2, 6 test3, 4 test1
    print(k, v)
end

Demo4：
local tabFiles = {&quot;alpha&quot;, &quot;beta&quot;, [3] = &quot;no&quot;, [&quot;two&quot;] = &quot;yes&quot;}  for i,v in ipairs(tabFiles ) do    --输出前三个   备注：因为第四个key不是整数
    print( tabFiles [i] )   
end   
  
for i,v in pairs(tabFiles ) do    --全部输出   
    print( tabFiles [i] )   
end 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;table&quot;&gt;table&lt;/h3&gt;

&lt;h4 id=&quot;section-6&quot;&gt;概念&lt;/h4&gt;
&lt;blockquote&gt;
  &lt;p&gt;table 是 Lua 的一种数据结构用来帮助我们创建不同的数据类型，如：数字、字典等。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Lua table 使用关联型数组，你可以用任意类型的值来作数组的索引，但这个值不能是 nil。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Lua table 是不固定大小的，你可以根据自己需要进行扩容。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;上面是runoob.com的lua教程中对table的描述。在我看来很难去描述table是个什么东西，但是我们可以通过对它的使用来总结它所扮演的一些角色，或者说什么场景下table能够作为什么来使用。&lt;/li&gt;
  &lt;li&gt;看下第二条，table中索引可以是任何类型的值，&lt;strong&gt;所以索引是个table也是可以的&lt;/strong&gt;。但是必须不是nil，所以&lt;code class=&quot;highlighter-rouge&quot;&gt;look = {[www] = &quot;ok&quot;} 这样是不对的，www没有赋值，所以默认为nil因此出错table index is nil&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-7&quot;&gt;常见用法&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;数组&lt;/strong&gt; ： table一个典型的用法就是作为其它语言中的数组&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;str = { 1,2,3}
print(str[2])
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;字典&lt;/strong&gt; ： 也是常见的用法&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;str = {name=&quot;Sai&quot;,age=33}
print(str[&quot;age&quot;])
print(str.name)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;table-1&quot;&gt;table使用中容易出现的问题&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;看下这段代码&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;temp = 1
tab = {[temp] = 1, 11}
print(tab[1])
for i,v in pairs(tab) do
	print(i,v)
end

-- 输出的结果是 ： 

11
1	11
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;why?第一个print中为何结果不是1，因为tab[]这个用法的参数是key，而像11这样没有显示定义key的value默认的key就是1，所以这句话认为是输出key=1的value了。而且从遍历看居然只有一个数据，也就是说value 1的数据被替换掉了。&lt;/li&gt;
  &lt;li&gt;那么怎么让这个1显示出来呢？以我目前掌握的只能是改temp的值。&lt;/li&gt;
  &lt;li&gt;总结一下就是注意三点：&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;第一，所有元素之间，总是用逗号 “，” 隔开；&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;第二，所有索引值都需要用 “[“和”]”括起来；如果是字符串，还可以去掉引号和中括号； 即如果没有[]括起，则认为是字符串索引&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;第三，如果不写索引，则索引就会被认为是数字，并按顺序自动从 1往后编；&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;数组（lua叫table）下标从1开始，有点不习惯。&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;判断table是否是空&lt;a href=&quot;http://www.jb51.net/article/64378.htm&quot;&gt;（参考）&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a={2}
if next(a) ~= nil then
	print(next(a))
end
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-8&quot;&gt;字符串&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;..&lt;/code&gt;是字符串相加，my god…&lt;/li&gt;
  &lt;li&gt;对于string的处理，除了用string.xxx(strArg)这样的方式外，还可以用strArg:xxx的方法。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-9&quot;&gt;函数&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;function可以返回也可以不返回结果，在定义时没有明确的约束。&lt;/li&gt;
  &lt;li&gt;支持多返回值，nice&lt;/li&gt;
  &lt;li&gt;Lua函数不支持参数默认值，可以通过or来实现。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function sum(a , b)
    a = a or 1.1
    b = b or 2.2
    return a + b
end
 
print(sum())
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;支持闭包&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;tab = {1,2,3,4,5,6,7,8}
 
function iter()
    local index = 0
    return function()
        index = index + 1 
        return tab[index]
    end
end
 
for i in iter() do
   print(i)
end
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;可变参数，这里有点小特别：
    &lt;blockquote&gt;
      &lt;p&gt;Lua将函数的参数放在一个叫arg的表中，#arg 表示传入参数的个数。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function average(...)
   result = 0
   local arg={...}
   for i,v in ipairs(arg) do
      result = result + v
   end
   print(&quot;总共传入 &quot; .. #arg .. &quot; 个数&quot;)
   return result/#arg
end

print(&quot;平均值为&quot;,average(10,5,3,4,5,6))
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这个#还能来取table中元素的个数，但是使用限制比较大。建议还是开启循环来计算个数。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;.&lt;/code&gt;的区别:&lt;/p&gt;

    &lt;p&gt;是个语法糖，调用的函数会自动传递参数self，即：&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;local a = {x = 0}
function a.foo(self, a)
    self.x = a
end
function a:foo2(a)
    self.x = a
end


--调用时：
a.foo(a, 2)
a.foo2(2)

--上述两个操作是等价的，用:时就省去了定义和调用时需要额外添加self用来指代自身的麻烦.

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;需要注意的是如果一个table中的方法调local的非table方法（简单来说就是一个类方法要访问非类方法）需要将非类的方法定义在前面，这个和C的机制一样。同样的，非类方法之间的调用也要有顺序，都尼玛血泪的教训&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;api&quot;&gt;API&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;标准库的API可以在&lt;a href=&quot;https://www.lua.org/manual/5.1/&quot;&gt;这里&lt;/a&gt;查询到。&lt;/li&gt;
  &lt;li&gt;math.random的行为很是奇怪，一次调用永远产生相同的值。如果想得到不同的值，需要多次调用。&lt;/li&gt;
  &lt;li&gt;对于table等的操作建议看参考2的连接。&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sat, 29 Jul 2017 23:15:54 +0800</pubDate>
        <link>https://caihua.tech/2017/07/29/Lua%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/07/29/Lua%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</guid>
        
        <category>Lua</category>
        
        
      </item>
    
      <item>
        <title>Unity返回Value的协程</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;起因&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;其实一直以来就有个想法，希望能让unity中的coroutine返回一个具体的数值，比如int，比如string或者一个GameObject。最近也查了些资料，然后总结一下这个功能如何实现。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-1&quot;&gt;回调函数实现&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;这个算是一个取巧的办法，在调用协程时传递一个回调函数，在执行过程中根据情况调用回调即可。不废话，直接上代码：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; IEnumerator CoroutineWithCallback(Action&amp;lt;string&amp;gt; callback)
{
    WWW www = new WWW(&quot;https://caihua.tech&quot;);
    yield return www;
    if (string.IsNullOrEmpty(www.error))
    {
        callback(www.text);
    }
    else
    {
        callback(&quot;www fail&quot;);
    }
}

// 调用方式

IEnumerator Start()
{
    yield return StartCoroutine(CoroutineWithCallback(s =&amp;gt;
    {
        Debug.Log(s);
    }));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-2&quot;&gt;利于协程的原理来制作一个可以返回数值的包装器&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;协程本身就是利用IEnumerator的可遍历来实现的，在运行期间如果约到yield语句就会等后面的代码执行完成后返回结果。如果在代码块的后面还有yield就会继续执行。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 包装器
public class CoroutineWithData
{
    public Coroutine coroutine { get; private set; }
    public object result;
    private IEnumerator target;
    public CoroutineWithData(MonoBehaviour owner, IEnumerator target)
    {
        this.target = target;
        this.coroutine = owner.StartCoroutine(Run());
    }

    private IEnumerator Run()
    {
        while (target.MoveNext())
        {
            result = target.Current;
            yield return result;
        }
    }
}


// 真正执行逻辑的代码
IEnumerator LoadSomeStuff()
{
    WWW www = new WWW(&quot;https://caihua.tech&quot;);
    yield return www;
    if (string.IsNullOrEmpty(www.error))
    {
        yield return www.text;
    }
    else
    {
        yield return &quot;fail&quot;;
    }
}

// 使用
...
CoroutineWithData cd = new CoroutineWithData(this, LoadSomeStuff());
yield return cd.coroutine;
Debug.Log(&quot;result is &quot; + cd.result);
...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Sun, 23 Jul 2017 23:31:11 +0800</pubDate>
        <link>https://caihua.tech/2017/07/23/Unity%E8%BF%94%E5%9B%9EValue%E7%9A%84%E5%8D%8F%E7%A8%8B/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/07/23/Unity%E8%BF%94%E5%9B%9EValue%E7%9A%84%E5%8D%8F%E7%A8%8B/</guid>
        
        <category>Unity3D</category>
        
        
      </item>
    
      <item>
        <title>AssetBundle学习笔记：Resources文件夹</title>
        <description>&lt;h2 id=&quot;resources&quot;&gt;Resources文件夹&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;这个章节内容不多，但是也很有用。我们可以从这个章节中学习如何更合理的使用它。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;resources-1&quot;&gt;Resources系统的最佳实践&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;不要使用它&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;是的，不要使用它。因为它有以下问题：
    &lt;ul&gt;
      &lt;li&gt;使用 Resources 文件夹会让内存颗粒度管理变得更困难&lt;/li&gt;
      &lt;li&gt;不正确的使用 Resources 文件夹会增加应用启动时间（因为要创建上一章讲的映射图）和包的大小，随着在 Resources 文件中的文件增加，管理这些文件会变得很困难。&lt;/li&gt;
      &lt;li&gt;Resources系统降低了项目自定义分发内容到具体平台的能力，消除了增量更新的可能。AssetBundle 变体是 Unity 用来在不同设备上调整内容的基础。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section&quot;&gt;正确的使用资源文件夹&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;下面两种情况 Resources 系统很有用处：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;1.因为 Resources 系统很容易使用，它很适合是在快速原型制作和试验。但是当项目要转成产品时，强烈建议不要使用 Resources 文件夹.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;2.Resources 文件夹对一些满足如下条件的案例很有用：&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;存储在 Resources 文件夹下的内容不要很大的内存&lt;/li&gt;
    &lt;li&gt;存储在 Resources 文件夹下的内容在整个项目周期都有用&lt;/li&gt;
    &lt;li&gt;内容基本不用升级&lt;/li&gt;
    &lt;li&gt;在各平台都一样的&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-1&quot;&gt;序列化资源&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;一个工程中可能包含了多个名叫Resources的文件夹，所有这些文件夹下的对象和资材会在build的时候全部序列化到一个文件中，这个文件可以理解为一个特殊的AssetBundle。想来这就是为何不利于增量更新的原因了。
    &lt;blockquote&gt;
      &lt;p&gt;AssetBundle包中索引信息里面包括了处理对象名字到对应的文件 GUID 和本地ID 的查找树。它也用来定位对象在序列化文件中的偏移位置。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;用于查找的数据结构是平衡搜索树[1]（在大多数平台上），它的构建时间增长到了 O(nLog(N)), 其中 N 是在查找树内的对象的个数。这个增长也使 Resources 文件夹内的对象增加时，索引的加载时间会比线性增长时间长。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;说了这么多就是告诉大家，应用启动时初始化resources文件夹（按照上一章说的应该是建立实例ID的映射图）这个事是不可避免的，当resources文件夹中内容太多时会严重影响启动速度。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 23 Jul 2017 23:28:45 +0800</pubDate>
        <link>https://caihua.tech/2017/07/23/AssetBundle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Resources%E6%96%87%E4%BB%B6%E5%A4%B9/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/07/23/AssetBundle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Resources%E6%96%87%E4%BB%B6%E5%A4%B9/</guid>
        
        <category>AssetBundle学习笔记</category>
        
        
      </item>
    
      <item>
        <title>AssetBundle学习笔记：资产、对象和序列化</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;前言&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;这篇及后续的几篇笔记是我阅读&lt;a href=&quot;https://unity3d.com/cn/learn/tutoriazals/topics/best-practices/guide-assetbundles-and-resources&quot;&gt;A guide to AssetBundles and Resources&lt;/a&gt;的一些记录。官方的这个系列文章详细的阐述了unity是管理资源的。从一个asset的导入开始，unity就在背后开始了它的工作。它为每个资源创造了一个mate文件，给予了资源一个唯一的ID，从此这个资源的一切都与这个ID紧密结合到了一起。可能我们的一些操作会导致资源丢失它的mate文件，这会造成一些很不好的后果。&lt;/li&gt;
  &lt;li&gt;与此同时，系列文章中还重点阐述了什么是AssetBundle，如何下载AssetBundle和如何从AssetBundle中加载asset。&lt;/li&gt;
  &lt;li&gt;最关键的是最后一章，在这一章中详细的描写了AssetBundle的制作策略。AssetBundle可以说是unity中至关重要的一个概念，但是在日常的工作中按照怎么样的颗粒度来划分AssetBundle，如何平衡AssetBundle的精细度和方便性，这一直以来是一个让人头痛的问题，第四章中给出了一些答案。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;资产、对象和序列化&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;这是系列文章的第一部分（前面还有一个类似介绍的章节），讲述了unity如何处理导入的资源，如何去标识它们，管理它们。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-2&quot;&gt;资产的导入&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;首先asset这个词如果只是看翻译的话可以是&lt;strong&gt;资产&lt;/strong&gt;，其实在我看来它可以是资源，和resource这个词的含义几乎一样。但是因为Resource这个词在unity中有着特殊的含义，它代表了一个特别的文件夹，所以可能需要用一个别的词语来表示资源的概念。&lt;/li&gt;
  &lt;li&gt;asset可以是一个脚本、一个音频文件或者是一个美术从3D建模工具中导出的FBX文件，它保存在unity工程的Assets文件夹下，它的格式可能unity能够直接使用的(比如一个material)，也可能是不能直接使用的（比如FBX）。&lt;/li&gt;
  &lt;li&gt;每一个asset在导入到unity时都会进行一项工作，就是将asset序列化，因为只有只有unity引擎才能够使用它们。在这个导入的过程中可能会对纹理等进行压缩，所以这个过程会比较久。&lt;/li&gt;
  &lt;li&gt;这些被序列化后的数据保存在工程的Library文件夹下，我们不需要修改这些数据，因为这个是unity自动做的，每次你导入新的数据的时候都会生成这些文件。而且如果你留意的话，会发现你切换unity的目标平台时（Android→ios）会重现生成一次序列化文件，因为每个平台能够识别的数据类型不同。同一个纹理文件可能对于了不同的序列化文件。（没事不要删除Library文件夹，因为这个序列化过程非常耗时。）&lt;/li&gt;
  &lt;li&gt;通常我们在unity的IDE中看到的asset文件都是原始的文件，因为导入的过程中虽然做了序列化，但是其实是生成了新的文件，而原始的文件并没有被修改。&lt;a href=&quot;https://docs.unity3d.com/Manual/BehindtheScenes.html&quot;&gt;（给出一个参考文档）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-3&quot;&gt;资产导入的结果是什么&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;答案是序列化文件，那么我们通过什么使用这些序列化文件呢？答案是 UnityEngine.Object,或者是大写O的Object。&lt;/li&gt;
  &lt;li&gt;Object是一套序列化数据用来描述一个具体的资源实例。它（object）的类型可以是任何引擎使用的类型，比如一个mesh、一个音频片段等。基本上所有的内置对象类型都是UnityEngine.Object的子类型，除了ScriptableObject和MonoScript。&lt;/li&gt;
  &lt;li&gt;需要注意的是，一个外部文件的导入可能产生了多个asset，比如FBX文件的导入，可能产了mesh、material和texture。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;scriptableobjectmonoscript&quot;&gt;什么是ScriptableObject和MonoScript&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;ScriptableObject在我看来是一种内置的数据存储格式&lt;/li&gt;
  &lt;li&gt;MonoScript代表了工程中的一个脚本文件，它是个editor类。用法&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#if UNITY_EDITOR

                mediatorClass = RTEditorGUI.ObjectField&amp;lt;MonoScript&amp;gt;(mediatorClass, true);
                if (mediatorClass != null)
                {
                    mediatorName = mediatorClass.GetClass().Name;
                }
#endif

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;unityasset&quot;&gt;unity如何区分这些导入的asset&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;这是一个核心的问题。unity在生成（以FBX文件导入为例，可能一个FBX生成了unity中的多个asset）一个asset时，会同时生成一个mate文件。这个asset会分配一个File GUID，而这个asset中的多个UnityEngine.Object会生成多个Local ID。这个理解起来比较容易，一个asset就是一栋房子，有一个唯一的门牌号。而一栋房子的每个房间又有一个唯一的房间号。&lt;/li&gt;
  &lt;li&gt;unity editor将这个File GUID与asset的路径关联了起来。这样一来，如果你移动了asset的位置，unity会更新这个File GUID对应的路径，这也是为何unity建议我们移动或者重命名或者删除文件已经要在IDE中做，因为unity会监控文件的变化。如果你在外面改了文件名字或者路径，回到unity后会发现unity会给这个asset重新生成一个mate文件，显然这样会分配一个新的GUID。&lt;/li&gt;
  &lt;li&gt;后果是什么？如果你的这个asset中的内容已经被使用，那么会出现丢失的情况。总的来说，unity就是靠File GUID和Local ID来管理资源，一切变化它都会关注，而且也会帮我们处理好。但是外在的变化它无从得知，所以只能出现错误。有趣的一点是，如果你只是删除了mate文件，但是不改变asset的位置，那么unity在重新生成mate时会给asset一个原来的GUID。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;unity&quot;&gt;unity是如何在运行时管理资源的&lt;/h3&gt;

&lt;h4 id=&quot;persistentmanager&quot;&gt;PersistentManager缓存的概念&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;由于GUID在运行时比较的时候效率较低，所以unity使用了一套其它的机制来管理运行时的资源。这就是PersistentManager缓存。unity将File GUID和Local ID翻译（个人认为应该是经过某种变换）成一个叫做Instance ID的整型数据，它在单独的会话（single session，难以理解）中是唯一的。我个人的理解是在一个进程中这个Instance ID是唯一的。&lt;/li&gt;
  &lt;li&gt;缓存维护了一个InstanceID和内存中实例对象的映射图。UnityEngine.Objects通过这个做到了强引用。通过Instance ID可以快速的找到内存中的对象。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;persistentmanager-1&quot;&gt;PersistentManager缓存的初始化和更新&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;这个映射图在游戏启动的时候就会初始化。数据包含：游戏启动时初始场景中用到的对象的映射，Resources文件中所有的对象信息都会被映射到缓存中（这个缓存建立是需要时间的，所以如果Resources文件中内容太多启动会变慢）。&lt;/li&gt;
  &lt;li&gt;在游戏运行的过程中这个缓存也会进行更新。比如在运行时新的asset被导入了（不能理解这是一个什么场景），或者一些对象从AssetBundle中加载的时候，会生成新的Instance ID，新的对象，也就有了新的映射。&lt;/li&gt;
  &lt;li&gt;还有当AssetBundle被卸载的时候（这个卸载应该指的是所有已经实例化对象也被卸载），对应的映射数据会被删除。而当对象重新从AssetBundle中加载时，会产生一个新的Instance ID。这个也是后面会说到的AssetBundle管理的一个重要内容，如何保证无效的资源在卸载时也被删除掉。&lt;/li&gt;
  &lt;li&gt;需要注意一点就是有时一些特别的事件会导致内存中的对象被删除了，比如ios的挂起，此时unity是没有办法重新加载这些数据的（比如材质数据），此时场景中看到的就是品红色的对象了。所以如果手机上出现这个问题了，就要考虑是不是内存中对象被删除了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;resource&quot;&gt;Resource的生命周期&lt;/h3&gt;

&lt;h4 id=&quot;section-4&quot;&gt;加载&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;按照文中的说法有两种方式来加载UnityEngine.Objects，第一是被自动加载，这个需要一个实例ID映射到这个对象，同时这个对象没有加载进内存并被间接引用，而且对象的数据源存在。我对这个的理解是参考初始场景中的对象，前文说过它们会进入缓存中，而且在一开始肯定是内存中不存在的，而且如果这个实例ID对应的FILE ID和local ID是有效的，那么就会被自动的加载；至于说间接引用，讲真，没理解。&lt;/li&gt;
  &lt;li&gt;第二种加载就是代码加载了，这个API就多了，resources的load或者AssetBundle的load都可以做到。&lt;/li&gt;
  &lt;li&gt;当一个对象被加载，Unity 会尝试将所有引用从文件 GUID 和本地 ID 转换成实例 ID。（这个应该是为了把运行时的引用关系都保存在PersistentManager所管理的映射图中。）&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-5&quot;&gt;卸载&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;如果一个fileID和localID没有对应的实例ID，或者实例ID所对应的fileID和localID无效了，那么就会出现missing的情况，此时实例ID仍旧是存在的，在场景中它也被别的对象引用着，但是你可能看不到它或者它显示为品红色。&lt;/li&gt;
  &lt;li&gt;这个情况其实挺常见的，由于操作问题导致asset的fileID发生了变化，但是原来的实例ID没有跟着更新，就容易出现。&lt;/li&gt;
  &lt;li&gt;文中列举了三个被卸载的情况
    &lt;ul&gt;
      &lt;li&gt;在未使用的asset被清理时对象会被自动卸载。这个过程会在场景切换的时候发生。&lt;/li&gt;
      &lt;li&gt;从Resources文件夹中加载的对象在调用Resources.UnloadAsset时会卸载。但是对象对应的实例ID保持有效，而且也对应着有效的fileID和localID。&lt;strong&gt;这些对象如果被其它的mono变了或者对象引用着，那么在调用Resources.UnloadAsset后这些对象会被重新加载。&lt;/strong&gt;（这个就有意思了，代表在Resources.UnloadAsset函数有时不会实现我们想要的效果。）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;当调用AssetBundle.Unload(false)时，unity不会将从这个AssetBundle中加载的还处于激活状态的对象销毁掉，但是会使这些对象对应的实例ID与fileID和localID断开引用。如果这些对象从内存中卸载并且对这些已卸载的对象的引用依然保持着，Unity将无法重新加载对象。&lt;/li&gt;
  &lt;li&gt;上面这段讲的比较奇怪，因为在后面的最后一章中应该是描述了这样的情况，此时是可以重新加载asset的，只不过会造成内存泄漏。&lt;/li&gt;
  &lt;li&gt;在注视中讲到了这个情况的一个例子就是APP被挂起后，GPU内存中的纹理、网格被删除了，那么在APP恢复后需要重新加载这些内容。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-6&quot;&gt;加载大的层次结构&lt;/h3&gt;

&lt;h4 id=&quot;section-7&quot;&gt;几个点&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;在序列化层级结构时会将所有对象和组件都单独的序列化到序列化文件中。这对于层级的加载产生阴影。&lt;/li&gt;
  &lt;li&gt;层级加载时CPU时间消耗在以下内容上：
    &lt;ul&gt;
      &lt;li&gt;读取序列化数据&lt;/li&gt;
      &lt;li&gt;在新创建出的transform中设置层级结构&lt;/li&gt;
      &lt;li&gt;实例化对象和组件&lt;/li&gt;
      &lt;li&gt;唤醒对象和组件（awake）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;后面三条基本上花费的时间是固定的，但是第一条不一样。层级越复杂加载的越慢。&lt;/li&gt;
  &lt;li&gt;在所有平台上，内存读取速度快过磁盘，PC读取快过手机。因此当层级过于复杂时可能读取的时间都要长于实例化的时间。&lt;/li&gt;
  &lt;li&gt;对于层级中数据相同的对象会多次进行序列化，比如UI上30个复制出来的相同的元素会序列化三十次，加载的时候也是加载30个不同的数据，因此很耗时。&lt;/li&gt;
  &lt;li&gt;5.4之后unity修改了transform在内存中的呈现形式。每个根节点下的所有子层级都保存在一段紧密连续的内存中。当实例化一个会导致重新指定父级的新对象时，考虑使用GameObject.Instantiate方法的带父对象参数的重载。使用这个重载可以避免给新物体新分配根 tranform 层次。测试结果中，这个可以提高 5 - 10 % 的实例化时间。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-8&quot;&gt;总结&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;这个章节讲述了unity中对UnityEngine.Objects和asset的管理，从资材的导入到运行时的加载卸载。读完后应该明白一下几点：&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;UnityEngine.Objects与asset的关系&lt;/li&gt;
  &lt;li&gt;asset导入后产生了mate文件，产生了fileID和localID的概念&lt;/li&gt;
  &lt;li&gt;asset在运行时中产生了实例ID的概念，并且实例ID和fileID、localID是通过一个映射图结合到了一起，这个映射图也让内存中的object与磁盘上的asset产生了联系。&lt;/li&gt;
  &lt;li&gt;asset可以被加载也可以被卸载，而它的卸载需要注意不要让资源出现内存泄漏的问题。&lt;/li&gt;
  &lt;li&gt;最后在场景中的层级结构需要合理的规划。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 16 Jul 2017 00:13:52 +0800</pubDate>
        <link>https://caihua.tech/2017/07/16/AssetBundle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%B5%84%E4%BA%A7-%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%BA%8F%E5%88%97%E5%8C%96/</link>
        <guid isPermaLink="true">https://caihua.tech/2017/07/16/AssetBundle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%B5%84%E4%BA%A7-%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%BA%8F%E5%88%97%E5%8C%96/</guid>
        
        <category>AssetBundle学习笔记</category>
        
        
      </item>
    
  </channel>
</rss>
